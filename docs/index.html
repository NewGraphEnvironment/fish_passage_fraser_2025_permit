<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_fraser_2024","repo_url":"<a href=\"https://github.com/lucy-schick/fish_passage_fraser_2025_permit\" class=\"uri\">https://github.com/lucy-schick/fish_passage_fraser_2025_permit</a>","report_url":"<a href=\"https://lucy-schick.github.io/fish_passage_fraser_2025_permit/\" class=\"uri\">https://lucy-schick.github.io/fish_passage_fraser_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-07-25</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file of all sites is attached to the application and can also be downloaded <a href="https:/github.com/lucy-schick/fish_passage_fraser_2025_permit/raw/main/mapping/sites_fraser_2025_20250725_kml.zip">at this link</a>. The KML includes detailed site-specific information accessible by clicking on each location, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Society for Ecosystem Restoration Northern BC, the Ministry of Transportation and Infrastructure (MoTI) and the Provincial Fish Passage Technical Working Group. Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from throughout the study area. Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<!-- ![signature](/Users/airvine/Library/CloudStorage/OneDrive-Personal/Admin/Al_Sig.jpg){width=50%} -->
<p>Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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++WXX9pFF11EZTxGTvhrS2WspTK0Y8cO69u3b4aiWs7VxVj3YBIQQCC3BOhil1v7g9QgUHACulLas2fPU8pXXV2dPfHEE1ZZWWnXX399WOfHH3+0999/3+bNm8fJ6ikpJm+h1paxxmLq3qlBQ2bPnt34I6YTKnA6ZUxEjcuQWiO7dOmSode5c+dQOTpw4IB179494zMmEEDg7ApQQTq7/mwdgYIRUMuPRmaKg7orjRkzJp5s8VWDMjz88MNhcIYXXngh3GukJ9Ora929995rvXv3bjEOFihsgbYoY43FVBF/++23bdq0aTZkyJDGHzOdAIGPP/44Y4Q5Xazp0KHDKee8qTKkeyfVVTg9xNNqHScggEBuCVBByq39QWoQyFsBXQX98MMPU+nXfUSnWkFSN5OpU6dax44draqqyrp27RriUXz6TP304776NTU14eqshvq+++67U9vjTeELtEUZi9XUzWnGjBn2xRdf2PTp08M9SPFnvCZLQGVg165dqUzrXqFTqSCdrAz16tXLtm7dmopTb3RRSC1HpaWlGfOZQACBsy9ABens7wNSgEBBCGh0unfeeee087Jz50675557bNCgQaF7XfrJgu5DanxvyOrVq8PNzgMGDDjtbbFCfgu0RRmLRdRSqW51r7zyip133nnxbF4TKPDiiy+eUa5PVoZUdvWMN7Uaqbuewrp16064L+mMNsxKCCCQdQEqSFknJUIEEDgdAV21P3r0qE2YMME2btyYWlX99YcOHRr+T830NxrwYdSoUXb11Venz+Y9As0KnKyM6cR1yZIloeXowQcfDKOVqaIUh0suucSKi4vjSV4RaFKgpTI0duzYUPlW9009Y0utSXrelkb4JCCAQO4JUEHKvX1CihBIjICeOh8/jFP3GaWHESNGhK5O6fN4j8DpCpxKGdOzuBSef/75E6LXg425R+QEFmY0EjiVMqQWJj1fS5UkjYqnB2SPHDmyUUxMIoBALggU+TMeeMhDLuwJ0oAAAggggAACBS+gbsUadOacc3jSSsHvbDKYtwJUkPJ215FwBBBAAAEEEEAAAQQQyLYAly+yLUp8CCCAAAIIIIAAAgggkLcCVJDydteRcAQQQAABBBBAAAEEEMi2ABWkbIsSHwIIIIAAAggggAACCOStABWkvN11JBwBBBBAAAEEEEAAAQSyLUAFKduixIcAAggggAACCCCAAAJ5K0AFKW93HQlHAAEEkivwxx9/2M8//2yHDx9OLgI5RwABBBBoEwEqSG3CSqQIIIAAAm0psGTJEhswYIAtW7asLTdD3AgggAACCRSggpTAnU6WEUAAAQQQQAABBBBAoGkBKkhNuzAXAQQQQAABBBBAAAEEEijQLoF5JssIIIAAAgUqsGrVKps/f75t2bIldMEbP368jR07NiO3c+bMse7du9vo0aPtjTfesNWrV1ufPn1swoQJNnLkyIxlmUAAAQQQSJ4ALUjJ2+fkGAEEEChIgWeeecZGjBhh7733nhUXF9vSpUtt3LhxNnny5Iz8vvrqqzZr1iy78sor7amnnrLq6mqbO3euXXXVVbZ48eKMZZlAAAEEEEieABWk5O1zcowAAggUnMA333xjjz/+uN100022ceNGW7Bggf3www92//332+zZs0OrUnqmv/rqK7vuuuts586dYaCHNWvWWFlZmc2YMSN9Md4jgAACCCRQgApSAnc6WUYAAQQKTWDevHmh1WjmzJlWUlISsldUVGTTpk2ziooKq6qqyshyaWmpqcVJlSKFwYMH26WXXhqGDs9YkAkEEEAAgcQJUEFK3C4nwwgggEDhCWzYsMEqKytDZSg9dx06dAgVH7UqpYf+/ftb+/bt02eFdWtrazPmMYEAAgggkDwBKkjJ2+fkGAEEECg4gT179liXLl2azFenTp3szz//zPisvLw8Y1oTanGqr68/YT4zEEAAAQSSJUAFKVn7m9wigAACBSkwaNCgZrvHbd261YYNG1aQ+SZTCCCAAALZF6CClH1TYkQAAQQQ+D8LXHHFFaZWpA8++CBjyxp84bvvvrPhw4dnzGcCAQQQQACB5gSoIDUnw3wEEEAAgbwRuO+++8I9SJMmTbLXXnvNdE/SwoUL7dprr7WBAwfaAw88kDd5IaEIIIAAAmdXgAfFnl1/to4AAgggkAUBjUb39ddf21133WV33nmnHTt2zDp27GijRo0Kw3z369cvC1shCgQQQACBJAgU+Q2p3JGahD1NHhFAAIGECGgkOt13dP7556eG/E5I1skmAggggEAWBKggZQGRKBBAAAEEEEAAAQQQQKAwBLgHqTD2I7lAAAEEEEAAAQQQQACBLAhQQcoCIlEggAACCCCAAAIIIIBAYQhQQSqM/UguEEAAAQQQQAABBBBAIAsCVJCygEgUCCCAAAIIIIAAAgggUBgCVJAKYz+SCwQQQAABBBBAAAEEEMiCABWkLCASBQIIIIAAAggggAACCBSGABWkwtiP5AIBBBBAAAEEEEAAAQSyIEAFKQuIRIEAAggggAACCCCAAAKFIUAFqTD2I7lAAAEEEEAAAQQQQACBLAhQQcoCIlEggAACCCCAAAIIIIBAYQj8D0sDAA4zQmBHAAAAAElFTkSuQmCC" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-20600-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515409
</td>
<td style="text-align:right;">
5989806
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12200170
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-00200-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522065
</td>
<td style="text-align:right;">
5993180
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12200289
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-81100-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
497107
</td>
<td style="text-align:right;">
5990162
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-29500-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
496209
</td>
<td style="text-align:right;">
5999657
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
100-596500-54900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
583374
</td>
<td style="text-align:right;">
5911978
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
100-596500-03300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
537250
</td>
<td style="text-align:right;">
5991350
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
551588
</td>
<td style="text-align:right;">
5970657
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
100-574400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526285
</td>
<td style="text-align:right;">
5978523
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522679
</td>
<td style="text-align:right;">
5956610
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518502
</td>
<td style="text-align:right;">
5962002
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
524160
</td>
<td style="text-align:right;">
5957999
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196160
</td>
<td style="text-align:left;">
Tay Creek
</td>
<td style="text-align:left;">
100-615400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
525765
</td>
<td style="text-align:right;">
6009127
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
100-560100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521127
</td>
<td style="text-align:right;">
5965112
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
100-567900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
516996
</td>
<td style="text-align:right;">
5972733
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
100-562800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515025
</td>
<td style="text-align:right;">
5966533
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
100-596500-82000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
573972
</td>
<td style="text-align:right;">
5894796
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
100-596500-90900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
590481
</td>
<td style="text-align:right;">
5882133
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196353
</td>
<td style="text-align:left;">
Williams Creek
</td>
<td style="text-align:left;">
100-596500-98000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
599849
</td>
<td style="text-align:right;">
5882781
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-535900-08600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
517279
</td>
<td style="text-align:right;">
5936628
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518845
</td>
<td style="text-align:right;">
5961982
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
100-572700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521864
</td>
<td style="text-align:right;">
5976392
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-587900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526448
</td>
<td style="text-align:right;">
5985791
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
100-580500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522978
</td>
<td style="text-align:right;">
5980978
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
100-536400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
520105
</td>
<td style="text-align:right;">
5935908
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388945
</td>
<td style="text-align:right;">
5997015
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388276
</td>
<td style="text-align:right;">
5996951
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
398947
</td>
<td style="text-align:right;">
5996427
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199174
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
397158
</td>
<td style="text-align:right;">
5996575
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
180-296000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
425559
</td>
<td style="text-align:right;">
5996140
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
100-683800-01900-12800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
587921
</td>
<td style="text-align:right;">
5972449
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
100-698700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
606373
</td>
<td style="text-align:right;">
5965784
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344022
</td>
<td style="text-align:right;">
5862734
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
199328
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388367
</td>
<td style="text-align:right;">
5996766
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
203302
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344226
</td>
<td style="text-align:right;">
5862767
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
100-596500-84300-21000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577020
</td>
<td style="text-align:right;">
5886032
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
100-596500-10600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
536470
</td>
<td style="text-align:right;">
5981315
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541465
</td>
<td style="text-align:right;">
5981577
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541358
</td>
<td style="text-align:right;">
5981709
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521645
</td>
<td style="text-align:right;">
5955176
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
100-545900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521513
</td>
<td style="text-align:right;">
5949553
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
556416
</td>
<td style="text-align:right;">
5962053
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
4931
</td>
<td style="text-align:left;">
Crooked Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344710
</td>
<td style="text-align:right;">
5862865
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388738
</td>
<td style="text-align:right;">
5997154
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
BB;C;EB;LKC;LNC;LSU;NSC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12200170
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CC;CH;RB;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12200289
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CBC;CSU;EB;KO;LSU;MW;NSC;PCC;RB;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;CAS;CC;CH;CSU;DV;LDC;LKC;LSU;MW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196160
</td>
<td style="text-align:left;">
Tay Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
BB;CCG;LKC;RB;SP;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196353
</td>
<td style="text-align:left;">
Williams Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
CCG;CSU;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199174
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
LKC;LSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199328
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
203302
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
4931
</td>
<td style="text-align:left;">
Crooked Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Francois Lake
</th>
<th style="text-align:left;">
Lower Chilako
</th>
<th style="text-align:left;">
Lower Salmon
</th>
<th style="text-align:left;">
Morkill
</th>
<th style="text-align:left;">
Nechako
</th>
<th style="text-align:left;">
Tabor
</th>
<th style="text-align:left;">
Upper Fraser
</th>
<th style="text-align:left;">
Willow
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Acipenser transmontanus
</td>
<td style="text-align:left;">
White Sturgeon
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
E/T (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Carassius auratus
</td>
<td style="text-align:left;">
Goldfish
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus platyrhynchus
</td>
<td style="text-align:left;">
Northern Mountain Sucker
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cyprinus carpio
</td>
<td style="text-align:left;">
Carp
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Micropterus salmoides
</td>
<td style="text-align:left;">
Largemouth Bass
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
E/T/SC (Dec 2018)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Anadromous Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Char, General
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
