<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_fraser_2024","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-07-28</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https:/github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/raw/main/mapping/sites_fraser_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Habitat Conservation Trust Foundation, Society for Ecosystem Restoration Northern BC, and the Ministry of Transportation and Infrastructure (MoTI). Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from throughout the study area. Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigCO5nitYJJ7iRY4kG5nY4AFcBdePbvVtRbT/CFgbtwSGuZRhB79Rj8fyqLXvP8a+KG0WKWWLSLM7p3j6SMOo/Pgfia7LQvD9hoZl/s+MoJABg4+UDsOM+/wBadl1A41/B3ivWDv1vxQ9qp5MNmpI/PKgfkajf4P6XId0msayXx1Ey/n92vTKKNOy+5Bd9zy9vhM0CAaX4p1e1YDqxD/yIqs9j8SfCqtLaXsHiK0X/AJZS5MpH0OD+AY16zRRpe9kF33PPNC+KWmy3C2PiSCbQ9S6GO5UhCfqeR+P516DFIksayROrxsMqynII9QazfEGgaZ4gtGt9WtI50IIDEfMmf7rdRXlt5pHif4ZTm80CSbWPDgO6a0c5eJe5/wDrj8RRa+wz2aisPwj4o03xTpq3emS5IA8yFiN8Z9CP61uUhBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFQyXVvGP3k8S/VwKoya/pcblZbyNCP72QPzoCxqUU2KRJo1kidXRuQynIP406gAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKoeIL3+ztEvrvODFCzA++OP1xV+uY+JMrReDr3aMlig/wDHxQgIPhfZC28KwzsP3t0TKxPU9h/KuurN8NhRoGnhWVh5Ccr06VpUAFFFFABRRRQAUHkYNFFAHi/jzRbr4f66PF/hsFdOdwL61X7q5PJx/dP6HFetaHqltrWkWuo2Lh7e4QOp9PUfUHIqbUbKDUbC4s7tBJbzxmN1PcEYryz4NXFzoWu654N1KXfJZyGW2Y8bk46D3BU/nT3A9booopAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFY+u3V7JatBoLwNetxufkRj1xQlcDYoryTxkPEWh6AbjWPEzeZI21IYI1BdvTOBx+FdP8J7fVovDCy61LKzzv5kSSHlU7H2z1xRZhodpRRRQAUUUUAFFFFABRRRQAUUUUAFFFU9V1Sy0q28/ULmOCPsWPLewHU/hQBcqhq+sWGj25m1C5SJcZAPLN9AOTXNLq+u+JFH9g239m2DH/j9uhlnH+yn9a0tG8KWdjILm9kk1G+zkz3HzYPsDnH60bjehjzeKNe1jC+F9FfyG6Xd58ikdMgH/wCvVu38LaheyrP4i1u6nbGDbWreVCPrjk/Xiuvop3XQlXKFho+nWAH2SzhRh/GV3Ofqx5P51JqmnWmq2UlpqMCT28gwyN/j1H4Vbpk8scELyzMEjQFmY9AKLsZzuh6Rb+F7m007TXnNjcb8RSyF9jAZyCecdq6WsLQ2fVbxtYkBW3K+Xaowwdndz9f5Vu0N33AKKKKQBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABXMfEqMyeDr3AztKMR7bhXT1V1S1W9025tnGRLGyfmKaAi8Psj6Fp7RYCG3TGBj+EVfrmvh7dNP4cihlBWW2YxEHrjt/n2rpaTAKKKKACiiigAooooAK8e8bg6L8cPDGpQnYL9Ft5T2Y5KH9Ctew14/8aY2HjbwNKhO/7VgAdeHjP9f0poD2CiiikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABVbU76DTbCe8u2KQQruYgZqn4m16y8OaTLf6jIFjXhV7u3YCuI8GprPjYTaj4j/d6JI2bezAwJADwfXA9e9NAaOhXWr+Lrhr5mNlo6t+5Cj53HqM/wA/yFb+uarpvhLRXuZwI4lztjX70jf1PqTWpdXFtpthJPMUhtYEycDAVR6CvLtFtZPiR4kk1bUkb/hH7N9ttAeBIw/zk/lQ3d6AkWfC2iX3jDVk8R+JciyU7rOzYfKR2JHoP1716hSKoRQqgKoGAAMAClobuAUUUUgCiiigAoornPEfjDTtF/chvtd+TtW1hOWJ9D6UAdEzBVLMQFAySe1QTXttBa/aZZ41tyAwk3cEHoR61wOq6J4h8d2bW+ss2h6UxDGCJt0so9G5H6/lXSaN4N0fSrGG1jhkuEiXapuJWfj0x0/SnbuPSxcj8R6RI6qL+Fd3QuSoP0J4rVZ1WMuzKEAyWJ4A9c1x/jXQ/Ci6JGdcs4ktrYl4RCSjg/7O0jP48V594Ht9S8bS3Fg95d2vhi0YFIT99lycLuxz0PJ4GOlFl0YaHear41e5vn0zwpaPqV6OHlAxFF2znof5fWrui+FQsqX2vztqOonkl+Y0Psvt/kVvaVptppVmlrp8CQwJ0VR1PqT3NW6NthBRRRSAKKKztd1mz0WzNxevjJwiLyzn0AoAu3M8VtA81w6xxIMszdBXMpFP4puhJco0Whxn5IzkG5PqfRajg0q98SXEV54hQ29lGd0Onhjz0wZD/T/9R64AAAAAAcACgBFUIoVQFUDAAGABS0UUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQBwt7e/wDCJ+NRJdBU0fWGC+aWAWKb0P1P867qs3xDpUes6VNZyHYzfNG/9xx0NYvg7XZZJX0TWB5erWgCnJ/1q4yCPwoA6yiiigAooooAKKKKACvKviWxufid4Ls1wTHKs2O4G8ZP5Ka9VryVidZ+Pq7QWg0u2wTnodp/9memgPWqKKKQBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVm+IdbstA0uW+1GZY4kBIGfmc/3VHc1NrGp2uj6bPfX8ojt4V3Me59gO5ryzQNNvviP4kGva7G0Og2p/0SzJ++wxz9OOT+H0AJtA0a++IepR674otzBpMTH7JZ5I3jPUj09fWvWI0WNFSNQqKAFVRgAegpVAVQqgAAYAHauO+JPiQ6No7Wtk27VLv91Cq9Vzxn/CnuBzHjvULnxj4jh8KaI4NtEwe9mDYGAeR7gfqa9O0qwt9L0+Cys4xHBCgRVH865z4ceFV8NaMDcKranc4e4kHJz/dz7fzrraQBRRRQAUUUUAFZXiDX9O0C187Upwmfuooyz/Qf5FYfiXxe9vqP9j6Bbtfas3B2jKRH3/zgd/Sjw74QZblNU8Szf2hqv3lVxmOA/wCyO59+3anYCjFc+I/GS77TOh6K3AkdczzD1A7D8vxrqdB8P6fokRWyh/et9+aQ7pHPua1qKQ27hXMeMfGNj4cUQf8AHxqco/dWqH5j6E+g/nWd8SfHUfhe2W2skW51aXhYgc+WD0Zv6CuP8DJcT3E97aRNqfiS4GZLycEQ2ueoUkcn/wDVTSuBal0vULi+tr/xURe6tdAraaYhACD1fnAA9PzPavRPCuiLotiysQ91OQ88gGMtjoPYUugaEmmAz3Ez3moyD97cydT7D0FbNDelhBRRRSAKR3WNGd2CooyWJwAKwvEHinT9GIhZzc3zHalrD8zk+hx0rHi0rWvFBWbxE39n6dncunwtl2/33/w/SgCzqXiqW6uGsfC9sdQvAcPL0ii9yx4P+etWdB8NG1u21HV7n7fqbnO9hhI/ZR/Xj6CtywsrbT7ZbeygSCFeioMD6+596sU/QAooopAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFc/4n8Mw6y8N1C/2fUrfmGcfyb1H8q6CimnYDjdH8Vy2d0NM8VxGyvc4jnP8Aq5h656V2KkMoZSCCMgjvVXVNNs9VtTbajbR3EBOdrjofUelcnLoGt6BJ5vhi8+0WvJezu23Z/wB3p/MUWT2A7eiuM0/x9ZeebbW4JdLuQcbZAWU/pkfiPxrsIJoriJZYJEkjYZDIcg0rgPooooAjuZo7a3lnmbbFEhdz6ADJry34K27ahqniTxLMhDXtwUjYntksw/Va1vjbrLad4PazgP8ApOouLdQDg7erf0H410ngjRU8P+FtP05Rh44wZMjkueTn8Tj8KYG5RRRSAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKjuJoraCSad1jiQFmZjgAU9mCqWYgKBkknAAryXXL26+IviVNH0iZ4tCtTuuZwvEhB/X2H40AIPO+KWvhsTweF7Fv4htM7f4/yHvXq9rbxWltHb20axwxqFRFGAAKi0vT7bS7CGzsoxHBEMKo/mferVNgFZV1oNlda9b6rcIHngTbGCOFOfvfWtWikAUUUUAFFFFACMwVSzEBQMkntXnGseIb/xZqc2heFWeK2Q7bnUAPlAzyAf8OT9Kp+INcvPHGtT+G/DbbNPiOLy8HKkdwD6cY9/pXomg6RZ6HpkVjp8QjhjyfUsTyST3Jpp2GReHdCs9CshBaKWc8yTPy8h9Sf6Vq0VgeIfFuk6ErLc3KyXQHy28R3OT6YHSkI3643x/wCPNO8KWLAOtzqT/LDbocnd/tY6fTrWBr2p+Lb/AEi4v7ryfD+kqu7BO6eQHoB6H64rJ+E3giK+vF8SaqrTxqx+xCUkknPLkdPpTSurjegng/4farr18fEHi+4lhkuG8xbb+PB/RPoOcelewafY2unWqW1jBHBAvREGB9fc+9WKKL9BBRWXrviDS9CiD6neRwkjKoTl2+ijk1yrat4l8Vx7dBtv7I0522m9uP8AWMvcovr/AJzSWoHS+IfEul+H41bUbgLI/wByFOXf6D/HFc75/iXxWQbMNoWksDmSRMzyD2HYfl9TWx4f8IaZpDrcOhvdR6td3Pzvn1GeF/Cujp6IDK0TQNP0aPFnAPNI+aZ/mkb6mtWiikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAVNT02z1S3MGoW0VxEf4XXOPoe34Vydx4E+yz+f4d1OfTmA4j5ZfpnPA+ua7einfoBwjav4s0Mn+1NNj1K1XrPbn5gPU4H/stXrL4g+H5wBcXTWcveOdCD+Y4rra8p+N1zp81rDo9nZW914ivmWOMhAZYlPfI559KNAKWmXcXxD+Kf2mIifQ9HXMe4fK7+uCO7foK9jryrwj8K7nw1p8Umma5Pbakyhpz5YKM393gjge+a15dQ8c6Q+240201WH/nrbnDflwf0o5WF0d9RXAxfEzT7fCa5Z3Wmz5IKSL0x65ArYtfHXhu5h82PVIgv+0rD+lJ6bjtfY6aiuTv/iF4ctLYzfbvOUdolJP64rA07xJrfjm8SHStNn0vQlcNLe3HDygHO1B27dM/WjULHpdFFFAgooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoorA8b+II/DegTXr4Mp/dwr6uen4DrQByvxI1241LUIvCOgOWvrgj7S6H/VL1xn6cmux8J+H7Tw3o0NhZjJUZklI+aRu7Gud+F/h9rOxfWdRUvqd/wDOXfllQ8gfj1/Ku6pgFcz4z8YWXhq3YOPPvCu5IFOPxJ7Vb8Wa/FoVgHx5t5MdlvCOrt/hXnniXw0sOl2rajI8viHV7lE8wjOzJ+7j2Bxn8KErgen6Bftqmi2V88XlNcRLLsznGRmr9RWlvHaWsNtAu2GFFjRfRQMAflUtIAooooAK4P4i6/cCWDw5oyeZqN98jkHHlof5Z9ewrrtd1KLSNHvNQuDiO3jLn3PYficCvHvAvinRtNgvfEeuXbXWrXkrJHEnzOqewPTP8hQNHqnhDw9a+GtHjs7VVLn5ppccyP6n+VQeJ/GWjeHBtv7pWuSPlgjwzn/D8a477Z428aSj7FbDQtFccyTN+8dfUDGT+g966jwx4D0bQX+0LEby+JDG5ufnbd6qOg/n700r6sWi2Mdbnxd4tKm1iXQNHfrJId08i+w7fp+NdF4b8IaVoH7y3hM14R811Od8h9ee34V0NYvjLVhofhm/v84eOMhP948Ci/YDhfFcknjjxpD4cspXXTbEiW8ljPBPcZ9e3516hbQRW1vHBAixxRqFRV6ADoK8/wDhqtj4c8FR6pq88VvcagxuJZJD8zc8Adzxzx602bxbrfilntvBdg8VseG1O6G1B/ujv+GT7Ci3RAdrret6dolq0+pXUcKqMhSfmb6DvXEt4m8R+LUMfhGx+w2ZJV769G3j/ZGOv0B/CtLw94CtrW4F/r9zJrGqE7jJPyiH/ZXv+P6V2oAAAAwBRtuM4zQvh9p1ncrfavLLrGp53Ge6OQD7L/jmuzooobvoIKKy/EWu2WgWBur9yBnaiLyzn0ArJhh1DxRYxzXvmabZuQywIcu4zxuJHFIDW0/xDpOo6hPY2OoW893B/rIkbkf4/hWpXifxPk0P4f3drqmjFV1tnwYd+4lSPvEdv616N8ONZvtf8IWWpapGsdxPuPyrgFc8HFBTWlzpqKKKCQopssqQxtJK6pGvJZjgCuUu/FFxf3BtPC9r9sl6PcPxHH/n/OaFqB1tFeZW+reItM+ImlaTql/DcR3cbPIkXQDDY6gdx2xXptABRRRQAUUUUAFFYWreLtC0pWN3qUG4fwRtvP046fjWB/wtbwyOTNcgdz5XA/WlcdjvKKzNB13TtetPtGl3KTxj7wHBX6itOmIKKKZPNFBGZJ5EjjHVnYAD8TQA+iore4iuU3wOJE/vLyD9D3qWgAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKK47x944tPC0SW6KbjU5/lhgTkgnoT/hQBN4+8YQeGLALEon1OcYt7cHknsT7fzrH+HPgye0u5PEfiUCXX7rLANz5Cnt9f5dKj8E+CriTVB4m8WO0+ryfPFA/wB23HbI/ve3avR6b0AKKKKQEVzbQXUfl3UMU0f92RAw/I1nXvhvRb21W2uNMtGt1ORGIwoB/DFa1FNNrYVkZVn4d0azC/Z9Ms1K9CYgSPxPNao4HFFFDbe4JJbBRRRSGFFFFADVkRmZVdSy/eAPI+tOrnodFu9P143OkyQJY3MnmXkUmSxbGPkOOBznFdDQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFeWa5t8afEuHR8s2maUPMuAOhbPT8+K9H1q8GnaTeXjHAgiZ/xA4rhPglYSDQ73WbrJudSuGfcRzsHT9c00B6OoCqAoAA4AHahjgEgZPpVbUr6DTrOS6un2xIOcDJJ9AO5rM8M3mp6nHLeahCltbSNm3gx84X1akBBpuhSTaw+r6w4muAcW8ePlhX1A9f/ANfU8Y2os2ofFjTbVjmKwtWuCueCSMA/UEiu8rznT7+2tPi/rIvriOF5bRFi8w7QcbeAT7DNO4WuejUVn3OtaXbBjcalZRbRk751H9a5XUviZo0c32bRln1e8PCx2sZK59zj+QNTdbDszuqwfEHivSdD+S6uBJcn7tvF8zn8B0/GuROkeNvFRV9VvU0Owfrb27Ey7fcD+p/Cus8OeENH0BVazthJcgc3M/zyk+uT0/DFVa24tOh4x8UPEXizxDDb2Lac+kaNeyBYzMh3yHI69/fsK9U8C/DzRfClpbmO3W51JFG+7lG5i3fHp+HNXPiD4ZPifQxbwSJDeQuJYJHzgMOxx2NcTb+OPF/hwG08SeGLm82fKlzbZIfA/vKpB/Snrb3R76M9dorzG3+Jup3oKWHg/U5ZemPmIH1Ozj8cVZkg+IGusPMksdCtG6qrF5QPbHf8RSSYaLqdrqmt6bpWP7QvYICeiu4B/KvEPjf4yvtX0230zR7ORLCeYZu3BCuR6HGOvoTXpeifDnRrGb7TqPmarek7jLd4K59k6fnmofjDoE2teC5V0+INd2bC4iRR1C9QB9P5UJLqCdit4S+Gtha2FlJr8j6rdpGMpMcwqcdAvfHvx7V6DFGkMaxxIqRqMKqjAA9AK4n4WeNbTxRoUELyLHqtsgjngb5WJHG4DOSOOfeu4ob6CCiimTSxwRNJPIkcajJZ2AA+pNIB9ZfiXW7Tw/pM1/euAiD5VzguewFY+s+PtD00ui3Iu5lH3Lchuewzn+Wa+ffHnxA1bxl4gWO2tntLCzOVRieT3Jz3/CjV7IpLueyeHrVZ2fxZ4zlijDfPaQzPxEvrj1x0HPrWZrHxD1XxHfT6T4HtHbAwbsjn8Oy/U1zvgnw7feMGFzqT3V1GijbcTMViU+ij+L6CvcdH0q00mzS3soIolAAJRAu4+pppW3Jv2PEPGXw/sPDvga91nxFPJqGuSsoMrOSsbMeg9e/Jr1v4dxrF4H0VI/u/ZlP58/1q14u8P2nijw/daTf7hDOvDr1Rh0YV5Vb/AA6+IWmQrY6R4ugTTY/liDyyKyr9Apx+dCTew7rqe0zzw26F55Y4kAyWdgox+Ncfd+OFvLo2Xha0fVLroZBxEnuT6dfSsjw98LwJVu/F2qXGs3f/ADzZyIl/qf0+leiWVnbWMAhsreG3hHRIkCKPwFK3cV+xzX/COajq2xvEuo74h1tbUbUP1bGf6+9dJYWVtp9qlvZQpDCvRUGPx9z71Yopt3A8h+Kk8nhn4geHvFMsXmacimCYgcr16e+GyPpXoemeK9B1K2jntNWsmVxkBplVh7EE5rTv7K11G0ktb63iuLaQYeOVQykfQ15tqfwR8L3UzSWkuo2GTnZBPlB9AwJ/WjfqO67HeyeItFiBMmr6eoHrcp/jWFqfxK8MWB2/2gty/Tbbjf8Ar0rDsvgr4XgZWnk1K7wc4muBj/x1RXWaH4L8O6G4k0zSLaKUHIkYF3B9mbJH4UW7v8BX7I5yDxr4g1uRl8OeG5fJxxPeZjQ++Tj8hmrA8LeIdbTPijXTEm7P2fThtXHoWI6/ga7yijRbDuc3pvgfw7YD5dLt7iQ9ZLpfOY+/zZx+GK100jTUh8lNPs1h6bBCoX8sVdoo5n3JsjzDxFoOo+DtbXXvBem/abaUbLvToRjPuoHT6DoavWXjXxLqGUtfBF9DJnAa5l8tR/30q16DRS0Gcxb2vii+2nUbyz06Mj5o7Rd7/TLdD7itC18PWETLJOsl7Oox5t3IZW/I8D8BWvRTvbYd2FFFFIQUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUMQoJYgAckntVbUtQtNMtHutQuI7eBOryHA+g9T7V4x4g8Sa58R9R/sTwmsltphYefckYAXHV2HH0UdaFq7DsdB41+JEgvv7E8GxDUNWkO3cnzAHvt9fqeK0fAvgM6fc/2z4kkW+12Q78sdywE/3Sep9/yrV8C+B9L8H2rCzUz3so/fXco+d/Yf3R7D9a6qntsIKKKKQBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFMnkMULusbyFRnYmNx+mcV5b4/wBE8a+MLB4NPki0y135WNpmRmHbdtGf1os3sCt1PVaK8g+GEPiPwVqK6H4puPtcN2QYHWUy7D04J5wfSvX6dmtxu3QKKKKQgooooAKKKKACiiigAooooAKKKKAOT+Kqzt4B1b7NncIwWAPJXcM1z/gzxz4f0rwDpgmvIxNDGInt0YGTd9M8euTivSpo0mieKVFeNwVZWGQQeoNcVbfCzwjb6m98NLV3ZtwjdyY1Psv+Oadk+oX8iTRWufFxj1C8HlaXndFCCQWIPHPQj1I+grs+nSmxoscapGqoigKqqMAAdgKdSAK5nxV4H0PxNMs+pWzC7QbVuIW2OB/I/iDXTUU02tUB51a/B7wvDMJJxfXfOds8+Qf++QK7TR9D0vRoyml2FtagjBMcYDN9T1P41o0U3JvcVgoooqRhRRRQAUUUUAFFFFAHnXjL4WadreoHU9Ku5tH1Q8mWAZRj6leMH3BrBHg/4nW8EsEXiiyuY3BXNxNIxI/FDj869jopt33VxptbM8gg8LfFGRUS48T2EUYxnY77gPwQfzrQh+F1zfFJfEniXUL2XGGWM7R+BOTXp9FGi2SByk92Yui+FtF0ZIxY6fAsqciZ1DyZ9dx5qW68OaJd3DT3WkafNM53M8lujFj6kkc/jWrRQpNbE2TERVRFVFCqowABgAUtFFIYUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVyPjnx5pXhO1fz5UmvSPktw4HP8AtHsK1vF1nql/oFzbaDdx2moPgJM5IC888gEjiuD8PfB6wjmgvPFF3Jql4vLQg4gz+W4+vUfSi2g01fU83/tXVfiDqiTavHqlzpascQ6bDuLD0X+6PU9frXp+lXXiKx06Gw8IeC49MslJ+a8mUHP94rkEn3Oa9Hs7S3srdLezgit4E+7HEgRR9AOKmpu1rIV29zzf7B8TbgFm1TRbbI4QKTj8dhqs/h74mSOpfxLpgXuFDDP5IK9RooTje/KgvLueZjwt4+jcNF4rtz6h1cgfnmnz6P8AExCfs3iHSCuON8RyfzQ16TRR7v8AKvx/zEubueYif4p2SqXtdH1AjrtcLn/0Gon8aeOrNtt54Nkl2j5jbqz7j7EE16nRRaPb8WO7POZPiVdWyI2oeFNXt89cof6qKcnxe8OAkTx38BHB3xDg/wDfVeiVBeWVrfQ+Ve20FxF12Sxhx+Rosguc3pvxC8LagyLDq8CO38M2Y8fUnj9a138RaKihm1awCnoftCc/rWLq3w38JaoQZ9Fto3BzutwYTn/gOAfxrLj+EHhRDlob2THTddMMfTGKOXz/AAC67HSv4u8PpjdrFlycD94DVC6+IPh2BX2XrXDLxthiZs/Q4A/Wo7T4a+E7bBGkpKw7zSvJ/Nq3rTQdIs5FktdLsYZF6OkChh+OM0WXVhfsjl3+ID3BUaT4e1a6LdC0RUfXjPFSC/8AHFyA0OlWFqM5xNJkkfg3B/Cu2oo0DU4J7T4g3K/8f+k2oJ6DJOP++DUI8M+NZlAuPE8aEkljGG4+nAr0Oij3e35/5hd9zg/+EJ1uUfv/ABnqg46RAqP/AEKnN4G1IggeL9YweuWJz+td1RS0fQDgJfBevxwkWfjC/LjlRMDj8w1Qiy+IOlQtLFe6fqaod3lMTucenKj/ANCr0WihWXQLvucX4K8eQa/fSaVfWkun6zCD5lvIODjrjvn2Pau0rz74hfD+bxBq1vrWiakdN1iBAgcDCuBkjLL8wPOM88dqwx4b+KaKqL4i0wqowGMshb8f3fNNp2ugTXU9dory6PSvinGq79b0eTb0Cjk/XMVTta/FD+G90fj1xz/45QlL+mgbV9/wZ6VRXnkB+JUQ/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-20600-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515409
</td>
<td style="text-align:right;">
5989806
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-29500-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
496209
</td>
<td style="text-align:right;">
5999657
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
100-596500-54900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
583374
</td>
<td style="text-align:right;">
5911978
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
100-596500-03300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
537250
</td>
<td style="text-align:right;">
5991350
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
551588
</td>
<td style="text-align:right;">
5970657
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
100-574400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526285
</td>
<td style="text-align:right;">
5978523
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522679
</td>
<td style="text-align:right;">
5956610
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518502
</td>
<td style="text-align:right;">
5962002
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
524160
</td>
<td style="text-align:right;">
5957999
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
100-560100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521127
</td>
<td style="text-align:right;">
5965112
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
100-567900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
516996
</td>
<td style="text-align:right;">
5972733
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
100-562800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515025
</td>
<td style="text-align:right;">
5966533
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
100-596500-82000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
573972
</td>
<td style="text-align:right;">
5894796
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
100-596500-90900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
590481
</td>
<td style="text-align:right;">
5882133
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-535900-08600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
517279
</td>
<td style="text-align:right;">
5936628
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518845
</td>
<td style="text-align:right;">
5961982
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
100-572700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521864
</td>
<td style="text-align:right;">
5976392
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-587900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526448
</td>
<td style="text-align:right;">
5985791
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
100-580500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522978
</td>
<td style="text-align:right;">
5980978
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
100-536400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
520105
</td>
<td style="text-align:right;">
5935908
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388945
</td>
<td style="text-align:right;">
5997015
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388276
</td>
<td style="text-align:right;">
5996951
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
398947
</td>
<td style="text-align:right;">
5996427
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
180-296000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
425559
</td>
<td style="text-align:right;">
5996140
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
100-770300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
650784
</td>
<td style="text-align:right;">
5934858
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
100-683800-01900-12800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
587921
</td>
<td style="text-align:right;">
5972449
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
100-698700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
606373
</td>
<td style="text-align:right;">
5965784
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344022
</td>
<td style="text-align:right;">
5862734
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
100-596500-84300-21000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577020
</td>
<td style="text-align:right;">
5886032
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
100-596500-10600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
536470
</td>
<td style="text-align:right;">
5981315
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541465
</td>
<td style="text-align:right;">
5981577
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541358
</td>
<td style="text-align:right;">
5981709
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521645
</td>
<td style="text-align:right;">
5955176
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
100-545900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521513
</td>
<td style="text-align:right;">
5949553
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
556416
</td>
<td style="text-align:right;">
5962053
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388738
</td>
<td style="text-align:right;">
5997154
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
BB;C;EB;LKC;LNC;LSU;NSC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;CAS;CC;CH;CSU;DV;LDC;LKC;LSU;MW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
BB;CCG;LKC;RB;SP;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
CCG;CSU;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
LKC;LSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
EB;LKC;RB;RSC;ST
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Francois Lake
</th>
<th style="text-align:left;">
Lower Chilako
</th>
<th style="text-align:left;">
Lower Salmon
</th>
<th style="text-align:left;">
Morkill
</th>
<th style="text-align:left;">
Nechako
</th>
<th style="text-align:left;">
Tabor
</th>
<th style="text-align:left;">
Upper Fraser
</th>
<th style="text-align:left;">
Willow
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Acipenser transmontanus
</td>
<td style="text-align:left;">
White Sturgeon
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
E/T (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Carassius auratus
</td>
<td style="text-align:left;">
Goldfish
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus platyrhynchus
</td>
<td style="text-align:left;">
Northern Mountain Sucker
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cyprinus carpio
</td>
<td style="text-align:left;">
Carp
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Micropterus salmoides
</td>
<td style="text-align:left;">
Largemouth Bass
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
E/T/SC (Dec 2018)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Anadromous Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Char, General
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
