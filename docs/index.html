<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_fraser_2024","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-08-06</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/raw/main/mapping/sites_fraser_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Habitat Conservation Trust Foundation, Society for Ecosystem Restoration Northern BC, and the Ministry of Transportation and Infrastructure (MoTI). Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from throughout the study area. Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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ypUr06ajNPCgCyJwHASohHNq06pVq/wTDsL1SFwk39R9jmLKiUBTBLKVMZYh7sNFa5zcsJjGGkaMGGG33357U2J1TwREoJUIFKDnrK6Vnq3HioAIiIAIiIAIiECsCHDdEU3Ml5eXxyrdSqwI5BMBKUj5lFuKqwiIgAiIgAiIgAiIgAiIQIsS0D5ILYpXwkVABERABERABERABERABPKJgBSkfMotxVUEREAEREAEREAEREAERKBFCUhBalG8Ei4CIiACIiACIiACIiACIpBPBKQg5VNuKa4iIAIiIAIiIAIiIAIiIAItSkAKUovilXAREAEREAEREAEREAEREIF8IiAFKZ9yS3EVAREQARFwAty3aNu2bXbw4EEREQEREAEREIGcEpCClFOcEiYCIiACInAqCHBjzoEDB9rq1atPxeP0DBEQAREQgRgRkIIUo8xWUkVABERABERABERABERABJomIAWpaT66KwIiIAIiIAIiIAIiIAIiECMCRTFKq5IqAiIgAiIQcQJr1661ZcuW2datW30K3pVXXmkTJkxIS/ULL7xgFRUVNn78eFu6dKmtW7fO+vTpY1OmTLGLL744za9OREAEREAE4kdAI0jxy3OlWAREQAQiSeCRRx6xUaNG2ZtvvmmFhYW2cuVKmzhxos2cOTMtvYsWLbJ58+bZ2LFj7aGHHrKdO3fawoUL7ZJLLrE33ngjza9OREAEREAE4kdAClL88lwpFgEREIHIEfjss89s9uzZdsMNN9imTZvstddes++++85mzZplCxYs8FGlcKLXrFljkydPtl27drmhh/Xr11v79u1t7ty5YW86FgEREAERiCEBKUgxzHQlWQREQASiRmDx4sU+avTss89acXGxJ6+goMDmzJljPXv2tOeeey4tyaWlpcYRJypFdEOGDLERI0a46fA0jzoRAREQARGIHQEpSLHLciVYBERABKJHYOPGjXb66ae7MhROXVlZmSs+HFUKuwEDBlhJSUn4koc9cOBA2jWdiIAIiIAIxI+AFKT45blSLAIiIAKRI1BZWWmdOnVqNF2nnXaa1dbWpt3r0KFD2jlPOOJUV1fX4LouiIAIiIAIxIuAFKR45bdSKwIiIAKRJHDmmWcec3rcL7/8Yuedd14k061EiYAIiIAI5J6AFKTcM5VEERABERCBU0xgzJgxxlGkt956K+3JNL6wYcMGGzlyZNp1nYiACIiACIjAsQhIQToWGV0XAREQARHIGwJ33nmnr0GaNm2avfjii8Y1ScuXL7dJkybZGWecYXfddVfepEURFQEREAERaF0C2ii2dfnr6SIgAiIgAjkgQGt0n376qc2YMcOmT59uR48etfLychs3bpyb+e7fv38OniIRIiACIiACcSBQgAWpWpEah5xWGkVABEQgJgRoiY7rjgYPHpwy+R2TpCuZIiACIiACOSAgBSkHECVCBERABERABERABERABEQgGgS0Bika+ahUiIAIiIAIiIAIiIAIiIAI5ICAFKQcQJQIERABERABERABERABERCBaBCQghSNfFQqREAEREAEREAEREAEREAEckBAClIOIEqECIiACIiACIiACIiACIhANAhIQYpGPioVIiACIiACIiACIiACIiACOSAgBSkHECVCBERABERABERABERABEQgGgSkIEUjH5UKERABERABERABERABERCBHBCQgpQDiBIhAiIgAiIgAiIgAiIgAiIQDQJSkKKRj0qFCIiACIiACIiACIiACIhADghIQcoBRIkQAREQAREQAREQAREQARGIBoH/Ax1lj7EkniCiAAAAAElFTkSuQmCC" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-20600-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515409
</td>
<td style="text-align:right;">
5989806
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-29500-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
496209
</td>
<td style="text-align:right;">
5999657
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
100-596500-54900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
583374
</td>
<td style="text-align:right;">
5911978
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
100-596500-03300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
537250
</td>
<td style="text-align:right;">
5991350
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
551588
</td>
<td style="text-align:right;">
5970657
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
100-574400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526285
</td>
<td style="text-align:right;">
5978523
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522679
</td>
<td style="text-align:right;">
5956610
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518502
</td>
<td style="text-align:right;">
5962002
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
524160
</td>
<td style="text-align:right;">
5957999
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
100-560100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521127
</td>
<td style="text-align:right;">
5965112
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
100-567900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
516996
</td>
<td style="text-align:right;">
5972733
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
100-562800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515025
</td>
<td style="text-align:right;">
5966533
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
100-596500-82000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
573972
</td>
<td style="text-align:right;">
5894796
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
100-596500-90900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
590481
</td>
<td style="text-align:right;">
5882133
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-535900-08600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
517279
</td>
<td style="text-align:right;">
5936628
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518845
</td>
<td style="text-align:right;">
5961982
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
100-572700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521864
</td>
<td style="text-align:right;">
5976392
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-587900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526448
</td>
<td style="text-align:right;">
5985791
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
100-580500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522978
</td>
<td style="text-align:right;">
5980978
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
100-536400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
520105
</td>
<td style="text-align:right;">
5935908
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Burnt Cabin Creek
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388946
</td>
<td style="text-align:right;">
5997015
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388276
</td>
<td style="text-align:right;">
5996950
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
398938
</td>
<td style="text-align:right;">
5996429
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
180-296000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
425562
</td>
<td style="text-align:right;">
5996164
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
100-770300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
650785
</td>
<td style="text-align:right;">
5934863
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
100-683800-01900-12800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
587921
</td>
<td style="text-align:right;">
5972451
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
100-698700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
606373
</td>
<td style="text-align:right;">
5965783
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344034
</td>
<td style="text-align:right;">
5862741
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
100-596500-84300-21000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577020
</td>
<td style="text-align:right;">
5886032
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
100-596500-10600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
536470
</td>
<td style="text-align:right;">
5981315
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541465
</td>
<td style="text-align:right;">
5981577
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541358
</td>
<td style="text-align:right;">
5981709
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521645
</td>
<td style="text-align:right;">
5955176
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
100-545900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521513
</td>
<td style="text-align:right;">
5949553
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
556416
</td>
<td style="text-align:right;">
5962053
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Burnt Cabin Creek
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388738
</td>
<td style="text-align:right;">
5997154
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
BB;C;EB;LKC;LNC;LSU;NSC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;CAS;CC;CH;CSU;DV;LDC;LKC;LSU;MW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
BB;CCG;LKC;RB;SP;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
CCG;CSU;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Burnt Cabin Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
LKC;LSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
EB;LKC;RB;RSC;ST
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Burnt Cabin Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Francois Lake
</th>
<th style="text-align:left;">
Lower Chilako
</th>
<th style="text-align:left;">
Lower Salmon
</th>
<th style="text-align:left;">
Morkill
</th>
<th style="text-align:left;">
Nechako
</th>
<th style="text-align:left;">
Tabor
</th>
<th style="text-align:left;">
Upper Fraser
</th>
<th style="text-align:left;">
Willow
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Acipenser transmontanus
</td>
<td style="text-align:left;">
White Sturgeon
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
E/T (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Carassius auratus
</td>
<td style="text-align:left;">
Goldfish
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus platyrhynchus
</td>
<td style="text-align:left;">
Northern Mountain Sucker
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cyprinus carpio
</td>
<td style="text-align:left;">
Carp
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Micropterus salmoides
</td>
<td style="text-align:left;">
Largemouth Bass
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
E/T/SC (Dec 2018)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Anadromous Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Char, General
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
