<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_fraser_2024","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-07-28</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https:/github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/raw/main/mapping/sites_fraser_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Habitat Conservation Trust Foundation, Society for Ecosystem Restoration Northern BC, and the Ministry of Transportation and Infrastructure (MoTI). Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from throughout the study area. Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigCO5nitYJJ7iRY4kG5nY4AFcBdePbvVtRbT/CFgbtwSGuZRhB79Rj8fyqLXvP8a+KG0WKWWLSLM7p3j6SMOo/Pgfia7LQvD9hoZl/s+MoJABg4+UDsOM+/wBadl1A41/B3ivWDv1vxQ9qp5MNmpI/PKgfkajf4P6XId0msayXx1Ey/n92vTKKNOy+5Bd9zy9vhM0CAaX4p1e1YDqxD/yIqs9j8SfCqtLaXsHiK0X/AJZS5MpH0OD+AY16zRRpe9kF33PPNC+KWmy3C2PiSCbQ9S6GO5UhCfqeR+P516DFIksayROrxsMqynII9QazfEGgaZ4gtGt9WtI50IIDEfMmf7rdRXlt5pHif4ZTm80CSbWPDgO6a0c5eJe5/wDrj8RRa+wz2aisPwj4o03xTpq3emS5IA8yFiN8Z9CP61uUhBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFQyXVvGP3k8S/VwKoya/pcblZbyNCP72QPzoCxqUU2KRJo1kidXRuQynIP406gAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKoeIL3+ztEvrvODFCzA++OP1xV+uY+JMrReDr3aMlig/wDHxQgIPhfZC28KwzsP3t0TKxPU9h/KuurN8NhRoGnhWVh5Ccr06VpUAFFFFABRRRQAUHkYNFFAHi/jzRbr4f66PF/hsFdOdwL61X7q5PJx/dP6HFetaHqltrWkWuo2Lh7e4QOp9PUfUHIqbUbKDUbC4s7tBJbzxmN1PcEYryz4NXFzoWu654N1KXfJZyGW2Y8bk46D3BU/nT3A9booopAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFY+u3V7JatBoLwNetxufkRj1xQlcDYoryTxkPEWh6AbjWPEzeZI21IYI1BdvTOBx+FdP8J7fVovDCy61LKzzv5kSSHlU7H2z1xRZhodpRRRQAUUUUAFFFFABRRRQAUUUUAFFFU9V1Sy0q28/ULmOCPsWPLewHU/hQBcqhq+sWGj25m1C5SJcZAPLN9AOTXNLq+u+JFH9g239m2DH/j9uhlnH+yn9a0tG8KWdjILm9kk1G+zkz3HzYPsDnH60bjehjzeKNe1jC+F9FfyG6Xd58ikdMgH/wCvVu38LaheyrP4i1u6nbGDbWreVCPrjk/Xiuvop3XQlXKFho+nWAH2SzhRh/GV3Ofqx5P51JqmnWmq2UlpqMCT28gwyN/j1H4Vbpk8scELyzMEjQFmY9AKLsZzuh6Rb+F7m007TXnNjcb8RSyF9jAZyCecdq6WsLQ2fVbxtYkBW3K+Xaowwdndz9f5Vu0N33AKKKKQBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABXMfEqMyeDr3AztKMR7bhXT1V1S1W9025tnGRLGyfmKaAi8Psj6Fp7RYCG3TGBj+EVfrmvh7dNP4cihlBWW2YxEHrjt/n2rpaTAKKKKACiiigAooooAK8e8bg6L8cPDGpQnYL9Ft5T2Y5KH9Ctew14/8aY2HjbwNKhO/7VgAdeHjP9f0poD2CiiikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABVbU76DTbCe8u2KQQruYgZqn4m16y8OaTLf6jIFjXhV7u3YCuI8GprPjYTaj4j/d6JI2bezAwJADwfXA9e9NAaOhXWr+Lrhr5mNlo6t+5Cj53HqM/wA/yFb+uarpvhLRXuZwI4lztjX70jf1PqTWpdXFtpthJPMUhtYEycDAVR6CvLtFtZPiR4kk1bUkb/hH7N9ttAeBIw/zk/lQ3d6AkWfC2iX3jDVk8R+JciyU7rOzYfKR2JHoP1716hSKoRQqgKoGAAMAClobuAUUUUgCiiigAoornPEfjDTtF/chvtd+TtW1hOWJ9D6UAdEzBVLMQFAySe1QTXttBa/aZZ41tyAwk3cEHoR61wOq6J4h8d2bW+ss2h6UxDGCJt0so9G5H6/lXSaN4N0fSrGG1jhkuEiXapuJWfj0x0/SnbuPSxcj8R6RI6qL+Fd3QuSoP0J4rVZ1WMuzKEAyWJ4A9c1x/jXQ/Ci6JGdcs4ktrYl4RCSjg/7O0jP48V594Ht9S8bS3Fg95d2vhi0YFIT99lycLuxz0PJ4GOlFl0YaHear41e5vn0zwpaPqV6OHlAxFF2znof5fWrui+FQsqX2vztqOonkl+Y0Psvt/kVvaVptppVmlrp8CQwJ0VR1PqT3NW6NthBRRRSAKKKztd1mz0WzNxevjJwiLyzn0AoAu3M8VtA81w6xxIMszdBXMpFP4puhJco0Whxn5IzkG5PqfRajg0q98SXEV54hQ29lGd0Onhjz0wZD/T/9R64AAAAAAcACgBFUIoVQFUDAAGABS0UUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQBwt7e/wDCJ+NRJdBU0fWGC+aWAWKb0P1P867qs3xDpUes6VNZyHYzfNG/9xx0NYvg7XZZJX0TWB5erWgCnJ/1q4yCPwoA6yiiigAooooAKKKKACvKviWxufid4Ls1wTHKs2O4G8ZP5Ka9VryVidZ+Pq7QWg0u2wTnodp/9memgPWqKKKQBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVm+IdbstA0uW+1GZY4kBIGfmc/3VHc1NrGp2uj6bPfX8ojt4V3Me59gO5ryzQNNvviP4kGva7G0Og2p/0SzJ++wxz9OOT+H0AJtA0a++IepR674otzBpMTH7JZ5I3jPUj09fWvWI0WNFSNQqKAFVRgAegpVAVQqgAAYAHauO+JPiQ6No7Wtk27VLv91Cq9Vzxn/CnuBzHjvULnxj4jh8KaI4NtEwe9mDYGAeR7gfqa9O0qwt9L0+Cys4xHBCgRVH865z4ceFV8NaMDcKranc4e4kHJz/dz7fzrraQBRRRQAUUUUAFZXiDX9O0C187Upwmfuooyz/Qf5FYfiXxe9vqP9j6Bbtfas3B2jKRH3/zgd/Sjw74QZblNU8Szf2hqv3lVxmOA/wCyO59+3anYCjFc+I/GS77TOh6K3AkdczzD1A7D8vxrqdB8P6fokRWyh/et9+aQ7pHPua1qKQ27hXMeMfGNj4cUQf8AHxqco/dWqH5j6E+g/nWd8SfHUfhe2W2skW51aXhYgc+WD0Zv6CuP8DJcT3E97aRNqfiS4GZLycEQ2ueoUkcn/wDVTSuBal0vULi+tr/xURe6tdAraaYhACD1fnAA9PzPavRPCuiLotiysQ91OQ88gGMtjoPYUugaEmmAz3Ez3moyD97cydT7D0FbNDelhBRRRSAKR3WNGd2CooyWJwAKwvEHinT9GIhZzc3zHalrD8zk+hx0rHi0rWvFBWbxE39n6dncunwtl2/33/w/SgCzqXiqW6uGsfC9sdQvAcPL0ii9yx4P+etWdB8NG1u21HV7n7fqbnO9hhI/ZR/Xj6CtywsrbT7ZbeygSCFeioMD6+596sU/QAooopAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFc/4n8Mw6y8N1C/2fUrfmGcfyb1H8q6CimnYDjdH8Vy2d0NM8VxGyvc4jnP8Aq5h656V2KkMoZSCCMgjvVXVNNs9VtTbajbR3EBOdrjofUelcnLoGt6BJ5vhi8+0WvJezu23Z/wB3p/MUWT2A7eiuM0/x9ZeebbW4JdLuQcbZAWU/pkfiPxrsIJoriJZYJEkjYZDIcg0rgPooooAjuZo7a3lnmbbFEhdz6ADJry34K27ahqniTxLMhDXtwUjYntksw/Va1vjbrLad4PazgP8ApOouLdQDg7erf0H410ngjRU8P+FtP05Rh44wZMjkueTn8Tj8KYG5RRRSAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKjuJoraCSad1jiQFmZjgAU9mCqWYgKBkknAAryXXL26+IviVNH0iZ4tCtTuuZwvEhB/X2H40AIPO+KWvhsTweF7Fv4htM7f4/yHvXq9rbxWltHb20axwxqFRFGAAKi0vT7bS7CGzsoxHBEMKo/mferVNgFZV1oNlda9b6rcIHngTbGCOFOfvfWtWikAUUUUAFFFFACMwVSzEBQMkntXnGseIb/xZqc2heFWeK2Q7bnUAPlAzyAf8OT9Kp+INcvPHGtT+G/DbbNPiOLy8HKkdwD6cY9/pXomg6RZ6HpkVjp8QjhjyfUsTyST3Jpp2GReHdCs9CshBaKWc8yTPy8h9Sf6Vq0VgeIfFuk6ErLc3KyXQHy28R3OT6YHSkI3643x/wCPNO8KWLAOtzqT/LDbocnd/tY6fTrWBr2p+Lb/AEi4v7ryfD+kqu7BO6eQHoB6H64rJ+E3giK+vF8SaqrTxqx+xCUkknPLkdPpTSurjegng/4farr18fEHi+4lhkuG8xbb+PB/RPoOcelewafY2unWqW1jBHBAvREGB9fc+9WKKL9BBRWXrviDS9CiD6neRwkjKoTl2+ijk1yrat4l8Vx7dBtv7I0522m9uP8AWMvcovr/AJzSWoHS+IfEul+H41bUbgLI/wByFOXf6D/HFc75/iXxWQbMNoWksDmSRMzyD2HYfl9TWx4f8IaZpDrcOhvdR6td3Pzvn1GeF/Cujp6IDK0TQNP0aPFnAPNI+aZ/mkb6mtWiikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAVNT02z1S3MGoW0VxEf4XXOPoe34Vydx4E+yz+f4d1OfTmA4j5ZfpnPA+ua7einfoBwjav4s0Mn+1NNj1K1XrPbn5gPU4H/stXrL4g+H5wBcXTWcveOdCD+Y4rra8p+N1zp81rDo9nZW914ivmWOMhAZYlPfI559KNAKWmXcXxD+Kf2mIifQ9HXMe4fK7+uCO7foK9jryrwj8K7nw1p8Umma5Pbakyhpz5YKM393gjge+a15dQ8c6Q+240201WH/nrbnDflwf0o5WF0d9RXAxfEzT7fCa5Z3Wmz5IKSL0x65ArYtfHXhu5h82PVIgv+0rD+lJ6bjtfY6aiuTv/iF4ctLYzfbvOUdolJP64rA07xJrfjm8SHStNn0vQlcNLe3HDygHO1B27dM/WjULHpdFFFAgooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoorA8b+II/DegTXr4Mp/dwr6uen4DrQByvxI1241LUIvCOgOWvrgj7S6H/VL1xn6cmux8J+H7Tw3o0NhZjJUZklI+aRu7Gud+F/h9rOxfWdRUvqd/wDOXfllQ8gfj1/Ku6pgFcz4z8YWXhq3YOPPvCu5IFOPxJ7Vb8Wa/FoVgHx5t5MdlvCOrt/hXnniXw0sOl2rajI8viHV7lE8wjOzJ+7j2Bxn8KErgen6Bftqmi2V88XlNcRLLsznGRmr9RWlvHaWsNtAu2GFFjRfRQMAflUtIAooooAK4P4i6/cCWDw5oyeZqN98jkHHlof5Z9ewrrtd1KLSNHvNQuDiO3jLn3PYficCvHvAvinRtNgvfEeuXbXWrXkrJHEnzOqewPTP8hQNHqnhDw9a+GtHjs7VVLn5ppccyP6n+VQeJ/GWjeHBtv7pWuSPlgjwzn/D8a477Z428aSj7FbDQtFccyTN+8dfUDGT+g966jwx4D0bQX+0LEby+JDG5ufnbd6qOg/n700r6sWi2Mdbnxd4tKm1iXQNHfrJId08i+w7fp+NdF4b8IaVoH7y3hM14R811Od8h9ee34V0NYvjLVhofhm/v84eOMhP948Ci/YDhfFcknjjxpD4cspXXTbEiW8ljPBPcZ9e3516hbQRW1vHBAixxRqFRV6ADoK8/wDhqtj4c8FR6pq88VvcagxuJZJD8zc8Adzxzx602bxbrfilntvBdg8VseG1O6G1B/ujv+GT7Ci3RAdrret6dolq0+pXUcKqMhSfmb6DvXEt4m8R+LUMfhGx+w2ZJV769G3j/ZGOv0B/CtLw94CtrW4F/r9zJrGqE7jJPyiH/ZXv+P6V2oAAAAwBRtuM4zQvh9p1ncrfavLLrGp53Ge6OQD7L/jmuzooobvoIKKy/EWu2WgWBur9yBnaiLyzn0ArJhh1DxRYxzXvmabZuQywIcu4zxuJHFIDW0/xDpOo6hPY2OoW893B/rIkbkf4/hWpXifxPk0P4f3drqmjFV1tnwYd+4lSPvEdv616N8ONZvtf8IWWpapGsdxPuPyrgFc8HFBTWlzpqKKKCQopssqQxtJK6pGvJZjgCuUu/FFxf3BtPC9r9sl6PcPxHH/n/OaFqB1tFeZW+reItM+ImlaTql/DcR3cbPIkXQDDY6gdx2xXptABRRRQAUUUUAFFYWreLtC0pWN3qUG4fwRtvP046fjWB/wtbwyOTNcgdz5XA/WlcdjvKKzNB13TtetPtGl3KTxj7wHBX6itOmIKKKZPNFBGZJ5EjjHVnYAD8TQA+iore4iuU3wOJE/vLyD9D3qWgAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKK47x944tPC0SW6KbjU5/lhgTkgnoT/hQBN4+8YQeGLALEon1OcYt7cHknsT7fzrH+HPgye0u5PEfiUCXX7rLANz5Cnt9f5dKj8E+CriTVB4m8WO0+ryfPFA/wB23HbI/ve3avR6b0AKKKKQEVzbQXUfl3UMU0f92RAw/I1nXvhvRb21W2uNMtGt1ORGIwoB/DFa1FNNrYVkZVn4d0azC/Z9Ms1K9CYgSPxPNao4HFFFDbe4JJbBRRRSGFFFFADVkRmZVdSy/eAPI+tOrnodFu9P143OkyQJY3MnmXkUmSxbGPkOOBznFdDQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFeWa5t8afEuHR8s2maUPMuAOhbPT8+K9H1q8GnaTeXjHAgiZ/xA4rhPglYSDQ73WbrJudSuGfcRzsHT9c00B6OoCqAoAA4AHahjgEgZPpVbUr6DTrOS6un2xIOcDJJ9AO5rM8M3mp6nHLeahCltbSNm3gx84X1akBBpuhSTaw+r6w4muAcW8ePlhX1A9f/ANfU8Y2os2ofFjTbVjmKwtWuCueCSMA/UEiu8rznT7+2tPi/rIvriOF5bRFi8w7QcbeAT7DNO4WuejUVn3OtaXbBjcalZRbRk751H9a5XUviZo0c32bRln1e8PCx2sZK59zj+QNTdbDszuqwfEHivSdD+S6uBJcn7tvF8zn8B0/GuROkeNvFRV9VvU0Owfrb27Ey7fcD+p/Cus8OeENH0BVazthJcgc3M/zyk+uT0/DFVa24tOh4x8UPEXizxDDb2Lac+kaNeyBYzMh3yHI69/fsK9U8C/DzRfClpbmO3W51JFG+7lG5i3fHp+HNXPiD4ZPifQxbwSJDeQuJYJHzgMOxx2NcTb+OPF/hwG08SeGLm82fKlzbZIfA/vKpB/Snrb3R76M9dorzG3+Jup3oKWHg/U5ZemPmIH1Ozj8cVZkg+IGusPMksdCtG6qrF5QPbHf8RSSYaLqdrqmt6bpWP7QvYICeiu4B/KvEPjf4yvtX0230zR7ORLCeYZu3BCuR6HGOvoTXpeifDnRrGb7TqPmarek7jLd4K59k6fnmofjDoE2teC5V0+INd2bC4iRR1C9QB9P5UJLqCdit4S+Gtha2FlJr8j6rdpGMpMcwqcdAvfHvx7V6DFGkMaxxIqRqMKqjAA9AK4n4WeNbTxRoUELyLHqtsgjngb5WJHG4DOSOOfeu4ob6CCiimTSxwRNJPIkcajJZ2AA+pNIB9ZfiXW7Tw/pM1/euAiD5VzguewFY+s+PtD00ui3Iu5lH3Lchuewzn+Wa+ffHnxA1bxl4gWO2tntLCzOVRieT3Jz3/CjV7IpLueyeHrVZ2fxZ4zlijDfPaQzPxEvrj1x0HPrWZrHxD1XxHfT6T4HtHbAwbsjn8Oy/U1zvgnw7feMGFzqT3V1GijbcTMViU+ij+L6CvcdH0q00mzS3soIolAAJRAu4+pppW3Jv2PEPGXw/sPDvga91nxFPJqGuSsoMrOSsbMeg9e/Jr1v4dxrF4H0VI/u/ZlP58/1q14u8P2nijw/daTf7hDOvDr1Rh0YV5Vb/AA6+IWmQrY6R4ugTTY/liDyyKyr9Apx+dCTew7rqe0zzw26F55Y4kAyWdgox+Ncfd+OFvLo2Xha0fVLroZBxEnuT6dfSsjw98LwJVu/F2qXGs3f/ADzZyIl/qf0+leiWVnbWMAhsreG3hHRIkCKPwFK3cV+xzX/COajq2xvEuo74h1tbUbUP1bGf6+9dJYWVtp9qlvZQpDCvRUGPx9z71Yopt3A8h+Kk8nhn4geHvFMsXmacimCYgcr16e+GyPpXoemeK9B1K2jntNWsmVxkBplVh7EE5rTv7K11G0ktb63iuLaQYeOVQykfQ15tqfwR8L3UzSWkuo2GTnZBPlB9AwJ/WjfqO67HeyeItFiBMmr6eoHrcp/jWFqfxK8MWB2/2gty/Tbbjf8Ar0rDsvgr4XgZWnk1K7wc4muBj/x1RXWaH4L8O6G4k0zSLaKUHIkYF3B9mbJH4UW7v8BX7I5yDxr4g1uRl8OeG5fJxxPeZjQ++Tj8hmrA8LeIdbTPijXTEm7P2fThtXHoWI6/ga7yijRbDuc3pvgfw7YD5dLt7iQ9ZLpfOY+/zZx+GK100jTUh8lNPs1h6bBCoX8sVdoo5n3JsjzDxFoOo+DtbXXvBem/abaUbLvToRjPuoHT6DoavWXjXxLqGUtfBF9DJnAa5l8tR/30q16DRS0Gcxb2vii+2nUbyz06Mj5o7Rd7/TLdD7itC18PWETLJOsl7Oox5t3IZW/I8D8BWvRTvbYd2FFFFIQUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUMQoJYgAckntVbUtQtNMtHutQuI7eBOryHA+g9T7V4x4g8Sa58R9R/sTwmsltphYefckYAXHV2HH0UdaFq7DsdB41+JEgvv7E8GxDUNWkO3cnzAHvt9fqeK0fAvgM6fc/2z4kkW+12Q78sdywE/3Sep9/yrV8C+B9L8H2rCzUz3so/fXco+d/Yf3R7D9a6qntsIKKKKQBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFMnkMULusbyFRnYmNx+mcV5b4/wBE8a+MLB4NPki0y135WNpmRmHbdtGf1os3sCt1PVaK8g+GEPiPwVqK6H4puPtcN2QYHWUy7D04J5wfSvX6dmtxu3QKKKKQgooooAKKKKACiiigAooooAKKKKAOT+Kqzt4B1b7NncIwWAPJXcM1z/gzxz4f0rwDpgmvIxNDGInt0YGTd9M8euTivSpo0mieKVFeNwVZWGQQeoNcVbfCzwjb6m98NLV3ZtwjdyY1Psv+Oadk+oX8iTRWufFxj1C8HlaXndFCCQWIPHPQj1I+grs+nSmxoscapGqoigKqqMAAdgKdSAK5nxV4H0PxNMs+pWzC7QbVuIW2OB/I/iDXTUU02tUB51a/B7wvDMJJxfXfOds8+Qf++QK7TR9D0vRoyml2FtagjBMcYDN9T1P41o0U3JvcVgoooqRhRRRQAUUUUAFFFFAHnXjL4WadreoHU9Ku5tH1Q8mWAZRj6leMH3BrBHg/4nW8EsEXiiyuY3BXNxNIxI/FDj869jopt33VxptbM8gg8LfFGRUS48T2EUYxnY77gPwQfzrQh+F1zfFJfEniXUL2XGGWM7R+BOTXp9FGi2SByk92Yui+FtF0ZIxY6fAsqciZ1DyZ9dx5qW68OaJd3DT3WkafNM53M8lujFj6kkc/jWrRQpNbE2TERVRFVFCqowABgAUtFFIYUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVyPjnx5pXhO1fz5UmvSPktw4HP8AtHsK1vF1nql/oFzbaDdx2moPgJM5IC888gEjiuD8PfB6wjmgvPFF3Jql4vLQg4gz+W4+vUfSi2g01fU83/tXVfiDqiTavHqlzpascQ6bDuLD0X+6PU9frXp+lXXiKx06Gw8IeC49MslJ+a8mUHP94rkEn3Oa9Hs7S3srdLezgit4E+7HEgRR9AOKmpu1rIV29zzf7B8TbgFm1TRbbI4QKTj8dhqs/h74mSOpfxLpgXuFDDP5IK9RooTje/KgvLueZjwt4+jcNF4rtz6h1cgfnmnz6P8AExCfs3iHSCuON8RyfzQ16TRR7v8AKvx/zEubueYif4p2SqXtdH1AjrtcLn/0Gon8aeOrNtt54Nkl2j5jbqz7j7EE16nRRaPb8WO7POZPiVdWyI2oeFNXt89cof6qKcnxe8OAkTx38BHB3xDg/wDfVeiVBeWVrfQ+Ve20FxF12Sxhx+Rosguc3pvxC8LagyLDq8CO38M2Y8fUnj9a138RaKihm1awCnoftCc/rWLq3w38JaoQZ9Fto3BzutwYTn/gOAfxrLj+EHhRDlob2THTddMMfTGKOXz/AAC67HSv4u8PpjdrFlycD94DVC6+IPh2BX2XrXDLxthiZs/Q4A/Wo7T4a+E7bBGkpKw7zSvJ/Nq3rTQdIs5FktdLsYZF6OkChh+OM0WXVhfsjl3+ID3BUaT4e1a6LdC0RUfXjPFSC/8AHFyA0OlWFqM5xNJkkfg3B/Cu2oo0DU4J7T4g3K/8f+k2oJ6DJOP++DUI8M+NZlAuPE8aEkljGG4+nAr0Oij3e35/5hd9zg/+EJ1uUfv/ABnqg46RAqP/AEKnN4G1IggeL9YweuWJz+td1RS0fQDgJfBevxwkWfjC/LjlRMDj8w1Qiy+IOlQtLFe6fqaod3lMTucenKj/ANCr0WihWXQLvucX4K8eQa/fSaVfWkun6zCD5lvIODjrjvn2Pau0rz74hfD+bxBq1vrWiakdN1iBAgcDCuBkjLL8wPOM88dqwx4b+KaKqL4i0wqowGMshb8f3fNNp2ugTXU9dory6PSvinGq79b0eTb0Cjk/XMVTta/FD+G90fj1xz/45QlL+mgbV9/wZ6VRXnkB+JUQ/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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Ig747wm1sXWjl9deepi2WOfixucz/4IZ57zwXobrNFmhAE4myQzDe677JibeCEfmbFO8+PCZkc6lA37po2DI0MhL+p1kBKRBSrIM90tyuYYokd0wTNo4VTcSy9YHiuPe43113/22zf5jzfM2YvhIO3fm3L4GA61R75ifSpz7HEndGFcCJ9t9qd1XZS8+t85uvPFG+5cFl8Y1Dn9oYCM6hj4CU1blEo9ATVuNvbRmvc2bN8/+7cp/TbwIKkYiIAK9IhAxjNSr++RZBERABERABERABERABERABHxHQAKS77JUCRIBERABERABERABERABEegrAQlIfSWn+0RABERABERABERABERABHxHQEYafJelSpAIDCwCtCR45MgRtxA90vz6wEqFYpvIBLgHWl1dndHaZaKvX0xkjopb1wRo/KCmpsZZQOXmrnIiIAIDm4AEpIGdf4q9CIiACIiACIiACIiACIhAHAloil0cYSooERABERABERABERABERCBgU1AAtLAzj/FXgREQAREQAREQAREQAREII4E0v4dLo7hKSgREAER6JIAN+995ZVXbOLEiRa73ujAgQP2wQcf2O7du23o0KGWk4Ot7DtxBw8etNdff92mTZvmNqrtxItOJTGB7soYN5j+4osvbOvWrdjwuNVGjRoVRaqn61GedZDUBL788ks7dOhQr8sQy9327dvt008/Na6/HDNmTFJzVOJFIFEJSEBK1JxRvETAhwSeffZZJyBdfvnlUQLQ/fffb7zGxc3btm2zF1980SZPnmzFxcVRFLgQ+oEHHrD333/fbrjhBktLS4u6rgMR6KqMffTRR3bbbbdZbW2t+6xfv94obM+aNctB6+m6yIqAR2DHjh12991327hx49xAjXe+pzJE4WjZsmX27rvvWn5+vr366qtWWVlp5513nheEvkVABBKEQHqCxEPREAER8DGBqqoqe/LJJ+27777rkMo9e/YYR2M3b95shYWF7vqDDz5oq1ev7tBxeOONN2znzp0dwtAJEeiujJ04ccJefvll1zldvHixg8Uyd++999oVV1zhNJrdXZ80aZIAi4DRGiI14PykpKREEempjLEMbdq0yVns3Lhxo7PauX//fjfQc+mll9qUKVOiwtOBCIhA/xLQGqT+5a+ni0BSEHjssceM2p/HH3+8Q3ppGvfmm28OC0f0MH36dDeyyns8V15e7jq5t9xyi3dK3yIQJtBdGeNUqHPOOccWLFgQ9s8yRsepnT1dD9+kH0lNgFOAqb1+9NFHO2i3T6YMcWony2AgEHAcS0pK7IwzzrCPP/44qbkq8SKQiASkQUrEXFGcRMBnBO655x4bOXKkccQ01s2cOdP4iXScnz916tTwKG1LS4tRq7RkyRLN2Y8Epd9hAt2VseHDh9vy5cvDfvmDZYxTNDly39P1qBt1kLQEZs+ebZdccomlp6fbc889F8XhZMpQRUWFjR49Ouo+Hv/+++9R53QgAiLQ/wSkQer/PFAMRMD3BCgcnazj9JPvv//ebr/99vAt69atcxqmRYsWhc/phwhEEuhNGdu7d6+tXbvWrrvuOie4R4bD3z1dj/Wv4+QgUFBQ4ISjk0ltbBni9DyuecvNzY26ncfUPsmJgAgkFgFpkBIrPxQbERjQBN577z03x95LBNd3ZGdne4c9fm/YsMFee+01W7lyZXhOPtctffjhh256XY8ByIPvCZxqGfvhhx+M2qYLL7zQTe2MBdbT9Vj/OvYfAQ7Q7Nq1K5yws88+20pLS8PHPf3orAxRW5mamurWMUXeT8HJm3IXeV6/RUAE+peABKT+5a+ni4CvCHzyySdR00UuuuiikxKQuMB51apVxvtpzMFbH0I4HOkfPHhweP0SrZDR3XfffbZw4UKbO3euO9af5CDQ1zJGOlwDsmLFCrvqqqts6dKlHYD1dL3DDTrhSwI0BENLc56jxbmTFZC6KkM06jBs2DCrr6/3gnXfdXV1VlRUFHVOByIgAv1PQAJS/+eBYiACviHw1FNP9SktDz/8sJtWt2bNGmdRLDIQWniiIQfPcVH9Tz/9ZGVlZa7D4Z3Xd3IQ6GsZ++yzz4zljFM3aWY+1vV0Pda/jv1L4NprrzV+eut6KkPc/411F+s0z1EYu/LKK71DfYuACCQIAQlICZIRioYIJCsBTp+jVuCuu+5yo6uc3uI5WniKXXf07bffug1lr7/+esvMzPS86lsEuiRQXV1ttHI3b948Gz9+vBPGPc/ca4vWEru7zpF/ORHojkBPZYxliIIQ93G77LLLnBGat956y20WS8MPciIgAolFQAJSYuWHYiMCSUeAexvRPfHEEx3SvmXLFje9rsMFnRCBXhCgEN7Q0ODMKceaVOZ6JGoou7seOeLfi8fKaxIR6KmMsQzRWuc111xjt956q2VkZDiLnJwqzA2y5URABBKLQApGzto3GkmsuCk2IiACIiACIiACIuArAs3Nzca1RzQNLicCIpCYBCQgJWa+KFYiIAIiIAIiIAIiIAIiIAL9QED7IPUDdD1SBERABERABERABERABEQgMQlIQErMfFGsREAEREAEREAEREAEREAE+oGABKR+gK5HioAIiIAIiIAIiIAIiIAIJCYBCUiJmS+KlQiIgAiIgAiIgAiIgAiIQD8QkIDUD9D1SBEQAREQAREQAREQAREQgcQkIAEpMfNFsRIBERABEeiGAPct2r9/vzU2NnbjS5dEQAREQAREoPcEJCD1npnuEAEREAER6GcC3Jhz/Pjx9vnnn/dzTPR4ERABERABvxGQgOS3HFV6REAEREAEREAEREAEREAE+kxAAlKf0elGERABERABERABERABERABvxFI91uClB4REAEREIHkJbBt2zbbuHGjlZeXuyl4F198sc2fPz8KyPPPP2/5+fl2wQUX2EsvvWTffPONjRo1yhYvXmyzZs2K8qsDERABERCB5CMgDVLy5blSLAIiIAK+JPDII4/YjBkz7O2337a0tDTbsmWLLViwwJYtWxaV3vXr19vq1attzpw59tBDD1llZaWtW7fOzj//fHvzzTej/OpABERABEQg+QhIQEq+PFeKRUAERMB3BL7++mtbsWKFXX311bZ7927btGmT/fjjj7Z8+XJbu3at0ypFJnrr1q22aNEiq6qqcoYetm/fboMGDbJVq1ZFetNvERABERCBJCQgASkJM11JFgEREAG/EdiwYYPTGj399NOWkZHhkpeSkmIrV660wsJCe+aZZ6KSnJWVZdQ4USiiKy0ttTPPPNOZDo/yqAMREAEREIGkIyABKemyXAkWAREQAf8R2LVrl5WUlDhhKDJ12dnZTvChVinSFRcXW2ZmZuQpd++xY8eizulABERABIkt6YsAAAJKSURBVEQg+QhIQEq+PFeKRUAERMB3BKqrqy03N7fTdA0ZMsRaWlqirg0ePDjqmAfUOLW1tXU4rxMiIAIiIALJRUACUnLlt1IrAiIgAr4kcNppp3U5PW7fvn121lln+TLdSpQIiIAIiED8CUhAij9ThSgCIiACIvBPJjB79myjFumdd96JejKNL+zYscOmT58edV4HIiACIiACItAVAQlIXZHReREQAREQgQFD4I477nBrkG666SZ74YUXjGuSNm/ebAsXLrQJEybYnXfeOWDSooiKgAiIgAj0LwFtFNu//PV0ERABERCBOBCgNbqvvvrKli5dakuWLLETJ05YIBCwuXPnOjPfY8eOjcNTFIQIiIAIiEAyEEjBglStSE2GnFYaRUAERCBJCNASHdcdTZo0KWzyO0mSrmSKgAiIgAjEgYAEpDhAVBAiIAIiIAIiIAIiIAIiIAL+IKA1SP7IR6VCBERABERABERABERABEQgDgQkIMUBooIQAREQAREQAREQAREQARHwBwEJSP7IR6VCBERABERABERABERABEQgDgQkIMUBooIQAREQAREQAREQAREQARHwBwEJSP7IR6VCBERABERABERABERABEQgDgQkIMUBooIQAREQAREQAREQAREQARHwBwEJSP7IR6VCBERABERABERABERABEQgDgQkIMUBooIQAREQAREQAREQAREQARHwBwEJSP7IR6VCBERABERABERABERABEQgDgQkIMUBooIQAREQAREQAREQAREQARHwB4H/Byh5Aws+yoDGAAAAAElFTkSuQmCC" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-20600-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515409
</td>
<td style="text-align:right;">
5989806
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-29500-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
496209
</td>
<td style="text-align:right;">
5999657
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
100-596500-54900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
583374
</td>
<td style="text-align:right;">
5911978
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
100-596500-03300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
537250
</td>
<td style="text-align:right;">
5991350
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
551588
</td>
<td style="text-align:right;">
5970657
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
100-574400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526285
</td>
<td style="text-align:right;">
5978523
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522679
</td>
<td style="text-align:right;">
5956610
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518502
</td>
<td style="text-align:right;">
5962002
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
524160
</td>
<td style="text-align:right;">
5957999
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
100-560100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521127
</td>
<td style="text-align:right;">
5965112
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
100-567900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
516996
</td>
<td style="text-align:right;">
5972733
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
100-562800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515025
</td>
<td style="text-align:right;">
5966533
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
100-596500-82000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
573972
</td>
<td style="text-align:right;">
5894796
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
100-596500-90900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
590481
</td>
<td style="text-align:right;">
5882133
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-535900-08600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
517279
</td>
<td style="text-align:right;">
5936628
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518845
</td>
<td style="text-align:right;">
5961982
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
100-572700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521864
</td>
<td style="text-align:right;">
5976392
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-587900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526448
</td>
<td style="text-align:right;">
5985791
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
100-580500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522978
</td>
<td style="text-align:right;">
5980978
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
100-536400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
520105
</td>
<td style="text-align:right;">
5935908
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388945
</td>
<td style="text-align:right;">
5997015
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388276
</td>
<td style="text-align:right;">
5996951
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
398947
</td>
<td style="text-align:right;">
5996427
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
180-296000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
425559
</td>
<td style="text-align:right;">
5996140
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
100-770300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
650784
</td>
<td style="text-align:right;">
5934858
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
100-683800-01900-12800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
587921
</td>
<td style="text-align:right;">
5972449
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
100-698700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
606373
</td>
<td style="text-align:right;">
5965784
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344022
</td>
<td style="text-align:right;">
5862734
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
100-596500-84300-21000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577020
</td>
<td style="text-align:right;">
5886032
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
100-596500-10600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
536470
</td>
<td style="text-align:right;">
5981315
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541465
</td>
<td style="text-align:right;">
5981577
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541358
</td>
<td style="text-align:right;">
5981709
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521645
</td>
<td style="text-align:right;">
5955176
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
100-545900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521513
</td>
<td style="text-align:right;">
5949553
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
556416
</td>
<td style="text-align:right;">
5962053
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388738
</td>
<td style="text-align:right;">
5997154
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
BB;C;EB;LKC;LNC;LSU;NSC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;CAS;CC;CH;CSU;DV;LDC;LKC;LSU;MW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
BB;CCG;LKC;RB;SP;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
CCG;CSU;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
LKC;LSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
EB;LKC;RB;RSC;ST
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Francois Lake
</th>
<th style="text-align:left;">
Lower Chilako
</th>
<th style="text-align:left;">
Lower Salmon
</th>
<th style="text-align:left;">
Morkill
</th>
<th style="text-align:left;">
Nechako
</th>
<th style="text-align:left;">
Tabor
</th>
<th style="text-align:left;">
Upper Fraser
</th>
<th style="text-align:left;">
Willow
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Acipenser transmontanus
</td>
<td style="text-align:left;">
White Sturgeon
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
E/T (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Carassius auratus
</td>
<td style="text-align:left;">
Goldfish
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus platyrhynchus
</td>
<td style="text-align:left;">
Northern Mountain Sucker
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cyprinus carpio
</td>
<td style="text-align:left;">
Carp
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Micropterus salmoides
</td>
<td style="text-align:left;">
Largemouth Bass
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
E/T/SC (Dec 2018)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Anadromous Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Char, General
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
