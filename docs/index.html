<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_fraser_2024","repo_url":"<a href=\"https://github.com/lucy-schick/fish_passage_fraser_2025_permit\" class=\"uri\">https://github.com/lucy-schick/fish_passage_fraser_2025_permit</a>","report_url":"<a href=\"https://lucy-schick.github.io/fish_passage_fraser_2025_permit/\" class=\"uri\">https://lucy-schick.github.io/fish_passage_fraser_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-07-25</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file of all sites is attached to the application and can also be downloaded <a href="https://github.com/lucy-schick/fish_passage_fraser_2025_permit/raw/main/mapping/sites_fraser_2025_20250725_kml.zip">at this link</a>. The KML includes detailed site-specific information accessible by clicking on each location, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Society for Ecosystem Restoration Northern BC, the Ministry of Transportation and Infrastructure (MoTI) and the Provincial Fish Passage Technical Working Group. Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from throughout the study area. Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<!-- ![signature](/Users/airvine/Library/CloudStorage/OneDrive-Personal/Admin/Al_Sig.jpg){width=50%} -->
<p>Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-20600-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515409
</td>
<td style="text-align:right;">
5989806
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12200170
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-00200-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522065
</td>
<td style="text-align:right;">
5993180
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12200289
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-81100-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
497107
</td>
<td style="text-align:right;">
5990162
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-29500-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
496209
</td>
<td style="text-align:right;">
5999657
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
100-596500-54900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
583374
</td>
<td style="text-align:right;">
5911978
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
100-596500-03300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
537250
</td>
<td style="text-align:right;">
5991350
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
551588
</td>
<td style="text-align:right;">
5970657
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
100-574400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526285
</td>
<td style="text-align:right;">
5978523
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522679
</td>
<td style="text-align:right;">
5956610
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518502
</td>
<td style="text-align:right;">
5962002
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
524160
</td>
<td style="text-align:right;">
5957999
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196160
</td>
<td style="text-align:left;">
Tay Creek
</td>
<td style="text-align:left;">
100-615400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
525765
</td>
<td style="text-align:right;">
6009127
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
100-560100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521127
</td>
<td style="text-align:right;">
5965112
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
100-567900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
516996
</td>
<td style="text-align:right;">
5972733
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
100-562800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515025
</td>
<td style="text-align:right;">
5966533
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
100-596500-82000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
573972
</td>
<td style="text-align:right;">
5894796
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
100-596500-90900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
590481
</td>
<td style="text-align:right;">
5882133
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196353
</td>
<td style="text-align:left;">
Williams Creek
</td>
<td style="text-align:left;">
100-596500-98000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
599849
</td>
<td style="text-align:right;">
5882781
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-535900-08600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
517279
</td>
<td style="text-align:right;">
5936628
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518845
</td>
<td style="text-align:right;">
5961982
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
100-572700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521864
</td>
<td style="text-align:right;">
5976392
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-587900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526448
</td>
<td style="text-align:right;">
5985791
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
100-580500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522978
</td>
<td style="text-align:right;">
5980978
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
100-536400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
520105
</td>
<td style="text-align:right;">
5935908
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388945
</td>
<td style="text-align:right;">
5997015
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388276
</td>
<td style="text-align:right;">
5996951
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
398947
</td>
<td style="text-align:right;">
5996427
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199174
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
397158
</td>
<td style="text-align:right;">
5996575
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
180-296000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
425559
</td>
<td style="text-align:right;">
5996140
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
100-683800-01900-12800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
587921
</td>
<td style="text-align:right;">
5972449
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
100-698700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
606373
</td>
<td style="text-align:right;">
5965784
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344022
</td>
<td style="text-align:right;">
5862734
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
199328
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388367
</td>
<td style="text-align:right;">
5996766
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
203302
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344226
</td>
<td style="text-align:right;">
5862767
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
100-596500-84300-21000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577020
</td>
<td style="text-align:right;">
5886032
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
100-596500-10600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
536470
</td>
<td style="text-align:right;">
5981315
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541465
</td>
<td style="text-align:right;">
5981577
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541358
</td>
<td style="text-align:right;">
5981709
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521645
</td>
<td style="text-align:right;">
5955176
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
100-545900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521513
</td>
<td style="text-align:right;">
5949553
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
556416
</td>
<td style="text-align:right;">
5962053
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
4931
</td>
<td style="text-align:left;">
Crooked Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344710
</td>
<td style="text-align:right;">
5862865
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388738
</td>
<td style="text-align:right;">
5997154
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
BB;C;EB;LKC;LNC;LSU;NSC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12200170
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CC;CH;RB;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12200289
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CBC;CSU;EB;KO;LSU;MW;NSC;PCC;RB;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;CAS;CC;CH;CSU;DV;LDC;LKC;LSU;MW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196160
</td>
<td style="text-align:left;">
Tay Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
BB;CCG;LKC;RB;SP;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196353
</td>
<td style="text-align:left;">
Williams Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
CCG;CSU;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199174
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
LKC;LSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199328
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
203302
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
4931
</td>
<td style="text-align:left;">
Crooked Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Francois Lake
</th>
<th style="text-align:left;">
Lower Chilako
</th>
<th style="text-align:left;">
Lower Salmon
</th>
<th style="text-align:left;">
Morkill
</th>
<th style="text-align:left;">
Nechako
</th>
<th style="text-align:left;">
Tabor
</th>
<th style="text-align:left;">
Upper Fraser
</th>
<th style="text-align:left;">
Willow
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Acipenser transmontanus
</td>
<td style="text-align:left;">
White Sturgeon
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
E/T (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Carassius auratus
</td>
<td style="text-align:left;">
Goldfish
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus platyrhynchus
</td>
<td style="text-align:left;">
Northern Mountain Sucker
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cyprinus carpio
</td>
<td style="text-align:left;">
Carp
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Micropterus salmoides
</td>
<td style="text-align:left;">
Largemouth Bass
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
E/T/SC (Dec 2018)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Anadromous Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Char, General
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
