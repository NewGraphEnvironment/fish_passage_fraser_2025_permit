<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_fraser_2024","repo_url":"<a href=\"https://github.com/lucy-schick/fish_passage_fraser_2025_permit\" class=\"uri\">https://github.com/lucy-schick/fish_passage_fraser_2025_permit</a>","report_url":"<a href=\"https://lucy-schick.github.io/fish_passage_fraser_2025_permit/\" class=\"uri\">https://lucy-schick.github.io/fish_passage_fraser_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-07-25</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file of all sites is attached to the application and can also be downloaded <a href="https:/github.com/lucy-schick/fish_passage_fraser_2025_permit/raw/main/mapping/sites_fraser_2025_20250725_kml.zip">at this link</a>. The KML includes detailed site-specific information accessible by clicking on each location, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Society for Ecosystem Restoration Northern BC, the Ministry of Transportation and Infrastructure (MoTI) and the Provincial Fish Passage Technical Working Group. Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from throughout the study area. Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<!-- ![signature](/Users/airvine/Library/CloudStorage/OneDrive-Personal/Admin/Al_Sig.jpg){width=50%} -->
<p>Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-20600-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515409
</td>
<td style="text-align:right;">
5989806
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12200170
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-00200-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522065
</td>
<td style="text-align:right;">
5993180
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12200289
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-81100-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
497107
</td>
<td style="text-align:right;">
5990162
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-29500-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
496209
</td>
<td style="text-align:right;">
5999657
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
100-596500-54900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
583374
</td>
<td style="text-align:right;">
5911978
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
100-596500-03300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
537250
</td>
<td style="text-align:right;">
5991350
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
551588
</td>
<td style="text-align:right;">
5970657
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
100-574400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526285
</td>
<td style="text-align:right;">
5978523
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522679
</td>
<td style="text-align:right;">
5956610
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518502
</td>
<td style="text-align:right;">
5962002
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
524160
</td>
<td style="text-align:right;">
5957999
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196160
</td>
<td style="text-align:left;">
Tay Creek
</td>
<td style="text-align:left;">
100-615400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
525765
</td>
<td style="text-align:right;">
6009127
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
100-560100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521127
</td>
<td style="text-align:right;">
5965112
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
100-567900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
516996
</td>
<td style="text-align:right;">
5972733
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
100-562800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515025
</td>
<td style="text-align:right;">
5966533
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
100-596500-82000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
573972
</td>
<td style="text-align:right;">
5894796
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
100-596500-90900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
590481
</td>
<td style="text-align:right;">
5882133
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196353
</td>
<td style="text-align:left;">
Williams Creek
</td>
<td style="text-align:left;">
100-596500-98000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
599849
</td>
<td style="text-align:right;">
5882781
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-535900-08600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
517279
</td>
<td style="text-align:right;">
5936628
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518845
</td>
<td style="text-align:right;">
5961982
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
100-572700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521864
</td>
<td style="text-align:right;">
5976392
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-587900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526448
</td>
<td style="text-align:right;">
5985791
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
100-580500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522978
</td>
<td style="text-align:right;">
5980978
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
100-536400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
520105
</td>
<td style="text-align:right;">
5935908
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388945
</td>
<td style="text-align:right;">
5997015
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388276
</td>
<td style="text-align:right;">
5996951
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
398947
</td>
<td style="text-align:right;">
5996427
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199174
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
397158
</td>
<td style="text-align:right;">
5996575
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
180-296000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
425559
</td>
<td style="text-align:right;">
5996140
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
100-683800-01900-12800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
587921
</td>
<td style="text-align:right;">
5972449
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
100-698700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
606373
</td>
<td style="text-align:right;">
5965784
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344022
</td>
<td style="text-align:right;">
5862734
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
199328
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388367
</td>
<td style="text-align:right;">
5996766
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
203302
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344226
</td>
<td style="text-align:right;">
5862767
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
100-596500-84300-21000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577020
</td>
<td style="text-align:right;">
5886032
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
100-596500-10600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
536470
</td>
<td style="text-align:right;">
5981315
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541465
</td>
<td style="text-align:right;">
5981577
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541358
</td>
<td style="text-align:right;">
5981709
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521645
</td>
<td style="text-align:right;">
5955176
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
100-545900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521513
</td>
<td style="text-align:right;">
5949553
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
556416
</td>
<td style="text-align:right;">
5962053
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
4931
</td>
<td style="text-align:left;">
Crooked Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344710
</td>
<td style="text-align:right;">
5862865
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388738
</td>
<td style="text-align:right;">
5997154
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
BB;C;EB;LKC;LNC;LSU;NSC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12200170
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CC;CH;RB;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12200289
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CBC;CSU;EB;KO;LSU;MW;NSC;PCC;RB;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;CAS;CC;CH;CSU;DV;LDC;LKC;LSU;MW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196160
</td>
<td style="text-align:left;">
Tay Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
BB;CCG;LKC;RB;SP;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196353
</td>
<td style="text-align:left;">
Williams Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
CCG;CSU;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199174
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
LKC;LSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199328
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
203302
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
4931
</td>
<td style="text-align:left;">
Crooked Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Francois Lake
</th>
<th style="text-align:left;">
Lower Chilako
</th>
<th style="text-align:left;">
Lower Salmon
</th>
<th style="text-align:left;">
Morkill
</th>
<th style="text-align:left;">
Nechako
</th>
<th style="text-align:left;">
Tabor
</th>
<th style="text-align:left;">
Upper Fraser
</th>
<th style="text-align:left;">
Willow
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Acipenser transmontanus
</td>
<td style="text-align:left;">
White Sturgeon
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
E/T (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Carassius auratus
</td>
<td style="text-align:left;">
Goldfish
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus platyrhynchus
</td>
<td style="text-align:left;">
Northern Mountain Sucker
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cyprinus carpio
</td>
<td style="text-align:left;">
Carp
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Micropterus salmoides
</td>
<td style="text-align:left;">
Largemouth Bass
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
E/T/SC (Dec 2018)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Anadromous Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Char, General
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
