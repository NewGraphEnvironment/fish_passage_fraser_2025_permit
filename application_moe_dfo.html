<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_fraser_2024","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-07-28</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https:/github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/raw/main/mapping/sites_fraser_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Habitat Conservation Trust Foundation, Society for Ecosystem Restoration Northern BC, and the Ministry of Transportation and Infrastructure (MoTI). Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from throughout the study area. Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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ARxLkhlG8Fz/JibeCEfmbFOC+PCZkc7TAb/0UVIwKPKSfqcYAWmQUizDkyW5XEOUyG4wJm0crxuGZev9xXHv8d66r39db//59DM2dMgwO/3M6b0NBlqjnjE/njj3OpK6Ma4EjrX7sm9bjT331HK77rrr7F9nXRTXOPyugQ3tHPpQTFmVSzwCe9r22PNPr7AZM2bYv1/2b4kXQcVIBESgRwQihpF6dJ88i4AIiIAIiIAIiIAIiIAIiEDSEZCAlHRZqgSJgAiIgAiIgAiIgAiIgAj0loAEpN6S030iIAIiIAIiIAIiIAIiIAJJR0BGGpIuS5UgEehfBGhJcP/+/b4QPdL8ev9KhWKbyAS4B1pdXZ3R2mWir19MZI6K29EJ0PjBnj173AIqN3eVEwER6N8EJCD17/xT7EVABERABERABERABERABOJIQFPs4ghTQYmACIiACIiACIiACIiACPRvAhKQ+nf+KfYiIAIiIAIiIAIiIAIiIAJxJJDxH3BxDE9BiYAIiMBRCXDz3hdffNHGjRtnseuNduzYYe+++65t3rzZBg0aZAMHYiv7I7hdu3bZK6+8YpMnT/aNao/gRadSmEBXZYwbTH/66ae2bt06bHjcYsOHD48i1d31KM86SGkCn332me3evbvHZYjlbsOGDfbRRx8Z11+OHDkypTkq8SKQqAQkICVqziheIpCEBP70pz+5gHTJJZdECUD33HOP8RoXN69fv96ee+45mzBhgpWXl0dR4ELoe++919555x279tprLSMjI+q6DkTgaGXs/ffft5tvvtn27dvnnxUrVhiF7alTpzq07q6LrAgEBDZu3Gh33HGHjR492gdqgvPdlSEKRwsWLLC33nrLiouL7aWXXrLq6mo766yzgiD0LQIikCAEMhMkHoqGCIhAEhOoqamxxx57zL7++utOqfzxxx+No7Fr1qyx0tJSv37ffffZ0qVLO3UcXn31Vfvhhx86haETItBVGWttbbUXXnjBO6dz5851WCxzd911l1166aWu0ezq+vjx4wVYBIzWEKkB5yctLS2KSHdljGVo9erVbrFz1apVbrVz+/btPtBz0UUX2cSJE6PC04EIiEDfEtAapL7lr6eLQEoQePjhh43an0ceeaRTemka94YbbmgXjuhhypQpPrLKewK3detW7+TeeOONwSl9i0A7ga7KGKdCnXbaaTZr1qx2/yxjdJza2d319pv0I6UJcAowtdcPPfRQJ+32sZQhTu1kGczPz3eOFRUVdtJJJ9kHH3yQ0lyVeBFIRALSICVirihOIpBkBO68804bNmyYccQ01p155pnGT6Tj/PxJkya1j9I2NzcbtUrz5s3TnP1IUPrdTqCrMjZkyBBbuHBhu1/+YBnjFE2O3Hd3PepGHaQsgWnTptmFF15omZmZ9tRTT0VxOJYytHPnThsxYkTUfTz+7bffos7pQAREoO8JSIPU93mgGIhA0hOgcHSsjtNPvvnmG7vlllvab1m+fLlrmObMmdN+Tj9EIJJAT8rYli1bbNmyZXb11Ve74B4ZDn93dz3Wv45Tg0BJSYkLR8eS2tgyxOl5XPNWWFgYdTuPqX2SEwERSCwC0iAlVn4oNiLQrwm8/fbbPsc+SATXd+Tm5gaH3X6vXLnSXn75ZVu8eHH7nHyuW3rvvfd8el23AchD0hM43jL27bffGrVN5513nk/tjAXW3fVY/zpOPgIcoNm0aVN7wk499VSrrKxsP+7ux5HKELWV6enpvo4p8n4KTsGUu8jz+i0CItC3BCQg9S1/PV0EkorAhx9+GDVd5Pzzzz8mAYkLnJcsWWK8n8YcgvUhhMOR/gEDBrSvX6IVMrq7777bZs+ebdOnT/dj/UkNAr0tY6TDNSCLFi2yyy+/3ObPn98JWHfXO92gE0lJgIZgaGkucLQ4d6wC0tHKEI06DB482Orr64Ng/buurs7KysqizulABESg7wlIQOr7PFAMRCBpCDz++OO9SssDDzzg0+qefvpptygWGQgtPNGQQ+C4qP7777+3qqoq73AE5/WdGgR6W8Y+/vhjYznj1E2amY913V2P9a/j5CVw1VVXGT89dd2VIe7/xrqLdVrgKIxddtllwaG+RUAEEoSABKQEyQhFQwRSlQCnz1ErcPvtt/voKqe3BI4WnmLXHX311Ve+oew111xj2dnZgVd9i8BRCdTW1hqt3M2YMcPGjBnjwnjgmXtt0VpiV9c58i8nAl0R6K6MsQxREOI+bhdffLEboXn99dd9s1gafpATARFILAISkBIrPxQbEUg5AtzbiO7RRx/tlPa1a9f69LpOF3RCBHpAgEJ4Q0ODm1OONanM9UjUUHZ1PXLEvwePldcUItBdGWMZorXOK6+80m666SbLyspyi5ycKswNsuVEQAQSi0AaRs46NhpJrLgpNiIgAiIgAiIgAiKQVASampqMa49oGlxOBEQgMQlIQErMfFGsREAEREAEREAEREAEREAE+oCA9kHqA+h6pAiIgAiIgAiIgAiIgAiIQGISkICUmPmiWImACIiACIiACIiACIiACPQBAQlIfQBdjxQBERABERABERABERABEUhMAhKQEjNfFCsREAEREAEREAEREAEREIE+ICABqQ+g65EiIAIiIAIiIAIiIAIiIAKJSUACUmLmi2IlAiIgAiLQBQHuW7R9+3Y7dOhQF750SQREQAREQAR6TkACUs+Z6Q4REAEREIE+JsCNOceMGWOffPJJH8dEjxcBERABEUg2AhKQki1HlR4REAEREAEREAEREAEREIFeE5CA1Gt0ulEEREAEREAEREAEREAERCDZCGQmW4KUHhEQAREQgdQlsH79elu1apVt3brVp+BdcMEFNnPmzCggzzzzjBUXF9u5555rzz//vH355Zc2fPhwmzt3rk2dOjXKrw5EQAREQARSj4A0SKmX50qxCIiACCQlgQcffNDOOOMMe+ONNywjI8PWrl1rs2bNsgULFkSld8WKFbZ06VI7++yz7f7777fq6mpbvny5nXPOOfbaa69F+dWBCIiACIhA6hGQgJR6ea4Ui4AIiEDSEfjiiy9s0aJFdsUVV9jmzZtt9erV9t1339nChQtt2bJlrlWKTPS6detszpw5VlNT44YeNmzYYHl5ebZkyZJIb/otAiIgAiKQggQkIKVgpivJIiACIpBsBFauXOlaoyeeeMKysrI8eWlpabZ48WIrLS21J598MirJOTk5Ro0ThSK6yspKO/nkk910eJRHHYiACIiACKQcAQlIKZflSrAIiIAIJB+BTZs2WUVFhQtDkanLzc11wYdapUhXXl5u2dnZkaf83oMHD0ad04EIiIAIiEDqEZCAlHp5rhSLgAiIQNIRqK2ttcLCwiOmqzaOypMAAAIwSURBVKCgwJqbm6OuDRgwIOqYB9Q4tbW1dTqvEyIgAiIgAqlFQAJSauW3UisCIiACSUnghBNOOOr0uG3bttkpp5ySlOlWokRABERABOJPQAJS/JkqRBEQAREQgX8ygWnTphm1SG+++WbUk2l8YePGjTZlypSo8zoQAREQAREQgaMRkIB0NDI6LwIiIAIi0G8I3Hrrrb4G6frrr7dnn33WuCZpzZo1Nnv2bBs7dqzddttt/SYtiqgIiIAIiEDfEtBGsX3LX08XAREQARGIAwFao/v8889t/vz5Nm/ePGttbbX8/HybPn26m/keNWpUHJ6iIERABERABFKBQBoWpGpFairktNIoAiIgAilCgJbouO5o/Pjx7Sa/UyTpSqYIiIAIiEAcCEhAigNEBSECIiACIiACIiACIiACIpAcBLQGKTnyUakQAREQAREQAREQAREQARGIAwEJSHGAqCBEQAREQAREQAREQAREQASSg4AEpOTIR6VCBERABERABERABERABEQgDgQkIMUBooIQAREQAREQAREQAREQARFIDgISkJIjH5UKERABERABERABERABERCBOBCQgBQHiApCBERABERABERABERABEQgOQhIQEqOfFQqREAEREAEREAEREAEREAE4kBAAlIcICoIERABERABERABERABERCB5CAgASk58lGpEAEREAEREAEREAEREAERiAMBCUhxgKggREAEREAEREAEREAEREAEkoPA/wN1q3sIYPoQxgAAAABJRU5ErkJggg==" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-20600-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515409
</td>
<td style="text-align:right;">
5989806
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-29500-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
496209
</td>
<td style="text-align:right;">
5999657
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
100-596500-54900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
583374
</td>
<td style="text-align:right;">
5911978
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
100-596500-03300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
537250
</td>
<td style="text-align:right;">
5991350
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
551588
</td>
<td style="text-align:right;">
5970657
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
100-574400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526285
</td>
<td style="text-align:right;">
5978523
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522679
</td>
<td style="text-align:right;">
5956610
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518502
</td>
<td style="text-align:right;">
5962002
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
524160
</td>
<td style="text-align:right;">
5957999
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
100-560100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521127
</td>
<td style="text-align:right;">
5965112
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
100-567900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
516996
</td>
<td style="text-align:right;">
5972733
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
100-562800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515025
</td>
<td style="text-align:right;">
5966533
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
100-596500-82000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
573972
</td>
<td style="text-align:right;">
5894796
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
100-596500-90900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
590481
</td>
<td style="text-align:right;">
5882133
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-535900-08600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
517279
</td>
<td style="text-align:right;">
5936628
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518845
</td>
<td style="text-align:right;">
5961982
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
100-572700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521864
</td>
<td style="text-align:right;">
5976392
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-587900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526448
</td>
<td style="text-align:right;">
5985791
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
100-580500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522978
</td>
<td style="text-align:right;">
5980978
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
100-536400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
520105
</td>
<td style="text-align:right;">
5935908
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388945
</td>
<td style="text-align:right;">
5997015
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388276
</td>
<td style="text-align:right;">
5996951
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
398947
</td>
<td style="text-align:right;">
5996427
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
180-296000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
425559
</td>
<td style="text-align:right;">
5996140
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
100-770300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
650784
</td>
<td style="text-align:right;">
5934858
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
100-683800-01900-12800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
587921
</td>
<td style="text-align:right;">
5972449
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
100-698700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
606373
</td>
<td style="text-align:right;">
5965784
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344022
</td>
<td style="text-align:right;">
5862734
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
100-596500-84300-21000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577020
</td>
<td style="text-align:right;">
5886032
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
100-596500-10600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
536470
</td>
<td style="text-align:right;">
5981315
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541465
</td>
<td style="text-align:right;">
5981577
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541358
</td>
<td style="text-align:right;">
5981709
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521645
</td>
<td style="text-align:right;">
5955176
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
100-545900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521513
</td>
<td style="text-align:right;">
5949553
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
556416
</td>
<td style="text-align:right;">
5962053
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388738
</td>
<td style="text-align:right;">
5997154
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
BB;C;EB;LKC;LNC;LSU;NSC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;CAS;CC;CH;CSU;DV;LDC;LKC;LSU;MW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
BB;CCG;LKC;RB;SP;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
CCG;CSU;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
LKC;LSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
EB;LKC;RB;RSC;ST
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Francois Lake
</th>
<th style="text-align:left;">
Lower Chilako
</th>
<th style="text-align:left;">
Lower Salmon
</th>
<th style="text-align:left;">
Morkill
</th>
<th style="text-align:left;">
Nechako
</th>
<th style="text-align:left;">
Tabor
</th>
<th style="text-align:left;">
Upper Fraser
</th>
<th style="text-align:left;">
Willow
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Acipenser transmontanus
</td>
<td style="text-align:left;">
White Sturgeon
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
E/T (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Carassius auratus
</td>
<td style="text-align:left;">
Goldfish
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus platyrhynchus
</td>
<td style="text-align:left;">
Northern Mountain Sucker
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cyprinus carpio
</td>
<td style="text-align:left;">
Carp
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Micropterus salmoides
</td>
<td style="text-align:left;">
Largemouth Bass
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
E/T/SC (Dec 2018)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Anadromous Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Char, General
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
