<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_fraser_2024","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-08-06</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/raw/main/mapping/sites_fraser_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Habitat Conservation Trust Foundation, Society for Ecosystem Restoration Northern BC, and the Ministry of Transportation and Infrastructure (MoTI). Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from throughout the study area. Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAAJYCAYAAABYRsb0AAAEDmlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPpu5syskzoPUpqaSDv41lLRsUtGE2uj+ZbNt3CyTbLRBkMns3Z1pJjPj/KRpKT4UQRDBqOCT4P9bwSchaqvtiy2itFCiBIMo+ND6R6HSFwnruTOzu5O4a73L3PnmnO9+595z7t4LkLgsW5beJQIsGq4t5dPis8fmxMQ6dMF90A190C0rjpUqlSYBG+PCv9rt7yDG3tf2t/f/Z+uuUEcBiN2F2Kw4yiLiZQD+FcWyXYAEQfvICddi+AnEO2ycIOISw7UAVxieD/Cyz5mRMohfRSwoqoz+xNuIB+cj9loEB3Pw2448NaitKSLLRck2q5pOI9O9g/t/tkXda8Tbg0+PszB9FN8DuPaXKnKW4YcQn1Xk3HSIry5ps8UQ/2W5aQnxIwBdu7yFcgrxPsRjVXu8HOh0qao30cArp9SZZxDfg3h1wTzKxu5E/LUxX5wKdX5SnAzmDx4A4OIqLbB69yMesE1pKojLjVdoNsfyiPi45hZmAn3uLWdpOtfQOaVmikEs7ovj8hFWpz7EV6mel0L9Xy23FMYlPYZenAx0yDB1/PX6dledmQjikjkXCxqMJS9WtfFCyH9XtSekEF+2dH+P4tzITduTygGfv58a5VCTH5PtXD7EFZiNyUDBhHnsFTBgE0SQIA9pfFtgo6cKGuhooeilaKH41eDs38Ip+f4At1Rq/sjr6NEwQqb/I/DQqsLvaFUjvAx+eWirddAJZnAj1DFJL0mSg/gcIpPkMBkhoyCSJ8lTZIxk0TpKDjXHliJzZPO50dR5ASNSnzeLvIvod0HG/mdkmOC0z8VKnzcQ2M/Yz2vKldduXjp9bleLu0ZWn7vWc+l0JGcaai10yNrUnXLP/8Jf59ewX+c3Wgz+B34Df+vbVrc16zTMVgp9um9bxEfzPU5kPqUtVWxhs6OiWTVW+gIfywB9uXi7CGcGW/zk98k/kmvJ95IfJn/j3uQ+4c5zn3Kfcd+AyF3gLnJfcl9xH3OfR2rUee80a+6vo7EK5mmXUdyfQlrYLTwoZIU9wsPCZEtP6BWGhAlhL3p2N6sTjRdduwbHsG9kq32sgBepc+xurLPW4T9URpYGJ3ym4+8zA05u44QjST8ZIoVtu3qE7fWmdn5LPdqvgcZz8Ww8BWJ8X3w0PhQ/wnCDGd+LvlHs8dRy6bLLDuKMaZ20tZrqisPJ5ONiCq8yKhYM5cCgKOu66Lsc0aYOtZdo5QCwezI4wm9J/v0X23mlZXOfBjj8Jzv3WrY5D+CsA9D7aMs2gGfjve8ArD6mePZSeCfEYt8CONWDw8FXTxrPqx/r9Vt4biXeANh8vV7/+/16ffMD1N8AuKD/A/8leAvFY9bLAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAANIoAMABAAAAAEAAAJYAAAAAHRXjz4AAEAASURBVHgB7L15kGTHfef3q/voqj5neu4ZzIEZAANgcBMAAYK3IFEUZV2WJXE3dtdhxa4iVnZYsRF2bIR37fD+sY6wtSuHHWF5tZIlUZR4UwQoEiAAAiRxERicgxtz3zM9fVXX3e3vJ7Nf16vqqu6aAUBigJczXfXqvTx++ct8mb87YwtKFqUIAxEGIgxEGIgwEGEgwkCEgQgDEQYiDEQYsHiEgwgDEQYiDEQYiDAQYSDCQISBCAMRBiIMRBjwGIgYpGgmRBiIMBBhIMJAhIEIAxEGIgxEGIgwEGFgEQMRgxRNhQgDEQYiDEQYiDAQYSDCQISBCAMRBiIMLGIgYpCiqRBhIMJAhIEIAxEGIgxEGIgwEGEgwkCEgUUMRAxSNBUiDEQYiDAQYSDCQISBCAMRBiIMRBiIMLCIgYhBiqZChIEIAxEGIgxEGIgwEGEgwkCEgQgDEQYWMRAxSNFUiDAQYSDCQISBCAMRBiIMRBiIMBBhIMLAIgYiBimaChEGIgxEGIgwEGEgwkCEgQgDEQYiDEQYWMRAMsJEhIHLDQMLtmDfPfFMO9gxs5j+Becex+JxS6b89NYjayw0bW6+ZvP6926kuI4QG4hnLRGjdhNEK6UFay7MW2m+qtYXBGUrrVyulS+uUkOJvA3qjwQOuiXamVM73Z+alYWD6kLN4SooD95y8aTV5ptWF4Rh+II8tD+aLFo6njD+LaWFmNX0rzzfCJWjdepMWzqWbMGq2/Vm3c7XZhwc2XTacomULcQWrKJ2m83m0vi5+nWG9fy8/hrCmvLQbjx98TIdlbKx1KBlY2orhBnmSsUaVhfsS0n3wAF4EkTqRQsbvldLOQVb3Mq1vKVTVUsnaqq5lbeVS1cqGNO0yySSllYfqmpzrq761VYioZmkv3DqbCf8jLrmG01rzqtC11zM0umk5eMpQWtWaTYEl/DYnBeuEm3wU8+Cw2dTbZslkr5t10fN43mVFUhLCVyB+5iexeMxtake6jql9kjuXVN+vhvVujXqdYs1F2xNfsQG8wWLqVsLQm1uPm3N01P2yA8ets/8+i/Z+WLDpuslvTsJ255Za5tza1x/eDMrzaplNSeSmo/Uy7+Yq4iGzC40Z+1UbVJzsWDr0sOWFD7nNTfmGhVLqr6BRJZset8YOyV98Dvu+qC8wlupUVY7NcsrL/P5THXaTtQu2Mx82WoCmHc0pTmT1fylTspfbHKwqy3wxVoUTvN6R6sLdasLxvB8DOfp95q5HcDZbxnyAVFVfWWeh2FgXeM9SQn/4VRx60Y9fKuva3CX0hjlND/jwmWvxFjVhA/a6VyjqYPnrH3FeM6NJfVwrzJfd2O22hiRF2yXNb/09vQc04zgpP+MWXmqZEcefdEGFhL2kVs+Ytu2b7dUKkXTLvGeHTl62H7y459YNbFgO+/aZ+dOnjUbSVt8KGuxBK1eXsnPBb/qeZyyqq3ejwD/q+Wk/kIsbdtswEbiGcu5N7hVipF5zSbtWLO0bIxog/nOu59THc1Y02YbVZudZ/do7evk2x4ftCvmc/byibptHEzYBo3HQZu1N5qT7v3ud1R+de1tbg3oN3+U74OFgfZV8IPVt6g3H1AMQMRNzM8t9Q4CE2YIYiQgTHgY13IaJD2yUqwiJgXm4J0n6kiLoEqKeINI6yQoOluAwG8m5h0BUNWmToIYiUP8rZbU4UIiZ5ZM2Iwjrxuub2wWwVbmN6iYCP6qlfTXLbGJTC+IJYBqDSX6EhexD2EI/rol8pRFQA9YVkyNCEf1WWS2IzbqKlMVkxROQDYfh9lgS/R18l0V/idtzmYTVRE781aLNRyBM+sYBk/0O4KYylQvTFNThEhCRHMiBcUdbqW/a2CBnBqOFZdgCUqKBbC6GxcR+CJcmSc0Uo83rSxGsgGRu5hZPILyhPsTt+lmzKrVjK0dnNRodLK/ripRZvMixMXEzKdcG7Mi5qvCJW3FhHcYBeYBXWM+pfQHLPx1JhichsrSp7jmA9MnqX+zGgHqrAtX4g4sJlzFxLy2JTUAE9QQg0WnYnXfdrNUs4kn37bq0QtihFShR4Ir6uaDysXovPoxr1cqu3XURm/fYalcxjNcgrMugn9e8zpeE37Up+MnT9j0sfOWLay1XZv3WLpasUNHDjtmtJHUuIsYviI9asnZefvyN75sxw8fs5tuvtHuvuceO/LW2/b0M0/b+YkpKw4P2cb16+ytN95kOthdn77Hrrx6j508esy+8sN/sNPHTtq+G2+0Oz/6UZs4f9Yeena/nTp50q67dq9t3LTJHvvJj+zE0RN26y0327XXXWcHDx207OCA7d67x155/mWrzs3Zumt2WEUwnavpzdGYMw68V2J9NdvT7roNj11+BHN8iZgE9a3lp72Enmm2WUnvYp051/70In+JQdag5B0z1/92znzTTNC8KTtGKYA7ofuFWFZMja8L2GAZ5xY0vzTGF5vAS1ZMB+sG612vRDusBTMLZfcWkY9xYJ5nxMQiaKnqnUzExISH5ue83t1ZMbswm6sl10ZCgjIxyAhBOpODdSFjBcZcc9gGtWZ87EqbeO2YfeOx79naJwbsmqv32tatW+34sWP20isHrFIqWXHnett8zRVijPJ2+s0JSw0MCG4vhOhs4/36m76DkQExHguakwiOUsI5Ipa69ouApQzmSTDf6Q/3WMOCvIzbSuncwpwd1i6QE+NZ1Dwbi+VsrYSNA6rh9eaUHVoouTnXq45zjZKbE3Wtzexl3dqbEIN1Nj5g5ys5CVVqdqyYtKML05rH7Ej9p3A/+y8V5fygYKD/FfWD0uOoHx8YDLBRJkQk8hckJ7FNBJJzlkJPfsAcQNy+W4maIBiqumATH4zl3YbSa0FlE0kq54CkZm6j1uI+lJSUUfdWSxAWg8m8PuNWEaEypwWffib1FxPhTY0wg+LBRHhCpAe9DtfMBogmazkhQX40T6slNHBJSVebggHCHOIZLUi3RH9hHcP44DoprUZOzF6lAYMgyb80ShW3yQm2OkSFpPdZSXD1D0I9kRTWGE8I9EtMtFuS5HgwLq1GuA6aEJSZBTFfYgxm0fA5PEhLog0/qY17QUxekOhqWX0vixGgnpjUQslk3SZLY/qr22hhosXAUUxjjAbM9UWfTVWA5qhWB3+MuwNAEHimKC0NU0p9rqkc2pplSbf8KKpOxxz5msGZ0xzp281/GMkuyY2XmByXqEv4r09XrHLgtO1oDttnvvjrlsmIEe+VVP/k1KT9+Jkn7OCTB23841e5LjjORWUSkq6nNb2qp0WIvHbCrtm+2946cdIuFE7YOjFT4BgGDAFBXu/BUDlpD9/3gE1MXLBbbr3FfvrMMwa6a7W6/eixJ+zzv/55e+j+B+05MXX3fOrj9uZrb9pTjzwuwippD/3gYWkjG3bV3r3206eedhqsocEh+9EPf2RXbN9mg8WCPfXEkwyBXXPDtWK49lt5riwmasKaQs/g0JA98eOnbHCwYOP7rhTTGWblNXTCdE31JzX3IBR7JeZLTetAxb1XYgb0fqCFYE3oMoKuGgjQmnDgGPJeFfd9X2OottFOZzWeGaf5YXaunICBedMJo9duqd/0gJdcyeV1GAnm8sp1L3sKo655vVICDv8eJJ3ghbwICzIi2BEYMNFgqlPSGiCeCRJkOZrqBb3fvbTfQV7aQIPblICnofydvedtYn1EI+l2FBXIDOVt/a27NUd2WPbopL124ID99OkntY6JeV5zhX3qzq3WXJ+38yLpeb+vuek6aSIrdq45I4wtX2sDWN5P3+ABlviq+JBtSw46AcyRZE1iLLAOg4T1RdlpG73GUUy53gnmGtrLtOZ8WuslI3xC2t2KhAwrJ4/5ktZ9WKFTEhQkxJAyqoxh55zsrIsxKklwttKMopZDYv9r+ZKdOicmu6w5jfXBSoU6G4p+f+gx0FppPvSoiBBw2WBAi1zAGEEQBim4QrNRldkUyzAmcLEFSedFzELIBHmCMu/GN+1g1jYoYqpb8m36T6SxbPQs4MAIobjahgDQYh/0EV8qG9NmXNOfVALS3XhCGeITE6JefYQJ8ltTNyj7uechhdnk/4rJwQws4MRr9pBaxyU1REoNJCUxSXyLHnFwQZwlHIEXqln1hMc49KTvS6CGqSynapIOZ1yb4cLUnxRcWbVNPp88Tv1ncEsEqEgs6ZU83LqNaV0yWbULYpKyMrXLp2UaIoJwAbNAxkcJnFcaYqZFlNUaql+3Pc0nRkxtDqYw5YI8FIGgZ1VpeOY1X9vaDmpqeCI1YBhpwct+dQGu+OiWlHFBcwWGjYQmCu6hXtHsmararTd91NZv2LQqrodHR6wqU7o3H7vPGmJkEkmZHDEX1GxSkv6BXFZa0gnL6f6uKzYLLxfU7yk92+DwgTkj8zCnvBfOTIrYfNau3LNbjNe0g+XACwfsqn177ZrrrrWPf/LTNnFmwupiKj/1mc9YIVOwI4cP2XPPPOvm+cekbbph3w3SiDXs7LmzIpKbtufqK+3uj91te/ZcZYWxYTvw8gE7fuSYnTt7xpq799iWbVvstTfesP0/fVbM2oJtFjPVSMn0Sn1hXIIEFut656pOe+ml46HHjpHGRA0hidf0+TeLvmHOm9V7zZi2RoMrz95SjjWA+lrPF1vWuITbWbzrv5TZ5Q+teTygBERsQ8w7JoJobDqZOuYF+Xh3WQ+piGvmaHjO0DZ1oDvICX5+M7xeELIMWj1ZOVE3771nF1cuj0bcacpdqzBM9K1VBtyWRHwDd0ZEedAn+lqUuSjrKbBDQPfEoerkTQvKdkJPG6zOwAKS3HsiEOIpmVruGrfrd2yxLQ2xWcLhs0cqdkbISaldFE7g99y5SZtNy4wvKwhaoHc28776Da5gjvYmhrU+CzNak4YWsnYkVrPzYkgRFmHSNi8zQunqHOww0Giugy5SB+voYDInARBjtHoKypKTMQ1W3tVL9odaV39ec6Ep0+o59SvDGEUpwkD/GIgYpP5xFeV8H2Eg8C8KgwTRUdMGClHDghskNsP3MrHoQqDAgLFxB4swrcIAsHEDD3AAYyA5RhqHBgP7/KBMNzghYtAMSc8jk6+wr4/vFxsz5bGJXyl5sr6/zaVbPcDfQZt1y+buQWhgG450ERxcqM84xgipI2ZFvr8B+SP4ZRaWSHtNTs9K38ED8D/TmHOEe0Cuhaujb5gVJWTmA+zdE1pASU/VB7RIpKQIiIFM2UrlQbswO2KZwTkRoNqUOwaUEXIS+xBBil9MRn2GAGFUYBAxY8SkBaKyM1En0nzyXizT6LRHYtqCNC9molEVq1euyrxSfZdEnDphNqZnZuRXlbJ8Pq9+laymfGi8MkjNM/K7k6bLzW0xWE5HCLMl4OjFoJ7HRgbt9edO2J9/9as2vGHE7rj9bpPjkMMJzPFQSsZrMgubb05buSS/HxFUc5WyXXXtNbZj6zYRmef8PHMaOpFiQgXtL8ingzlerkjiLA1aekDaLmnLMrSpf/hlxcV4icu20zK3+/73HrTSzKztvupKuzA5JZ+QuF2xc4e9+vqb9tgjj9q1119r49s32pTmRaNjzQBPDCGmgzURw84vxfWad1E+ZBp/xilMcoETxrmiMnVp6nivMT1yq5HGjfeeMeY3+fzbq0JBEh7n9R4smzzBcwpIk+qY42WFaRvhi5gljS3vGWsRzANtobEqy19DKLK8GHLqKUkYoNnucBc0wbfTIolcnVcf0DLWtOYAc5cmw8V6XntNSst3h4yturgCQp/8ff8Z3Ft85Mow/nOCBXO7nPqHJoME04MfXlbaYMe4SmAVNr6iRmY/GnjeMXDVLTEyrJPimVtr3SIgrPGHYvJfSzZsp8y3ZElnRyoNG9FSkM0lrFyN28uPv2n53dKObhtz861bG++ne6yLY4kB2yEGyYtoGAtp8cUojWvuTqnPdZCnP9bNnEREeuzycK9zjDxjToHOJz/7XrNeJrPSgGmuz8+pV8P0A9iiFGGgPwxEDFJ/eIpyvU8xwHLnTN20iUO4sMF1LoGt7fe97QTMDoQaiTaRQKORAC7u8Iz7AXxcwySh5fLBDFzRrh8NETgIft/JthMYHnZt4BJvtvqyvAII1jlZs5fEKGGeB3amxcOBhwBPrpT6jz/NskRngwaWPby4G1Q13ZxzBOtYouCIgfC8wAoIBsZLytvrdnJ01FxKEIpuLPUbFqYh2JtNHPnli9SQ9qQux+PkrJ60MziuGyLwnfS+rjpUHQxJSoQ/z4AFRroiZqGrczewoVlSucTFOn+rDAzSgtoL8B5D26nf+CNh1AQEs7Mz9qNHH7MfPPywbdi40T79yU/YGWlenn3hJZm9VS0jpun3/+t/6uCGiG/WRPom5SMml7fGyZTmcsJOyeQQz4L1d95gNjplW+VDNFws2ukjp61clu/VZMk25tYpYEXaqvmY7dh5ha3bMG6/8PnP2Wn5IUl1pj6qnxDnghuNaEMEP4lrfNI2CraXX3nVXnvpgA1ks/b2W2/a2PCIFQuDdursaWemd+HseTt/+qxdeeUu27Rhkz395DM2W56z9SpbKAzYqeOn5Ld0h+VHC3aqft4xArQXTowL4z3XlK9QXD4Z6hmMVFlaQIh+TNAIXgEeSV4bowvwquezyhvgOxCQuIy9Plw9GicxUWghYaDd5AjyAx8aJs29Xgwy84h/BC+oL0r/m2KMazIhBK8wkKIVnUCC1TKAL2gi+EaIIdaQTqm2djCCPP1+E/ylmpBmS8wLuGGNhgnjHz5+MM2sf7361NkOEDlNpHCMWarzmFIdboUVymCcwB3jFuiSWIsJ0FAVDpjrvRIjCUOIEAQtSVvPwZv+nRBeZoTbmYx8pqbEcIoxyogQPzEnRn3XTsusmem7L73g4L6HMoC110itVMPKzxgHNIV79L5iwB20SCme5bWuDWidmHJYDKDRt5/uXStH2MOKRvmfexIIsgC0REEzrSRBgdaURX765w5aBMDlgYGIQbo8ximCsgMDrNFsVmgpKtrQWJC5t8La3VHDu/uTdtE8OPtr/UBaDJFCxKRga/OkRqtdthAILbQRyUWpfOtp+xX+U/NitjoTdfTX50W7cREPwNiCqb/ytAOxiEQdyTTYByYfEU+2+nKybWcJAkgp2WrDw+rvBTm6fiuLemwNSWjxQYoTdKDPnnatTzdhfibrs66W0USxjSSAdYVg6xyjmoIwnCuj4RMB54hGCGNtvBqvhhiCGWmOpssj0l4kJLlP20xlyLIDpe4gqCAmhM04juZSfiiwSHJx8HA4nquLkZbWJKFdHbrbYUB4gNF0ketgFFQwMK9b1ghohfAU/wWTtURwOnhFzEuD4pLyydfdamX1FoIbuz4lfIEOHj5sv/M7v+s0Lo8/8ZT9s3/2T+222z5iL73wgh149VXL5Qh0cc7BEU9qDkzr7xRO7cLJmLS3KRHhyYrFRTBmsoq4KKZqql4RTiR5Fux/9Wd/aelk2sZk/va5X/qc/fLnftn+6q//2p554hnbtHWTfn/ORkZGbHz9Wkc4j8ikT5SNTPQUxVHM1tiaUbv66qtsoDgoDdH37LGHHrE9V+22u+66yyalJZqUSV9a/k5j4+O255o99siDD9vjjz9hKTHgxULesjL927p5i1237zrbuHWziz5WrnjTNMa/W2JW8C6jk4BxIxiF0Cx8atYIrsUhdEU1xfS7xcAE86k9V7dWdI+KgsoYc9XdqUl09esZ7DlzyH8sr492YeZgjHy3GGOYT73Duoc2LWhqeWnu+DnB1cr5yLFyAhYnKBJTwVuGrw4peNvwOyPwS04MVOD3tHKNHibqraovBFTBLyknFhZ8UXsGSlhRCktikubk44KPHkxrPwlNEfsK/qJEMWxpVjxWGF+Y3+aAcKx/pWnlyClAw5zgHx1WkAbhVwFoWhhc3irPwCvMIehgbSUhxMKvx5kha6zoI59u3BZ/u4yX+EG71Ec7A1rHdyja26ZO38zFuhNixNcIrzPCh5bBPpJmJesTc9O10keR9zgLa2BcUTPrJ+Q7q/UuWeyrI+8xVFH1lwsGIgbpchmpCM42DECYE1oa7QxL3s972WPTQVMSJDY20mqEkduwtAHxvVofOsk357eiDRyzO2pYrTywQIggUQ58XNjKIFh6EYeuE4sfAaEDYUgULkxV/MYukkES73xCRHBHYrMUKdlxt/+ftNlUOzGZz3TVrPRflcsJvJOKgkRCkwROGDvMpTDN7EwJKH/9HZ0YFrEpE7PUnK0ZPuvCWZ+bHpd2I+38jgYycsqWH1OpMiAJdFYakrJw0t5vNz5ojOTPwMadgvHT+MG4QcBBzGYyaSuK+YLQY1xKaCvEODVFmDNDnFZBdXRNvgEHbxNmi/wihBkvroOEJqYubQ5KsYwCZszXccf2M7YqX5yJiXNWKs2I4ZiUf5Ui5M2W7HVFkdt3w436LW0Zk1WoapwR4zgpxjgnP4VtYmLyi9vJ4mSGsTtTK1tD/iHXXbHF/ujf/g9i9oAL5kKmpbmcC8Lx3/6bf2W1UsUyAzLfy6VttLbBtu7bY2dlgnfj3R9x+SfjFdu2b5ftum63zauZnZtG7Pev3y0tljQTAzLZU7nipjV2xdU7bFa+E+eku7z7c5+yuz/5cUfgpmTKSJj1OUWtO3HqpG3YsN7WbNtop2tTdkHzgXkRvLOuwY4Pjz0RgEJ9TISlYz5bKHW5uQdu0STB1F9KigtXaAnn5bPGxYLmgaptSzBnjgtmGjCfyNCRR51xzJyrrK30z+cH60tVgHeC6X/74Ah6MVYFLijPFAsSOK9gEigfmfyCZy54jiCHKH0EgulnfQvqow3MpQm8w5rGegHTxHuKdg+zSRc1MKN3Kyv/RgVoqUzrW1EhZ/ZLiKDYJYNbBpnkQZWu3wHMrLlBZD7MetEIoklDmIYmzcWOWxpT2DHHVir4g1h0vT9BPUuV93lBOQL7bLFB26oANGMKmY7paK9A9kyzQWl0c5pn6MRXS9TPeopFxKLMZbUi7/lzB9OARlT7U7Mi08mi1zS+5w1HDXwgMBAxSB+IYfzwdWJG5hKQNMGG+X7AwEoE1krw0Q/MX9h4+9386DeSRsxLMF8pizkj3PZK+HCbl8jFoohiv/9CYcnMT8zmnPC5WgI2WKKpZtllpb+0xxYOw0QIg27tQxAsp+BcFSt/aFNLSuIfk5qFf+9WwokeoocaB+N5kVCSQovwgABqtSKiRcQQIdPTmXlbN6xodeVRG8pP2lBmSnNPPjDJY9IkyDwoLZ8YCECZ2FVrWZutDIrYbzHLYbjBO1okdwaRftBeWZqhskzYYIryCmeOmQpEMtLxag1fEMGlvC6in1M5taAM1+2u9Qjmg/wwlg0xSmiLMGF0IbwFZ60s3xNFDMwWClafkS9SfEZjZ7ZOWpfb77jNHpOZXbVateGRMQVIqNup06dtTuZp1yliXICg+bKYgVmNj7RG6XH1SRGihL5FEASrxg4GEMn3mfq0/WT+TZlDaX6z4yzma1ZEEup5XlRmMh93IcorM1URcd7HqVzF1Mkzk3UxQuAH3MDEMYEHkLRnJSCQmWBhNmsjyQGBp9/4AGmMITbTGTWo9tAcFeVc/5MHHrE3ZZL3iXs/bfXhhJ0oKwiE5m6v+QWoYNvNYV24GQJn2SMJLMe7uND0IQK5R/aut5nvst2U4kxcqIj+JaR35BbqfGMAKNyE5RA+CEdvODuq+pn8BMxwAjoXCU1EOoyCY/QWM/DMmTFKyIBQIPjNOwlusRlAu4M5XaB1QsCAMCCvUN1uHJSHeQB7cbGJsBysjs4sTxpDGCaPTc0UwUAwAwIX5EVwz55ZsLUK1rJvbcmOj2etkCcsuYLBAIQrBQTMHAU20Dih3XL163Gw4nDuF798G76Uhzlo1cPj50KQy+fo95Par4wP297YsNMeAVO4pW71yELNBjUGs+AwNO99SQ8HffAjRA1uMnar6udzT2ArWKw1CJoxI2Z0TN8MbJQiDPSBgYhB6gNJUZb3HwYC4vz9B9nFQ8Q2g7aAEM+rbVhB7RAHgd9SRlRnXEQmfj4EgaCWXomtDAlfOFGPXOVD23P46fLr1jbunwG/I1xEOEAAdKb21jqf9vitQhBMPc3JehTr9zZM0kRDYWDFXEKusLF3wun7hVZpwYrZWQVjUAAG2QN5gkCRtBS9zhVSRu6lRCQVcjM2M1eUZkkkn0zpAgIoDBd9gpADV5jWleV3hGQ6l9apO7pHuzBsME2YdEHtJWSOx6GyQYPkWSnRhgKVK5qezDzFJM0r+AKhwbHDb4rpQluTSmfkW6Q+uU7ItEf+PNfuvdYq0i49//zzdvutN9v58+ftxRdfUKCDq+SIrrDncG5CVLwgdni7mPrcYkhrd5s2JR2X1ikjKgR8QlhBos6KqV6OYd8DziYLEnlyYgpkZKh2dG6XMyult8tL42MS3Ed7kBJDwj//DhEQRVrBQMspf6mGzIlu+9Rd7m9W/iOvl0+6A2OX1xxA402eYOzoF4FSILh7JTRHcLYoHXFWx+yrrh/MtX4Tvi8Q0FUxnGWNk0P2KoUdYyrYLoEPWKXm1mrU+W6sWrCPDMwQ+sr609lP2uNMr4rM42AsHLukjvLPE/Y+MA6HhXJgt9OsKmdV80VLo2OSGnpGSHlmz8UmFzpc7cF8EVlPOlI3l4IzgZwpmbQryYLmvCxOS6fmbXC0bNfcuN3qKWmDJZVw80EN8x2sGvQkWBPCcPG8WwIPMINl9ctHPuyer1vZ8D00pJjSXRkbckxlgMNwnm7XtMaaRNxRzTCX+Cb0ekH7TkK2d3GZOLJqoahmzZkT43iCoyD07/2Q8BOMFSUGOa+Q8RL4xNOC6/0B2vsBPREMK2AgYpBWQE70KMLAzwYDbPoQUf2/jgkRg2xbbuvVYp/UZjWoey4wBKYYEEx9JU/UEqIZ5+RL2TfYRCF26AXETPsWvki4StPCJh3U78nnFoCU6UUktHK9u1doL4hgBiYLCk8rfUQIdk+W8QycwlPGoXw7U6iznOuUy0jnVJcWqVG00cw50cvgI+h1uLAO9UUSLi0BhCAS5DxnPimv80dS5Lg6TI0IEc7iycEgifKD2eB8nn4STFIqg/+UtEYlnfsiogUtUiqb0SGvWVuQTX5zWuOmdiBAIeRKpVmZ1E3Zx+6+266/fp9NTU7Y7it32DXXXO8JPvCgfJxZVVcEvAXBEpefUU51euK+JfHnPCf+fO+74cD3IvwEIgszIDUhoUHA7IdztHoeEGDMm2kdDJlU30acb5l/L4gmNy3zQQKhEK/taGLCCiKmqW12rr+DTwmikRHeYYwwg2pLgtERv7qPmZfAEGMoXMgsC58nzOzwL/QBCUITpa2S1g80ZJTPisBMElZaswGCP1yyOyZadbx7V1oXNA4YYOEPQyAccBDg/J22Q584O4f6e1GrhMCvam6q5bbmAhww7pw/1dSh4WghXV2CuSKcJSVMwGQWjffFJOAi3H9YM8U7KXGUBCDyY1GN6MpTMqclpTIJG9wobfOFmM2cn7e39r9piWLeijobKTusd03R7eRypy5qTvop4sqt9kEfgQV/0bI0Y6uZgPaqzzNCMVsvTfm+uDTgmlu+5l4l2u8DQ0E2rQkFKWH28zeoeblFYcBz+oGCMyb/SxJ5WSeL8TF7Ui/w8YVZf8899XvE4uXP/CuugDDNM1pTKkRLBdZgFv3MQYkavIww0D9Fdhl1KgI1wsDlhAE2FqL79puQZmdFXLQxFFrvIemR3Nck0asjSe1SIfc6m4LogTRvyfG7FOxyi3qQiGLrj8QVrVZn3UAFkzEoOwc0BWhGIDgGRERq222rFYK2ojzL62jL1tcPTLGccU0fjCJEBCGQE2KSwG3QPrjqZORWazwlQiKXnrOpuUFpNBoKjV2VtBUzuVBJVUybhCxmDGF2Cb3sTetE9EnrMyffI8YTLRqhwPP4jqkvHLAbwBeqsfelmKS0mCHCYmNalxDRniJggirBqjImpqyeX7DnXnjeNmzaaONr19m9v/A51y7MFGZ2t912pytHoYlz5+25l56XlFzaFM47UaSrIYXZLiaZeX5uOcZIsBKVr22O9oZy6UlMpkt1aWEIS+2Ju6VHPS+Yv2ASXyKISZh9Dn4t1WR2qnriMJ4imPHjqug+qdu7EW4g/NxrMoBmOeZhkFx0QT1DE4LJGKaFhEInMaY1EceY0K6aVFdDTDgMFXOikJaPiAIXYPqJPxcmZMAShm3VOhczOEZO9cJwh7WyQZ8CxseZMWokYXYxe+M3iXEhSExYyLFY9SV90Qc0fl4M0b0K1qSs8NjQuMHkd0u8rUTcQ0sHrkmMEmvNnMyO+xcUUY4x1Lsm87jAbC+oz9fqNSSMrNDhkobGcoMpGxgS1S0QzxyX+a2EQdWZnJWn8FmTllXmXbkRaUYHtRKmPPNP4WAc/XgEv7hPn9CeEUdQmig/BA5XC51Mugdj2Wfw7gyKIdqVGLTtMSLV+eA6yzKvcgPLBqftVgdHNSe2SBiXRZNMEtjhtwJ80ObtibX2mvwz6duYmMtjC2U7NO/j4QVzzVfw3n8CU1zcXExBZebnxKjKPSxKEQb6wUDEIPWDpSjP+w4DjoyVxB7HeDakpEylSAQLQJLPcz6JNBZf/P2+60QIIKLDyYdUhEmL0HT90Udr6/TXLsqRNqrlCYkqB5J2Z44gRwiv3OlvxAYHYSBy0mFteb3d70AQ5iCktCEGxHG3nGyIMEMFOQUrnpSjLjJOktmee0DEGETRrDRgbPDhfutnOyLaiy775Wz9tTmXxGwEROCyTIs3eA7pV1a7mOu4diFK9bzdL6lXDa37zLVcumwz1aIdv3CFFfPTtrZ40h0oi0uJJmcbgQohllWEvqyIeDZyzrApy/+H+cvZPwRFgBbxRDpu3Mvx4sI+t2OrBdDiVVJannRKTKlwgqmYI5hrYl7F2KT3rLEDbx61w3/6p3b1riulObreNm7m0FjNGMFLaO3Tp07Z/uf224uvHbC50bitu0vBElSXA26x7TBj1G383Bup+lZKyKlhBhjui02YP0Eoc6bWvAKR4IPlTKFCba7UOm3yjqCJAj9EaURrRCh3mJZlSZU5fy9mt8YWU9eUCPpwyHrms2PWgWtZBe036LUTECgCmsJOOIFDktMtlRYkqq+K8fJMX/9MkmPghAd/cLGmn1R0CQkncM6H+Wd8ebH8NQIBaTwWmSLX8OIHQpB5wYU2DkyshMdwuV7XMJISCSy2vzwXuHKBeBxDuzLmWF/oRwATuUvzBGeQhrOjapfX5Ww94cqPuwh/rUthE+Q0wWH0nIiAXovTUaF+Bu8fmt7r796niG+K2od5Z1lRBEsat1lpOI9JCJOWGd56mf8Nqw3NMYRFC2Lc67M6W2lOfp2aa8wBtI4wSP4X77vvGX6LmSH52Wl8VlrTeIYGbJeOxSZK3SAMn8NEq8/Le9H9DiXEVyjCYMzKwvGIMIU7z0qJPgxob7gpOeayAf9mG7D1guOl5gWb1GrLfHuvkgevBSSa91wpLZ/RjA2MyOwyjrki+wLz+L2D473qX1Tvzw4D3aisn13rUUsRBi4FA1rZanK4LtULNi1JfaORtIJ8RIZyUyL4ZI6g37P1olWqOecLsmHkqM5wwc/j/bsYsh0i9eScjqw2ZWIZYerB9gjRx2bJYp6RpsbZx3fBG8R8RRtzLwIGMy4MyTgfJYj+RzXUi1kTGqDw/S5NuFtohIARWCAs2Gha21GvUmiSTAyIAkT0zE//ZCgj4mFWGh3nPK8x41DTeXEJ+L8k5XTvibpe7fj7MBuY8DTkMwTBsfrIi5BRPldOeKJX7jBQkUWrl23BAh4wRxnKTumQ1YL8kYbcGI4XT2mDror4V4ZFiTClAsZyDl8hNc6hqUjEIYLAQ05MDeNfgpjS8zZY1Bi+S/gpEcChV4IYyYlwZ9zABaQxmor4kMrJN8em19rgVYMigC/Y/iPH7KfffNk2FtbY7p1XWlaHw77yxmt2Yvqs1eSAPvSxbbZ23ZAjtH3bIjg0PjN1fzAnxBEwLsEpGHGqh5GC4esnEiE47JWcD5QydKsnIHaYH2jM8D2grn7mC+1hSkdQCBgjTPIgNOFp3aTgu0ciZHZWdlQKNeHMIMPtYTrLG7lSn8LV0qbTvGliwCRB3AWJ9023LopJApaY+iQZkg/6IOaxoYAXVb1XA6mcMwcMv7294GQOIZiBWXdHGQRAdfl2OO96H6NBH4hEbPmSdqozK3MHozL8bvxq1pmj9Zu2XEQ4VpfFScda6X3P6LTeR613zEr6gD8RJoPMDMq6tVIX3HEht1tVu3mTFaHPKtcUg4oQpaH1FebFCRiUl/cXzd5J+UrxfkkVLY2v3sV0wjIK4JAuyuQMc7xZMbdnxWScUGOzcRsd11wbSNiRVw/amadet3RDjKnmLJ3w2jLfmdZ7tKC1RJrprQUb/cgOaYHlD+h6EAJYl/QJOK5NjMjfqOje9W752kut/At2LAN+HbZWztvtKe2D3506jHYslrUXGhN2WN6JwLrUv24FL+EedcLMs/YzhzDZHY4XbVJRBnMaj3VFaeIlzaiIeSbYEH67nhH1jbXgaV1dAhhRkQ8IBnrvqh+QDkbd+OBhgEXw+Plt2piYvlrI9H9SZ9FMK3pYNiWzivmUGCNtE5LkpZxm6fJY7CCjYFDQIrDJZSX9G5btOGYWZd2nF0Tuov/dEuQEUsluvWWDgpDAVCYnJgTpOsRBkHrVGTwPvnE8L+h8kYCY6LdcUJ7vlct4vwfamKnMKUQ0xAjCVRgV9UIEX78JfMJc9FuC/ET0wwyLMmzs/ZYNw8S8y0iLVMzN2oXZUR1QKpsO9WF8SExSB6NOmzDFro8aEyKy0Sb9xLQuI6bCheWWdLkTFoi0pvJTt4ala6IMfjQQDJwXhs9TXsT8ghjHZkZwbpCkPici4YyYwtQaG7xh2GI3N+zC0Qn7wRvPOD+g4vZxK15xtRzSFQ4K/AMsuNE1YcrxyoCoxyQvDCPMDPOMbxeBT4zEO0pq1/n6qF0Y8xWTHq9+1k+rBhijvBhjTLJ4B2FWV2nBFWaOLJnWiZgGM0FifBhbxyAGN/v4pk7mLWQ9BF44wSTBJ83KfJADWHFscTgRtM4ZXe9IJ+AueqEIfOojSIcTNKi/aDxoq59ELkJVIBihvUAC3yoLoMDrA1rA5PM7SFwRuIK1BwJ2GZBBRn27vGqLvjal1e0Fo69T4yaim/UoXKdHm4KDEFFS72JGWgPwwLrKX5Ag+wN8taD1MKBJIy8HLDOzvWiHwBs6J0kENmIrEnN/TnBS7ZFnDtjgpjGFkF8vs1Mdv6o6qDc/JF+lgsKOTyoK6JmanTiogDaJil145rDde8fHbc/uqxUNUwO7QpqVf+A3v/VNmzh43hJXrXfmsWEc+6ISImkezwgWwq8Mhju1Qt2rPSoKE8R7bGFutRLLnzOOw9Ii3ZFaZ2MLeTvQOC8Yvcn18tyXdodxGksVpTUjsAYMkg5GnpVGThExh9Zq3VAHsFPAhLRABFMsLjR2iENgfnnvQBnrgJ93HS/gpYEVlbpMMdBjW71MexOB/aHAAEvW+pFjbiFjwY4vHsoH7caGgYkdu550D+4agvX9rD0C6nBiYYbonJBPRVzRrBTbTAs+xGn7dhheuiHovM/H0n6/VCU4wueHYLqYg+BgnBLxgTmPr8PbvGOiFK5zqQJdcB/pb5g5Cj9/N68hTRMyvMdMpNqUCYqYJKcN6AVcl8bpJ0EQnDamy/NetwJ8vBO6grJJaWgG8xesVBWDW8/ofKSindb9dTBJyeXaTNeuCrpvEXIcIouTuiPo/MRuAxniG82avhThzpF5bc/DP4CHbR+H9xiRt1QfZAnENYxSWmexNhXVrXZCxN8hmeGtlZR/17hlrxh17w24T4hZc4kGw0kAY2YWJBd1T/l9VDH6o1mjXSacJ8h7sd9oSNFaOQeQUJsXW0+3/KwWaI6YM87ET0wdCmfHXHQroHtggvGB4CesOWZ4aMmCBAHtmC3WpOBmn9+sAZTnO9CMBUV5d/MajgVFOUTLSotNjS1EHgws/k+d+A7OZUIDhFawkMk72IM6+/kGFrTMnA2Ukuky0IEFPvnANDEI143/D7j0WJJCRZNgQMSxN9/rDxswSLRR1TrF/A2Xok3MF/PuMFcw0Hrq8SU8iJGJ6T28MDtmw/kJG0ojfGjlU6EVEzld3xZzuZHQTfDs++7fK4LbOCwo89D2dYoQqeiQIrRLCopSkO4FbbDT7Os1LYzJ3EtajNKk2bFXz0mLV7AN6zdZQSH3SYEAiPc7uOY+v8fSo7ZFec9VTjjBCGuEbi9LjFFDo3tUmuxtGpGCU4Muy9b3DdjAQU2cazQeCNjakNJ3LT4jeMJo8RpF01sjrfeLMrk7Jf8kMAi+20UsrTLAwPMgDzh1gKj/oIB6GRPOtiuyVyrBHLF0Tk/IP02h8/MFBALUoPz6Yi4MyKQyrz/uhutZnNUujysQfXwoMRAxSB/KYb/MO63VLJsh/KvS4gL58+oRi6qDYxUAyAewSxu0djYObGWDS8gHJbwZ+qoUjUnajOPV85JQaxGX7xDMCb4DkM0QT5gQUC+bJy7t3RgcYBtQOYg4DwO1E+QhuRSKlo2lgnmZe8Lz5YlnSI8DzVFnDo8DPoOtpTPHxf+GIWOrI6Rs2WmSvMS2n5ogUJxZVz+Z34M8MOmZZEVM0pSdmxoXKDGbkzRbgZS8JkkhwYPN2jUv1MUxhVI5J+kWsclxOGzwKTGLEA5LmNVgwCgQdADmaCUinrGGseCsJeZMYMIYlxaAydeQhoeAAOmiAgxslwbzjEzmTnPqvMKfr8ekERNHzVWZZdFW5zzld9s9wdWoCi5pJ+Ka19T9riT6DNMiWOKrMISX0h6RAwnJHfga4Qzv3ofO/oUqZ7ZDpMfAj/rNobrhhPZnQP3H44KIakHd4Ty9rh0DLHg6CeUgf0YR1fBLKkmD2NBcwe+JyILk1/LQNeEwz7liOfliwNhdamIFgnlfmo+uIoctdwVesmJcmpzNpllHwqzTt8nT/hIQwgCh+cYHj3caCT8mUbwR7sww19nldTr6WXaFA4oqOVUalqCioH5PCS7NTSJL8mKtkHhKm2W9pxw+GwSroEgQKIE8ngFe5ECEArRHyuH+wziVxchTHq0bh9lWVYj3qLA+Y+NzaZudbn+nagpDfeHCBRseHrK6wry/+tprNqJAKVvkE4iGyTEGi6CDcf74BB8aXsfkO8Nn9U/H29oxPYVJyrtc5L20RJNJCVfejRTAvC42YEMK3nN2XudHyUTx1MKczUqjw04UsLxgtijGbJt8mCY1dpJAaF2UAbr6x/yD4Sf5t1VmdNrn3B4rUJkDM1NVd4jvkIQ+TpDU0QVXXPcWq3Flw9rpjuy+sejzQ4OB9hX9Q9PtqKOXPQa0ogWL2s+rLxCtSKmcL4aAcAu2PsOLKjBCr/jDL/3ZLAFh4TQAyh+XSWA3nwr6RXkYpZqimk1Jo4RU1WmDkBIuEnHk64YNJImBSUsbrgRgUlokfJmw80faT198HWHoXcXuCYwRgRXC9dAPCJayCAEWEsytnFmKvqmFjSroq6/p4j4RxhNEAMIuLhzMunNv+qvDEYr9ZX1PcrlxF4E7kJm1qaSIHR0iC2FXqhTsTGydbRg+IXy1M3yOgJX/gvt2DJKndCGKPPEjnKpiCG2IYZy2k9IW+JnXvRt+jPQpYo/DLTOSOjMuaJI4GwkmiXsFCO6cTLc2ylAzI7L2lObXEbGnG2qWGpTPkhgkxyThA6Z/4QSDhMaOhL8LZ6YQ2AFC0h1Q+y5oe4LxTOLfQXuijMDTu5VgFCFinZkalBUJZoNu9WpGz5Cog0vOtQrDwxgtaHx5b3hr0IFcTKJZZ+7To23mRFoMWQUNK0FZhHcNoUteut6lNSpVWo058LnIiJZShYSOMBPe/Z1uAUozGNrBVMQcQ4N0n7nOk1Y+/Vg1kRt/TBiyjMrD5je03tBH4mAyFzqTn5/c1/osLcqATF0rtQHhalq/MYVDm84YLy/bWZc/fFbabI1ikHsRja5HwBL8ZvxPPvu2DawbtOK4tK96fQk5zvllBPBw81aZnQ9TTIFospoT0uAG9fIefff+++2JJ5+yL37x9+zHP3pUYfZnbXp2WpEl77WbbrrRgUfQD9Z2VlnwgNk1xxQQ5hymzglYeKZ/09LNHFcbW7XHtHrQ2cufz2/mESGJtsiUfJMVdSR3w87rTTmhsO0npFXCXHyLzm66SuvnsJjMIxrL02KfWkmYW1x3gntuLHSb93hurmYTRyUU0sG9xREfbCPIF31HGOgHA+yuUYowEGHgIjAAs4NvCNtsQIy47V9EEcyM18bIHl+LP1GQcsqf0B8bAueJlBSAgLC/lE2iPYITWCGxgbLwU55Ia2zKg4m8ygdba6sw+ZCu4VCNv1BgA9/K0bpiS+UQTBIhhc81FFgAp1UIw1Bio3VmRKo3/ITWIXyqMiVxxwKKWPRkh2ccIaXTgqNbVKxQ9V0vHZOwZJMvTYb+AUd34qxrFb1vqhPU0w1/vQtdwhMhKCst0vDApJ2dHncVLEh63cQ8Sd+B8/hSzcoPTPwDZ+AS+jTwHWrUvJYPwg4NTU7aAPxsVj0XiUFT3WjiUiLk3TlLMs8ifDL1YBrFXCRIRUMER2ZM5mYphRg+LeL7sKTf4zo/achjPlYVY6azX1yFAA7MfCy2AfwwRTBfzKP5OgIAL711+ShzESnQoDAfAm2U87sSg4QmqW0MF2G4iOpdVpgtfNyIfKdGHHHlGALGogcTRlMQ2UkYJOXpNGnjeUMfeKCg572UeUsZJONs0tQXTuAlAdMgzXJFUQ+bGjv8vByONRxdE/3RH8PVT2L88CGLidJ3kUEpexHJ53YQOX+pdGJ+kUjvr54gF33nDyGOZqtjlpYmXBd4KEeAGxheNHvFzIzNSYNU0/lk6YSu9bwgJqnTb6lLVa5dfBJhgNG6u3FwgHkz6M7DW/188esk2Rg/BDt19gFWZIdDCSd0n/c2WGsZl7ffPmjP7n9W55DNuO7ddfc9Nj4+bt/+1rdsYuK8VTXOzIlhrf3j6bUKH671XVOWtdGvFnp3tWjQbni+zBGUR7CnNVffj4k+ARlBTjbrrdoo3yB5EkszKgGThHLi75R0lpPWzUmFTa8sCZbCvWz1jO20XK7b2YNiFnUo7JrNmjP67p67VS66ijDQiQH24ChFGIgw0AcGWMhhFAYVCQnHYDQmbP/84wqpHmGiByXNG9AGPKSNjIMpYY5I5MOhm+hkosJ8RDauLzLh7Bz4eHQWZRMvaoPB1CBsFtKZT6AoATckh5P3OpiHEwOOeOCE+5w2p6L8DehHTv1ZvsHQH38Gkt9+PEGHEQyM4JyYRcICvxsJOpU+L4fhImpXYYjrhsxYmnXvN8CYvpcJ/7hCdsYFD4E5Au94b3Rqj8IwABEaCMxHiKRXESGFRqY6I6lqSdGyhIyiDmYl2AIJ5ny1xCxLi6FqqNLpaln+SN7/jGkAzeZ82NQGRKVjxCTdTm8RnEOS2Z/OWP2ENEzSWnF4a0O4W5aoiKRvGH60VQFqkea6By5Dnx/qO/5MaK3oe5BcREONIXDC2JBgFmDIGFuuLya5svRbzJFj7tCASTPnAjw4uJfXRgvgk5DembTEJGIIO4Uc1MUYYvoKkX5xUPk2GZOSzNTw58F8NiAklyASWmFw8TniLCYCMPj3eilH2wUwQcATYKEsoQZO6Ssl8jM53Hldi7heKX/4mRtxMd1Bv92a0EX4Ei4TvqYcQWcQOOEwz5tPnUF9K3ZU+RBeFWW+ldG6lVFk07zewVpTWlxpcjCLwz8ITQ41+hVclz0Sq5oTHmg8aD9garwGvwUR83HdvitscMNYm0UApRCaTekwY4ICOM2k6gnP1UqlYo8/8bjdfNPNtnHjZsvq/d61c4f98JGH7aWXX9S99VYYGHAQMi4IULwIDNNpjZEEG84CTkhyfBDIckk+hsIFa/zlkII5nhPERfmsBbsj98Uq2TrEEiswekzZqkx8zx5C2DFv67aIMZQfb2uULgcsRDC+XzAQaZDeLyMRwfG+xgALLIwJvkBIMnstuI4J0iKOKZzfTtu7RVnOACFSXT+psx02DKIUdSb2Q9rGNwF5Yme5zvzu9+ImCiE3BzmiQmi98oIdojsgHFaqizz4CUCXQszwm7RYtYgQaSVkHhFokWBywA0EB+32l6gVjRzOx/2W6ahZ8CENd9oHPcIXI9CKOeZAcAawd5R8xz8JyjCoEPRVSbBBFEwTpiGe5OtWPdEMJb0XjvBjUCFnUkc0NMYerST+YMDNvQDXDLpnHCD2xaSI0A8Sh6fS9nRVnhCSiNN/x8i4DHIiVzvURx4IwKTM7tCKJDcr0EBewS5OaU6c0AiMi8AriHnT/A0c/wEgjDtHiEu7ExfBfikmdksMDwS/UkwoYN4AL3VTJxZrnrnxsNBv4HFEvSu1+ke4vOsB2qMQzrrVIAxpFkowIGY3rUiZMRzFujBSvOcITDhzqi58honhbvV2u8cMwcyOQCPS5bn6iEbIOkTdMF68R03NJ7RpYdM5H4LdM30B3mjDabs0NxgvBDy9kptTwnVKwTkIAAH8/PWDX8oSlIDDfpm7JNqr6h7Bl/HJUUXufrcPSsAUMvfRvqmkWzPpt9eK915/g/r8OCGwokWd5aVIdmdLRDdVHTEil+HrovdJOGBtwmzNi4oArb1+3wM/7tQfMEi+C/RjsY+6MXX0rKULOuBX5xWp2VCCzVKIdk5nFtqz2N+F0vM6qPnAKwdsID9gr77ymjRJ+y2Xy9i9995rk1MzdvDgEdu+fWeohMJXqyK0wpwa50KQ6ymMKOwkTXvImKtqUu9HZ7/aKgv9YNUI+szt4Dqo093QD+4Hz8j37qf22nkfxvTeXVCfp1kAOhL9w1QW5gimfu02aY4yMJDt9XQUi35GGOiJgeWUVs+s0YMIA+8TDGi9g9DlrJN+U7Dl9SZKV66JLQftD+xHP/LglRZltC4pUX0+qALbTvfERkWAhnAO7rGZt5Z8Ecn6wfZLHKvMvOSKjmBr5eheu78L0TMnUgFzj6AdcNS6Xqm0fwa5lRPjCNEMQRiU5SlEQV3ESEqaKBLMFFH5MOtCOg5RHs7vMnX5AKKUiB2I+0tLwpA4QOz0U4J1QJL/pJgM8ImZDAT2xUa86xcOtEXF3IxCDhetXFPoXxG0q/UZ4pc/Emb2jFNaUuVMLiuiNenw5vJIau3MwzQJ8DMCmzA2gU+baweCT3XMyukbzRHBIJyWRPcZO8w9MbtzSfncGUKqw4Wn1u+0Im/FMyp7XAzBBcmjhxmDFXqgR2g2FtDEdMtHf4BU7S9LApR5RACTIDG3m00vNYfYF2jYFbkEXjDhg0lxmlnd5R6pa/3uif/AR4q2yA6+gLlXokaadSG9RaThd0RBAiX0agf/RJ3QujSOvepe7T5rF+2zXqD9gOR3wVLEQCJoQVOMlq6dQaJprVSgBsZS5V0fhHMOJSaiZbcxJA+MDZpC/H54X9wZW3rgoVCGjhSMImVZGzmoGgYJYr0zVfX+onnzb15Qsj0Xdynp11nfKppofFToN+sf2m2Y5m59CNdGDlac0azg0fuhEdRaJQGAyiKgwX8SvBLyh7yYT8N0sEb7QADcZS6h0RKudc18pK/MhaqYrZp+uFz6mDp81oYUqCEjJinWhdmmJAfYwsz7A2Z95ddcfZWtW7fOjhw9YlNTU7ZmbMT+5ktfsit27LDTp0/Z+vXjElpg0s04K/iHBnab/Ioy+BJqgWjqmre/or7N6veEfml1dXCl9FvTu68E3jHJA+tx4UDVuUOQE7Jz4+6kvvFrYvaMCpd5p7bqNTP6avKiMmEmOC6YShoILQltqalZVqw1AABAAElEQVRxPHNQ5wiKB92wVb6rCvXojxxvy7b0gzHsqGLpWXQRYQAMRAxSNA8uSwwg1WSrWumAzHDHqjpYlpSWucXFJkwnkMjiNFpXebZSR4Q5RkSElTbU/hNEqYTwYhhmtF9j5uLqC1UAQYRJBGZ6KRHx4cSCzsLuE4eZKkqP4Aq2qLjNOA1QkGO1bzbEpsqvtFG0Pwt+BS3SgohX9YpoefOytw8Ie/+EEOJi3ORsC7GF6R4lndOyzA9L5NfvoFbKdE/4QUGQSIsk4u2ikhDGGOJ3ANFHYAMfhcvjEtgxIXSw9wXLRbXuMqcUDWtIvki1BmYjkvhDhEC99pEYbyKkxUQgFXN5R1wSkhrTIySmgVaMccDcC0KKs4+w3YcAZK4ija/rnXGaJc3bgKh3BK0YhWA0nXYGmFQ2RhswKtKSJAckhR8Ro3JOUtqK3iP9XuTfuvdAA+pJzvbHwII5G+9TMggdHsqix+556Jarx78jzJP2mUI/YmirwgV0zXg3FtcI12fywTi6d1ZtiLlwZmnKB/ULcxU866jK/XRzRIx1SiZaMFUw1K5RFW9PASZVp2AFMppEiHGxiZqC/vpe8wl5rnGAGQZ2EEZiTP2V/6n+SAIgxlJw8qdrfLgGZHZWkMksocyZP+FEeZgazGOdtkfMDEweQiEiybHOeQgYW59oHVaI4ACt794CAPJUZN6mY7CX5uBiVW1fnWZU9A588O4DN2cRsT4SsS3MGLZVsviDcglpbEYyTZuuqS+qS8EZHYMSF4NTXjzTiL7Q97qI8Iru48eJXwwMaEP9k7HrYr89zjWybt1IoI0SXOB0fN92H+2xB0cC3gImCZzNS2jBXCoWBxXqe9DWrV2rv3HbtGmjbRdz9Oz+5+yjH73Drr9unxUVCrymA5mrMnUlzDqh5cEK7zlzTOyT5cSwDGs+jwgvhxQIoiThzJxanBSTVNR6g12Dh2E5prhfVf63VK4GU6WxUlVubU/oN/OupHuT9Zgdn0vasDTj1+VjMnuLu8NwPVaW1/vu3fFvRE1Atc9c38K54/LRLCXs+k1ZW19QFEUBBIMEvsOJfoKFM+rrhNjeXqmzXK980f0PLgYiBumDO7Yf+J61kwQrdFcrYrlelKO8wqWOHFWI8LLoCpZJv1CyyayUIOrwWxGJqWhIkv5pgXamOBBcbEpiYiCw+02UgQEqiqGAwWGDDPrCZpxQ/VlJSJ2UuKPSAFK2CjQwMEf0wiV9lUXUlJJVdxZEPws8MnM0KTURCR4jvio+wQusCNJkWsC0xJnFKWNgksLGHJTzfQh+UYOHjLL0F4IjgAn0wyQtCAeccwLRQ59WSh5vGBt5pnKlvEvPXJXSvhDFCc2JCD40LOGWILKBJSZYSgTBECztvViq7ZIvcHLPped0Bs2c5qLaUTS7bLoieGQeI+adDZtDjoN5udRQAKgQnUuJQNf8QNPlwkZDYMHAKA+alZy0YjmZxpEH2nlWwUAg2tCOEB6bPjmGQv0ngfFwP3nWNgZQIe7PCyISORGBFJ1RKTFICMghQpywgApXSfMCar4h00rV2dWUzdUF46gLkuCBqEcSj4YEJgWAYcAXc/h8HZ++j8qo/zBBaNhUgWag77evWrNJUnxmAviBeeqWaAd8ovlEq+AYvMWMaGa8f5W/4TUSHOss7bYaR8PAdWCS1a3+bvcQoWQ0T2FOnGmh6gI6BA1lEdQQ1uraqsn1z42p+kcf5LNGtLO0rjXTlpXnDu+YY4T0AyzPq036UBEKeeedgEEjwaSDWUH7yvqgXroagWsl2KifuZtM1C3XxdSOsg4yvRf+QjeWJX9u20yz7NYUzO6YG4w7aXnP/L0MmiNpbxtiIjinjOwcm1BXdDTmJv98+/TNa3pq0vSzvsMkkr+zboQ2aQlc0N6XpDlraB4R0GFlLKBV1xo2nLFzCyV74qmf2J0f+aiNr19nOZnYXXnlbteXfL5gmzZudu2yR7zwwn478NZbltq80ybOCvcb5CeodyMMk7sW7Bxqm9V4aaeTxmfeZnVQbkqLbkEZRrQWDmkOsPaHy4I75hkMJzMMZpaeVBQYAWnIqUrMDk9nbWIuY5WGzM0VyCW/adZmJUDZqff0nZ63RPvtENF6kDRz9L5VtOCcBZ6OxDJVnUzY1WNpWz8kqwvhAO3XgOtBuJ5WwQHms/5glMLrHr9YGYY1N6L04cZAxCB9uMf/su095jBL0u4VeoGUFcnwQHrazi+MyrxB9uHaNoI0L/MciNeVnOYhqOMNT0A5swnVN+82YzZUtDheCnUxTBIbKJt6Ma7Yym20GSSET52bF3dpD5ZoTpoXzFj4vZRUkE1tqjHrQjezqbPhhHIsZW1diDnQdoBstDMnUtFZMQyBRsjXo1y6gADknzdJ8UQVAQUgmgL4gzbYcCCy/PF9wV2/FRKqF8YFEguHdsx7qAOWDNM8ouDRFgQYzCSS7RaGWnWtdIWklVrQHMVdmOsuuTWewMJcgUmi75396FLqom6l0SLpXKRTkxvsxORmWzd4WhqhSZlJpZzpHb5KbeMZ1K75iQ8RzEJZ/SdoQ1yD0ID4F+ECoITqLkpzBIMNET8nRgRiOpnGzKt9FkBoOG2e/NWYL5g94YeBFoW6XVIdzO6U3jMOFoWhnRdRuyApfGNScvUxSdilAcLYs7KIK0p4HQMS3hbTv9QNLqiICdQlOeYDRziSxmPJD0pETFZ9J3H4aPfS7vHSB3mcaZmIt5iIS3etsQ0S4ww+3SsS3OzxDSkJs+JKq5xjjPTDrT9uHfBMGwIL5g14AIvVJbz0qLjLbZgTzMcQkHiCXz1RG2h5a9IcoMlo9aJLBaFblHemjsI38wLfNcYYCBmfbgnC0DF2zgSYtmiN/PSnobmCmZlsmHTfy+aZJR6ifuGiPg619iZ87WsU7zlCHtY28Ngr0RbrCmsv5wsFpnH4FLl/i+PSVoN+DKQwS6RWntAHteLmY1tO1yPax6SxoT7j85fXKgKjGU5BKViobHLBjjx/yAbWj1hxC4Ea2vNSzvdJ75WgLBQGbM0nb7VjT75uf/G3f2PrR0ftphtusJ27rrS8GCXm2dT0pL322uv2/IvP2WR1zjbeutuyo+N2ZmLBXj1etWvWSziX9Yx7GC7elrxamxKADSGLfla1jojHselYzbaJOR2WRqlzzBBkcZB4Q2qpsXTRhjIDbu5XpLmKxS9o3WnaeHbOLlSTEsAk7MiMLAeGm3ZYde5SnWjmLj1pnmq9zxeHnYa3Up5y2lqGMpUZsnQqp7FTJD+ieUrTF05JjZGUWYLXr4d0TN1dMTktpcYTbXaACOZ5TjjYqN1gRDZ8y0dwxSqjhx8wDEQM0gdsQD8U3dHil09L86DNa6WEGQ2aHwgtWeHYUPGCfmOIwDalSpT4bkosnuEg0mCV7FJpQs6ebCdod5ztuwg9NnMvzWaj9gu2C1ig8r52KgraYYvy7bHocrdFWuhHXwnJqaSBjoCHUVieaGMGk5H5CzaaKTqiH6KHf0Hym/TiL1XCwYn490C0BNBCGMxSj/rY2Q6/g940FJihKlxwr4XVoCX/TV4McHye0LPFijlLBhmwGxndQ4PDBl9RK9PNOUewOUJFm/PFJKqHMByQJDAl6TlEMfgBE84sxzEBrRoZD5hWGLZ+g2i0Sq9+BSMOk5SUeRAHxyaWJKE6s6OaE/MkZlFMUpsWSZ1g7IbSA7Yrt95SYoJmRCi9XT7pomKNiojZPbhZoYwHxBCV7XD1jE035nQorYQAaEYgAFAnQQSqff5xcvx1ua02Fh9wkQbfqKsunT0CchhJpylUXjQrSMdhkuZEIDmfiZxG84L+SoIrK0JPAgYZCTmcbsqssasGNmse1ey1ueN2ojbpxhzMUK9jSvQuytbPtdWGMQeiSG7USxD2MhXk/BhKosFJauwgznnfnHncItOD8KJbQjLMaDclRnYaQ0cEd8u58j3mkP/j0yfqi6n+VuK9RNPCTFdHllL7r6XbK1xA4AM7jVKaVp1mSgyvD9jRrTBttuDrzAGB6bTeIrgZW6KvoSHpVoI2PQwEAaE/nckzS8EAMq6XkmAkiaRHG07/pIb4xicx+NdfvQHzhi+Qh4Z3njlDUAeERJo6Sv7dT+l6XtHN6H0A+fI+tlomD4xgN0y0cvmxInLeyIZxWxhE2xTU7nPRJ97jrIQSxVjenWXnRD8jCRv97JhVp+fs1JtH7B+eesySP3zEtmzcZHVFtjt+5rQb2rVb1tvePVdbdsOIQlcrwmhe5wWdkCDnRE1MUt6Gcl7bQV98f9CCqI/tYLg+Yz53BhPCpvyxlrDgyyF42cFKnB2WKe2CPfPjp+3C+Um7dt9e27djqx2Ka32R5o7dj0MHqtr2CpqvQ1pjnC5rEZkwGlTd2nf0QHUvJY2PSxp/LQyL11pv8sP2kyf326gOx921Y7sYJjHpqn9aoc//7mvfts/c+1kFr1CQHzHRS6NIO7V57WGsr4sdDjW11GboghZPah0+hyhD+HBJyFojS4JNC2J2WTMXMekfRp8fRgxEDNKHcdQ/AH0eSRXtVO1CW09Y0tr2A7fIieCWpB2iZjCrc35qRREJLaIKInWuVljVNwnGiMM0WX+rqpdgBGHTGbZpmCQ2Qn+gKhu/CDQ2fBEDkPbkJx+SU8JxI/UE3lXW8sU+QoQ1nVmdDyawUkkxbCI+KhUdUqh/ELiYB2VE7CKdZiNvT5hjyNREmwWbDownvkFA24bP9kLul39OzpUS2iDV3EJ7e+bFRpDkBlmoj2h3lUbZEfH9YilcMSQQh+oSrc7PDfqJP4WPbEQY8nZzJRg576+zWr/D7fR9LSAa2oAbQkRGjBDMEggGe6JdNU+C3rdqhKYgoMWaZNGy55r2iqJdXX3TtbZ5YK1VpSHanZOs83jZXnnrgN1w5012VuN7pj6l+uXELvMb+uNGVcQjIY+hRfI6fHd+qmwPPfSobb9up43vWWelstdIMv4wiJo1rizkoTsMVXdy0iTNF8W4ivdqTorwHIVxESEqIAnSMV5XBK7HntU4J2z77bvtbG3GMd70EG0KxLAzlZPmyWm+Wt1U3/VmOHNBjZpeMjRiab0n+FChUeQFqkl7UpfAwwWjEF4oAyEK4xUkxtmfA6Y5L9jQOHkfvSDHxX9D5NECdZM6iV/6hWGdk0T7LJf8SUthuTVtEkClouAa4AwilLcyeFO4RoQR5xlmaV0Tml7fB7QhK4uCIGoxD3ShINyaQJVA9W4masPUDhEMmKWf76QFX9bX40LRa84Q1IH7MEpo94MziDIBQe5a9h/B2OrXJSfo7DU7N0i7z1jRL5+ACvPiDclhwYEePRCQMLP0jmr+5kYG7Irb9trWG3bb5IlzNnHyrCWLWdu+bqdCVW+20ULR6mKiLpycsqYOoh1X/t0yDXz7WN32Hynb9k06M6iYtCHVh8acRKjshODgbLNw4ql0MzaRaNo6RfVjNwhyYJpWSA1YaaZu//7f/XvLDmRtaHjIvn/fd+zXfvs37daP3yEN0ojOYCN4uFYHcUgwE7yvDUXIpJ5MRv61dfY5mTCm5GumtWNBwraaBDgJRc/En1KOg8qp8gSNUV0sTPNoqWRGPDM9Le3asOZ907765b+zL/zKr1hFar+nnvqpfepTn7Sd8tFCk35sbsIdnh5XQyWte2W9Jymic7qau3/wjPl9XqaWp/TW8i4EifUE/HnmKLgbfX+YMRAxSB/m0b9M+84iV9AZCYTLhimBzciJeSEhHcUunkToW5zV/bk3stfWYXEECEVCjzSfBKmxIJOCWkMMBNL7HssrJhGcITMnQsRLVlsLq6tIHzA/nHdRRiq1uPCSi/u0BNz8bqAB0tKcco7A2jC0gfdKbK6S9zoiryRbiXJdx7sqUIQjrnsVWrwPsUtZIr+VRC5oP3XMwcb0qDa3UJsCDLMKTHCAkw12VlLCdzPNyLN/QP4PmKnQpwAX4Ta4F0g8wRYSUAi1igvBHc7Z3zWM0YBMGCGwqQdfAhdZTMVhNp1/TqgqNkjvpL1caxbKdsmXELW1upgMIk5pnp6fG5EyRdLQOhH1NGfbCBnNVZmHLYhZiDnHH7NDb7xp/9f//if2W7/32/aJ3/tlmcMJpwqY8Nd/8SV76cUD9u/27rGdmzbZlYWNCo2tcip/tj5jJysTdsXguA2m8s4fJ53K2IWpM3b0xHHbsG2j7RWTNZ4aln+djmeUFJZxIrT2QlJO2SJaCPvutCYaDwJCNHXmbUVmLsUCWjmd6iRCF01TuqZDaEcmRZDNO4bu7uFrRKTBaMmsRyqnl2cUoUuaKiT8/LUlDb5jdqQ8ycuXKq/3mfnLf296KaJSBBN/3CMRhQ54kqiHg4mj+2hM+VlWXpj9sCDDFezzw2mzELKkmK/Mzu4JgQUamXeaINxYoUJdUVfR+GBuxnxN2kRljZV06CkEJS36P2nZ9HKPZM86U+JOOKjPm4Yh9/d9od5eiSesSQNCaw1zK42vF51QypdbCR+96l1+vwVDb+x2L7Vafp4H0LJ+oHUkiIw/bsCXdnk0dkGflrfUuoPpo7DYutFxBT5gyI6++KalRnT+3fiwNiCvtaLs3twW2yoNK6vuidqUE7BtlPYXYRoWAcdqE16DL83pyNZx27Jzmw1ifn12xoaHhq00O2ujnK905pSdrUpoIFOyohiobdvNXjhWsSeOzdqajQm7brBoY27lZNpKE98bZDstePOaHCMa46Wk/OnsgD3+7JM2ceGC/S//3f9sa9assQceecheOfCK3fPRj9mpk6ftG9/9rqv7C5/7vM5KG7YHf/ADu+euOyUASdr37/+B3XbnnS6K4n33f9Umzk/Yx+6+w2666TYXyvzEyWP22lsHVT5u99x9l3yrnrNjJ07ZvZ/5rO299lr1q6D1ZsG+/vWv25e+/HWbKc3ZZz71abeLPvLwQ3bk+Em74cYb7Oa7b7fjeu/e0rp49NBZMWkbVW7TUlfCF6CBXbis/lakOTquBY7dPpz4JaWZu7sC2sJFousPOAYS/0bpA97HqHsfQAzEKtowtInPafMra+krot3RHlZBUxFa+JxZjzYdL20WYSYCMEyAsOc162KQ5rOSkOPS2n1pxMgCIojvlZJfctsXXjZPXythppM2Km3AgCRdJZkiEb4WyTDn2wS5fP1eYzQraeREVRF3SkPSdOUsl6k4M6zuUHaHrNW++qo+YELDgbZhPLH5Y9qDczjaJrkbO2ahHabu9fdzF7l1VRI+HMWxc4dBBEueKFyEUAMDdmFSIC0grL3pYjs++2kP/HBm1Y6UqHn9gFmi357IESHPv0VG2tUnvKD/4ywnZtDF4LcfeMhDrQ0RuaVqXlpNMUYK+U1Uu3mYUzk8DykUuItuJ6zMS1My8epxO/vMQbezb1yjWFHnKvb040+5s2lu0YGS6wtr7cyhE/bdb3/HBoeH7Z577rG05sp9X/6WPfiN++zUW8fthu3X2I7Cejvy0hv2d//PX9qzP/6pNKGK8jS8xl555RXbvHWTzkiJ2aPf/p5tX7NJoXvzdv9Xv2nf+9rf2/SJ83bjrmts9sSEfe8r37b9jz1tjz/wQxvLFGzH2g323a9/2x7+1nftuZ/81N587oCNKhLX9KRk09IEbV2/2V56ar/9rdp847mXbOPIuG1bv8XONqYc3jvnFcwRPhf4zKT1x3sCYxSMkWOeeHGZChqrpeTKqTaeKUHGwnxx9hBl2+e4y+JMDl14bzE/tNktsV64MODyicIUKqX1pZOpCxjqMnNG7/A7TTAxMPLMU/9GiKFRvRWZ1xHtkjVqtj6kawWMSFQUkGNOzOSs1g7l0dow1xBhKUabZ+H563HLnPcR6ljDeE5/wvnC8HPfnw+ExpU/jiWVZlFl8N24lN76segc+XCrq197uNBw6kpj7gRcqxSjjFhr9wduXa9dWUojUPPsX69qaMWdwYQgi8o6ErdYz/CHOn/4tMzEJLxTmG8hWE+kXdHcuTq72X7wtfttvqwAOmvlo5QbsFOvHbbHHnzUvSvZgtYCwQF8HDS+Nb1GZ49N2qDMpAsK1vDX/99fq+24rV+3xvn+lQXKBbFkNZl+r5E2iWh7s7OYXzcU0lwmYsoreYXCcusdci9NO9AeMq2vgptVEW0T98gakyApncnZgw8+7IQoQ2NDtvfGfXbbLbdaSSHI/8Mf/0fbfdVuMZ1m//D9B+xW3f/Wd75jUxMT9syz++31Nw/ZHbfdZv/xT/5PBUTKyKdqu33pb75i+/bdYA8//EN76OHH7Kabb7Lnn3vevvb1b9q111wrIWbN7vvu9+3OO+60v1BfESYVRwr2ysuv2o1qe9v2rfadv7/PxsZGbduWbfZ3f/sVu/na66w+UbLD+1+3bcNr7YjWs6t3brK8jkIIJ97wOQmfDipQxUkxRue1tyFy6BxLVhXJlBzDGKwK6dzw0toSrjO6/nBgIJgHH47eRr38QGCAhXxcROUuK9pa2XNjX49VwaykyWiQmvg4dCR3ZpLbAToeaFVMpeUUXM1KQhuSpC3PpiVV/yDOWEkvIlGOTZmADJuyYzaWECEj+Ak7DeGO5qaTVKEJ/iYrGTs5uUml50WATrhIZ2zrl54U1Ug+KrPaXNkhlsgV4cYRmcIlJMSYmDgXtevSG+ooKQmrCMlT1Uk73jhvRyrn7Fj1vB2rn7MzIpqnFuQ3I7PAMqyZCFsk/2VJViFrLiXRL8xqphYURlybI30LsAYxi9Q/+E39jJGPpte/E/zFwoUJVCFbsjGNY8xFTvI1oDgiGtaG9IiNpgY1N8Sonbhgw2837Be33Gb5t+Zs6vg5S2SSNr5urTShKXvlmRctJ4/rt199zYaGhnRffgxzFXv5+efFeFXtV/+LX7NyqWQPfPN+u3D0jN33je/YVdde4wiT793/fTvw8gFnjnLk0CH7yt/8nea+WTFftAcefNBOnzlvn/vCF2xCBM93v32/nZTE9snHf2pX7pGGSn/33/ddFzL85jvusNs/8XH5RGTs4NuHnanMi9Jkvf3aW3b49bfsgfsfsLs/+0nbtmuH3ffVb8s5ribN0pDDdlfc8X7qD1+4aZnk8B1OjGFwRhP33W8xUwSdCBJjCmPEHGJMwwlfrHmtDU6jrLUi8GUK52m7hoEQPGWZAc3KPKgmxp0EmJhQlTS3MEVFw/JuJdaBpXfStYMpr+aqFrh0vGrj+ZO2ZfBNMcdHbEzXI5lztiZ/3DYNHxQxPSFmSn5l9UG9Ny2cMLvRqqNJcb6FIuTxI8G/DzPT3hpx3yu0WqwJMEkIVooi4GGy8ddrx/ByLATPWaMJPME8x6yMxPjw3H8HOd2jrh/kg1EpCobB5IANK1x5Vu94GF/dCvpWmBcyHdaaAjvk1wCPj/aVoFsNjDmjvjxxF+aLs42ITLf+pu1W0DlInjmibz5SHkFW3njldTulM42UXQFjEnZ+4ry9+errVrswbWskKNklDdPu3AbbHhu21GzNvvHlr4qZeNgqeo/nCdCh97s6V1cIbwkosuMydVtjO/MbbLgcsy068+euXVtkBVGwQ+dnbVLz+4yAq4SnwXLwpVExBVjQ+yasBD1saK5v2rzF/sf/6V+7A6X/+H/7Y/tf//W/tamz5+2pp5+26ekZrRVDtmXTBnv9tTfcuU3/5B/9nj34yGP2w8d+ZL/9W79hA0MFrSkKGDQ1aWvXrLV/8S//uTvnibDzt330VvvUJz5hX/j852y3AlJ8Wpqj31KZmkyGK/K7Yo/lgOKPilnaIvPCu6WN4gDd0dEx+1WtS1/41c/b+MYN0oJP2cTpCRtfu8Zuun6vBEwK9iPBUliAQp+qYlSPylpjSgst2m1oBf46k8urEWvw0kcpwoAwgMY3ShEGLjsMwKewjOGMC4FZ1obgTOu0ADcxw1kkpvrpWCqObFVaJJk6ZVfQIrm61FZDEl3a58BNCfx6SqF925y/k9WZEQUFC+AMHB+mGqIEaWFBpkn0Q9W1JTZkiIFBnXqXTByX+QAMjXJ1ZmwrtfoPiqOhOSEGJS//nKFUwZm9dW4J+CkhOfYHs3Y+Xb2dbjlouyQmCPMtkjtgUUOF+R/3AiIk6CJS6pVa9oRPUMpVufSBlHxa/ksQ0WzUBGnA3AtCj2dhiT/1eG0FREKPFgUU9Th/HG24Yb+XpUb7uEBDNJiT7FcapKnZEcEX9FZ+N2KW8wmZ3Yh4OtKYFIOXkHR40HJHZd9fFoTzMj0byNv2HdslfX3Otmzbaq+/8obddNvNdvjtQ5LWpux6mZ7MVav25BOP64DJ0yIY5uXMfdz1655f+ozOaEnaDTfdaHOTs/boo4/aIz94yPbdcqP9xu/8lp09cdqefOppSWDz9oYInwvSBk2JeNu8WWZ7e3baXZ+42w4dOmJvvf6GAmg0HRz4C0yKofov/6vftLWja5y5HYTOq6+9ZiePHLdzJ0/ZmTNnBctZO3PypKV2ikHqffSIwyAYQbLfba6D97jzYVAu4a5ruPCOcYDgYk1Y0NoQFnC4+SOmKez6xei7PzFdKAAWpJamDAw7gTvwi2IO+aAhmkcq7xYDbJko+A4Sc6+TNmOdCPxZmDvtfkae6adZmKfR3Fkxhgqd7/5EGYsYdEmVhuulFE9YLwl8kRTxSOAOfPNWSv59o5uEIde6q7UPrQnarXDngxkNbc4aF/hbcu3HVr5kepcQUvDPo00aLtXTi1mhHHjHl4dvDwUleyPdlVHHU3qvyOXbhPn20fl4DhvdEp3oRo9E38EafQ8SdcIaE3XPaTo1H+fOTFkqp9VTvjusPSQi3AUaLxAwksgpUEPR3U3JPPT4iZP2nX+4z37xV75gY2vH7M//01/Y7My07d+/3wrPv+CYhJqEHv/wve9pL5C/jczt/tE/+ce274abnODjqcefsMnpWbv99tvs47/0i/bcwWn70Q9+JEFL0zbdsMPGdm91ZzM5YDo+XB/0MaPJPqhJAcjpbF4wHVcgiJT94R/8C5m4le3P/vOf2Zd0cG1RmuqK3m8nYBHsn/7kJ2xYPkqjo1rL1LeE3o+16kNaWrPf/4Pftx89+mP72je+7fbMP/qjP3I4cX6IsqCY118up1VZgWdqYmx4z9z7yWgxN5DaKLHX8humEvj4TR0cJr1r1xV23/3ftf3Pv2ijQ9K2FfOuDB/KqhEzO64Fh1DnKqm/lRNLU01at6wi2K2ee+W6oqeXPwYiBunyH8MPaQ/8YsqZHjhvE66YFa2xqD3i/BOIJ4iO1VJcKzvnckwrWANnJK20MjqTPRGZTUn0mjIZwzSuaxIsLOajiUEbkbRziTjQ6o4MFe0GYatXXoTxB5FULAZMK+fsCsMKN5F6co4I4cILybytk2R/CVeC20W70qb0bqfwaISv6R3EUfhecB303BNc8nURocXIMubQp/SFP7+5BhDLX0vMWJIIhSKQcHLXVHH+NJC4hO3FeR9NAxs75XsRZ+De+d5IO+kObIVyfgcJfyMChsyWkbJCvKFhXPzTpBlMF2zbxs321tsv2N98/+8tuXnEbts6Zs1XJy0jgmLHnivtFUmeH/zeAwp/m5Zm6GrZ4b9tc7NV++lTz9pLL79sH/vkxwyznZnzMmmDIBRhBSGCX94aETBnxXBB8qWVZ0oRog4fPCzzR2lR5Vs0sKFoueKAY6S2yKepOqsId/RZ9icJ3ikhEvOrM8dP2fdlFnP9LTfYDbffLibolGqUrlN4qougS8nUKJ2X1lQM1t7r9tqGDRvtYHPqHWDOF3Xv4OIYLI25pirt0if6SjhrEq+N813SeqBHbQkiC+0TxCu+igRiwYSMOqua+8wNkiN01X1qx8fQk148UYVuKuiDhnjh30GCaS+p/pyqIdQ2ZqkETlkQzuP0TaaQrp0V2oDZMf0Fb5IDiY+usPlcMGANMV8cgoumpzNxz78j7QjkvcJEEU0vDCS4B3+8nXzTB/7BOy7Bo8rRUWe1buKN6HDo7klQsniuG/V0JqDKclCv6u7sS2dufrv8agOtFYIm7pUwxkaLuNgu95glneV1a1nCFHpB5tk6RUr94VgCTPOk8dAe4NYe1cI8mXj9pBU3jykiJefi+RV1TppGmD81bvf9/f321JNPy4QtbceOHLOCTO026x17+BGZsx05bGdOHbdZaWh+TRrgbDZnV2y7wvZedbU9+sgP7XqZlP3CL3zW/vZrX7U333zbGrWGBCUv2m//zu+6YAp//v/+Z9u773prnD9ld998iw1ks/b4q8/ZwKY1NiBBy0pzpyQJ1bwzotRrrgixL+z/kf3goQftD//wD2zL5its/fhae+ONt+x6hSF/Xlrq3/yNL8jcb629/Mqr0mAP21e++jVbu27cStNT9sADD9lnpRX68l992X7hVz5nn773M/av/uV/b0cPv6V1VO3oXQXn7DHOp1DX/HaCTfetEVrce0pzcwrMUtE5dTr4VetYkLiGMd8gc8WPfuxue/rtGbvjyiEbyBAUgtF3K4Edl+DgPCPOBF4lUYqxhKGKycKjqHkTpQ83BqIZ8OEe/8u29xAxqNNTkiLBHkGfuFWWHmmjYnlEYsxhiasl1O35VMnOz4zbfOG8lteVF1M2QkKHuyVY190SdWIKMqZoe2iNyOsS2fUwJ+KC3dn5vGgzgIDorIk7EASYpWCexkaPH5SX/3Zr9eLvsSFgIgR04fYhzgi33X734utfqYTHiDc/dISpMgeHtAIL/Xf/hGNwSFSyjNPCUatDJFufg51PoleVRWAi3fdPJQ1U35Bm8psNVfJy4VSEE5/S0LhIdpIAU55/tNeWBKTTEuh+SmMeNudqy3cRP9AapRKKuKQoUk2dgcRcQTPAfUypgKMgqezue2+1o+WzCrYgMhMpq/qCFmtcoYTXjY/LhO179t/84T+3fGHAERoNSXbPnDolYilvwyMjdloaIcK3o9mpKkrdS08/J4fvoj0mH4DrRGytlWnKrXd/RIzVnH1VxMwXv/i7tvvKK10Y8VvuvMXOHpcGSkQYDBGEjUvCB4qJ2YkpOWY/KAZswm74zV+Vdui4LVTqzjwwLViv2L7Nco/L/2DndhtUBK4jhw9bMptxGklmlWdfLgJpoay8+xx8Cy6EqiViaikLFJg0szBzEFrkJV84MY6sDUR4zItZJow4/4hOSeS74HDkcJnWdasyp0nkZ8e0aeXt/4pxZ47Oah47gYr66QQ/qhumT3Q5VKWfj0gGuiYPyBI4rE9LP7oWcKhxETYdEdnKDGMEk4MGiOZ4VwKmkZqAADjzMrdLC2bP6C/6Kbnnvq5ukNJX/7T1yZlnaHmcfwgNLCbKA4c7p0xzMUjch9GCscT80a8F+Fh6TRPvuA9O4UvwPDwR8LmkfFVrBtqslRLwsrY0NflZq7wZJ/W1ymHCuXavtDVZkVWhfYG5RH742+vlT3OL/HM45+jZZ56xV1864N7tnTt2umADMzMl275zh4QKG6X1Fm71bi8wV/W3Qf6CwwqYMLpmVNXH5Ovzth16+6D9xZ/9pbQ9GTt69IRMXxXAR5rkIwffhOMQPkXsKy9YBtpeqaSn2CjIc8qqpRm75+N32dFjh+yP//hPdA4UVTXsH2t9uE5aqxPHjtr/IT8k5seeq/famrG19rwCLXzx937H4eavZLJ7t5iWbdu22X/6v/9UNcZs45ZNtmPHHnvrrSOWRrum9w1foTGtQXHeQ5m3b9i4zgmg1q1fa4NF+ekOFMScbbT/n733DrfsLA9739PPPr2fmTOa0RSNOgIsUYRoEk2WRAfH2IQg23FIcp/cxHHyx33uc5/E8S1Oct2Sm9gJsenYOAEbMMEU0YRBIDoIUB1Nnzm97NPL/f2+tdc5+9Q5Mxp40Mz5Zs7ea6/1ra+8X3v7+673vC/e8ku/xPPdicljf3p392Kb1RATRDB+cqImrt7bFn3dTagUsoYh9uZhjE3gzr2f8cnGfbOer74vnJQ2PULYjw724utT61fn2fl1+UBgh0C6fMb60uopyEMVLkFbQG7kfKYjoHQCJG4R19nRe+5u69q0tnYW25CzvLPVMVJWFoVnx07ZvdKl9cpd7a7FnoR/Hq6rkhkSkYThMwe/KMEsbUgqJmsOao7GJPWo4VCQEzsGMr9cHMVacmozzy8sQXzwqvWsJA26MySx/O7K86d+JUy0cWoBuSqg6mc/pjnMp+lfijWVIJfV7oFoL3NubwbN7NMxKOUCMSIPiISIirD0iYRlLY4RVB/SQYUEYU0JEaxOXMK6mAGRXgSJnkOyY6DavMS8l9avK9mLlWxvJV7HjHmkcX1KqU1lNUgsMeDGPEk4IYPU1tYeVx0+FG0tbXHrS26DaJmLZ8HRnZqeBPk4ED27euLW226Ld7373fHu//quaO9sjyv2XxF7IVZeescd8eE//x9wrOvjedgO3XDN9XGm/ywGz3ujs2s39kqTcezE8bgHl7rvff/74vd/+99HHwjLnT9/V9TgPvjK/VcmYqsRhO0Aai1yfrVRmpqeiff/6fuiHYLsxS98UeynHVUQdNdfd2PcdtvReM8fvRv3ww3xnOfC0cblb/MSngwrUKoEoV0L57LeL186lv5LDhKygU7jKwc5IyXJmk2F5Xe8IUIHZZnlYdzLUxpPkM862tmYiCMIQPJo85QClK7JX/5ufm2W5SVXalf+7Kl+21/nr61eVzTzQMmXD3UikbaLrdprAesKWd9C0UjXnSqEufqvjJlMoRCpIGpHVagdZbKp1QUqMcq8w60MxWqIr69v7R3zqzw3a/2sQWGQJ2uT0M9U6/K72bf7a/JOx36qqpuSQJkoahbkJFj+huVbrkSn/SyQTxVtugXhdy5pvqVkqpZrl2pevt81TdhEScwuT47sqTB1HPZhU7PnugN4gGyKoZGBePyRR1Obbr71ufHuP31XnEEl9Xnv+PWoZc3ILFLiW409jl4k3aiFSv5XhxRq/4H9cec9d0Ew7EqODnogHI6Pn41vPPjNOHl0Irqx/1MitCxpzZqz7lO4LNIxVYjnsFGt4ey6995fjRHspPQi1wlR1gwRtsge/Xff9pYYOPtK1OKwudq1O83H3/yN3yTOoGEEquKf/pP/hTXfHHe94bVxC97r5tkj2iGE6lA9fMVr7kwqreM4TDh4w7VxzaED2NXSI+K4/Yvf+OcwdtriV+99O0QjDDEIp3/6v/7jGEEduBuG0D/6h/8AWyQkc6yNX7/33iQhe/gEDE3W7eHuQgzCcDoLcZTOrmW+KEDnfz6fuOSnn6vTyvPsqafHWYLfXrc6286vywwCOwTSZTbgl0p35aglzr7YI5t6SstfXKzfAzftugepdkg1hTLiY9Pc23uga2T/5RvvurdK7TNIq8omRiCfgaM5gZrJ6sNMZwPGLqpEJY7QqSBDK12jdLnjHAYbbfrr6tzghmXJEfX95bZSpNIKkaYLLTevyjI90LM2Z7XoQrgFA+tWdPFVmrHmKY41x1G4mXxnbdroXnkeISOi1gTBNYb0ULxR6YDIkK1QlSojBG0ND/mqAP4FoKuUSVuxMwsjCdHK2stzEJ2E7JDdMtYiPuX1b/fafqjWWQOBlPfUwLFymumBLaPtGeQlDJTwFSH0Dly9N1596M0QdBG7r90fv3DN2+H6ohpF9I7XvP0XIKgCRGZv/Mvf/t9BMlH/hLiSMz5CvKVn3PGcePZtt6Q+14KoqCr2gnvuIAYLBuaU8cpffK2V4k2vJu79jXfE3ORMslcCZaaxS3H7gV0xsjgV9d3N8ao3vwbirjre/s/+Iep7SpYyz4gNqAQZ82sSwu109VTc/sa74pV335mkD5UEdzwNbEVze2vaccwxnNqw1fySOMocroi8ZUinMZISYUBbddjgPmA+VWqTtIjWlACYpF56xVPaq71Cip/EeIpsJuIIKZPzRRgZQ0WENJutFnKuRJ0MVJpP+WQ51yvn+XzLYp27IuJsf1n8KGfNmlQq4Fxz1jFoROW3tQpVYHqkpMN7FJ22Vks2jtXoEqq+dFr11DSRyqrboPb0NBvfc0PVphqVRic7a1N6mwrc5ktdWpXFe/USRdgZ2mZzrW2PeVRrVkqlzoFOcnJ1QvcHGSPueKYFn7n3bUAJbVR/eokPpSKnv/V4NO+GmOjDJbdz1fvMuSQRLEkmZQSxqpMEdB7JrFoBB686lCRJEk67ITpqcHzCi6i6fTuuOXgwjbH7mZNbRweqRT4XT5bf++5345tf/1rsQk2v//SZuPvOV0X7rta47vabo2dgKoaOo7Y5jmowxbFUNk24DUKqXuodFc3PjMEwGo9iC2Pd1hRVrK/pKeIOMv6uufYWQgHQvsU5wmbwXiPlz0yPpfY1ES+tyPsnKjjLWqm0rRAnFsdiGgcTWSgJCE1i9FWz5+5HrTeLn2QZNTihGMQGkzUN1To9OcbZVBtdbajXUV49Kr5zM6jo0j4dhizOTsBgGo+OxoBYwjsobZuGSKqCSGtkTJ0HBlcWbO2EOLBu7VKL/K2dHzLpVJ2cQRXbmbDVOG8KxJ0HlxwEdgikS25IL48OzWGI7kZZUSuBoT2K2/RTTGt3zadQ3ARejZpwrNAE8i3atWmi0fnTWiJ4N4KwFnk3v+e3m7x8sVWxVngg4mAQ3BoQvaeSRAxxGCuZkGA6jLb+4Pw48LxwiNo2kWGJFRER1VisR+9XbSBiiTAq9V1iQLU37ScSp/UCO5O11vkQKYaIsFNCl8PSA1CO+Cp0rdQGOdH1QKATJwkjxOpR/U550wTIjNKKXKVLG6TEzb3ANuavqVJXAxc1R8J0WDEJ4tNk47kGZAlGej4cXBiPM7MjBEWcAJagVjOqlilRBAEAsVdqVg+yoQREIqGOeWRsogWCemSSiMVowG1vZy2YBEhEcWw2hmeLy3YlwqMBewXTXHEeSUFmlzNzBqRnuDIa9oJgtEPsJ3XWrM4kjQMuIiFVIDRpqhQtQX+L1D2zlOzajK/kPFokHpOIofl09N6Gl8SBOWIm0d5184z+a0+khMxVXS0hJDIGfHQ6IYFkOcaSMlCttoaOSSKUaJOME+EnAVHN2gBv5TnxmuiXc6GGMSx4n38SRlMgm7nNgz3YdgIeixR+MebDtutcm9G+JQkoMKHfebL/xj04F3FkfgkE10lKvJjj0Xlpzg+dMUzNY9PHuqjdxFYpK6BUDF8q7s4lSaGOChyH9YSLuW2qHvamCGnAzElj5P2VlNkbQpKSd1k0sPK4dJWI1XV3V27YH/OkHcJKSWk+uE/hmW8KBlRxHvuiRQjoKs6XUp4s5zY+KawgMVGAqIC4cu5KajUoqQJut7/iZbGntzcR9osQRvtxsvLKn39lijPUUFuIvX17ovHaayijIdmn3vXae+Irn/9yIiZe8tKXEOdoF4FUq4gn9Ky0Pg4eOhR//x2/Fp//wpfi5BNH49bnPwd12raoBI5BANiF1pqYHJ1BDXYhCk0LUd+wOexaaWn+1PEfZ10+wakwxRzfx4qtwFYygxafrLulCuwSTfRZwjUlgUmf57GZreO6j/unmDdDqrwxdsJ+hra5HoWP8b0ehfGzm7nXRXv11CMRqEQvJa4Xtb8tJclXzwqT9ae9kzzOK+/q4r67riX68BS7QABbNUNqoNzmkCwuQJwNDQ7GFbs64wj59GboO45SJ46K9lS2p/5Povp8ZHYgqWlbz066vCHAHHJK7qQdCDyNIMCUHTj1o7QxjiN6+cz8icThzPfVn42eZN7renHdLDHgRuy/jVLebvX7p/1j815Joum45sahghKd5eUKDHRIITJYQ9yLdUjmSgHbuFJuAdctcWArU3Ry68zbZQG2PDtQsu/NCrWPIgWNEEbtIMHKiHzP8kR+RJRE2tbBggomUHMRiS6vd7N6Vu6LNokbgjzzZ1KdLm9rusGHvw2Aqh3Dpok2ZKOkXZQ8ZIhV2jQMl3JsupgQm0qQ9YuRPOjHp5tx4d4H4p55K3xWD+5+ceW9jOfSHhHHMwvDCXksh3x5/zKEVsJEJBl1IZCvJYk6MgnrOgLDtsDVTXZeyZ4AIgnkRwPz5Vg4YC1LENuJGBQK4Fjzg8iPGMeO/aijQYA5IyRoxuCyav9nXgmPKpC2rG3OEhMEL4Rcd3Vb9Na2Jns74TrOvNYrooSO3PWhxYkYmpvIXin7zAkdHWPQATjrzCjqMYmcyUG3rfbP+xKtaYDLylDFqi4RQRLnxPQSqeOfyFQdyKr/tFWbK90ve/Wcl67B5CIcOMtN1zPgdgiRcxb8VDPQLkdgeS9wkpwjOc9lYjQjzS3Arc8DKa99bQymQT/SAjHYJvIqEdkoWaWrUMJIKWXy7sZv86d4SolQygjV/H33u0nGiJHNb2347fuNFfVpzpZnsE77nfXdWbqWxMuelb+z9pppgSMXEPpJJM6148x7pbubp/I685r9ToQ6GD7TO+1DMgNcC7sIzt2FPaoSy0EkHzIYukDMW2sao46ARfd99jPxuc98Lt7ytl+Ozmv2xjBhD7oJJCuDTcmUZ4NeB3U5X4f3N8dJSYjr0ihIWrpWM5fnZ5HosC4NbfAkDKeTuM0+fXQG4qgiOnfXs4fZ8pUkzNyvD+Mhs4UfPiXGdDyC9IeIZtFG+w8ucYKZ8QKSJO0Y6sQncAIymWbGYgzPIWkrEhC3FiZKQxaHCcjE7gVU5smfzeKsLeWtTWHcaYfq5jZHKfwPThYhgJbihr7GWKhriIr6lvj4hz8WX/vbryRve8+86aZ421vfmgLU/tmH/iL+8W/+k5jEX4VS0kpgODM3E72NbfHE138c3/zq1+IX3v5LMVqX2bG6Nz6jfg/QKW/FBQBh55WnLQS2wBaetn3aafilDgH2q9oSxxsfdqXeumX+lDeyLausSBHSF2eGkSTVp5hHEkp5G0XXEsHjN0inEjANjeWKr02q1al+tZyoVw57coPqyb428TwnpJIR+drn635DbPFvFIQvT+Wleq1NlZzmBZDKqYTMrCWgst86pmjFpXkTXNOMEMrQB4NLVpa41PkBmNeVf2sMPsehbn9N1mteSy5vT3qYPoQZRu1wJTMyyXcgFHjfILF5kjBQdQ8lCvJtkajE9/PaKlG/a64AGawB4QfZHoVIvVhJ7qc2SLVwLKchkFSxy3Qls94mEHBLgq4FiZu2WWtTDhP7JMpgu3PYZr+IPYOdXjPqOiJpqe/gtRqa6xFNpx8p8UCHB4k4SoVRMs8riMFVjYqM6nQ5m1jihcmX5p+OI1ZLT/IWkYVs46jkzc0gkWKO1jB37Ms8yJvXEihtFY0xg/dIVUfLkRDnrM/Fp5z3MgGgaVKSIFFqtOgf0iQrkmhSWpQny5IIMuixThfmaEuaRwDVdsmEkFzPZmb+1sbfy+uotM4ScaTkCOLSMRIelRJ8F4lw3rgV27xLG1dGYHvvCBeRbb29ZdLV9e9ZpowN58s0+61Ez0YEkvkkc/SMKdz9l7cnuUVn7KdZ3/XuJc49Hio1kgmQz9v1ta/c0etkVBIgN80kRpn+ZsSYhK6WnCUimIKt18/0jx+21/5tRMiaV03lM5ONSPDn2K9RuWN+WGZ5so0SOMZeStZtiQORZlapZgisHz0ZzR0t0YrNjd42XYcUHafmhuM0ElPVpXFpQTsijs8OJqZQ93whxnDO8OrXvzr2HT4Qp4lSN4Wq9TGcnti2bPaW5jC/KqVgKNXWsXzSWrkCIqaT/Uqpic+q+Oqh/slGApK3s7f3LxC8dpaA0tadlUpGcqIyyepDYa70qyJOYnujfEiY9RmUmDIt9UKSu047NqBNrPljeJT7xkRFPDRYIFYbRB5OFHobsUVqRVEYomSKRvcwoF0SZLRnhnbOQliNUzHRxvjGDo6GGCC+HWlwU9oUaBvt0xlHK4TOX/zVJ+J+PP798tvfiq1ma/yH3/uD+DhStSt2XxGTk8XUp6saemKof4AwBsOxf28fZwOuwQ/sjbbmpuggMG/d3GQKaj4zBhSuoMIk8rqQ3u+883SHwA6B9HQfwcu0/W7nHn4n4bRNgSRrX/JTTWzKmQ0U+yfI2mbJYJKTuDwe4kgtwO2TU+vBI5KRiB72Xw+f/AjKe+Fv0Tif6GggO+qzvNblb43hPWn9lxLZVa1SHUxEcjsxYrIXN/8U2VQaVAsCZS+XOJxqUVEQYc9d+4oCFCCM2kHkG/jWWULW8rJy846V3fLS2+b1QqcJwmaK/nroqR6mVEj0qZ772hCsJIg68qgqoe1AXrxw0zOgBJmImAUn4ojrVM9KAee8ypx9gBRxuNu2rKV5Ted8/ZwZqlCnrE6c6nqCe1bH9/obYk/LbFzRuECbs9pSm+nnuVJ5jgqQdpEgA8pqD5ATR3KtJW61L8vn26pyKSTvXVavbXAssxnmPQ3cnfdKTbaa9yLHEj6gegnuEpttC3C6mUtV2COZRLp7kDJVg/qMErTUNi3PZYkkbKjAnVObMiQobx1rTvUx8jjX03s2jsd+JScfzBd7qfQoEVkQMTIUfG81USenHxfozOtUOnATMU7vpXewR7AtrDXLTgQicNQDXrLd49n2mBC8/DOYMuiVgEffMwiubqhkh2vKQKiOq67HqxlPvcCtzJiVd5xnUrfuHZZvykp2zWpPh6dAkHCJbtdunidl3OLDMmYYmznQd4m6bK7AXKK+fA8oL0vpmMS4zhnMm8Z3g/Jt4YnxQkzP4fGxZYq1B3ENyWDQalWDs33YeYVknP0tU0ekvLUFMhfmRrC7aUDNjr5layerUCmN72VtyeDtZxG1xRYYaK98493JjfhZJEDj85RBa3Omz9omCzGT1UsgcpKEbrrb8ASXWXRmo9gIkwOFu5jsqImp8aWY6GcfLWC/U581XFjZnm7yVVOk+/sQzJNTQFjpruNdV9Ua18LIUIKU1Uqm80zWU0ND97LSB2vn4zEqQmjGPlIZJ8fr42yxJnoh3g6w983WYuvGc1uIhnAa18TK4AY8pdTISTaFs6iVzp84Hd/78neTCmIN9pVXFTriS/d9LlRNPHDTddg0FeKXf+XtMUKAW5k/ElFNEKifwfvnfZ/+bLLtbMQT3m/8038WTxDc+sEHH4y+t/bE7//hHxDQ92x0dnTEb//Wv4m6uvJz5zw7v5P9aQ2BHQLpaT18l2/jRWdGObQfIa6KG7tJV8RugmsRoOzp9j8zNG3z40AkaR4Vo8TNBlHcKuXHshKacbjORZBGD1kDHuaHuYeBx49cTBGQ5LKWQ18iStfWemYyqKst8p1J1Iv0tuWNSlUmfE+1ChA6r6tqOY5552IlufmWZv0eXfq2agRBrAfRkYCxjxJR/omKZPlS5g0/7K95RLb99h2RmZz7nEtqfGZ/zT9JPaaGRCRliJXxVzIblvRo+UMYTqrrDjIsUsL5T8prXc52zgs9Ovme9ilyuS9msmQDfypFSsgQdQ3P4AZ7mPgbNWNRXQAt4J6QUcIoLFI3ttGIJTA3XQS3IDlSisJ0TSqoEkcJXvxOcC3D8FIAXMq2nuUE/luJrpDwdA4sUNCsxDf3yrnQy/nXXCzPBOcyqj6Ds5NR19KDmhR8Ze4JXuUW3cTgkis/gq2VhMly4nlS36NRts822xmlp0IjETsgSuVJGCUCie9Z8qlCJ2Hk3kCVwNxCy9/wGmLSfYNnOmyYY33NmR9kPDEaSuIry06SqjJplW+vJd68ty5Rd7Jzsi9r3l+X96d8Q6LFOUbDgIS9zOZH3gzjtY3h2UzCyOeqei0g4TD8qfuYTI3sHUELEorhvcA2r4SLNpV+58lxXGVPmT/Y1ndGNiyy/wFKalhJ/nYfsT1KbyR6bQ90C3nLc66843SYQiIzz8tdDdP0x7XmqpOxAjEEgaWdn3uVzily4sgSrG9VYm4evuX6NL65XUyy2SoRRtkuSoWlpggfmUDHZ4dSfcIlg9PGbV1V15ofRVuYiNaVdy2/DQiMoKLa2lUdA8fmYmKY8AK9tmBusAAAQABJREFUjBlruANbxV1IYpQgKelRsfsEEj7boWQvSYAZa/h6cRBFPmgrnmzQ7zVt2ein79VCEN3IGTHZMx1fOlMB4zBjSixA2J0YK8SZiVoIpZkkUWqnTtdxDuPUq7xrfM9z7H7rmz+Il+AyvQ4C86vf+Xq0XnEgprE9am1uTdL+Mzh5eAYx2pqRSEn8WJjqx8Zo++V73xqteMz7t7/9O8R3ehhHFhMx2N/PfoFKM0GtX//mN8Vzb74ZJtOKJsJG/dq5d2lDYGvs7tLu+07vnqYQcNP8/txQPAbneZxjOx3ExGvRc1dGIF34puaWPDNfC7EBEVBPdAixuDxRsV61UvwVjhRtI843efho8Kx+c0LeQRxEvuVaSxD53P75ac3TIHizHHySHjWc9NNs8MXZ3NNdRliYO0mzeKO6DiTHU/8iJduygtqsFCrMRUTkIpvHxnovXa9kW77KnmUIgLFe9IolZ9/8qk1wGoJITSUvfpaVF5r3RLRIuCW4ADs9u2WuoperWL6wOLmqIja1EAoaAy8lz1vLWTa+yOEmJm2ici+11xFhsA8XK1mDanZ6T6yAa2tKHFK+nQdKXyRKNPAWycrqLrUr5d7kgyYar6mAnYJzV+mqyJ+ER5pZdCipZir5KPVXBD+pjK0p0t5KbEnJWHNSk6Kt5wUHXpxHzW5mCnUVyulfQlEGpKwNtRbRMhFz+10AeZomJlQR7nkifEoEfmpjamdG6GTe6jLkW8nN2raI2NIx1g3zg/GfxdGDUtU0iUv9XdPN9NMRmIHpMcHaWlGtQnJEO3IJkfBwUmQrNP0AxiV48lOvehullAe1PL+NzfSzlgyCemZpOBEEOvuoS+p2CZJRnJuK/tnR5DQg2d8lIMjMcUVC+AJbbZd02Z+ITzonWeIwmGSmZGtbIklZwMVNzktbKoGrtChzBqGTEaZbqRHm2ShlXUEdkw1oP5KjFSZQltvnEvCq18okyCBS6tgmBU6iKldLvC9dWhdQ81WdLiM/aMUmrwpH/1Zq3ajwre9poTrIQuqhksziNZupMkfkJxRa2UvGkDQN4cSleQFCpC524XgBv5OpWa7z49gdWY77egtErpoPSui/i9OCwZrZuLayJdqgTFxG2v+Y1sJsbSt9np8ffheYN89ifxpum4xvDTZiP+TeloEmI5QakkTpmb0TsYcICJuAjAecfZy/D//wh6xP1CMncLAB80YGkBSxxJVqttneRVtTc9lvUQvu7t2FndJHs/eIGzdN/Li0z1GbsRObiNt25cEro6md4Ol2diddthDYIZAu26F/+nbcve5B4mNnRARcyjmOXiQobpo5wvLUpEgVMVjshss2B3dKda/SJsmXG6b/sv2Wz/PcQH1PY+QJEGC5+4Y3zAmj8q24/FqOua6Y0aIocbZT7dRdGkPaoEtnDyO9JUl8ZapFOYpQylf2ZQn562W3111KAG1mm2DmrBzU2SBARCBKLVtVjkjwwMIEbZrl4IJjCUIlQmD9/uHwLEaK2GzNe7RTjqpnGPZWV+NEYPl4tS5V6jInDuduP7YhAMR8SrnyubKqYf7Ixw/CE5GDAOSPbZGD3KQ0b3y+SCvOkzBIb2/9Yd9qqgmuKtcaAsHWGh9pCfUjq3cuK60pABPVMyfhxK8lCNbWkOYnfRJREDkSaRX9EhCuEQkMEflcwqg0VG9xGYG9ujRhtoSnPRVxRISVHGxnziyXQp26I5ahkJwpoPK3gMvwAdSIZii3rbYJ1R3aCtyVUoxgvL7E85wgsRzXnojTIp7TqlDtrAKZ1XmDbXNdpH6UNcqRnrGfPEv5JI5oR0oJJkAQhkM54qPN2hTjP426UyKOSvndQ3Jpj2qKzl3hmks/HLEK1odoorYpziVtVxw3k99pP6JskVSdSSiR+llLrg+DwCbGzXwmgamHKJBQUrVOBo7zo4JOlAfedgyEBVBLe4RG72uTeYyn5DxWeq4k5qmkEmSBeAZz9yftI93ztkMUldetxFpGixI0y3UPS+PILPd3Ilu4yKZXZu+UEQZlE668QMb/ye89Gp37eqN3725iOjHvWc/2Py+lPHveF++t3Tvz3/k+Wf5e+bXwzQiwijjBmppgPPqARDNznCkHwSOzCGIC+LR0VyVX2+ODc9GH1zzped+dh+lxBsnREGVlR91S0nIo4EFuEic17oFPQCSN49lvd1KJzU5AodTCHNnF+lRFb33iHHU/Y+4orZITYrY22nYr7jqdbz8arGd/XoGnVzOcA1OzMN7qWd/c2KhoXdtf+4Kb4vEvPBSzY/Ox99k/F3WtTdFA/KUTTx6NZz7r2QSiLcTH/vLDxGwaiMOHDrN3VMXA0EC890/eHb/w1jfHs599S/zO//Nv016w3ILSBUtimYG3/Gx9B3fuXOIQ2CGQLvEBvpS75zadJDogTDliKCL2VJAQ0fYqNvXZudoYmuiOXW0nV4FQrpV/Il8LsOark3uf89tC3fDlpqo25pHh21uWwMOEGHOg1XCIa5SugbpvlyeRaD09iZBOc1BuVKb3EsHDhYhRXob389JE4UR28HkEd9UITJsn35HQ06w2fz/PbZuVOpxFDXIixZ6Ag84/GXtynNMBjnrL8fFGpGKoHeq0oK5IfdMgVHJszbE65X3Kv1c/XfnlwZ87IcjUXcreAJEROLqtDuL9VI4itcANrNxDvBrEQm9TVDRAxAHn5O0NtYsE/5XiL84VbajGSYPE4OyCTi1olkiVEqUcmNwjFHI0I3HR7itDMbauXhuwRj24MS4zvKPUcXYuI/SrWR+5J75l4kjdzrXJW7alVjRIZxiZ1IDmbD+RWbS1vgCyA0c9dZC3nXWji0XUYTAaxwlGLQiSapXzEsYGxnVwSkkpm+5757FfmpxmXFg3dVUTUWW8MOa5dgzlzBCbndRN6bP9y1PqK1JmpjNrVtu0laRana2Si6wEWlW4pFoHgZQIemApTFXZy4ht15COP1Ayo37VoswnsVYJMokMKqub+pXWJZtA9yWIhJ/15NjoYMF4MKLXtrgCqVcNbRea2X61uh/nmpO+p8pb4OL/Qogk30/t4FNCVZVj14R2SJRKm7L2ZO3L8nJ702RuCdlJpJUyqBIDgTIkSqpRxxJfLzC2XQRL1WOcxUtET8xOxchcEfhkjIKsXdaewYaJE3uu2R+1jUQUArOX8aXa8wJ7mY4lXN8mvyTJpiQtmcPuVblKoASfrvE7CJyqw55T08N4MJ3mDWtbnYS7aoC76/AUycQexiPkWaR9jyEtboEoc7eQsea3/12Hrd0LMXh6HgbgTHQjVRqEANbuSA9zOZ1iTUrimhmvaeaBELLVQwtFJNOoUnMypERHJmHmGENLpwmrEwQbNZ+CJG5l7rdBF+c5XJbdtO8FLdMwnxbi6CjhB/LKS4WoLpjPuNXlZpAokP/qlo5oRw3Oc/jQbuy+YEDc9frXxX+HAFpgv9OR08c//on4tV/9Fc50mJFof9Ti0bMGxzXf+Pq34onHjsQ3v/Zg3P7CF6e9Xk0Du6qHztTj0nitrX/n9+UDgap/Rbp8urvT00sBAm5e3yg+vkwceeKInBhxvAKbnAvZ1xJSmtQG5BRWxgS+QIuzOFmtQS+deEZrj105cka0zzbSC6kxGwk5ktnb2yyDbB6+OmBIgTJLp65vq2LisTIOJ9yAi7avPPlLhLVFd9fYDsjZlHhQHcHk4VxPGdr56HRB/ftzQVMFiQbcg0t0WUpeo++pAndmfjQhRZaflZVxnTOVHA4jcNMmDHP7morR0ziNxzV05JWqMAqeVsLXlJeb/dr607yQAcQGAinhn8irXOYcQ1maQsURY+rK/vGoGgIJnEI1UwGktSGNrIBY8noaPGCYeFAZQnQ+Ldi6feVPFzGQmppD1QS1TudCExLLnmbVfTKETYJY2IpciM5JcJ5rTDJI498RBE3JyCwqJN6Tg5q55C61gO4u0t+NksRjRbE66ptZVyBWxgu6IAj4En+Z5LW8JkmdTL1Uo+tpDdNZw7ZxbXJ6SkQ6L+YgJMem2yFUUH3CK1aV66dk05NJayhV4iifOBQmt3l+GhUvkNHaOua9Ls+pK5f05PVJGEkkJzVdmCASk8ZL8k+VMtX2kj1YMhaEOQJS6Lwx2T/3IIlyiQyRSt9vpK56HWXArnceZkC8IEhmFf2UPp1jq1pZ2iPyvqZmcM89RM9syWlCWZ6Nmql0RkRVqc3Kyt4oZ7byszZIFFlHDfsSsGRvyvYt9xtbmO3BlqIdTRV5M+lg2QRYU4VvuY50MmNNeU/dC1Uvc28/VNgdjWMQ7o+fitEnB6N6ZC4OtPdFC4SL6q9FCHRVE93jlIoldB6kvb6ZvZVzyLmciG4+VSV2bqTx5zesgOTpTzg4r1Q5phnUjdSOPvZVt8T9n/hccozQ2NZM/oyMs90Z3FauenBrPfr42Xj0uz/EqUBnzMGw00vjJETPNO3S3bdgEhr2s7ae2F9FY6HhNa6R71oIYp6ZpzyZX22EKRgsBtFdggjRaY0SVN28CytTxloIQlV79mTJ7zGenEB9mJVIOXieAzbCKE8IinFNzllTtxBncPs9oT1S6bEePbsK89FdcC3SNM87LrzmUbQyPoeXiKdHYQPEdPMM6WuGSYcUeu+B/XHVVVdB/DweY8Mj8abX3R233PK8KDAm3d3tccP1N8Y1z7gmnjxylHGqi1tfeGtcd801KThvZ3dHXHXwYBRaGuLggQPsxRBTGmDtpMsWAjsSpMt26J/GHWdznZ/l0HBnLCW5/XPcq0Y9qlxFJ3++1fc89kajM62UWcsBIKepFs47ThHgDveP9sBFRB2uXNXOwtJmnh+tW5W+/pkHuYfNIqoJM7NYF9Xo+phDyN3/QhLw8FWRtyKI7BwqRtlBmh9ZWaG2tgDRI9/V50oYJIpE5vznEeYbHo7bTR4gWCCk91XFmOFgVvIkx/XM/Eiy3Skvy7JFKCZxAd1U1QBH0raDZaZKQVBoQTOxTuZRpRJhTXYvfGcBT8tL2vzaokQ2EtLCdRolVTDHIYwmUNErghIoPfKZIE9gz3qdfmrP1o9KINKt6dbtECSpqPP+sK4qIr/X6KvXxJyohVhU0CCCLwEhx70WBF1vU83Ay9gyaxH77OWVT9Fz1VfEjVRxs4MipquIo1J2iYskOctfFxFxOIYhenXxi8Rlumyd5dku1rdzLyFxEBAV1JPNwzQg66qoQse0pTAKwwLVn1lh0YzaVxEPWY4lBJeqdY5zNpTpffeIeYJKK/HN4xWpDFoL8SLbI4+PlKROEov0PwWmFS78U11P5xQadxvDKUlvKb8R+xLjLNli57pj4p+El3YnCwAxSZvYT1RXE423WX7OU54OM5RcbdzT1PSfuY+M8MiYDyLPySsb60zYbzdJ6ovsrhVa5kNmST6XgeIadqwkWLIaMmIo3/W9JzFrXBwJI6193N0kXCQqVk2EsgZal/tJebIsvbbNs59VIb1oADn+7N98LB78ygPYrHTH4OBQNDY1xd/9lbdFz67mFJC0AecAtuzs9AiBnEdjT117NGJqZ74l5o/SIYMSK6maQirR26BPOYiumQmkOfVRQJKh1GJoejyptDXX4wWUfjdgi/fgV77GWUYcnn274kDjLvaIjAE1PFOM/pnR5AijG+Koo7I57j/9w/jmt74Ve3ER3tfWnZgM8sbcP2aRmozjttr+NMAYcyZ27huO7z8yFKMQfZ0NEDts+s7rtUn7MR1uTBIraMl9BJBNIuntrxiN7pqW0h5LjD7qGUPK21GSIrl39Uscecbx78hURXx3tCJe2LQUV+BBL1sHzCMuDsPEKnbPxOchwIZn6qkHwow9sdaHtosbE2Oo+U26vtnPYCiNsn4mXebcOAKTS1vTsxPjeLxkzVYOx949nXHna97I60tI/Gbjc987Fm04qeh+xnXx9SdOoHpXH3e/8U3B8RtjFdpZQSgCl+brD8V3hkaj6+pr4vHTxfjuY5Px8pv3w+hYfY6uhdPO70sXAjsE0qU7tpd0z8qJo7TjciCIUM/BLRcR2ogTvRlAtG2oAaEZmmpOHOokTUqZMUKer4+B8d7Y3X6CLdSt/cJTHvl7moB4xemWGKe+acpvqJmMntYzEGG4ROZwPq9Ek+z3IhjHBIdt8mTHwZQH1szLEgFIUhU4sBmqlj2xRxIQiYjg+nx6mMoDMZEwkis6n1TAOEdBWAxsK6JivRsluZxVcPyS6+5VlWZQTuhAQn4yJFRbCL1hnW+ytKphJA0DBCQVCeA/zTsnTufBPM28kNQ8zxHZdhPttlKjWnT7kyoZ19q9ORY+80/7CJF7FAHTHVVxtAnJx4ubmybHWYQjOT1AIrI2CYdV5XBD7b6FAdCoybqo38PvBtdAplK09v2L9dt22MbUZ+bxsioaN2R8mDI1umw26fmvGmnSwjx9Yr0sakNFRx2zVEhZw2SWSBhadmKcUIT5klQOzFD++TRIlHaM5cRRXoTwN5jk8n6TqoArjgTLIMja3yyyd9g+iVBTkjIBWVuuFK8aRotqYdkIKjmTeJIh8fRLSpt1HGIw5gtJiQR2MMqSc1AVxszpi2g5o5OAswIhibNcRqHbfWEpRDM2iNc504d3/L9+KizXKNIu0eu/8uR46dZbaY+Ppian4oabbojX3/Na1kF1/N//+v+KJ48di9uufGGcOnky/vZLn2LPronnvOQFcV13X4wMjMQDX7w/SS5e8MIXElpnX/zg2z+IvoN748ru3fHkjx+nnRVxaP+B+NFDP477Hvx67OnbEy+47Tbm8nw8/O3vxZEnjsS1V12dbE1lYHVXtcSTjxyNB776Vdxz18StL7otru3exTqtiAfv+2ocO34sRkbGklpYs2yU4en4/Oc/n86D1vaWOIQ0Zf++/XH29Mn4NO1V4vr8F78wrt3THQ/+4Ecxcvpo7DnQGw04JFgLD2Gj+pxEVa5D4RIzcLZ2Sz14n1Qy7x45wGcja7FA+cOoyk7wfHh2iZhHjTE4XY0k20Dks9GLK7zcZbjQr2UcrmXdDHTOxHcGIlqwO7qyeTa66mEk4JGu/yTMNKRdCnJk7AFAPNihBcGJQ3g6mCUwO1CDbEfKXdPI3siZ8+j4iaierMzsnii/BqKsOLUUxyaJ4QfBWIGP8dpxClJtlPa2QKhWkW9m1rXKPFNSyXct6sVMu510GUNgh0C6jAf/adt1Nq2aejzVucOa2LWhEdJmJzdcuyRtDpQmbSeJnLYWRpI63VkkRhMQL5btfauYmGqJkbrJ6GwcAPnxaN5+EgEWIVMlaHK6AaKoNYozDRATSl3YoBH9TCy2xOxQTSKSmuvhhJ2PJElkAEIiIRSeH54+IJlrm2k/cjfaBXTLM56sd1fAmH6cx4ecXtWj5uHgZZDKXk5IvQOyZZKLPsshhzUB7c9asv4F74tA6SlrEa6i3uS2kyTa5pIaFrr4dcAZnQ7MfZKkbTvvz3EgTxHp/Sd9PtrzahCHCp0TOK8V3yRorNQsDOQGGwSyDuRUiYv2DSs5NusRMkG5n2TcKK/ITvLw5utkWCKi6sIg8xJ3u4U9i9HcA/HLOtro3c1q3M59514tSJHxmESYTSLAOgBIsafyQkoVLzC/FpHmibhqD2Ne4VaJEw9f1w5J1cisKF/KykzFMLcqUXGrrRaNEyFS2lBFPBScXoAMy2F3vxD4ueQor95v95FEo5UXyX3bkKTA3K8Cxr6bYEgtIuB+ulOokmQg4xrY1UpCXCeOnTmMV5X6TxkSb5ZZnnIbqvOViJeXcfGvXY0XmtzvhMAKMFWX0zmCEiDJyzRGpeITwcQ84Wnar6w5k6OYgbJK+XK4+9yoRe4/q+ZAni+9la2lfN6VPbKYTGKNZAIlZTZTnAycHoyHn3g0hocJJ4EksK8DadKxE/EX73t/9ELcPHnkSAz0D8Rr7ro7/uojH45apBN6N33Pn7437n3bW+Nzn/5c3HjzsyBsXhAf/fBfxa3PeV4Mnjwb90HE7N+/P77w2c/HAl4er9y7N/7bf/6T6NndHdccujpJLZrqGiCkfhAf+uCH4uDhg3Hi6LF47MePxr33/kp87etfj89/6Utx/XXXxGMPPxItLS1oPszGe//r+zlnpmLfvr3x4b/4H/GLv/h3QP4jPviBP48uJGFDw0Nx9PhfIGG5O3ZhFzqN/eXR49+Pgy+/OWoaEBeXJcdJSd6uQmf0E+R2Srs0xk846W3yFOu3q7aVtVSPd8qpeGJ+IDpx/lCnBgCTX22MgRn2XzQ0HNvvEiS2q2UmDrOGOwkem6d6DqsrUGdu2DOJAx+k/zwYGcE26oR73FJ09dVGYxtrDPg76K6Tqxbro5MfD8FcnOO8u2FPE88hhFhv1TirUHqVVGVLlTjvusjvnOFRSu6jukE/gKQ8EW3e569S/b/UyzQFssw7n5clBFZm6WXZ/Z1OP10hkJAJd+qUOBrdgUlyBsE6zju5JdZXT8WejuMxXOyMwXHsHJLhPEcpG/jgeFc01hTRW9bF9nLFaQNPlXHLuyuHP7/IN4nzgfHp1picakJVqQ5kC34cj2qrJ4n8PcIb2Dv5bK4+Tg9dETPNA9HRNMjZbL2WuJISwbbm3vLTUtaEvmxih2Xb9FY1h3pZ8soFwql6im2Q2BHtTCdIKhRkmW8PlpQD5C5vjeVkKhwgEXDa1qYMAfZg5PkWKauxDNHZIq/QlXMt4SeX8FxJBMh8qunMceqOd9ZF62mNnc+dBPE0J+asBJIT4yecqlEpqYIwEhIVBI5VNStTg1xdsci9akQVcHWTdykkhmm8V2db+UU/NnvuuCbX3iVcAHoyFgewnSiiOta3EM3dScZCuxx/W3ZxAOHcKKB2pAbNOnngBu2VKFqCuFikr/MgQpXChveXiQbeSdJSBm0OO6N5iJ00l3kvT0xdMlEz8DOAcIEbcsUnQSjnkD4lBsMGqrn2WDgZC8oNRpWeDAra180nl/RJdZH2pEWdKtQORiQPFSva6oJSojQFMpmC2nJtmfxPz9IrfNgnpd5KzJIaH9+pvaoe8u9iJOuX2LTuKhopQZr20fMoPMHkPPKXZ5Us1JOlULQc7R0bcdLheJmEltdKSVXfkzCSNEqgKoEgXafcqz98rOquUmYJpM3yuSIkWjd/bjuQXlCWsHn00cdgmE3G6NBIFOoIht3UEl/+8leQKi7GgYOHEtHxhU/dFyO3jcSd99wZpwf6Y3hoOL72lQeTU4Crrz0cR598Mjq7OxMh3renL/7yI38ZLR1tcc111+GtbTYeeuihaMTj2iGIoDe98Y18H4qPfvSjNHUpvvylL8fh66+Je+66B0K/Kn7v3/9uPPzwj+LBr309XvqKl8RLX3h7XLF/Xzz80I+SdGtsdDTe9Et/J266/oYYH0F1r7ExHkBdbxI3+1fR3vk4EB/76Mdi4PjRuPmZ12EfVx8f+9SnYBTMAO/VBFIO4SbU4Kor22OgahwGVZKZpn3RgN6nZ0eSGl5xbhpZLA5nII6aHUnWWVPdYtzYUYwhJDaTqJLPLFTEKTxW1kKxOcatbrSMRzXfOvppRPIkzMdGZuLEw9NJLa5jD5LsuixIcxo01rLzZEaqT8aIGzTFpKK4RFcgjZ9rxjr8dj/VGsr3rDHl5dunvewtbPMp+WxVhuz2zudlDIEdAukyHvxLruuc/KrCuMnqUvd8k6ighElH00A01E5gAKo0qTltqEu4Hj0z1psIqJx4kYBZgEumUalElLGT9L6zyD3tmmbmC0lqtFDilpm/FqcPrQ0j0QJxVAeny02/vXEQAgld7JnmVJ8c8bbmYYiXkm0KeeaRhuhZr1CHAT/I9Hmr4pUBY55yUflGpQCvUqoVUnehjgC2lN2gihccNMkj80hvmjSw9k/O/xLxM4YmC6hOoB5YOxWdhSmCm6bjJcsMHOUMz3BAbSbpMHf6Y6y2mzzsGlF/EMPzcPb3Vkn1pmnc1EpYAVoc1mEUTKDEcyVpvuk65hLfP3ECiQpqmAeqjRl/S7snbSE08HdulMBf1mSN1kEmUPCqJG5JZmhe9ng7l5YLAr6gHRZ9lDiaP0t9EEc1e+aivisnnCWdXRMwHtY3ZDs1rcpDMRAPmceuDEndRqG8lDkkYdxtrIVskFIeEEgDOGuLmBEhWfnJTgUpUhWIVgOEkATaKBxwnZm4VywTXGYvL595lggkb0JQJDW+JE4SSSvtM0qpS3M4lxxVA7BKkEFXkUhYrXYtFLGAL2Q9k+ka231KpxGW73xOv1FlLB/xZHtzHutjA7CsupXIklQdBAAIfoWqk6zn5OzFQd5myqC6zcxl2bSfywMuKzVqYl0Kf1MuLdLdi8QrEExzP0dmy4pZd2luCZpJ3YhvSRw5btqAuQecuxfatN38nJvjnte+lkCrbfEf/90fxHchZo6fOBn9p8/EFz73+ahhXh2+9ppoaGyKT3/qkzEIIbV3/540Z7VBegbupx/98Ifj/i98KXb37Y6mlqYYGR2J4qlT2NYYZ28pnnH9tVHA45reFashwvQimNYH02F0ZDR2X9mHrhs2VsRXqm9qjLFiMRFfHe3tqP4xfrShknGUCGpoxo4Joqgam6M6pFnCZgjX1v1Iub74hfspvwYnBoejY3dfPPCNb8WTjz2Ba3BsjZDu1DchfUG64yJI87IEaSFVz1j1oco2jWrrOEGDx3FSoXOJOTaPYZgSzq0D2ENdNd/KGZERLoOQJYUWpGM+BRaJLGW/06XFMWx/lpDcIPrlW1VXnlIRW1tMTaC2inpe+24dqpSII9vCVLEtljNF5iX2kkq0IUIvf+llHN6wl6ohsbepCzU5mGMwQGoxpBzBw9/R6cEkIbQoiaUuzummnMjyphWsSueeI6uy7/y45CBw/ljkJQeCnQ5dKhDQjkC1l+TGd+1edx6dFLVpgFjoQ5o0MtmBDRLcPwxnp/Bqd3xob9pGJYYSYcRmD6rBAeBbcruziv10e038dy6q8ITXDmHU2jgKQmw8m+yZF5bQCKHRiLrAPPEhZiFYZmdAFeqVEPAyeXAsnlxBDw93JAKrUXfYG0iZtuqmEijbPD1biFFU/cbx1Jer+lVOyinXU9gsRA/uXGsnUTmEq8g926c6VHER2ynenZ5ppD1LeJwjlg1trBf7W5NErHU5Pg+SsVESNvKH17+5Ue6Vex74BmBcAGNfa2i9kiu/QgoEx7wO17RypqfaQL5QI6sjbsbSFgihpi1Fw8b/lJJqmFXAfWG6MU6P7oJQLmLQDQe1fgbkOpsnnv8rCQYA/WmsJJIiqi3TSZK08vRcVyI/yTEDwF/Cg1QijsZBzvoYe4yZk/tq5zIFSRTkRPK5yj3Xc8uTmysCuGFKfcyIiFQ5vzP1N+YmRI3qgpUgUzRtwySi2ACSaawn7bYWIZbm2ROS8wbq1DFDPXNhEiR6BPs3JSiJEAUOSXLDnNL+KdmgUIMqbknNjbmiMwtVHFWLY7gS0VOj10yQNOehHGqbpUTW3vFmaqOyDBFl1YMK1JfbV4kAT4FczkIomfQmmNZK9lq2LijLfxcrJfjRDz2SKT1MdjisTx15aO8ikSnBkhMtG9br3BEA55kkjLTvsT/JUyYIN9RZ+i0BqfsAZZapZOfleZSfiCPGU2bMVu8JSdF07b/y8dmqmkQQkx/aI6amIajHJxij+di9u4cAxLPxJtTXWns6ooj6XRE7oMceeSLe8NY3Rd+ePfGtb34Pe5fZuGHfFdFQX4A4+WLc+/d/JTq7uqKtoyOuPNQeb3j1a5ILcJ1CnDp2krm2MnNcIkuIWXv7dkHEHIlbnjsVgwM4VhgYjF09PdFKzJ9HsWm6+prrifPTH8WJiejBi90Ybek/cyr6du1KRNGBffuil8Cou4kF9Ja3viV27+2L06dORmdvTyx0ok57VRf7eW2MD1bFxDDERSt2QB3YEjXWpnmQE0rCy3nRgAy7gNfSdmb8ONKkCWxNVUesg9i4rqItugBWOrM4Z9pxmT4Io+wsHignkQ4BRlI2nyEN49HEIGREvFWihF1v00VV6NmzBXwpOa7+6bSjk5J6IGxqsR2qb4D5UN+E04sG9rQpZGCVcbCxM37wwPfib/76r5HmjcbevbuIe/RLsRfYDy5ii8r460ylFyJMBzhV7AkScPMQfT7LJJqorUNoXcz1l/dl5/vpA4EdAunpM1Y7Ld0CAm7gIjlyXZPdxRZ5t/OIfZJNFM88Tf0gXUUQ192JsCgiUVpOq9ibHiA+yY5oPyVGalCZam0Yi7bGIRB1VcPSUVPKZf4spbcoQEKogL3T2gwSN631I0gY6uLkwD488YwjeRpG6oP/nWS3kh082Yv5tl5qC1/aQE1MNsX4TBsOIgogSHDkeaUSYk0+9yIRzZcg+uTm1eO1bxbnEdNzBWBA5HV+G69nBsKtEulTe9MZPCItgEjrllZX2uuayx2lSDVIkVCNAnFZm3wnQ1bgWjJmWUvX5trotzCqxItYHQd0xmnNe742t2VaR85dnAcBLHZwxMI9r5lmHDZ5UdU6iaQLwAPXNmFbvyV06/H6NArM5pBUDhXbYmxqIcWF6mgoRhfEUiOeDhPiSqdyWImIZMisdzbpzNoWpPdBEoHdEtKqxUH49UWQDIijxt4a4LpiEzbHIkiqYcs1ri3s/H8n7i9cXdfpRkmEbFGONO3UPmqWOFX2rIY4SiLwUkfStsYpSrGKErc6KylBwDWEVKdKzvMiXvjANCWYRLz0KAa/GkmDaoz5eqUeYJHycK+KOZ2nhBzaEKq1bAmnRVR7XF1LqLHC5waOSKyYZTphULpqvkRU5oXwbb5F8mnuXpAQyTYK7jGWtMskXFZGlkuJMv/I6zhnZJQ5n3oyFEIV0oBKCCVV7jT4T01iXSxJJFFvtjaAUerRSp1Za93D1j9bybX+SpU5vYHZnwyFziSh9UiERWoF8kbrMet9Vuv6UoWYqrS6ol4vGU7zgZfyt/1WMuVYGQZh5clGJeOGuqU5/vZzX4qjjx9DOlOEuOmMZzzzpmhqa4l3/9c/jT/6j/+JshfjWc96ZrzijpdH394r4r3vfG80NNTHEBKbad6RoL/2umvjzNmzse/gvlisq4q7X3dPfOh9fx7/7t/9v2n+3HXXXdHT3RuNBDlN0jyao6SpinF45d13xgfe/8H4D7/7e5Q3Hbc8/5a4+mpslJjfH3jfB+IH3/lOjEK4HTiwP3ZDmD3/1ufHf//gf49P/OXH40c/ejhuoO4XveQlcfL0qfjjP/ojYB9x1dVXxV1veG0KrNolj0ViXQcG44sxPkCMpCfno7FjLrquRMrXlEluVwglCgCwxr3rZK9oq8aelv29BQKpDYmQczVP8s0kZDoYYaVJpzgLDDudJ5kl2crKvpyD865FnDokFVBuOye8XwCOHfx1Uq8xkIzr9vUj/fGJT/wNBN/xeN6znxVveO2ro7ejK36ITdZ/+89/FHe95p648cYb4qMf++t45//3X+Jf/IvfxAlEG5p5eAcdHsft9y7qCSSCJ6KAimNnW2/CIWbZn2ScnOnvjz0QW/l6zdu98335QACmmCfATtqBwNMHAiITf3zmM6saLIKjK94a4pxkSOOqx0/tBxv0HBIkpTrzRATX+F8PWouoms3j2lTHDUqY5jgk3NFVpdN9c3uhGB2o0lVj26RiwcVYaAsQMqdG9oBAE3kCAq4Bpw6q7KmipWregr5LU8raoam4bVdaZDDSZNBO+1T1a4PAairgAQn98P5iR0yhh9aMs4q+jhMcCmBvlCffb57+icRrJ2PyEBQ9kv+rEa9xUDYickQejBmiGhggXJe8p/cpOcrGNxFN2i6MOEaTp7zNVPiszPIlplqqGpcPOaUANcXFaDuNy28kBoBiVZIwOt25EMPNcBK325hVJZz/D2FZTA482ghiOJMI8fHJVhBV+gASUQ0x2oIKZBfEUlv9LO6lMzjJEJiAc66Hv7WI7GatECFXKqPXw8VhxncYtL0H5L0HN7dwUtXbt9sSEDoxmAGLXwOizYq+KPdtn3ZEBmucNV4VSGLukVLEvRLEMEsi+cggQboz7P4c1YNlOUelvJTe5CmptkEkaJ9jOSJGBoJOcPI+t5PzBgkxUiJoyCfSJsz9l3moE0q0iS+PVL00Zghgei3B1BJSTB/qEEEvzhqphjVAH1LgZ2BtfY6u95SE15PX/WwaSY+r7mInHVY0yJdHJTARzdqB4BnMdunopLwPed3GR2tEAuS7WyZhUYJTylciBoWZXvDqIZqUIvNzXfKWPVYyZy73Gv/KIWAenyvJ0M6rPEm0Jrfs3FR9TxsXpX0mzw/jGCnR2igJ52c27o+u6bqYGEFqxLmSPKV1tccQe7mEeSvMoqHjZ+lfRXT0dUVVAcnl9EKceuQxCKjWqEdq1NDcpKgR9/WsuWlaVKiME4uj0Ytjg3piEZ0+eToh5r278UpHZ4qozlUSZFa7trGhIZ41RCUSkoXJ2Th7DC+nzP2W3Z1xpmIs2qtR/SaGW3F0Ilpx0GB9bU3NcQR7pyJOGmQGvPdP3hO3vei2eOnL70gS0JM4l5AgVtVvBvugY7PD7M3Z+nZMhMws5+jwqZnoP4omBuutdRe2Qr0Q//RvFfDLAOeYQNrFVZwv68OFZxlngf3DVbg734BZlhclDKaKC3HsISTnEG57rqZP9KOTedI2j01a4lixNoD/iYHR+MM//gCB3JvjBbc+L+7/0pejrb0j7v3Vvxfvfe97owjR+Gu//utRz/Pi2Cg2YV+Nl73o9njP+98f3/n2NyD8WuIf/oN3xIc+9KEYHBmO8bGxeD0E1e0Qur/3+78Xk5OTnIez8dv/+reirm5j26y83Tvfly4E8tPm0u3hTs8ufQiAVahSk2IguctepOTGn0rjwjhFNQ0cqOmEzrinIjNe+ZeIJAgKiaNKONcd6ID31MstboJrVo9x6khCOLKD6MIbqFSrt+00SNscEiFslvCwp8vwCu5nyFWGBKSGJrW/DB62UWylFlfibRBtLQ2jcLyVaHG7MEsMD6LET7ZBSLXFcSRUjYUJArhOAFN0uJMqRNbXlD+DSkI0RM6Nu1TPoV6PNyORGHOKhGhrsRUBIyhBI0HEjXO0mAJBal+TQGxFP4EkQjPXgGOMTiLFwy0tAW25pilU68Zxbf3Tkh5ZsTOoqX4yGvljIhFTpJ0xBQFivJxXs0h6RgiMODmLHRzj3lKYjI46xgWpksj+tudUmq8i38CYri+Og562Ib3qRl2vjDhyHknULhNHDkg2jZbhdK6LbBaqbnb+o5nc9U/pWtsAm0ge9FhJ/XMQTEy2xASp1HkBCJxpW82jUxmyv6Y9dnYZt87mbdZ24CRSDcWT12Nd5df+Vm3Of0ldLhGT2WisJWayVZF5SUsqgEo/2bOSVz6JQBBp/9kZiTbrUSKlrY5r6CeRlOJJpNRSh/2sBha2rcI9DCTUNT2J5EtCKYea46m0ptrnrvayeZF6zm/zsh1h44RaI5JQtpCYo2tzBPOsgIFVAI3GIizlU13P/L6bF+UdXTno5dJgqhI2ErfaNbo/SC75TsrH83wNZ210DIkDhn2Zql/uR0201VVSSf9sr/d0Xy0hO8P+paQ/D5adw/nhqZNxmrhjNZ2l/QjpxyMLYzE2O5nq7qhpiqY92lBFHF04FmNj0ykAd8O+OoK1SrwjN1wcwkEPccxocz22P0WI/iJqYEPzEylvzf5GYAtDZu54ApoeSAenIMjokzZJS4sDMTE6kxgXDXtVSVyMh+eOELy6mObFFU0d0QVRMEk/5pBsNgDLbz74DTzfPRTjqNy1tbbFdTdch5rbJAQhTJArJGMq4jhqZq0zqO/xq58yp3k/HwUJq959tLd5Ls4+thhDR4kFeAzb1BYcyajvW5ayd/Kxm4sjFXhrLI2rd/PkVdrn2avyd/Jnq77JOAeROV3U0UZ1nHlsgThFFXGC0WOkKDEjkJVEPvnEqSgODsbb/vE7og+C77prrot/9X/+FszDgRiAuOzDxqoa26P+U2dibHwkrsZpRS37iETiVeR98+tej2rhdFx5eH+85fm/jBv1r8Qn/ubTqDI+Px5//Gi8/BW3xwtvfwn2S0rQdtLlCoEdAulyHflLpN9y0RcI7ClCsTb2z4V20U3czdjD2Cjobs/p+M5OYIotcTLZ0DPySGRqAW4XXo5qmxICgMwl5ZMo0X+OpaygABfasqxI1fZ2tZyMOdQfpgiYWcR2pTjdxMGaxSaxtTQ5Ja+V/hSwb2puHENCNAr3tkQYma+UqtET72rsB1GfiOGxruSgYqiiEy9HvCexhKQqlyDl7+Tf5USOyEt2DIKQ0ogtD8RSAeYxIr22IkmahCekcsQrr2flW2Q349Cv9GDlafmVMF8rUdT+aKYF70UgCfUES8ztkWYA30ALiKtM7YQ0WNJFGbXyJm1ynUYN7A1EFWmg0XLg4UZz/VR0N05EB0RsFUgQUz1JCdXbnwLpEfbbTryTVNuYG7NjUAUQ9NWd2A+gkpZLjixLGyElFhKJOhIQYU6EwtaDkprhtHPd1IOUSmCdd7wf2phBHCQT4sOJYLVVINZeiJjrVIEmJQTXvHXc84bQUL1ts5TPxaQ0QTb3DG2LKt1D4PIrGUgSKQrIVPhWSspLpdrlZHmzvFvr3sPd7Fley3K2dRdzqb5sdQhbCaIliAkJQiUhSo60m3MtaGuG2VwqO2/DugIv6IbSXyQrEkellif1N51OpOTsQ1IE4aR0TYcndRBMKQAzbVI1Ttf7EhvC3PXrPqcr/YYhEOVJr9kXJZRcS7yzOEafuxnHRggcytU7WktNQ6p/aHZi2TtlS1WBfUeCYjYFRbVsGSjaGkm4pXYrq2CC6ijA/cZkX2ohpKa5N49DjGqYCxJPzZTXArEzA2GnIwf3YlX+Djf0pb1hgCCvA7Njqf2WIzxSsFkItFT08qDnkIKogeHl2JG1lJC4zkLMwCSq1yYQz23pMU0jxilSpKnlfLZjYHE8vWvL5yDSppDsZDZUWV9GFmCWlAqfmOXdUl15ddp0KT1emhtLuSphoiyhGnznG+6J5zz/udhMTWG/1BezMHxO0j+J3Lw84aXz9DZUqp3nBurOy7WRMmZa21Ciux5350jbZ4gpVEeMIaW5aTGah792tCn0XDfJ+ZKX3QPp287m5HrIesIF6TTE0yh3nAdbJW145/oaoxsV0F2cA2vL8d3k7XG8Ib7C/BgZOhttbQ3YYZ2CSaptKXtcqZ2Sc9//zrfjs5/+fJw4dTL+4Hf/PWsLW6kbr48ObLTm8Lw3cX8x3vWnfxL92HFNwpRx9apud/Daq5EEti33d6s27zy7dCGQ74aXbg93enbJQkCpkZuiKTlm2GZP3bg9SEUIdD6Qpxy1KaA+0l4NoQOC4vE7iQrHIFy//HmeP/92y8dyI3bVtqFtjRre8pHNAw7xalTvEiKRv3Axvml7DR7napAENdePgiig7ocawiKHnipxottz2BkZebyuZhZVunEQ10ylpISKr28FZRZQIaltPxnteMxLpyaHX+LXpkNw/Sv5HWEzC2JSfihufRTmb2bf5hVx0eFAHcjNCiqyOp+/rGdc5GBVbevzbXVnEcRgEnskNCEJGsiIcbDOgrhVodLSlEoGmaNRSmg2sqHaquyn9gyijcCxV7QPIJ3AmyGEkaolwkfYwohmXISzKoagOiCAwiqHxVZwS+2ikLkJCEziblW1I3UtQIgwP8VbLH8OCZbcd6Ub2gBpKF2JytX2UkasuG5MyLeydlNmMkCnknPZB7omVZPVjihHsRKxwq967itRkYiYpm22VwIi3eOX9gv5O1ysS8JKCUlyyMDLSY0NYis5a3A/KDkpsNyVcoAPKwB8PhGXqh2pHifCLmEgUqtq2loifF3lZTckzAxeq4aXTAGoyGR3pYRMRxN1dXoRzP6swx0qJwLKijnnZdYPszFHmMxprrAf0OM05hLGyb7CybUu5Tdl9VSAsDbH4RoCimJ4n4g4xjhJXYC/tjJnkEocnR2MapDMejxFVjo3S0Wkb+ENpbB4ajwWkVBg2Bk9qJrNnh1DZZSAqC2NSApQkabfvQRHHXjiZOzWNTaxrk6gCpah4BKyrEf2MZ1Ku0G5Z9ivdgigq+p70v47hctq9926xkJC4Gv1IjpNm2or49H5fiQ2I9FV0xK78OI5j+Snu313fAumxBCezpZh5ni785X2PapIKZc0CRP/m3xk3joM/o99+/HoxHFD+67u5blOU8rSygp17iS32XyvrN88a6nw9LO8rixnG/1tSAREls8q+iHyiuwdhV1Ivipx+LJYxOGLJIxn5Eq9tp0TA+JoMXYznjPMiFPK7Er7jFUK78ZCNerbMh5cc85/n2T9bWDPOAy07dtxcgxBCUuQ9CL56WGOuSOZfCUFDgeOGXGU3U8P13z4xD9d5F8Ds69JlfVSOeVZHYPZvW2x9/CN8Z//yzvjyit644knTsRNL35OUrPbt29//PiHP4hZXKj//MtfBUF0Q/zW//Fv0rq3HFunXOgvP/GJePjHD8c73vEP4slTx4kb9ZHUTyGctcXPnXQ5Q2CHQLqcR/9p3vd8y9el9/kgKCI8DXCo9CCVoR8imRj+wxVtqW5M7mfVW/dQxKIJhBUbGxDFAbh1Ikalc2IZem6jPrcMD+zyZN6Mt/oT2mwplvMiET+1qF0t1+L99MsWuOH7a23LfZeM6X/2LEGCw6yeeE8+ULWlBmRI26aMADLH+nLyPm/+JM+x9bfIruOTHVGr83rPOCpF/jZ6vjp3drQ6HtMQUw2q1JQy2EZHfqKGWDYdC3Cy6S+E5Sxc0zqIksQZTjWAuDIJjB2lIXhW4tpaLv5vHWK0NuJJEA67yJ8IjRxvEetpVJ60jRLp0IbCPonwytl3WOROb5p4ru3RwigjWIOjii7jL4no+gbIK4i/8Uym4YRTGfZQGtbruENyLIceWUuX5nfuScD4vipZBQkq3pWAEXbLNk/2g4rORSDZEvuxNp8w0I5EaRGhVKgX4o12iFBLxEpYb2Qvk8orfbhHJNU87QYhTPTkt2g5qOsl7I58IroigparBKeJP2f8lMQ/fbDDiyDoVLmcEmx8tlXisaqDybW6sNB+CpuSSiRHEqPCyd+1eg9jDlqmKqqqsymJs/Q0TFvVUXrm+pTwEdHUrbrjoae0ZD9FG1I/LE3CjPWf4jxtUa7jq6Rn/ER/fObTX4rHHj8S06iOOTda8KZ22223xU0veU7MVuMVE+Kjsw3Xy/aXMvUWJtz5n1xTJ1hjKD8HMVpA4v7JT34EaUVz3Pqyl+K5kftKoohn9Wfv+UC8/M5XRe0NPdBS9dGKMwCV60ZRL6uC4lIVrI792u1rCMLAoKrj/SPxrnf9Oa62B5noFdHS3hxvfuOb8GK2N97/vj+L573o+dF6qBsPaV3RW2iP4w/+MB744gNxx5vujK6OlmitaQZiGQNGj4JjC6qy1UVbTWOqZ4TfI3PF5bVg/7K16byHRaY791K/twAnkJfo0C25nve2WK9lheT7nTZsqge2VzWlusuypHaNIanCchDHCBIYi9jv1MQw4z8KXJ2y+RyS6K5gPWFqGV1wh1SzPA7RhMJhKlKL0N0QQGjgxgT3hng2xrfPnVd9lF/L/DFdSR1tnA/KAomO4ERPY++zlIPfjcwDy/FJ3oaUlTyeTOlM5rMl/TE3eJjNU0vJku/5J8Ht/H7pK+6KipFH4hSBd2+77Y7ofea+mKicjjte+bJ48CtfjT9653+J5z3n5+K73/4Bc1VGYS1zkH2Jfcu6CzBczuLd74GvPhAPfPPBGDjTD/MDchIbyOQsgvbupMsbAjsE0uU9/k/r3uvVqprNeS0ytVWn3GALHOwGjFRX3STy2cXh3lLZsHyCpI3dzG7eIBetFQ0xWmnUbpDH5S3e51kyKKnBO5vJVzoW0gPLsRgPxZ904hxalVaOopW6E+mRiCI44XD7pmcyZKYeJwC5Cp25RT5aUBdpxNUp5GF2oEMojIOgiCxuaM/BexfaT+v0kDTexsrxWt6dDEnXccDGz8vzrlx7FErciFzpdlyurTxVEU/7sAihMNZZCSIsIQx6BAxXys8QTU2PsbT6KR6XIlDzIAnEMgFx0U5EQ3WTbmlVq5tAVUjVIY3lJeAdIwnY0/Mj9HeN0wa7pWtn3OfODwHlCVx69yKtQFJBDxMSLTGjyp6BK7X5kDjSMF3Edgb1n5SAjWsmdxMtEaUkJBEvEEYNritKlNuslCEhIiIklO28SOp9WUnn9em0dn74fmqxCDe/5Uirwme/z0Uc5RVmRBLlsHco1aKZiXBIKrqUqsOFJhDdduZ+gyp+pBG83s1AxIiUiUAnws+Jss2UiMREkGWETnotIZfAyz2MuSecLbEKGLorqbo3z3qTwM/7v83q2M9E2HG+AbyyFlOC5dt4TnwJNQnlRDBt1Q/atTCr8xskNqjl7t2zK177C68n8OnxuO+Tn4ldu3riFXe9CpvG1uTkobaiNer6OpHKwJAgBo+uk2dBNocGh2FGzce+PYdiojgRZ48PRi8BU9vJo8OQGQiiU48dRfLSGXt37Y454nvNKvngnRuadtMGPKAdOYFXuaY43Hul+DdqX5MxMV6EUKrkfgftI2bQBKpyuMF+1d2vin0HDsSnPv4/46Mf/qv4e2/7e/EKkOZ2vNA10tbhQdxlH8c2hRhD00ibmhbr41Dj7njy6DHm9hwe5NqxV6FtOFVQXfT00VNpjVzXdygeqemPx6fOJDshGUd68jSkbZLEMXCHfu56gOyIbZ7cX5yz55JM5/uQ41iPtEjPnTJ6XOtpBbgISimvsQ21xz0QK01JiiPTZCnaOCPP8sYZJM/uYvlrI+wx7cxolSy7eEcm31HGWQcjfdTS7USkYPy4RRu/hfFZGAoST6049ciTtl0dnKd5G/L7+ber6ArOmhrynELVbt7zh+RJWUDzoZW9LSOulGxuXIq1FeGIaAHWTn7d7atq9/znPgvJMpJACOgfzw+i5jgWhzp64p//b/8yvvDZ++Jvv/y16OrqiH/2z38jOnCv/qLbX4i3wSuReI7F8172ImIBzsWjONb4uVtuiYqbkZrVN8Sr7npldDAXdWiRKN5liNnqnXQ5QWCHQLqcRvsS7Ov5EEd2X46qCM6Yrn5Lh4XqFq2oJOQHUjmYNFY3KOkYOuEe8hlqVp4juxaNGZvD0J7I5GvzqH6n/v4E74uy/LRTqlEVBziF0ziQmJxtzALY4t2uUIfBbtPoMnFk22x/O57fhIkHrEdWDQdcG4h6M9zcMWLvjEAorfTEN7J8SjCExcqz7fdWYkDu/WZHpMSdh3jmPGD7NYjUq69vDHiDsNo+67AEW67Khoetv9fWbc5EFKx7sv1+nW9O69RQewmEoBnEyIbl7ZJQUmVT7r0t9p//xbDrwIA7UYU6OzecJJ3q4i8qoRgGTR6qx1i+Hk47BMA+frcVoh+jc9Wj/Kc7b6VTEhASRw1wWy1W24hE6IhQ80+JgHFzxGNE6pN0gHzaBjm3baf5JFzIiNoabfUeCL9EEyQVv84v2Q6VCnUYYPn2WwmvdjDiWqPGL9ki+Y5tY3YlWCkFNiXVPYmGUnJeOH8N5jqjF0qQwkbm/BT3JuHA418s1Zu9nb+1xTcwSPZFNCDZNjHHcqLENiUA+8UYGMDTG0rz7JtQTGp8K9m42l6yH1nh+apc/V5yPoEaqykb1ew6zaVSVse1/8nTMfzdozE3NhkDV3XG0DMOxhW4Qi70wExqbYlCB4RRb3OcHh6Jr/7VF6K9syNecfcr488+8sG4+ZnPIkDpcHzqU59OwVTP4ubawKZNeFobGOyPDoiVd/zar0OQVsV9n74vvv61B/EkNh53vurOuOMOjOONccPf5Nnx+NAHPxiDcPpH8DT2pje9Pg7sPxTv/ON3xtn+s/HzEEM3vsvnug8AAEAASURBVPx5yW5Qeznf23VFX1x3+JoYuvlM/M0nPhUjw8PxyU//Tdx9z91x5sTpeM+730svFyCmhqOrk4CijPGnPvLx+OxnPw8BVYizp/vjrlffGS972ctwEf2RePhHj8TwyEg8+7m3xB33vDzGalEBxK5HSY6q2su7HTAbgJiqb26IRlyEO65rUzaXIRy3YPQ4JhK29axx13/GpNKtRYkIWVOso+e51sO+sAvVtFrWnffSJxc1zENcFjCXK+M40s8iRE72HCYZ8Hc5aCfWxs163n+Up0VYQp0waFwe5vW7gXz7KSdrHzfKknk2S+l9yt9NKaqvM6MgdOYhwGpps0yVrI7803Lsou+51tw//A17Mp5k3M6yjmZwaLFAXxb1zArT8iR7wAQ7/ALn3BOT/dHb2Rp3/+IbUiE66xhE+ve1ycdi9/OvTcyUr04+AoOpIZ59z4vjuUu3xwIqgjPsLycrcZl++7MSfnBk6ki8rOZG1uMagNOWnXR5QGCHQLo8xnmnlyUIaD8g907kTRG+qgUFOGzZkbICpoR4oenejzGunD4363Ntk5Oqf0FMeaiVlyfi0QBHupikTyt1XOiVEi+R9o3U/daW6ZE6jw7+SLEbwqgBjmkdnDEOS5wxdLWcSap0mULPSu9sb4oHw63lg690DdiA3SISFwnBPPlGhozVeQADByU1K8/zfBt/m09035hKy/VtmBUpj33nEMy5+OVw3vAVblqmqpRZQNWsVXnb/M4lMBvV7TwQsd/o2Wb1XYz7IgZKigTiRnWLEJl8JgGjLYsEUQNEQyvqN/2TYzE9ApxGcEYxD7GLQ4/mPggfnFPUkE8yUYIR2QhwUd1Hjj3qM0pQ8P4kj3pcV9vYI/EYggzkBs+MroVZYqaYKrDpMGXqXOkyfdh2y0/qVDRQTqztUzIlvG17uavtlTfXX9k/EUPfcRVKJKkKu7umDc4zQYuF0fxojMLA2GguWJ/e4GRQGBhVt8bmc+1LBGyU5LLPAQ+llXLvyZoIPom0Jd537m0vUT6wttcGqZXwES6uDYpal4R9A+1Uvc8xybn9OYHK7UTU+eJmbfeZRSslIrM/1yXVunR8IAzsi+OVOdZARYx3LHsOzvoC9kLP3XtdXNG7O7786HfizOkz0WSsHnWc0p/2mTCP8Ow2OkqoAYJ7CpqxUSQzSIDGcLXcvas3fvFNb45jx47G+97/wXj93zGQal/8x9//wzgN0WQg35uefVO87rWvj0cffzzu+8xn4rrrrgFiEPxI8j73yc8ipayJX/tH/ygeeuj78c1vfBvJJnZQzKm33PvLcdMtz4pji8OpHXbXYK5fgOD64be/Hw985YG48brroqm1OYYh4qanpuJz930hDl97OO6+69XxtQe+Eg9976EYGhki79fjntffE8++5efinf/pnYxZJR7hHoxjSMt+gQCrizArPvSeD8ZNx26KhkM4kVDtmjYuE0dCGbCcwRamYy+2Wk2o5TGWGyUdXmwm8XR2eh5dW0m8HlQQVWlLtjuOE+Xzf1VyrJXh7oGw6YYBBrmTxr88UzbVJICAKUT/Wcq0Za0QVEpxVFVNie961E/riZM1Qik93PT56rSqx6sfbeNXO20o0IYnmWOLSK3sUF59/rp9xMdFipukQmMXkO4mr+fWEoyLSe6NooY8hkTsDDZUrpez7APOY+eNnlUfmjqW1tA881yG2iz3rCeTYmfzfggm3/HZobS/uMNn/zIYe+0Y3dGiRHDjdcSDnXSJQ2CHQLrEB3ine+sh4AbshqiaiRIRY/ms3aRVqRqCSygykaH/68tZe0eiZRxDXxHM8uT72tZ46K4/vspznvvattfTXr05jaNvLsJq+Rslj+8pgr2eHetFYoTrASQMdXiz62rrjxY82iWVOjq+9sizNNUuNkoi7aB36+rM+6WOvOpqo7Qtv7dROeX3hL2xVTy0145DeT77KXFYk9SQbDj94+DL7IPKc258vRGcLM+Atmvrtffe8y8/PDd6f+Oanvpd61UKY90iQFlb/CSVDc0cBjmDJ5BwTCj9YSSZF8a6mmPcmRxw7Wuio7shCs2oAvGeyJalGMBSz179ILhTqBVJBEqINBNPRVufcTxEzaB+JJ5dh6pdAy5yJaCmMMKfIWCl9dQjHRKZlkAyJo7l6vREaVQiIrihtGmBAKTJ+xh2IwWQXgmNOcoq64a92jCJmmj8LhdXaZbvJnsrsEVjbClBbkINdAr1VudB+RjZHpEn7UOEo9JgkZ5MqoPtDX3YjMtvY+zDSpwYwcm71GtZ50rmYBkkFUmJM9shnGTOKNXLmRvlhM6SanjAUURYT3fWY1uTdy7aAuMfohOOO32WuEmxm9a2hfuJwCOf0pl8sghry9P7mVJUiQlhIcFmch+REFMqooSpCtW1OYz4H37skTh55EiM1M7hzXIP/aCktd0v/RZewkhVPvslQdze3hKNEAu7ILL2XrkvBedswd5Hu1GdgNiOXoio+ramOHTtwfji53CZjgc2JY5z2MKdOH4kHn708Tj2xNE09zo7sVNCLa+lHQK5pz1+uHA6jswMxK66dmLxiHQ7R6fiu9/7Ph1ejNvvuAOVueY0v2dnZnDHPRo3Podgr50t0bO7J448dgRVu5Fohojac+VeAqS2RWd3V9RB7D3x+JPxox/+OM5CMOn9TAmXxL5EZB2qbIkaTNArfUCA73/2dUixWBeq626QHBslFWv3Rn+7D+9Ccn8Dbv53Q0ZIHIxABMiO0AVCkSvfL0+Oq7tERh5kDIi1w5Pn9349H/scoJTW59QzoNqfMzChRhj/AnuJdVysxBRJdkoHgZ9EUNbrldKta4G582TFDLZTnjTaQC3EIHN5Ebj7vnn8cz0/iTpmPWWVn2E6VBqexxmIL6cn5s6S+1x5St5Qy2+UXZfvJWW3dy4vIwjsEEiX0WDvdBUIsFd6cKsqxBkdDXVw+vhXfmB50J/FIYPIxPlskh43xptQHacxbdreMeFRKanZqa6zxj4ky7CtT7d5keVqED5Rn2YQQ5FEkZKVI2ClKOMaDYz1IAUw+OA8gQQHo615CKRND3C8kTdv5ZVUjsiuMFqXgfwJSeSJ9W1Up3dFICQ8MviVFb7J5fnA2PKtV2Re/SpVNkTKRSfPNwlLOcEZAbICDJFPFTCtQzhdSNnn25b1+ZWWzMAZHUsxipScaUeVtZXcdH92BuLoJEjuFDYB3ZC06mclyWigDglnFfZvUyNzBUxd6Kz0MIOihLaSzanA5TAPk90R60KbI20zREYasMXQoYnE2iSG+bNFJDVcV+NQoAJXzJltV1VC6EVYtJ0REXeMkoQC4kj1MvNbjm/omnm7SbuxAvMxQymzHojYKyFZco6CTIkgtYJYLi2hGMTas3brN3nt/PAvSW6Aj9KHhJmL7J8jleewX+4NyXaJ9yR4JBTT3lEOXJ5pB6TTCiVQDovtmKduCaPklME7SJXyJKx0Nb4AUmpRShKSZFAHDjzzZnJJTn0STcnJhPc3SJWIBLRhW0B9SWLS9vErSVlkbyhRc2bP2Rfez/qY2cVom1lA9clgpd3X74vB2pNxChW7joN7ownvbBVSb+mtrGKbUKMaJUSssPA91QiTKiEPzS6aO4dKH0Vn75aabb/yfteDtA+MFVNsmjQs5K1GYlkDA+s5L3gOBvmviALqbw3sfaPYNNmGReqZQLVKxw4WqYSwpa0lfv6ue5BcdcUf/s7vxpGjR1Lg1rTnS1wyHpPECKplCqRgycyLuroCRP9U8npWi03MUgnmxiK6BmnWXa+jvN29MQOB1Uz5jy/2s3PQgtQfLsqSziOSN8Sye/ml2ZO93Jq9yhGXSXO4siWuqWqNRsbN/rVCnLSwv9k54XyaiXSanWlORkheKN+ube2LlPJ2IQHK3i7LsM1L+3QWyYwSGssfoswu1Oxqqe9iJ2NubYZ8aqc0ugZG44lYYiaVOp4YC0iUlEKVQ8MZne0B3jVzOaQudi92yrvUIbDZHL3U+73Tvx0IeO6ANEzhuQ47j1JyOxUZbQRx1ulCTnysoFx5zo2/ObY5qOHQ8v7ysWKhG52mGxex6V3LU0KTky4im8YMUVqTc8ZEfIyHdHasO0aLneLLBIXFs1TzYDQQ+NV2lB8oayuzDsuSo2xgRg+c5UQ/VL6q0ZaCfzoDyDnhy3m4EFZyr6eRTmzvgMqQM2QX5cVseL16HASsxvOoX9Fmf203Wc6Kat1KH0W8lUqpJiic8/avrne7tTy1fCK1wwvjOAkgBhX/lEJqd6MaXcUsHr1O0vvpqmjvY4xxWb7Si5V6RSI3JB3TnJTQFFnmH0SUSKSSHePPiNg2wEVvJh6PNjkGvJwqwtPmeQ336xsbUBuDwFISALIzATFnPRabiuaeSLxEWw2EkYSO88m8lred5EwXmVfdLJP+OOt4n5oWaa+SLueyBH0b9nJKbmVOjM1PJomSyLfzWM9UhgSwZXpsq6I9NnIb9NG6ZkoczROMah4VMmGr7VANhGJSJ6RA1a70fieBpATJMZE4sw/Gl0rSIN5TClRev21NBBHtdTz8nSRcNHUJVSh/S4BYosSHOGtax9wvT5ZpPr2kSTwkF+jkkVkh7CQwlGTLqJEIc6zy5HOlcLp7rqcnurzf9eyDtBNnDYxlcR5HLiDtzTxLqobAYgFit76JoKktLfHg/V+NU8eOx1fvfwAbpJ9L9SVPgdlVNu6l5mYxn+zzUnwaO6F+7Ik0lt9/YF/09PZQH2MMzG7DqP797/1A8v43jTOHg/uuiKsOXpUxAig3DWTeAX7bzjn60NPTGy940Qvji5//Im68u5DazSPZqYlbnndzfOKv/2ecePwYKns/IiBrAalWd3R2dsZfvO/P4v4r7o/7UcN7zWvuiVtvuzW+9/2HsGP6ZLS245J8ejZe9bq7AxdxqeblavMLBvzhr30vOvd2R8++PcyzFQJYOCv9mS2THglve6DU6BnEnNsNMZSNawak9FkaX+dSF0RkEUJ0pEQQ5tVatpLVE6g36ziiHaIhPyPyPGu/fce/fCV6LZF1lJL0bOhvTpUYr16IToiurVLW2pUcvnshyVqG6IcqgLZh0wRMall3Kb5WmbMI8zu3dVBivKu8b5uWs/NgBwLngEDVvyKdI8/O4x0I/ExBwK3zG8XHn3KbLEeErbm6wLaabet+ihC0YcfRigqS6KV55PL5T+Rlq+TR1IxHHSUoy4mKVNkzArp1bl3C8lvrLkRlGyGI8lgclmS7RRjljnvAaGd0amRPjBXxO1QzEz2tZ6O7tR81KSUC5jh37fZVw/QGEGAJMt/J35IYkSsuZ1q7BbE8kdC1/UrINghhhgKs68q6G9YgAp04g+ueJrQwjUPm/SkLqiinUBsIueJ5+zZ4dd0t6ypAZHiQrk22Nw96ufbZef0GICJ4CZlNiO15vb2cOYM8NiFQLEUi2EK6xSg2H4OnJ2NyGGJlN4Rcm0QBjjOwwxmBOBhGxUQvfUpWVkZuucjlC8dsCucVRRgBOdx1DqF7aZG7JCEhj5Kj8XHUi7AXqTUWUXMjcwuJEMiahIDliPznyT7Pg0xqx1JNXJ8CiKlqbiLvkilJzYzvrcbMeS2Rrf2AXrWsw2R/nOuq7tUyhqpbziERmkXipQWG66OpUkmDKlDZ3NTu0Mrsk/3M/7ISt/mZxpO9APWuJB0BYxXpnpuEiQKxJEIvErvsojutSeaSEmX6kIg6kX4INevPCKQVCEhIWIZOSPRUaHuV2qW2UnAilkpt993kJpy8uVSJjBBGvMa95HDE9qW5nK0Vr5XsSnQan2qG8VqpfTUMbKvBViWWpiF8p+dRt+RaoquBOdVX3xEHeq+IPfv2xhRSykkQ8xuuvIpA1Cq5Rbz0ZS+NZ970jOju2YXHsL5o6+2MOoJv9vZ2Ry8OFOpBbru6uuLwoauiu68nbnjGtTEFHA9efRjnCHcnFbc2VN36UMk7xL1Dh6/CccLZaOfei1784ti1e3f0EGeo6/9n782DbE2uws6sverWXm/v13trQRJCarQiGCEh2wzhYYABz4QnHGbMOAg7wDPDGAYm7LEdhMMR5g8mYmwIvMAwWGMbwwAOY7MY2Z5gMItkZLXR1mq1pF5ev6Vevdr3ZX6/kzfrfvfWvVW36r1uqfvdfK/u/e73ZZ48eTK/zHPyLPnAJZjp1bSMIOgBrY+NX0xPPPRwuvzIVXxUgPfoI+kCgs9DDzyYHkSwuvroQ+nNb31rBIhYWV1L73nP16Z3f/170iOPPJJe/9VvZEwxv46Pp1WeXbxyIT355DvT29/9ZES7gyTpP/vAN6TalZl0gw0L3xNp3pwQbBlrNcKWj9Je+64kx6+0dLYy2R+adr9l8Fx6x8C5CMtt7jLOI1PLhzPxOv3iKuIGRgN6vhbmKqZxrmZHQwVlYJbxGAPzvYhVwQtoa+Y5T2+BsXMLLU1VMHEu3KCAgUo4g/ZIEpY2Fp/vJ8ogsG7yd4O/YQR6Wn8k/3E3zL0Nvb7IIeia91XnLa+dD/I9Psm3h/nw8gJHNExjvkrgmZIiF89X3TQ8lpqlxPHfXzv+WLw3x+fqPX2tUgAhnFm4l3oUeBVRwInv7934rXuG8SUOeJ3rn2iaUH0pnLRdTDDiQKOwEaGVZRqsv9P07/7sAyPnMQtSg1R/tfgy8ttLOISeNTnxGxjBHeHWF1Ymd4XFd3l9NvyN9vfYUceU7vzkPAxkEYxOW7MLuKZLYyFIuJPvv9YkfXT2Fwe1bY2UW2/ginWedaJXyX9c+8wDa5lWCRhgXTllKlju5CSjafQ1zTpwhMc0UWGsbSIP8QojoEY3kNvC8CbouUuuE7rmZTK1Z03isUOfLq7P4aDOob8HOJw/B5M8uZ9GHoTO9IGpiq/j78rwHO10vLSOmMge9FjYW03zu8u5rNkqQLx0ddgkpPL2ygZhwTF3w59DoUTNUdbgmIeoVwhkm5qucb2Nj9LWGgcOo2ky2tkEGpvST5p1GawkotxFfS2VZtTi0zKdcLeU2swpQjQPbNO/aIZkbhXcETUoCX1glNRyLiE8rhwQN6tpfFYqOumSykK7o3BE3sDKeyHwaK6HORhtHER4VAgTZ/OZCjmlUQhW3FPY8UGmCfd5ptmdIa8VjqZhrg/Is45gYo0FRgC8y4/DOs8Ix0ATHoh9aXgWIWo7Pb9xC98wQoCPnU+P1C5Cc7QcaJoUWqW//iwLmCuHVh6bz6VttdhoPDFtNtjDAYKcm0pjBF6Q8b2+vsBmwF6aHh4ntLqHt66kcxwoe26Ec3+gyc0Nwwdwbpmac/w9v7R5K6ITXhiaTlcR3CapY3VnI93aWSKi4zRwxqLvrGeJM4yM1Hh+ZBJfzBHgo1VjTJw7GEu/9E9/MXzrlDI/+fH/mL6LwAzn3/pw2sI0cGq4xrgawCd1JX1+7Rq1G+yg/WaOBxyH1kyhnGTfKXBqLqsWz+T6cZ4jJZ7sV2uURZnGiIksTX0eMBgjmp1dJ9raKoJM/ZXPmSufjjtNUh/CimAaKarM2DEe+VAwUhBaQKj1LDXvl/FVvivgAtdxKPw6Dh039FBJ5nVk3gKfF9z+q2t8bPWD5LyKZscZL+eLLi9Fj3wr/NieZxXWwM0yK/tu9uQNRWnvGHE8ee33/uZBuv1sH0L0KP6VzXOrtLy2sxBCUqN1R6rt6safv/jB+iZhV9l7mV5jFOjAJbzGWtlrzn1LAU0u3FE9Ls1zdsLgMIfmsfNcFionaZOLsTverE8hoKhRcXfKPe2SJ+csn073R1M+1NMy7Z4ezd96R4bXMNiNJarkyE78OzCKt1YusPBvsWt6E9+q1WyuceiQW/J3+43gw4J+EybFFrkwzXCI7tzAZBMAnXplFozAtcJOrtqknDJ76651N0k6aybXWFKPlmrum27oiEBEf50n9LUaIzUPWfsgpKOUjBoBO8QOaCzanfIcRa3zHeC5q4xzRuc8JzwR0wF8UzxA9tbipbTD7mntALO7KcywoK9jszU5ZlcQ6kMb0frw8Hemg58xLltIKlyd0hUuhwldrFmL0dgMP1yEI0HZa5plKhCqZdKMrJ98+oyMo4WUjIhECNw5uED2rYFNtL955gGp1d32gl7HPiKDqG5wqO3qxgrh6GscMnou/GAUWhQ2+mAEDQTgQZ+jaLFqMHgKg5qWVVNucog81dtN14U+cbCrbfCf/kKYJIXgC8Omlsz6YvuENrWQMtoXPmJA5jHj0jN2cjS/bRj1HbR0u5sw0CNECuRPGquh1YTtNCnGGvi0o6dwjqNpN/X4fj+3dSsEE+vwPXHT5jbCwyLHHOhfprllhNOwoSSy5UbHj/q1kdm5n8eu+PrQVMdwk3s83MeH7bnVmwFE+mkKWoQDWGaOI6ilOc6wk1bz4HCLP5PPbiOYPUcAB4XksqllNS9u3UYIQxPDxo3p7WgJ3v/Hvyl94g/+MC3cmk/f8xe/N80+fiU9tf18urGxFDhm/HjfYNVnEM7a0hfcnvnYJ9MUwSNmL54P3zu1bm4I6CdVRoUtnGA+nw3RLo89WgbsTCZx3aWRW5w6q6Zvk9+LCCJrwNKi7LiZxPZt0Eefxw9tDKQ9M2iaKKZqXOeJALcIjB0AGKSlrIp2U6dxYf8aHOILHKb9BCG1izG6oYue58wko8e50JTu8zv0ZJgLui22wXs4Rlv8a63FO8JfoB+eoZZ1AoPoA+YBvfMEWdDE2FQfRod1eHGwq/A3zYHF22loTO20Y4h79IGDSSHKf6VsAOp99ChwSgr0BKRTEqyX/SuDAvtO8CwaZfe8HVa7HHK4z0Lozu0gO3udkpGcrnN2DHMzh6M2hCTzO+mOsZBpIudkq+ahnwVSs45WvxcnfLIzcdcdtwVAcvEJIYtr85wmmV/TOn1POiV9DkY4xPbBuecxfdpGWFGgu/vFIeOa4RiadpEdW536m7RjICVdZEhklFZgkk/bRtsle6AvSWM59G5zUhiLyppvt/3lwlujLy8OTxJUNtNuBMSCgcOkzF3q9nhmpk/BTmGqfZ62VR65GXRxsa74IhzJ1OUNI9SNDhG1TbPCOyNpfAwBCfOmkCnbwJDJWmIH1vHqAcj+bpc6MUZm14Rsj4hrbjD0E5lLB/wIbgJt1MY52NV+qOnYJOKYvkWhKYFqYYqHYKI5qNqibcaFoZINKawPT/gh8cyDZtsym+2QbbnnuD+AiVwmktUwHhPniu8FRHH8a+IoF+jY9FBdw1zMI1iuHeRzkxRS7F+1NB3IEzUGfsCR4TIF60VIwD6EP32bhoFfQyOh7842AtpJSQbXyHZqMz1bzU2cuqwYEeD2oYs1hSktc1ed1EHvdrAVCp3jFDxtx8AQ7TphU6gdnJPuZawUEqA7CIpj0IJPaet1aCwRZNb0AYE5PkyZdPlnp2twz1BpBo2WJtFD0CNS8OIw47TNO575NTc4EfOG4zjjkrP62whl+p+FIM5twSvIbzhe0SQ53bh/9NT6F9Mj4xfSV/3n74kNgLXtzfSHnIGjSXSuv8BkLaDPnd87pR3MLdUai6Dzhwc6Z0a/0WjxnEdDsjRAND/GoMElVtHobAN2h80Zzykywpvj0nN9ivhhrZ1rbmBkTbYTXR3hV9BgYwJn68XEtqvdkz7CdcbV1LimJouC3m1N1rkMnKcJ7nOBsNpqkjSp816jVbmUv5f4+BR5Fe3dMHAjwJDiF5HuxiG6K7E0cE357P5S+vT+IrgSZMIAEzx3jhYL85iqdXjfsTE5NJZ2h/rSnRcP+HPTwydoImfIfxmT4BArudVLPQrcBQU6c413AbRXtEeBl5MCMgzPzz+arsy+EEyjwlJrcifbk9w1fdEx+7jkU3dGb2AC1zeCmUZfQ0hy2nVJ9Lykrdh9xjcCptNda3dKXQYIQMr0nOuQeXD3qprcRbRsmfCrz066tn7rllny+mhqOIan4TUey7Q213+0zOnvCNHFbgFzrAeGzh0FQIZhoi/JkOtQX8WggXfjqix7JZ/f4dN0FDJ38rLdoHLbTE03ZYgvD80GzauLvgyPi7B90imZR/8XGYmCZ6e8x92Xse7roB05rly7Z9JnEPv8icEVhIwNHAPwOYNBoEs6Jsf0AmZFI2p+GMVVOlhIespEHkl0U5gHKuwihGQNT9Z4qDldxoQqxA6RIq+mSqIRu/tuRsDAal4n82cymyaSWzDy0rWfneK9HbVfMGh3wchb3xDaFkOXL8NwDu6iUYBhdjNkexvTzrVt/F0INzAC06VmC/PY4LrBRw2Ywp4+TjJcZ02afQ3xfqpBDWZcgpyQHOf6boW/F8JiBHtQAwXeIwSaUEsngyuDHRHv1IhxL/yQ1KLwT2HIP825ol+pVjr3A6NfQVba0y77614kNy/0P5JmHnJaTI1jDAUGWUCxLucq36FjhuYhSiEIaYcXmU/GVaGJwRmtci7aGdpJs2yCjBEUp6iWFg3zvIVoQGaFkyhTp0OuQYopHIhlDr3+9Ma19PT6Sw0hgTm0Oo9bTkbfaKRqVNsmxv4b3/s10Rbr1dQwC0fNua3TJ586wHIBLNRvGexG2AorYmXyM/d2/Dz1Ry6viV9enUK0I+jKFoE2VtEua3qq+Z90MFS+kSDt49BK1+lVKhWndYQ1w2oLN1Mw41ny+O2dTPf6eOS3G5Cazi2wqWCAj0vUuErdn9pbTDedy0iKvMLUr9Q2t0s+128reo2NkdlHITXHHKzxbjset9AmrbyEiSvr8ugV6mes9lKPAndDgZ6AdDfU65X9MlGAHcqt8fTCwsPpyvSLRNvCVrkiJLmbKnM6hE9Ada51Fz4SX3nJaKDvpOy+1c2txTQw2p/GWa5c/E3KG6MsXmqR4jcfLp41FuXVLX1w3EHm7A6ye79pgueei5EapKb7AenkDxcDF4Xjkovs3BAn1MN0ylS5kPjvLPUdV4/PNBdZGSDyHwKidVSTNFeLtOOOeP1Zxh+mDRoqPLr02Q3m1SdEMz6T+fVVMtqZZnEubc3Qj/6Ogm0+rGOovpCWPmxky7vdYlJwbDwrV0CIyoV0xkTRu/E7aq1VdDy3anpsIe3WMKucsH/VVHZOPtNPxKANF/DHONV4oMNkyPWpsK/4jKAdwvTEegMf8JpF/YdBAdA2xVlMmKsaxEGGUn7Ws4QUw6S3Jns7WwqeCEicrXQ3Sbz66to5YZe+9hwftVRbBolAOOzDHEfTs+DB6ZeIMsc7s8E7mc06u8ciBBJfdOr2hVe42cV0if1vMDg5yQgqTBn4YK2udXOs2w4FJBl9BUtDrW+hwcsCEFWpgVNgVcar191aWwnYIPxRNB0KUBswjt3g1Qqr+luG2cNLPavM98ZAEpouGi0u/GqkAy91eWfLOGt+v8rdBuQDxoukzB+N+91e2Xd38GlaxudIP6HZoYnY6JrfWoZ+jQiaR99ihR9qkY5+1f/xdfi7XOc75skbVb4HpnrWZtpyc+HaPBEeMUQbHwzBJDIf+Tjg3RjE15FNDtcqnksGzeC8rqN1pNRZbxRcbadrhZHuDGQy2Lec7uDj5Wy9TIAXz9XTFHkGQUl/VzeS8tjJPVngiEdoEXnqO5d1h86ntiOXqOaNNtUptsSbssRK+tz+fEQLLfNwLpVb6HW1vDDF3XPbzmNOqUB3ffcO5n2YPzqFjJiDjZlphDHe+4N51m4C19CMXupR4K4o0BOQ7op8vcJfDgo4FT8w9wKR2TiXZW807W0McojhMutsnlYjZLErIDOtO5QyUtu7GOHscoY3HMYQju6a5/Xj11GSZS2tW/RLWwvh4F7zDIqYelkcmZQ1c8vnGOUJXJZriAhAK5tTmBiNpbkap3JTV/4X1YemYpmF56xJZsnd2+oC0grLBc7da0N+u2DFzjO/jZikKZT/TkzSin/S6rgk/DtoJcYQPt2RbIXM3nUwgIY2lg5G8yt+MJnCDegur1rhyMSZDK8tYyMMmTHNddwJt5cMAlFMZSLzMR8uoOMDaBba5bF5bR+UzPkMmW7PcCqlXolvUR/A72WPsd2H9iiYyxMqtk9lfDzYUsanOhYkQyaFn5V+51KmuH8478BGP8IUm8vw55oERW5u2CcRkhktRyRwi7NgKC+Tv4Z2yQNmwz8JgWWXP9Mo/kkKVkV7Y1uEpVB2N8kxtYHmSPPaWg0mEL8gTdBkxNReIX7AzBsKGu0Cf6dOtE/G3oAKkSDE9g6MJ/0SgssJAKXhOtqtnR20bjTaDRX9tdSqBX7Al/Hf5P3ddaOhpZMtz82WWoAD3frwW9JuTCZYfy8d54VvVMJK77aUPf6n84HnZblx4TgoNUtP50NnAdtRhS/zbH7nB5O/NZvSpMrx5waWfxQ8vvIunoqT2rY7mytpmeiOmuHyk7tVjNoAOuFxmxJxS4wt6tzqeEXv15gzodULn342zT50KY0/PItJaXm/MjTLiZcaRM9vCxPK/Chg2k97jE1jDb6cyT4QF6O0GjzCQDqFHG5SxUYV84VzqNEg3aAL7RNjyuQZWx7h4PESHqTuuNXseoz85vOvvhRH/uqHEKy9+KaKi0KZ2iufiIvaIMeLo0W8HGeaU2rZAYlJfekiQTmubd1BQMePLCqDsgGcHiKwBhFA8v3SMIv1Uo8Cp6TAy/smnhKZXvbXDgUMC/y7v/u7Rxr0wQ9+kMP/skbkd37nd9IaZ6tU05ve9Kb00EMPVW8dvWbSmxu/HdPnKNqZ22vn08HGdJoa06E2z4iG09V/QoZJH5AhT4aHYbtGCOw9nFa1yx4m9PXo6CYRlNZx5OaMDxYnFzC1PQpJl4YIlY1GpMyxniKvW6+LpJN0MAZw+FOjK+nm0gWi1F1Nlwmrfbt/CedhdrrQaunvoJPwiQt2wHVBqDIhmgIpmpU6rddrWsViWkyYZPMyjuoUZGhgTGCWvK8Jlf5SMhFtk+sIsHQ6Dyfy0ti2mfPNLQQZNRNDfTjB1KkRT4DlsqbpUDsw4t2a3EllmY3bljGHMPQR2oDaMhNSxYW4myQMqQCfSTpan3QTd0dGWxx5rolgK9PXTd0vex6Yv+ApwZHLrpOaOrVIMq0yZqUf1AfMEc5eMxt9RjqNUQVOXytNSkv0OTcHIlAB71lsQogN78egGh2Ib5jxeFeCowFvBIq9LYQCxwb3wu+m3j8yy2qWaNahUNZ141oybiF87CKUDY/B2I0yzzDs1R4ZFU6BbIZolb6X60TM2sNTweApp0niHj5l4GobbILC3yZ1KuiclPS98l2MMN1wdDJ1ARO4wwo5/FsHlu1Qe3RciplCWuI8ubPPu7iLZmAYp3i7gILF1K3de3Ac3PIM0JnxhUH2nWpNDkHxrTL65vG90lSs8X6JKdp2tBQbtO2kdgnjtEkaxhwnUiclEHMT7TRJsM4JBknY4j0oc0gIETqv2pE8f/xr3xQmqQMK5vGm5bfNT4UCVp4sNkrcShK+ve+3eTu9i5Uid30pBq29Wup1jo8ogmAiXiHwMhd7vc47Uw7ntbeNYrjCbK2m1s08gx1dQKCxve26wzous7bqOzhEP0yyjhSBaRbBxvnfDbaYk0BymjkqrwOZluJtX6gJ9lwp6Wxyvd9fgcJjmA0OQ0symreXehQ4KwV6AtJZKdcrdywFPvGJT6S/9bf+Vpx3Uc34dV/3dSEgyVz8tb/219LkJFbJLCYlfe/3fu/JAhKZi9+R68y58YU0v3oOAeh8OjcxzzqVmRhNTmK3FyZuH1OuidG99OC559ICeQ/Y3htGKBpGA2RQg7w0ZSycwGWfrhG4wV02BRGnYCfbxoSPgCJDEwdSECqWsNrXFq+kL80/lLbxjdocnsfkYyoOrcxQj/8UtgEQZDYUDvJea/bZaNRJu8FgHYFHxk5TogkdbNm5yxqbXEdZRoSpudo4edQiHEkA1nTnwDbAVHXLNLhIunPamqxXYbCKb2uedr/FszV5TziaZ5na5YkHLR+WMYKWvjcuwtXkoqqWqnOAhqw9krnvtr4q/Jf7OuhKGw7odyWkLKzATIGsY9Z/prgP9ar3NWVcQEi6HJsT5svPPSvpSt8sBzR6IC078EH1AHP4oQCllkhBSCZUjUyUZ/xnOJl97mMTwnfO5G54qcP3e2BiII1gerQf2hf6NHb6gcO7FcEF9EOBWbL+0o4AdIqPLZzrhwAzQjhyfQ9jT4CPoBtN1mRIbYZ+NDLU7pQ3wsZ3X5FlbWu/9FD44juEJfD32WGKivlVueU7ZrCL1iSD6E68ZnUbtEN6V4o1Zfe+cHYPxmFOOZ7Ac2eGMY/ib5j6dxAAs84s79SLp2jFRkgTpM4/1CCOMzbUHjS1qUORdv1Wmh/jgNa42RMH/naA8Urdji6ifR0J3AYRaa5/jHNDHlGO0yLU1EcsDR6bGIsxHW6v1bFQh9mgSaMSaa0AYjTQHKim8ezluyLsuQJrbBAcxar6Dtq3Wk40VhCfNnI0rnzv8+HWavIuuEkondskNblGFzUJv/6Wxm8tCGrQo8a6VZ6bpySvnc9c29RcrTGnO5/0E+Wib4fYdg+g8UTDnvvLtdQZ7FTdHThV21Xq7n3fXxQ4yuXcX+3vtfZlosDnPve59Ja3vCX9xE/8RNsann/++XCk/umf/uk4xbxtpi5v9qP5OTdxO91Yupxur55P5yduhQAVjAxRsozAlSM9oV3BLO+B2RcDcmHHnHvzcteo0MXPXfI8EZeJuvHcK5kt/5lvCAf6SzM30q2lS+xqjTBpL+Mn5e70yQyfbFs+uFSDaiL9gO9lFg9NDZYMnc237JILg8KRi1oszjA+M0N4S7GDuYGgp9lDWWi0Cw9hCwZRMzd9g0o5cQdUfAQTCbDT+Mu4MOXdwcaiJTyZTc1oxO1epbPAgiwIhOs4HnMOTz2CG+tnmE8qWLaFSSHNKw39Kw3b5rlXjbpbOLRlCB+TyzinT9D/7mjf2F5kbBCUAIb20sg05xSNhpP4Tc6D2aoLfPqPLRPt8NGRC3EWlMLsMgfLmvRR0jfhFqGRq8yIz+I3deojoema75VnO8lwaxrzlumH0zTn2tzGMf4zGy9Cxf304MgMfjAI5kQCu0kY/UiUG8BsbwC/oHgv2Mi4QNj4N05exUSMsMHr8+kLO7eO1m+H8scnMhQ904bxNLT48g4RHBFcNI0Vnv8UXOxL3//1rfVw5B5AiKtN1OKdW+N9OsuYDVNAV09CruuH5B82cU3RMjXByji3ZxIpHck2Ef4gaLtGGzRJ7DT+ovm8y+u702hjaANC0czoMjNINkjaosJN2uwmhnkVgC/jn6iplJsNdwifXMJbl/qr39IsTMDIr3b3uCSOtk/m3guFn07J3tPUdoxof+vbBAegPzu1sROMe3afsXGW5AZLbnEubb+pD5LOkYD7mf/vqTR7lQNxH7qSNY31R+2+LDaKz5n+rdmMWvgvf7KP1YB5uHQWHU6u0zLdpJyrjzOMVmNsXKwISQVCg4qd29s6B5W6hWGAnYiCybVzjO+27/TOOmHxRzl2YtyAMo5jIq7y6hkq3znQ+T02eChXcClwq9+u6R5s7Tp3fM5qqd71a5ECx8/cr8UW99r0ilBAAemNb3xjx7p87mnq5zjp/G6TS63mcZemr6etnZF0Y/nSEZD5vBKXNwQNGDP/1ELF9THTZeycYed8dEKlTiZSnaHzhI/wNYDwhW/UBGcQGTTCSb7zEpBR9LnCi7tl5pal2mMyv8WZLe56TWN+MIkWyzz6JlSFnGkido2x7yjDOg6LZSQio2MZPEKH1gEmeOGLu07VTvzVJIPr6h7R0KoPjr3OmrN+6LcOXcTZxVMhUYHuKJ06AxM3cep28e0MqeUJSEjHBcKSay8vfJn21jNwDkuBiAzDiiF5v5yM2yFCx19IY01Y3jpwNc2+uJ9etzWX3lC7GoztwxxS/NUHV9LU83vpjWhUHxo+H7u60jo0QYyhuT18c26spQv45M3g2G4fZo3BSAQJkHYyg/ZpXMenv3l/GC8DRIWzjCZ204TbHZnfSU/92u+m2W2YcQSjB4ge+Jb9y+nyzf70loEHIrJchpQ3HYJJUaCg/MTBSNp89nb67L/5WHqYgz5lTDQJdKxHGTQ0u5jnbW0hfmuihwbqSAJU+PEgtK1yNsuN/WXO71rhfJVVTOkw2CG2+C4C1OYa/QuMzfUt/JTQuMDezsR7cppR26jdOcV6Q8MCvTQVzNo16ORvid5F8sDUHfBbQXO0Y/jpDmVC6ONA1f1+oo2xQ/7g1GK6OE6UwnitG++2V3RT8PJujuiQb9ASHe/P4eSusNQONd8ThR3znSQciaK+jkucWWM4bLdwfJNL8qr1vZYe+ql4SKvChTi0w6PAeDm+pUtEoWugeqZqHP8hHEXpOjAaM31hlvO/al1p4227c+YG86hm3a8UNcRd7VG3ZstnIZB9v4SQdHNvOYQSzeYUzOO4Cxqex8dZIOdx57xkEs44vreugzurCEajbog6tvL48rlj2bVxBlM9/XTVOh236rh+uh4bir/es1bVS/chBY7fIroPCdJr8r2hgALQCCF4f+RHfiR95jOfSfoWff/3f3+6evVqVPDMM8+Eed2P//iPJ32RZmdn05/9s382vf/97z+CgLCWlpYO748QQjhdOPwZF06IapIUkq5j6nZj8XI6P30rBKfmnKf75WKyimZGJku7eqfMPDVnOO7Y71JvTPziEGzkyXXkBdaDDqcI3YyZALv7amUMTOBOvouvSVMFzdn8t8hhemUR1ZfEg1vLb3gsRKRGQAQZXB1dneDFN4ShKuY8kFHoYAFBiaNJOMKLs0648iyRfYJdeIaG2iMZW593m8yrSYa0eDmSQo9mZefQUqxzLdNdxc9rmfV19haL8FR9/nLgdDcwNauSKR/G1n98aT9du/VC+vEf/bH0jve8I/3X/8OfSwvDM5wFVEsf+dXfTP/0w/8k/Y9/9QfTI+95M0JMLU2jbdpnPOwiYLzw7AvpV//JL6Vv+fZvTRff9ii+QZgW4pMzMTiWXjfxQIxnGbfn1ogThYbp8fHL6dzwFPTbS7c3l9MXNm+kKfI+PnsFxmMsXXvp8+mjv/8H6Yl3vCn1TYMjgsLnPvu59Ou//Kvpv/mL352GZ1lmUKYOw3A8Mno5Xa1diH4wktvO2lb60vOfSf/xP3w8vfObvj597dQTsdu7QYhkmejzozPh3/OllevphfVbESFxsE6HQ1rSaTJk+tBpkGl/JvrbH953c2F6bBwfxWkEGPzbCJCggO/balhwhb4FBKrYlWYo+q50q1GNyHHUqY9VRMrDScV+Cu0RspzBF45LCplbvEfWbZlOSZ8l/bucG8bw0zDYzDZ4blFE00GjnagJM/lej0Fr39NxhJ0sjDTesVxLeZsrNUJHzZtC4Kvcbr30fVUTq4mib6+Cksx2joymLsv3imiFtMf3G3KEVi/mG545zsYwgdxG47bBvCezG/OTEtS9Sq2gwCECWWBeGYEcqIdbZ0qC1uxarX+TCRn4P/LW14UQr+llhu9nA5nGVa7adhtN0eMiIjogzLsaPEfny5fcUGxex16OumyDQpLae+eLDcziDLbjeFVjpvBuQIeTxlsVN8dKq2Cn0LtHuO/tTcbgede0ZhPWQnMpqsnoMJuaO4S/80Da6tpjPmkvXlr8rnKibilbxaF3ff9QoCcg3T99/Yq11AAN169fT5cvX05/+k//6fQN3/AN6Rd/8RfT933f96UPf/jDaWJiIj399NNpYWEhveENb0jve9/70q/92q+lv/JX/kr6sR/7saSfUjX97b/9t9Nv//ZvH9569NFH07f/3A8e/m5cwPLAKFyZvRZhwDe2xvA78ri8u005uo6+K5ptZdV7hqkGZJLdqQUn2y4XeBcO/YLO46MUTvOUk5GSOXFpNFUn5j6YObyOYrfRZT2c62F4XVzKTlrGJn8KwR27Yj7hb6+ri0E1/0nXtstFKIQymG2daoWvTmETZnivbyOgZ8xPglaeUw4I+gTdTbJOGb52dUtDTT0UFjPTkWvKZTSfxN+DRdugEl+pyTaIbzCldzbSwmdup8mVsVSbHOe8IYRzwtp+/jNPp80XF9JbHnokLb90O33iP/wHGHyEZfzsHk1z6ZPP/FH6zd/59TR34Vz6xm/6Jri7MSKvZYYewKFlczw+3D+Tnv3oZ5L+g2948xvTu979DvqZqIXXbqT/97f/Rfj1fN03vi89ceVtaXtjK33+o59K//apT4Z5iwy8goaR62SIhhkXam3EX9wd2a8fvpwe3JhIH/2t307Xb9xIT77zHZjhvjndGnw2/BJHOChy84u30iqbIe9+93vSNeaQj/z6r6TLD1xNb37XW9P4xEj69OoLmLNhNhd+REd7LY+D/OnToBsa2R38DAcH0arCmHs2UvgO+ZSxMYmAv80u/p0tNL8UNbR5t0nmLoQpDqnVnE94EZKbhscutS9Ou8RzA1PoWE6hdjniXvgsQVsDTLijnQ8qNTCDghUbM4x+D9/UYV2/JYN6s4EOk6cmeQTzrWHGj8xw/md0xh3oUX1jMs6840gyuwOaIVEf5TulhnCkEJDb5+aIxxk4HyoU1fV/1AouzFiGAS8QLeGmj9EOPTNLZ3w1vB0o1QmNE+9HpLx6LvvJP4MqqPkXRwVKhX7nIVO39duvbpY5/zaVAv4XPvG5NDY3kYbPsXkFwBB1oKUCifUqlEcpBCx7pNTrlX6kiBChxSXe6qkEhwDU5Yciu6aXCnkKty9ncnwssjY6HjwjT6I4VhSe0SfFOFNbo1ByUrJ/NK87En0S2m4sM+a22TiYIJfE5Mv8pkzl5mvb7jqun1IjufHg1qRCtIL8vR+Tjbp6V68GCpw8Kl8Nrejh+BVFAQWgX/iFX0hzc3MEQshnnbz5zW9O3/3d350+8pGPpG/7tm9Lf+Nv/I1gUtQcmd773vcmtUo///M/f0RA+uZv/ub0+te//rCNs8A9blqXHZgkspzmcyVlFqHxu9zv9tuSTs5G8pqGYSmMgeWdgJ1WtXGu1hB7dN4ggxouk5/mNUzpKFogFw5vykQIpzqZR37agOdEurmzyMKSzcXcRR6Psq253bl14cGcyGAJh49ZlFh8XZCreAv/5GS0oGF22jkbA22BuAuX/bpDaC54p02W0f+jVatzGjiT7I5PwvTOc5aHUZfatc17CrbGE+iDUZEZhEUMU8WsvWospKep+5XIK+7TCN9TmMEtz99Jz//eM+n1BxNpYelmmr82lh575PF04dKFNDM3lf7T7//H9F9d/Y70xS/8EcLHLTYeXudgSJ/91KfTz/z9f5ge5/dLn/xM+vRTn+L9+y+DMbUNDhHP3rnCEY4f/3cfTb/567+RvvqtX53+9b/8zbR8605621u+Jv3UT/4EQsoDvMtD6Wf+zj9If+H7/kL6wrNfSD/7s/9X+tp3vSM994UvouFlpxhGRZoOGd+YMR1MKTXIuMMyppn1ofQvfuVX0ksIXI89+mj6pz/3j9N3fed3YpJKeHqY/U/84cfTL/2zX07f/u3fnl744gvpZ3/u59LM+dn07L//nXT91o30zj/5/nRubDLdhuGiqq6SNNSsRvMa31rHrveyAABuaDEU5DxYGr4IAYqwzao8KklGW+0QxeqCWfNz26mfYwRugPHyHezTjyg89SuA6pcRtc/AMYzL6ADvg1gEq6CSor3SpE5hbVDfHYSjfA5RLiKD6Z/aEN++YfKOcFBzH/SfxO9uFt+wIuQURtx3zXlB8UUh1vo1WXQDwRbZBp8OAaOUFbVq2uY9c1MjYESp/NQ6ZLbd9ijUkc4lOc6qqfxWy+VB3ppftWoGqvnbXQujUcPRHK39qHji/FW0BIRTgBLQETpoAZCtAApmR+GVO74vBlQ4MghBZvXOEud7MRZmmNuLRFhnwsVVmsicy4iHJgV8FJ6qSc28Y2A0ouNVn9yba1voWFIQcE17OZN1uaHXpGnjXm5xFpbURBo4pTXPUbwMvJDXMZ9JP+ebWI1W8OMbh7b4OPo+ZgsK/SVzPvu+2rPW7zhwzJX3w75Rc27eEbTOrf1inb10f1GgJyDdX/39irTWCUrtUTU9/jjM3AVCYb/0UtyenuZUt5ak5qiqKSqP/9Sf+lPlMr7Vhfy9G7/VdK/1x6FwxEy4wRlFmr4ZyvvwfmuBLn47qao5MZKRZjt5woUlgMFwovZ5SV4brEGGvB/zPM9dykJaXpTzNN+YshtXGYKTtYzW0sEaAsAy9e6GqUrgwIJr8Aid0QsOVBO4KXTIOFVxcQFwBze2xQqCXX3jI8LZE5fwK4ldYODkxUQ26KzJiEjZPMd+rOLZPUTMHdn1v4hJ2TBM4SiM+43dpdiJboUhnQ21vhEIu3cqQ5lbYd1nq7+1lpfjt7vUw6Fl9BSS7c2BdAkm/09804fSH33qj9KthTswudBhbDQ99thj6dNPfyY9e/259OlPfyq94XWPp1HOANpc30ifm386PfrY4+kv/k9/Kd26PZ+e/eTTEe6+NFwGQiZ1Y2E1fexjH02PU/ad73lPMPu/+zu/F5HgZnlvf+B/+cvp5ku30j9jA+PX/+VvwLj3p/ehGf7v/vz3pP/01MfTr/zCP8dkyhDOjLM6Uf3y3VAIUVNSmx5PH/gTH0qLtxbSiy9eS+O1WnrxhRfTgw89mP4ITdQLzz2fvuVbvzV9HRrl3/q3v5Vu3riZ/ovv+rb0sd/7aHrphWvp9vVbaewh3uVNBCT60Ir8PC7JBOpflfudEhRQZ6DJZRwmCr5GjdMsrx9hxLmrJN/dECAQoHiBEZ5gfCvPSz6/vV+eqfHNzHkDVsmrj9I+8CKoQ7kpjdDo7WyBA3UMYZo8oHBF/x8cjLKRoq8jYxbcba+CjoxivD/ccJ5QV6F2e5RNA7UD1uNBrpqVKWCZ1Jiq/dGnK3ylBFhSvV15AyELSWG6V57zrQBhIBA3N5yf2qXWu/4WZq7Jz+YcPpFRVQu/6tyFsFJyt4Nf7lm/5aSIYyz3by7ZXEMuYQ6jjvov45Lv+3tUc0TeMcfEZt3kLz9t/rScPnIdtTsI0l/13rfFPLwK099ulhRD+84/8ZQJ10fGf2pYHEPm8Xwix4BiTCdaN2PX/S/hR31ooLd8Z7sveuqcvnnj9K3t6JTM000bHfGe91fSChslBh4ZJHrd5homqLPbvMdsePiOMUZ9P0yOY/2OFAqr9Th+YnwWgHxbynFo/+iL1Ev3NwV6AtL93f8vS+u/+MUvpr/+1/96+pt/828ehuxWMLp169ahD9IP//APp3e9613pu77ruw5x0LTnAXaqu0kqh4LnZzJUcijMyZGyzJEKJy9x/tGFiZuY3K0weTolny055SqcGHnIydXl3Ak1L815+ff6ztpcRNVzQh7kvKVLMy+xU64ZXl4AZVQ0gWmXZLA2YNhubS/hTAvjtDsKU4s5FX99NLo2vJZeOLgDQ4TzKdHKFBZcBCznolBtnfjpi+O5FeLbbTKvYXkvjkzR0nymRykrO1aiCJV7J39nRsbADrbddBp8qvAVGIzUFnhBD4W3y4Oz6cX66ezVRbCUE2eXv5LOWncp/3J/D8IoGZzDgzgdT6MTo+kFnOH/4c/8n5iLDaZ3vvedwXh6ptgjjz+a5udvp4/8xkcQOK6lr3//+8KnR8FkfY1oftO12PUfn5rEx+8b0zOf/WwEFPCdcSfbcbhHpLmbN/Dzee7FNH/rNkz6cHry7W/jnLLVNDUzjekV1CNC1IUL59Ptl26mMQSw2SsXeBc08iKKFCaivhvhc2PY+HqSARzFrG2EsbpFkIR/96//XXr26c+lRx97DCGCjQMEDyPQvfD8i1F+jyhu+/gILWF+q1D0z3/+l4F0kN745jelSfA3iuMeW/Pb+/h/cNCz55kdl2SqPAPKaH1jCNMGCRBjTVaVOFZX19LG+jrnJo0SPECdQiPloAtI1nXhKCLXNR53vqL5IbOAd3UsFnghSZkNAABAAElEQVStwpECi8JRaKng//aH8O3DN3Frey7NcK6RwV8kjlR182ODOUEGziTN/ZPJnlJrJG3w7bJ+hbQsHJoHkzwFAOnrnFkVjgQkFAGRNDvSDA/dBm8WApbqV+YWzfOycJTzdftZ5sZO+a1WQVYmuluNRgS2YX7Sr8nyhPVgXnfzg75FA6PJXrVeaadWLOdujE9xKvnGEUhl47USKPd8XpKaBYNdMKTbJ+6vLRKxEQ3SgfHmO+Sr3s6bawjGboD5vrs2UYH1eyizONm39yI5Fq1bGqntyxrLewG5ASPTLdfjp5s8J5nPGfa+umY1oDVfCbsIPV67UeDBuuurbHZsEA3wiibTzZuDQsg+chtosQlCgzmfKcYc48H5qSHAx6P4cI03cIr5eun+pcC9efPuX/r1Wt6GAo8++igHsI6mn/qpn0o/+IM/mDY3N9NP/uRPRiCGD33oQ1HiySefTP/oH/2j9La3vS09/PDD6Vd/9VcjmIM+SCclJ/n3Dl1IH8dpexVmYRhm7rg0RAjsYaJbPb/wSLo6+3wcKHtWIcm6nXDV1Lj7qEaJPatYNGPxYUZVOLpJyPF9mBVZpEGYi+HBBiPn5C4M85cJuCxe7tJqyz+P07hmcfv7BEAgMt/mdo3dvuH4ViM1NMAht8OrqTaykaZGlsLsb2wQHxAmdpkZ69W+Xh8bv/OSdRyVjj6bxFcF6/DDRankyAvV0YXI9gyxw+ouX1nIqmU0oxE/8501uZReJGCAvhXiYfIzm0UMs/PaOBU+Hnb4aNC9Q4Z7fLvUJ9hu2p93tvP0bNmxmYn0hm95X3r6eSJD3WS8E3RgizC9MrrnZ86lRx5+JP3fH/7H6Y9/8x9D+Hgi/f7v/n749czMzqSn//DZtL9BdDcEjn/173+f6JJfFbTzwM6L/ZOcR1JLK2N9aJ5ehxAyk777v/9zaXFtMa3eWsKU7tn0yd/8DUyHFtPW4kZ69pnPpye/5mvSGkLFFwjEsEd0uTsLS2kZE7tBBAnP8ulHQJJZVYgmflp6F4EfZJJuPPt8+iIBV779O78jXcVf6p98+MNh3jaE5uYDf+wD6eu/6RvSr/0//yo2UR5/+LH0xOueSD/wQ/8zGwO8bxuraXtyIITE9e1xNgMQCMbWEACyP85x3aXgsYnQtXGwQRjuzTAvrCGw6aydJmCy4j1jKwF69IGLNA2miXLS3nZ1LRxF/7pRQUKjwMA87PCAyS0F0/gDrt+a9Q1Sr2aG4rq9O5HWti8RWIIw/vhQkgUcPWNMDVD2mamOITdHDPW/v2P0P8xJ8esZwFxO5Ms7Yktk+PYQHsSjWl4c1FwV0z7bbB726xEm+YUsdpb5QxKYhFc+47LlQ1w029O8qeDbkqXpp0x3rS4c+cDyIcxFoxBiEMjXeDcMIVHqFf+sxai23NKVxLyZZ5JSqvKMS3GTKklTRjulng5x5t6zT30uTT44lyYfIjprBxPLUq58F9pmOpW7OYCNQqltc5yfNRX4io1qplxf1gw8RFvODjVjY9uFX/6pldFUzm+9rbohQbwXtO8kXJwTNU/M2re8gTTG5uf8MoEfRthsGW0PQ7g+GWRjKfdsrslX06AN21gYtJY0R+7X1l7hQS/dNxToCUj3TVe/sg39gR/4gfSjP/qj6Tu+4zuiYk3s/u7f/buphlmNST+kp556Kn3P93xP+CkZ8c4gDa0BGiJzm4+JjX4WQRYPFvaTkruGs5PzMEmj6aU7D8BYjqS58flgPE4q2+65E6fMvhqbLXay9/dqsavtzvbmzhjM5TkYERYJhKIaGqvp2hKMo4xJnpgt7y6twpWLn+YALueGmV7lQFeFpJjSWTRG0T6NDm1QdiEtIXhdB/e9PR2yiQqE0LS4epBu4FidBaZNBCZ2yj0wknOZ+ghYYYL9ie/TfLi8GRq8dXlQa+cOZDbraYbowujhklusii7AubV5oXHn+bRarGbomXU5x5ku+ljkxauRQwFpEm3aCov/SQKheTW3kImPnVSgFVwbEO/dlbSsMlTSL/teta/VxVoGw53jJkETbVHf+YuMkeG0MLCH39BGnOczMTed3vrk29PrP/rR9E58goaHhjFfG0vjUxMEbnhL+thHP5b+1+//oTRFYId3vefd+AaeS2urq+mnf+rvp1/GV3BifCJ96AMfSB/64IfST/2Df5D+4GMfI8JkLX3wQx9K73zb16aPfuIP0//2Q3811Qhf/AaElj/xJ78lfekLX0i/9wd/kH74L/0QChYClWAyOwyjPwbO0Tcw/LfRGP+dH/vxVBsbS+dm59IHPvB+olm+Of3E//5/ZK0UwsATjz6WjEp5kQASb3/7k2ntzkr6rd/81+nP/Ld/Jj3+xGPpR/7yD4PLWHrv+74uvelD70I7QLh7BIVJNgZqvPp7BBTwfKbW8dDce7wBCCMxgtQ2c6UloGNyAEFplHZtI+i5o+6hqqZg2hRwTH5Xphk1QQKp9mnOWP+sd2vAoA61HCY1OoMILgaYaErMYYOcDbXP/LDOO33AHHJ5eCvNjW4hmKkRMUQ9swWwxKiMGvHQPHKKTZQB/L4YVcyH+E4gpJrRd1T/qvBlUnAFvu9vNfV7H3PJdgKglHKH3fekpVgVRBfXWbNzQF8Brin50wiYJZpd08MjP2yvwlE+2qD1ccYxM+zRP9woeEs559usI2otmX/bSt/N41qrEFfVcom/PqHhkwR9H33LE2mXuOsH9HWpu11tuY48MzuONHmLIXaEPi032gFruWe/Wcr6bY9mkQpFqwiN+smaSp74cYYP8Xde01dHrZpzvzAd2fnzOCo2KhRPzyjaJ9CP4edbzTobOfNeg0KOwSxsnT09tEcwEqi/P02AEDYIuXVMKlTPWaSPAtIIWihN5J1FhJupdwyY3qP7hgKYsddXhPumyb2GvpIUmJ+fj53sdj5H4rG2tpaMenfp0qXODEcLwg7Zjzz379MfpQW0R+0Xy5YiTHoufv2YrYzEAYsjHBg7jqnaXbHGzKea+ujjtLmFhgefI7U9nsk0iVCkYDSMpkemoAhHBS/n8ZicnfARiFwk8o5em+mZhXcDuLdWLrILPIyGxl1uFmHuZ5M9liVwiSUDwAMwz7XhdTRMayEweS371G1bC24PcaaOi2A1GShCH6IsxFWfKKBwdgQaA81GXJAVPkwuO2sIfmqzhH2WZDkDRVwYnOlcHHpwNny6gc/WFkxBG0pGWVmRKbQmLukKqgq72YfsrNgdRcm6Xex1lvcMjiouMlge2LmKQCxtWpN4TYPfxZa2ypevQ1IsSoA9mN6hmSGM/cQEJ9IjkGxtEk1wNAf72NtSUwI7iDZngOhOX7p+DTM9/MkevBIHNK+i9Vnd0OQTWDDJs7PTaXpqNi2vLIdp2+TcTBq/OAlTRVAS/GBuv3gjGPzzD3IYM35xA8jetS2EIMztZs5Nw5wQOpcd3D9c+Twq1v307unXp80lemNL4Z6xjvB08dyFNIK/2PP4HRkee5o6CBSVxkbZVFhfSUOYEaop2VpeTzOTUyHUfOHZLyLAEab84lx6evtG+jgmTPbV1KjRvmArebnWeHeytpUxjq9TmJadsHEi3Utv2zc5xLdl87u0i8bJCIHu3A+AswfjmtQy7WyGXgWzPEy8FLzAOeD5oteTmiAFLoWjopkpz6JiC7Sk3X2FP5hONlYG2NxwnLrF4XtU8HXu00ROPMRZv6PzbBooOLhZpMDnhJMj5DFYyK/Z4yD9s4qZ4fWNxfCzsc1GxjOwRCdBT23gKGPYs8F85+8m6YeiNjEmwzogqaUeY42Q7s5+nVImVQ4WM4458XHalAyTM6WAqXBQkjBGeWdy2PPmOa3k8VtzaYWgPGtVn+Trgkv1ibRUSKrBbNvftqcqRFXzeu2c6twwRF6/1bQgT5Ea46f8MjCO0fI69ZH5SrK0s7waFv3PNjFnXkNj6BxX1paS96zfZRwqGI15XlYAcgsyU+Zu4CqMqx3UaqHyKjWBtB6FvHXmJd8Ke3LpS77/+FVdRePZweTWcprX2f/NVM7g3QTA0JX1XP8+T/XK7fnzFz8YG1VNSPR+3DcU6AlI901Xv3Ya6mT20y/9m7TNIZDtdj6Pa6k+PKZWgeW4Msc9C2M2Zlwn4AOY0T3ML5yBBwkrbDquHsuUVGWgy73GN7t1sZAi5sBACRneDb8khSUYU3fVd2GQEdb2driHoLAfzJZmBftpavwOPlDXQ3A7Dp9GfRx4iD38ZQ78NLmgGO1nnYUjm881L+W2whDEanZM5neRXuYwQimjJbfn6SiinjWpTXlohKiIFdO6drDU6uFiS9Q/gjao5WvJJJ09j2cCXPMzA2wYUS8fYtiav6V4Vz9laGaJPDetT0gs4bmnD2EryGHWcW1nAbrCRLdAdTf2wuB0CFdloS5ZFFA9APXWOgv58rn08MZmmljHHw2fBzVHqwjnO2xF10YGYeR3MdWCBg8TMZHIkgoRi9u6McNYD40WkA5SnhH9EKHSqIA1zuXaxHT1Nn5JRj2zLZ65JS5LO/lgUMNIXyBIhv5F22gpZME2d7bSjbUFxhnnF43Povm0jvoYjzqMjoaWEU2f73BEWjQHzI2w/S29RqnfA1Plkh7moFt9pNQwfAmB7hoC18DAOj5N+ObApOlgr9nZuoyg/jUKSJSLsPkhLDSa2e6qCBy7CD27tDmEHQUQOmUQoa6fvwGEI88gEh+Fk20OmdW/a3gcBhHzXn2IFFiMOHdEGKpUal3mi9EALEnjl0y1Qp3joGWkmOVwfFjeaHua4lWT5WoIIOfHZvFJHIl2KCiWFBok+slomLfYPNgM7S71Za68ZGv6VggZUzNS37HfgL6+x9Z1ltROQBKOpspZ+KqPkxbg3tWsKvoadrxo41qyNf30Xc5jqxmmFDYYhL6LrQKH7fK9WGEjp2zsNAE94Yc1Sedrv/d0ql2ZTVMPnDsSxdD6c+h1IvfZ8aRmDOPW4X1pb7RS35lqyj2rcNCAIWw1cbeY93xXNHLOySf3Jomr83ANvNzca4zMewNfKNZhKHYDYXRCvPSVQUeMqjj/HLMPbnqzjxEyXlsM7rdL0muKecxQDe2AFzrZ/yusXQpgPQGpHSXvn3t5W+z+aW+vpa8FCjCT7cAgaZN82tStgNAtXFkG+BYSSPFf7ZGpm3q6Xbpq/Zrc5KAELiHucF3fdSd4ORisvMjWtUlwdruYsmxjTnh75Vxa35rE5G8uNE9XZl9kJx8H5BOCVLhQ6DMSDt4wr+7YefK6S66LjM+ryXuGAve+uPinkOAuo4xK3pE7KghUYZx0LTxdxjMD2Tm3YY9lgR4Ymksv7tyOwyxbMc6u5xlPO81dXEOGG+0uB5BobWGuTzgya7K4mju1S9Jiemgc4WaSK7HNvWPecuW9MLBk4LSrqd09yyuE3CJa3x0EkTub59P8CiG/lzfSpU0OSMa0coTQwoROTH0w0WsAWZllHFzkrw/H8VUOWuZe0AJEPB+qmoJfY+zcIRCEeJYdbdtz0wAOBAwxBUPPKNAf5kubN3Ne7lvmAKHBDYsBhLN54aMlKynDr9OA+AjRcAUGxtcu+IamBo2GARH6sH8TnlG9FujNlf5NGBYYoS2Fpm00Y7B/MYZzPoUt/Ygigh7lQhChew7w1SuMcAgm0hv8Ivy2FdTzGhRCwYe9BPoWCtF4/YLKeUgBz7I0QgFogKMLdhEU97Y18ZXZVq4CB9pvu9pt2thOI9VVHeOFFybC9WksowSASqr+Uuipli/ZPH9qgw2Zpb3VNADtDKxQTbYn3mH9cmAe2+FXze+148Qx7iHZOwjPUrqKS2v+k34HDQFQhWF7s6lpfVy0ABGHiBqndow2noSBsH1H3MTJI6MZoK1QQ+SBtp6G1ApPhlg8z5KiXRQd5Kwux41joiQh+h6p7VM7IhFOqsXibtysMicpIGVNk1A8pFffMMyqmbcUWLIfzU4cBaFwaIr3PK6OfjRoc1yuo+XU7nhemqOrlXZHc7e/Y7tOarsaYmnUKVne1cDzvzwXbG1wHcEoWyeMo3E7CDN1tYDNQOzfbTRrg7SjXSp4SVfhaO7eS/c3BXoC0v3d/6/a1jdPfa/aZpyIuMxOmNDA9LvAO+mPsKt4CfOr5/cXYDBadpMREIbQrA3j+2S0u5VNzo3BNG+N7+dvP5we4BDdMe4L5zgh7k5of7LJxnLsqu5EtDx39xops01qj4wkJ8wsFMRl7AJuwdAaVepuk+Yy7vDCKgCqLGXtoWYqZaakNYfPsr6i+YnC4ATMuP407mg3mIicT3MnI6CNsHhqQmiwiQ2Ev9Z85hZPa+mEpU+OC2cs07hECNt83ko2YnFXcwGBY5mt0kEY3pFBBAWiyq33nU/L4FKDAR+fqqWhK5NpY345HVy/k3Ym0DbiqBPCDsLPof9JvDxt3qAO92VOW5kNOhqKNDPiIIbmJVM/O2e31FH9STZ9ZPYRjobQ9MSZPDDiQ2pqxJUaPUByFDNBBew7aIeMPDeMcDTIBoBaQJk0TQAjcAFwmphbAVS41BLaenAY+GhhfWwwA4WFfiLYqeyK8uCwgyCmsONvTehCoKjAUqPUvz0YmqNBtDkGWAgtGELW/i64c1JrEcwAQtv4UzgqzDewQtDSxC06B2ROSApG2QyweVQN45c2yp8igWNynfdtmjcv2kIjA3fqWd1fiwiAtrub5BjUTyv3ZjclOudxvLd7G3ynpUm7Z95rjVTXuYbGE9/t/P417pUr2+67ayTEPoQkTdyq41qa5Tm2lDjdt+Uvve0xKzkUZKUfvRyhrsNPqdsOoJzvR8zuMccfNU/eVIPChpyWFEZqdD5qTaX/crUI5ODSzxzmO+0/TaVDIGkt2PJbAU0fIcsI8ywpZsWyXkF73kTSUYI4LtSAqenxX8mTR0ruIymzCyL7aH3jjL8YR3VBlL5d4Z3L52o1w7e9bqDlGSAQOPJh+9wgzBYRzeWPZO7deE1ToCcgvaa7t9e4VzsFXCBc1KqLkguFoa5dsNTstJvsFX40J9QPyvDiSwpKyxfTc/OPxCG6E2NLEQGvnSmgdWnKdRNtRU55odKmfYCd+zHMKzI+GTc1RZrUyVQNwPCV0NQKd+MsVqt9nDPD87zYna1HZP4W2SG/ODDdRIvjoLVndtyB3YmdVx3cq8yZ5js6/MbBleycu1DDToTvgsKR7bHdMheagOyjxdT0qLqE+lzzMJ8pQGQ6NWNpnQo84te278iu5m2BA3DPDSLwcO1p9H7nujwIeYny/enGnUtpcfxcGlomUuO1zfTAJOfgEKAhTXNy/fX1tHmLgz0nMEObRLM42iLQNKN1979Arqs+hih7RmxTa6NABDPD0IHuCilQHc5nCHPVcczX/K0D+7lhD8xVMIL2bBCocbqD2ebCAcKgGg4YpEay1xz/jTsKNXuYxq0vEX0SoWh4DN9FtUklk7h7DRL6Ne2trqfdTcY7/ke7nk+EkGG0TM9KolgaQajaWsfXpK5FUhNUhCRx6zOKHEmsDvHjfjZ3g/VTgiwo8+2YCHTFoSUF4472SDglRRsQjCaG0EmA0AZmjivbG2kF38qxYQRLaCZ4/YyyZnQ7NBi6oueAD93pAI5iUzA43bdsbW5whuhnJ+FIyGpN9Ks67B9vnpiEevwYN4dmrR5OOoEArkZYSkgrmeIJInfq36ImqqSMcfl1zDcZb3/2xTTCeV81ok7SiJi79SOK4BBt+vYYaPHIun2nqvNUKeMz51xNmcvRCeWZ35axTc5zCji+FWXjIr+natsJqoOZmtE/29WR4eC/xRzfbq6q1nfctbhq+ucakhM+iNDFfs645Lvm09x3GYNQ51mFuWHyKNg6Y4bQGMJQxtajAsxfff99/6YwEd+gj50zHXnCPW1yE+Ys5U5bTy//Vy4FegLSV27f9DB7GSnggviVPvll/AoTJ8aN5KLiorXcWMcbDytXCkqeAzVXWwhBaXF9Jq1vThCG/AqLD4d3IjxNji7jPA8zWDcPLMWrC1e5F2aNLvR1hlSsXFzdhfTaEM+Tg55NhPBBNk+DPz84hb/NHRa5swtJwl7eWQ8nWx21Oy3mgSeZVwjpbIjcdm2wrALIIMxjq/ApVz16gD6MZzqnK/DJoMt2iUNJMm7m29XnByaljCVh+9udShn55lK5tEyNDFgpU2BWv6O9aO700TC/wlS1LXbBFELS3tRAmj+4kO7szaWx1fk0en0rnXsc876Hx+kYaLCwmGoIBWNrB2nxEn5JNcZTtSHVSl+Ja+qOcNYKRwgbbLVHGG/pLlpqevr2GEP4PRkRz3abavQH8aaCZoUWU/iTyNyt4HcQwRXU1AA3xkaLZiYEihpBIHieBR5GMkLNAP4Urcm+1UxqF+FnF6FK5muYSHu8JIdZfe5faIZogwKS8PytpqeP96AIYGFyhRCjiZytMYACW+QhdIlXaM+kB21UOG9Nmi4W07rADbO+YerSV0wtiONjWx8hhM49xv0yZkdj+IdpfuUZaDKmksMd+S1wUzA5Wktrrff2t+32r1EvQmiwvLl/q7V5J5j6yN0oUc3T7tp+VyzVX3Of969TEqLahWVoodmYGgXHn8kgM57ppYbXW/a9THYnrVQUqn/YN2sv8b7hYzc1NxYBMPrRdjrCNIM8TTK3dPDNL7i0851aJxiOGtR2SdO7LAQeNU2Od4RCiidGBfQwYf1uyvtWhScuBq4wj/rss4weMTSKqSmPAz4B3Ikq4uf86wZJFt0yRZrmQGDFb0G1vO/eNyCD74Bmh91oyQK5yod49tL9TYGjq8P9TY9e6+8DCrjoyfzIkIQPwKuwzS4AZVfvpIk8P2fXnPOgLk7dSAcTt1jwYayIhrdjUAcDOhCRbMTw4IYjjyXQGpp3Lr2vudMwi35JeSHLC3RewtTQ4MCO8BaJm+PoW67CW17Hj8Xywj1LkknRd6bGrnmnRNemRYMY4KzciS7el0HaYDdTYSvjXYEIM6NQNBRMjS3Mi3olR1wqNqk924UBrSYZP/0EdMhuh4PmITlUbbXU0Wtr3qFB4teOZkY6m0HwNez7wt4sPgh7aRTzusk5zCHPw7zDbG/UKM2ZZEMb9FGLc//RGl/mOxBD4WgfEySFBpMC0WGKjvAjMzyGrHYHOfdAHotVesr86BOhNiAYWHfsjSpnpgwmYJUP3/cRAiso/IYmCCHDucDAHlkC1jSKPwSZYmJHhkx/GbAWJleh6WC0oeWQSdMkTyENhQ6md/yul9GkTiY5NGfANx2oivLbOmHWTeZvYvaovwg0+awidtTBX98Ld9ZtqpG3tjjyIGjD9TKBOByXk/pR4MPiYZoKUo652G23Hit7xZKhwmlnpVL7VK1Aa/KOmgOZ+0K71jzH/XbLQ21J3rA5Cr9aNoKzYLK6g/+WXkmhIQZHNb9xOK6Z+S3eWcOS+6gKo3FNCHLEhze/9+0R3MONFQtb9ngsGhB8xxVQFIr0o3KTRU2zYztroap56XeeGL2tXQ3C0sJADU1+fxpl218dn0s8NLWeQuhQ63aaESQl9miLW2hVWojjSSnnKDnb5x/gDKS9TZ65DA1YQ87nlRo0BTuFM4ebptQF2kl19573KNATkHpj4L6gQJk2Xfz22ZF1N+4AU55w5G7ZffpKIkjwZe0WEtQAQ0TM82BWtSFO+yclaWB4cLMaQHiQEOQjBG2I2y5erOYyGIallrlSy3FjezGe54+66RIAmpe6ShYuZXCaEriOH4ylK/h/3Ni+E4dCdoNvEwx+iL8OtC5w7ep3ASzC0UlmFcLSPG4f3DSf04Ak6FOptF0dlcfQEV8g+mBHPwAYgJJkaDUJbLcbK0NuXtmebhbqFkqWKuJbfAeILDA3MQ8Dgp/J3lSaXyAS3Avb6eq4u+geGloonYXYJgCv5A+Q9b1TEBhgHMj8+jvs1YpwYIMcO7RpCY+j/oPVdC4R7htKVZN0U2tiKPk7mB5qdtOUmrM3PRrELC0CK3B3m8Nzt9GymQx37TOj32nip1YnaBf5YboxtQvBxUFWTyEQVXBTGySDpsCj+aCCif5JJZlf5n1frZFtj1QfZYC1zD5tDyauvEN8K9gxXQU+vrwFA7+l5yamgDvAywIFppSM65tbBPMYwo/NiGOYCkmjrWC2z7L/X0f1zF+YktqtlfKBe2u/8dyuM+CL2q78q1Lo8I7POr2djo78vLnk0V8llwFHfCN1zI/NH2heaGwpTf0MqtL+jc5w7TPz7e7g30ThPs61En63ydao7dsGl2J+axtti8KuQWpaATqXKEy1S9ad6dAdFgrPnSgqfKFoAbCEkDSJX2AIsHWEpJV/mWqd6/NJg64ZuyONIs9p0wjHC6xex7dsaSdNXGhoeYWT8coayTq6FRxOW1Mv//1Ggcbsfb+1vNfe1yQFXDRkUMpOrJO+DJbalggksOMdps36ai2DvImTq7uJnaf2Lw+pnNzF3b/GwtLARSHv4hBMMb4qmoGU5aDbdrj8yswrctTYGZzANEThSPM4k0zoysBmnGFUljMPm6wuc5Hx8CNjLLOQF74G1jrv1zBJe2B4Lt0gAp9nALUyvodgOlyYX2GmHQbyrYs4oqs5Ok44EiPL2x7HgWZ4Mpc1duRlcDQhjPHRAYfW2/aOTG9VQLKOHLmv1ceIEOQwQQv4UsmwFpq2wjztb6O6nUMruEuo99v7s2lo8VZKXyRIx4NAgjPtZ8zH31i3I+O0GJyQH4KokdlTrSLzubUbQkrRiMQbqZDE2AqhA/8dabiAtlAtw7nBidgJLn0nbRd2VtOd7ZWQ90MwOQGF6mPnhvB10iStrlUzjHeYzWG+xgvA5gNjgXwhsPltcpCdkMTlABNTw3HHWUhhOlcRDYClGV3ko5VqrJyvTH4qOMXcVTG1U1Bz0JpP88Bt8NgfQauAr9EOEfjW1glJzHgaRKMlppr2Cd+dfs8y8t4Wz7882iMqJ9UpmH/waZ+7geC/alLjEeJRzCGNJ5b3vY7ojzDz+gsaOMV3KHy+6jU4DxquvhlqA067K2EbFMCygxGlraEhN7+1eEDpDsLLcWkff5hnPvapdO6hS+nSI1e7tk4QVwNH6BuWR0Gmlwew1li31GZn4bdRu2XCvyg2yJqDyvgsxlAj+7FXQVfeKelQpVu5Ln2X+8BQ6Jjs0lY1uGrifUcVHz1naJQ5tDUJx7w+W6/7ICnYSW81wEdHRyuEzr8Z1mlwkvO6poni+AIRHEfQok/zvsQ61ShX2tK407vqUeBkCvQEpJNp1MvxKqLAHgcEhbkKs7nMrruRI5qjsNMf5jN1ZsTVYMjdYXZnOZUlFqg40btpifjyN9xgCTLxbf1uaAOeGmFypimN5mcGSwjmgxVBFqRzcoHDDAfBaHJIAxN1KDJyDaZFxsDDWTdYEF1gpjg7aJrfmisoUHZKnRh/hSQNWa4MzqZ53HANMNFtcnGWIWoNrGB5d2yXDtYRjhYDT/O2Ju/ZPs2T3J12N3gDXxDvu1gbzthoUGMhIGYGvRVGt7+loMyozMMYTEHRJMm4zROaXXv+TjTqto7WfMNEtbs4cyPd3LuYltbH0+giIajP79Ne/GfucLYLWOzUMAfrgslvhX1Xv+kbhZAQjgRE/Y6lXYSlfnyN+o0Ih9DQp5akTTKanwKRwSr0F1nHnFEBc41vtTxs/OeocaooTpNkoPxP3QZwMGhD+ArVhaEmhvQ0NLMtCCd9aIL2iIa3g5bKs5KGMMWLwVZwjOrRhDFO3NQpKTZ4/O2tSpMMYb6FtmubwBAKXnvjMKa0f5c6tjgsWCFK4WpIekJLfZQ8I0qqOhazeR3E8rVF+GpqX6n8Zfymp4GeG+TYV4NabXepWm1JFunyHUv4/mRfqqzD8X0VRv5nczSHFT6CIO9WmFvGr+4/hOW8RlBtNnKAVR8H3UJwo2mVMOrTT1xKk5MzYeopzJzymG8Hy7OOPHspH06bu92NoFHMwiIYOe1qjI5mCEL3sFaFY+eaki9oxr01hBGPmVU4KbRvhpB/mV+6r4VgmTWMzpVGJzXWnBYKhabmtR7NWqE2142BarRSD4TO6wiPW1JEpMQUVGFUOLZZTZSCfINWLYW6+GnXTz2EWSVzytLzmu+ythGn5rg2dwG2l6VHAXiFXupR4DVCgTBRkeGgPU7A7mjJoMbOq8xUPcXuKoyETIITvJNznI1BMAPtrI+Y7JSCLd/50Nn6sgTDlZeWlkx3+dPl3hCuYxwC2m4RCfxpx1RfLU0N11gsXcpgoKhXp1tDQ8sTlYVNNkInZk+V97wey9kC4fivJJkXz4P3210+BYfZgQkWP89ZYlHHvMmFuTnlWhTqPMOmXbIG90SniBYlrat1tstf7lluJJyEc3Sucl+U7xwUzVHuy8NnlQtpN65zO23Xr8dIc2LbSJq+wXASGc2dThdzGbUGRRo5u7kS1iJnCg1jYiXDYL+o4VpD2GzXj93APCnPMCaTk5PL6TbnXq3fWUsjtzZTbZIRhICyeJUNAs8FOmuDTqq83XPqUjCK84HaPedeO0a9oFj6R2ZsR/8qmClEjvBxcxzqwxNBEaijKtx0qKrtbU3nBoxOx9go80FosuqVi0vBoy2ANjeNVCcLaECIPTQ8CoUDaMXEsUkoiIbywfPDVCor3/UHatZG8CVz7tregB4ISgpgjfeHAsAJ4QwByF19ofqHKEkQB/oBGqq90pD2y5vYugE/56lqEjPnhur7If4hIIl/PX95bgt9vqdpmtrHKrAzXWcYwjwLLPt24sE5Shs5EI0+m3HiLqwwGwwhrgFZzbNaKce3dfpnBEW1+W4kKaR5r1PymXOUWnX95hQ8SvKZG36uH9ajP5LfnajkWmly42uIMTbMHJhHCeOO987oc1lQMlfBSmiN9liXJoJaa7SjYOBKPQZNKH3v5sdQBLMR7hkT6AwM9qW5h4fT/DOY5z6/k2Yeo73DPGjRJJ2xhl6x+5QC7bmY+5QYvWa/uikgA9BILsIsGI35Ox4ZlKHqF1DyO+W7OI+zMKygjTk5HaS1rfH4GxvaSKPD7D3i7GtkuKjUubm18pOBtsnRF7vmS/1raY7DR7P4dzRbYZQ0b3PfzyVqeGCKNfaAM2QQ+li8XOhG2bEc5FuysJ6HD85RaJqycNhoaI7ywaeTIUhllsR9aRfBVXbxW8gboMKGnnqri6cPynJqGywrwyOj201SsJPJMH+hgfgv7K9gYkio5zr8TrAsE+e6UJ3mcEZIalez+TQD2YbpriEkDSLoFRwzjfNeuPXZw7JtVfO6Ur9jzwh0m/heaTK0vL8eGrMqTYRX/V3KnvXbvnYcDo2hEV0eSTM3PKx1Ky0/xBlaw9TU4J/OWkX35SCQDKObFu2Swkg/QkO1D6Spd2QSB9i9Dq0HdMxO89Kd3hGcfw6IelIz3A+DWEJrl/vHflOx70r4/GiGqFADcLVajx7U0qNDk+lW/3Z6hjDiGwi3leqOBetDg1DIl6k1UjuFqicY2H5M75oSedRg+yIa2OGk1DcE48qBTUNouzS12+NQYLWyCk0y085tauIcUwogHvCKIxdjmV1750Z/s8lwL8fcSTj73Ppa6wytATjHJFQBokjR1Ln8sv/HMf9VQ1O0D5UiR2BXn3V7bc+ozVEwaSe0dwNHIfbFjz2TJi5Op/HLsxGwI5djPNAfHiGgCWGsD3xqGbDChkxpk/UbUU5tWPvZqR0W2YzXt6MxM+Z8UBc4+kOiKYesEwhex7WtCEm5nGVzUsNbI5iNJsjOdfZRnEHkDB4vpK8k5m2uPdG+esGWL+FZh2fpKWxpJpnnVmu8uyQaAyP9afYRQq0rJL2wl2YfZuR8ufcC7q5ZvdJfZgr0BKQvcwf0qr93FIgDHFmIXHSdjJ2ADRiwX99FGpQhk5loSWVBiMhH/HAxzxBaMlZ+LrJLf3P5EhoHTNNgQvqJEGfAgxqR4EY5iHWUsNmeMZQFJnESZvNCEDhWYHa6FJcFQlzX0OJoCncSbgWuxgwunFM4H1tzWbx8bvKAvT20ZpqulXvedzE3yEBh3w0fvD3I4bPkjLphyoYI3z3YhxhVXyAtV9KevhLAzfkzPc3HPm+YRhk9zqhQRfAo5Y77dinVxKrgaTcX4chyzZQ9CsnnanF2OCTUKHsd89crkHZLRFjT58qFX3Yhwn5TckwmFcFJ126FoHbClryfguLzW/PR95aXiQieEGgK40Mws1tosgqD1MpEHm3F8Xds0xBM/VhtI63WakQwMww4VCaSHfECXtkEMrbHc4T6NLGrCwC2vx+uxXOAgrEHK8eBEQONNhVeYFzns3o4ywnaG7HN4By+n5qV7bFLrRZUZi8zfHQazGk1FYEj/HeqD+rXjnFNcS0VQRC4GCWq4xsPJtLrNVyFUX2QDYmL+6Ppk/uL6YbmoMohUaINwAI3hKHsf+StaKNzDu1tlyJwA5olWkW7FA7KCG+Tu/7INg9zDtMBBwVHOxinWg7bVgU9k++pWsztHYIzoMWyrUdnvjZ1vFy3QKtQwGb4Prv14DsRc0od59AslIwVXNRnTKJ11ixrO8zoWmfTSuYzXDoG3UByzbibFOORPsj/CiQOZGXMDjOO+zHfo/siWaeHQSvIuilg/Qrtx4yAAjBoqTG1ZrtZs9O5lC1yLjJ/ht6GwIeQO49A1w8FOFOjz7xm3Doh8zxTrzN8+9ex6vzZGeMKMi2X0rXU3fIoNk+GORx75mHOSPsSFhQ3d9PUlVd+Q6AVr97vVy8FegLSq7fvepi3UCAcvGPpyA/UUKzjV6JpgQ6tLn556vYzL8yaFKjmdwHxutPkW63q9tr5dGvxEmuCTJ5MjbvGgxwwiB03B7K6CPUPYl9NyGzPFxofxkRudJ3fOg9nFksGz0Vf519xyWc1ZIYtAFY+XEg0ltAx/crQbOVJ50t3kDcxZVBr0ioYlVK2ViZK+lSTDLumH2WZKwuxDt8luU/tjucagk7Jl59lCrrTqH25C+cdopGFfxQwrdOUqZBLnPQpfM1IZFqj14C5gLlaQ3N0EoT8fIeVeQ+hTtoclzx3pmTRbVpBKLcR80J+71B3ML4wvbanuf0VyFQT5/LIEZD8lIk1TLlnQ8lsbOA7tMou8opmZLE7W0ZIFDnVR8BHeK2NrqWVsQmOQeJA1U3GIEz7aeh9qkqPywxhZBj1EQntib9bqOWYGmccOUalo21Q4NzyrCCSb5dhrHULUVA3oIY0lf5Z+OH9gb5FMLCMJrWa9VmX9TsvVJNChWZq25to2wxsACzzXhyeSFcPOD9oWx+yXTYB+tODfeNpGlb+cwMr6dm0hnax1TSzAVkhJMKY811NsVNe35ixbuvy/2GSRmqabBuasG6ScExBX80E88+mojt1szp9lqI6aRGFmrLdsx+aclpDvBvV9lFDvebDumSk9XvZoS+rc67zsG7+LV0W40LvpEHGyy7l9HfJmzhtGn5YS3cXQtDfJns/tSDeHYjI5bi78o4nYhBXD/XNIIIymf51mCEgMQeM0nnW2m1LzBcmb/Svmv5uMJbKrnPqyBgGZ07VvhKIoNyE6wqJSq3dtrUUcX5QgPTwV4Us1592M6/7dWNzHu6MufxLrsN7afKC69ZdNLog0fu+7yjQE5Duuy5/bTW4MdEeZSzzQqIPgNqKrP5XUNJETF+G2JFmRnXxcALtZgpdWDsXwpFUzD5IDXr622nbpMC0gcC0sT2elvpm0pXZa2l4/Da45CVlHG2IE37OjY8CDNQqk7+CRWMXrq51qENdw2dnFVOTyb6xOs6NuqtXoIHfAUw9K6GHbbpfa8hnmY/W5CGSkIN8mt2xZFPWWhUuy36gZdwB3Ua4yOFdczMMfLGFANqsRcpUlLZSVjyMsqdfkhTujsrNWGpiMz0wHmVDQAJDo+B53S086SxGCownJjmIwoBG5sbI8ErmNO/2Z4GnLTzpKPNXEY5c5Cc44f3S8HRokMS/Bjs4jsA0C33URi1iimefdNuu1rr76cBhNJkjY0QfJPpbbZUw2BvsUBP2W+bhy5IgWrv2OL5GEc6DRQa5MC2CtpoEacgjrT10Nw7iBXcFoxx1jrcM+vo8+/vkPnG8mxRUjFJnOnDHPnLGz+i7nU0inRnem75ROPLMmjm8ui8OYgS1B51Ut1HBLgyodY7Sb08On09z9NZTe/P0UeumQIYNylGu/uvwi+IhpIVgtob5LmgOc2htwbdk1ERORdNpDxWN8rnpBVS+BT2kz55zjgQztcmXH5z9U6FwD8FOoUA/q3Z1tFYrNs4lI2jZN+kH/5n0m+nr3+TsNBn5PBPGAz7qLYh3Rw3kLgKlJq53m6zFdSGiFrYBlrFzlNqKgkWbjDxeeu5WGpnArHYSrX1dyrMELjKMdlILIUq7j4F6pCLLbEFzt5tawB3JW26YLwJBYO0wwj81VkeQKZnvwXdsQlFF3lIrq+LRGk9qt1iax82jZbS4CkhuLtYw9/Osveq7XdD21Z+8jCCNZnX1JQRfgjaMzFi30HqpR4HuKdATkLqnVS/nVxAFnOxkfTRJCC8R5j4Zq2ZmvUzITtCaSCkkZEbd32XCLN/HNU8IC5rVLV4mW5m2jytBLqUNymlm14/JWUmBC0zBMIu818KTefbsoVgAONPmAj4Qu5QzyILCgDi6IN4mtPHwiNonzc3aLy/yQ5riKYCZLKt52SoMuBqj6jIhBCOD6Yshw7ICg77IQqQpUwS5QJAzmc/wriO0Q/+jLGbmg1KNKGaqwlWoMWURL7cxbpzyQ5hqjwwU0Wiv2qsBnJub6zwl6LvL3p70GSbPqsJRqSh2jI2oCPVkt0x+2i61eAbBMEDESwd3wmymm3EZQCofwtO0sza2kW7XZtPmGnGsltCI1SqZ2lyWkXivKeoo8E1r9F2u3LaNIJyondzAR8azevoxN/L9lfkrY6l8ky2EGxl9zywqpnMKHf4VYSM0dpSPUQ+DWpjU0mSjXO5xSHSch0QUyzH8eS4SrGRmEL8eKtmm/lHgRRCPPeoBRw9/FY9LByPpAjEvl9hcyT1XoObvyMe728ccA4j6Teco8ODPiHNqrUJo5vlwLWuvChSFuS1M+jTZHSZEyt32hXVG8IoBBEt9kGibeFXpVeo+67dtUet1VGPSgCjt/JMkh/1Zv1a7yOzEs0IwGXk07Qwc3obDfiV7JXmAsr3VKFN5eOpLx6KbZs3YZTDiq5Zmh/mwXZ/nXPW80Hvx2Rtp6sFzbIaNIhE1WosYXp8RG/eqZU9zrfZEc0NDg3uG00l4FdjSax3zRIyC8QMiEA2jDAKXx/f0OwKroLHSlG4IDbHrhUkc/Fc24Mq5dp0qV6jTJNu1O48f3iPGsd5orkL2Xbtk3ukH8JlaYSt0nblmmnzts7Yr3rvXo0BQoCcg9QbCq5ICM+zEKxw5QTrvOSHuEhLY5eK4ebBMqOX7uMbL1hXgd9Zn082lK/Xs1na61Kpt0iK8eWFT4EsIAixbMItGUZOZGRskaMTABges4k8CW+1i8fzWQjqPAGXYbdvhgnNc8rnQR2DCNbuJRbGFSDIlC/uET2bRNQnXBVhGRJwU4EwuWOI+2T8W9B/lvJgBBD0PodQsT56ghkBTzlIahamcg/G/tbsUUAPIKT7UMhhavNpOMfH+PU11ElbN646HT4F9aM9iLcN+mLgts1g0R4f3uZDkEUlKpuSQg27kUGhSSJVeNw4WERbst9Mnx1ptGLO9GmZ2a+NpbGktDVxASBfPNkNFU9Gdff0fFOTdlW6T6ZRoON7GEaQnPHwTJunFndvB2NiPtsnxJBn0NbI2zej6eXuz3rFNu8lr/j61LAgsh4mbCks+k6ZBe2oYVIgibyRpbQa+vTdSIwYwzw2lfBFGcw6trPXf2FxJy5tL6bGdUTRKjHm2/bN5XKaI7+WkWw+YjHoWkVVWk79DcMPP7dDninsHtHWP3eztjSwciYObGLsIa/aJPlBqeja2R9LNlUugtpcuTl3HR82zzVprqdbY3XUIeQTp2EdI0vTQcOBxWC7vbREsu4N01lz2eb2PWkAoEB+dvzgvjHnGKYeA9YzL5hG5AeO9gWmvY+VepDwi20NybHYbOtx3/so7HmeMwrgzJh3jDj318SEk34O+FEtxUkiqMQdDKd4hx0l3ydEkxTWNRpZPY8zf+eXprnw3uaSnbd+i8faV5pCFxqWvbYO41Nj4MsJedZx737nPtUgzypwKBH+5oRQjqv6s8aXmyle9jxfMsR0+xwLspR4FzkCBnoB0BqL1inz5KeACUSZVJ1snfZfLu50L+2AS3cnd8w+n7X12kVe3J9Pt5QtY5LDIx/Ikr+UEzHQvp1NPrULQ4f24EMucLOEC0Alfo3et9hGimchBTvLTmPbsE7L0xvYiJXH4RWi5vn0nrXKI6wUOilVbZPuPS0EtGLcB5DK1VIOEDc9+G1nH445fMCUVCgrRuvp4pnbLZPs9V2UTc7txHXYBbP0y9oaRNtk3BRsXqxnM49ReWYcUPE0yv6G5S3LhWyfYg2eHVJfM8vxM3yAbGh/65BDxbgCRP4rgCB+LMkxRMOgd7PiQp+KsJZnCVtwL4yAco01tYx53G9PEpsQz6RqKyaYHR3+MDG2ly+euwaCglbmFuckSAQ8u2M6jeQW6tjWRFlbOhf/Sxekb9NPZmU972AiAasNs6wYmrobRt//dCbbtBk/ZZJwHQ0N+278BU2yyfLuksIJME+9EeV5l8LMPEHjXtT4CUqPkn/k0YTPMtZvZCqqalW4wlj+/vJCW1/Ev2mRfmrzXhsfTE5jUPdA3kc5RoX4vJof3GIURJdEqKNC1xg3LuEUkOcdGmI4hCBFxboezihxj+jyFGRrw1OSo2YnDYd0UGVxPFzjwd3FjJq1sTKeZ2gJNscPqFInhKQOogOhI6D5F+w/9nDDPInBD326mSWi+HHh3kaI0eMW3qDVQrjCzzXU4wjT9bZfM6XykFl2NtdoCN1/WEQa8X96XdmXv1T1xUGtvMJtu61OAVyA14mYw/tFXlj955qtS56Te9bmjwJDgptC6xVXnj9It1mN7DJTju3DvhaSsEfc9LytBK/1KW50THHoex6HI4zrm+hR9z6+Sr7VVmtlVk/A1TVZsjqBEAD0g1J40iqHdCVAVSO+6R4EWCvQEpBaC9H6+SigQC0/GVV8Xzbz0sTkyD9aZWP0NTGFyUzF9yBBczxEUEIDurJ9PK+vTOIMTpQwBSWGpCEPm8fcAEetmxu+k8ZFVNDLDaWNrjFC6o2lrF4YQ3yP3lmNhEBkFKJicgQqjIybuKjqpm7Ndih32yJFZIYURzRV0tC3LjuccuZAUbVI7ON4zFKt78x6EGiZ20C4LR+KR/XkiFGwHABmXwpJlfN1VHYqoYy5U0dBDFiBTugFM4xJNBl9oOrel8fy4q1bq2A59moqp5HFlT/UsJJ1TlWhkro+xg2KGE+RoxtxfCgt3OBtJIS9H5MuUcrH33CjpZH/42/5eQnMYPmlwkn0IXQM7jBeud2ou+yclfZEwQzkHQ7mOsH9tKG0PY8pGVDvQaEp9cP6To8uMYSJq7bib29qDTdmP/eHYlKGV4TEVSI7dSRhHz89SKNJkyTegmUrtQQvDfK3mctXcYeqFABLmY8D1YFW1gaHJobDnHFWT+Za2NjhkFbNTBBjhD3qgKzguE077qYGl9Nm+tXQODcbVvfH0AALeBmWe2YdO9JJnMoW+i3utKTRa0EAcFER2GPdqkEwK0KHRYQ4K3CgviD46xbllnAAbQ/iQbe7UmE/wFhlYRcCzPby/mwhZlFfI8q+YGbbWX+qRM6wKkN4PIZE2eqimApt+Gv0ISnEO1Bk0SsLP4doNgkMF8WFNOSkWKCw4tluTWzP5vKajNCx5I3gObReOdZm/MapKrrv7VhNlXw5C/1b81YorDHeTHJ8v/cEzYWI39ejDCHSlzc3MfCus3CJWMdrm+69W2uMF3EQAodbsTb99qobfkm44tKON8NW4hABSp5/1+KeQpCZphKikRxJlfGu6e0sbpa1P0zlNtBV2rOe4pIn3XmiuGZes4c7tpk4t13qgmOyZT7ppGl7WBMeIS7xgbPVI3tsz62ESI2bCaJvXsV53rPGwWO/iPqNA86pxnzW+19xXNwWcQF3cFI48U6JMqDImTuth5tQyN3vP80SqjIOmRZuY1dzAhG51Y6pOFPLVt+qzpkihAtOy2p10nl1ez5sxWefBOIsN2pmdfc532B5N69tjhNblhHOEpdGRjTQxsgLTY7AIF3kXW6Zjrl0McqCGZiTVwBhR6fAulQywihn1aRtzhUbK2qRbmN+NjHDGEUypU341yZSvwpSWCH06NyvwlOTOYyfhyLa5GMnwNkPNi5LnkriQj2IiRHwpcpYeKNDr39wew9RuBlM5fapctNqlvFw1P3NxlUnyDA4Xwjt1M8BOMNrBPfEeVbrzaxSx4B9OLNA+g4zE5u44gvUQh/YuNtNMBgWyK6xmc8MGDOmmKZqaNk1ONCu5g6/Z4PJ2Gl9FyNlBKOfMGwEeYPZ1h9C12whJ3WiSHOsjV3DqfgEmECGpf2SbAxQZWy0dqgA/RxAR34PmHmjg2c2VjLAMsTBaqghGyXvFufxIPbaPf9V30zyOLLVv0i5gutnB78N8/IzADAgPkWicwRwUJkxFIIkf9Q/fvX3eRQUNQ2YXeJmp5X0WBnlvHGDeyt9/4v12zPnu1PAjU8trOPsjiXLS1sAFflv3CL5GezsEo4hDc7Op3cg4poe8sxHcgFa5YaHAYxkF28EBzvaCYZdFHQATTWOLELi5CjOIUKepoAfdHhEcAaJQpcorzllqQdL8ngW3TzAKhbRgzBHkDEHdz6aHuFiX9POMKfMHnCMdBmDuNQSB5orAgDmr/dlC0vIk4UhopcroeYnzMiShuhGhppo37bCGjH8+VkEztpMYfQfnxNW5NDzNgd3kjs4MIecQ5JGLvH55VIDbfKUGzjNDAFfrekLxgCctnYezPrOZRr5PCisKUX7nNyKPb2vbZO3UXJGtmCO4eUMtWH6fS0+0zdb2pmUNvGLwId+3TkmMs/bYGfTkelyTckANc2vejYY24EsBAzoQCZG2MqQjzD0vU1PVCm1qtV215oZqbOaM4Odr+5tp11So9+O+pEBPQLovu/3V32gnfidCJ1bPgmC1ZaGnXccuok7AJBhhfRBc+BVU7qyfw7/oAlojdmVDgGnQRyZFwWgKwWhufD6NIfCYimldnlKZpgE8gsnbaG0zTZP3AIZqn8VhACbEvOtEs1vYnIv6R/EPmQBOHLLXZj0w9LeLQDW5EMhsrLSsMxanBgREzr8JAalaSguKzNRFJDCuNf/JyaAV2aypDQqRxTo195JtqC4d5ve3C6zMvAdR6p8RCzpl2iWZWYMQuDhpJiPrV00uVsMwkzodC7c8lYG4iWmhjL7RxQx1/rIkKgwhKRjrs9Wwsz+cbq9fZnh5xtEW/mNr9H29H6F1Wf6lazVJSyM0KejLVMgo7a1uptl5vjlsdGeyP62zwyqTOrwC7dAkBYhqp1QBtlxrHTl0meAHX8LX6Boj4kG0GIz/6MRK3sGBXQQ1zfqa8atkOfbSUlmMyPux1czekXmxbU3Qow0KNPQ6DLn+OArxJuk0xpgfZWxtwUBueGZUCB4KFOBPNjVBwczXBZIoyAP9lHjtAq5j71CYyhnit/S0emuTeTTkuMKCzLLJ+6WvfMfEY4zNAplZ3yd7tKQQXhCaFEwsI32rvlIeGiuuTlI5Eh+l+TnA2WytyftRd5mLaMvwKO8hQSU0x1MrZWCEbSLxqZkaRNAKnyLmM5P1KDDaFwcISa1tN4/3NPXrx+Z2FxPREIaA6ba7PjSW119JJBWc9sl/nMZKmO2SNPJfxqw5h4FjpOK9SEJpV0c3sC0XGk3CbfcH8RuQ8hjMB7w6bx3L6FP23BseyJo5xoetnpanJwAAQABJREFUc17rlKzF6J4hrNfpkGvOG1/YRKC/VLPTwKc9rKx1dqapLg/SJAR6BC0FFeH4Gd+AtG0DjNPVXXxN2bZol3Jk1b043FXT0vY92a4kQ4fbao6neM+MwOpGXKdU2t3pefV+FiVd2xxZLv1Z7Ct5pClGfvysQ+W9YPjG+6ZfbfHZYtsh3WQ9meQ4DvGUHr3Uo0CVAj0BqUqN3vWrhgKLmCq5AEVilpRBOS7JoMFKxO5+TINuSbNo3FmfS0trszxl8YAhUcOzj7ZGoWaAaGCTtaUQjGotgpGTqYt7dUr1l+trTMw8CIMpuTTS+NAqG1k7aWl9Jt1agomeXEgTk8s8yaZIkYkPmRoFoWBu+J2ZCxhb/mmK0D5pf72dZnSSOJIwR4D5MwZeNYm79t+ZYa22IufyjtqMYXDJUGVws324uI0iOJmnlDzsi2olLdca2lwcmsF/ajF2/Xxc6hmlLrEcQRDQlrw451q31zr5W28rzUsV5rOPMwuQF87yrOtvkAkBUtVMlrbr/XkyBM0z1/FVW98yoATmWwjDoxNZmD4sLf8pjsEzFcrlp3k87YcJmuZ0E+tQFKFw4/wIzNsOjI6HWDIuNwlZi6nV5jGM12F99Qupgmyahi7yDtxAH7EK48ZxWnmstuZuxqv16fG/aUXILS0wqMhw7wqA9t9hkswINjL5hrZWoKgy4ULxLzOaPCf/tky7DM+hMACTSdjuCJYBI2by2sOhDYag/5DMUack02ewBhlINww2Ya4UklqTY0+TJ2HJTEce8oX2xShu1BmaFuosUe9aYQTOABiknadO1BthwIGvYKOgFFozcAgtFO9/+L9IA9APwdFm+HdM+/ugz9D/z96bgFmalXWeb0TcNfbIyL0ykyz2KqCKYqkSZe1hsRsGGJcRtIVGGB0RxwVFcVxopB1Ee0RpHHUeaRlkHtFubNBREWg2i12WAgqpBaqyKjOrcon1xl3jRsz/95577v3ixt0iMikqM+/JjHu/+31nfc/5znn/512OJIrkxZ8SBqAqxhkQ6lIvvQuoALpruR55tbeJqNCqLOCdZ6NJNI5vJt+Azu2Ubs+l9++QAxIU5U27Pd8AwnmnBg2MS4Ax+XRKh6QfQA2YQB2vU83p3/u++E0b3ztt0wf2OLl6lU/bg+RoeyxWNtSnAe3t9jbbYwMWqHV7eyU90prHatJpENAGNr9S6mdh5I6BHKHLusY4nu+gw/ZyOib1m7QRik7JqVJKAHMQlbvuuYUn3scC12nVhQANqSdl8c3GaWAHdEfLXlVzaSqvd0bxUA2PgXbw3q4IvHGMRLe+j/GH31ceBYYA6crr88uixTBNgwZU5EpSfbpv5ah2oDWpahZlMuVjYwMGKuwcjqVrdtXcCalJ6cR2qcrNCxxNZDlvR7uBWuCZmJlUJ2HmtajgCYgDJTcauk69Fg4YwKy8Uu2fus/mJhaUf97WqrLVCAeTN5tCGUziyFFY9CiHhf90bdEBTbcy2J0jDYuhty3mqLqlBPh8MWg+CcwAwKNzfmLCpXaAakXIK4AjABW7b6TBHbJLl8RQsEsZjGxZnroHsOK4VO0OZ+bsbG3Z80aVhPSUwx81pdxwUGhsCeo42unW824lkM+0FuEJedDj0N2Qf+iv7jXa/oSddc4lYvGtrFdsrRZUKbfH3HqnWpfNUHlefaUa6v9aedoKAsVTWUkTNXY8wHwK/KgpoSEqS03XX4thhrZZ+S+fPi/bEIH4VHHF1iVlcE95Sj+KpDSlsT/48PeiVZSlpsSULmosFwS05iJtQ9Uuxic5oqK0pY80TorqOUDvdnArWkATpQAcRecFsS7EL+hdQJAyonjrODTQNyV4Oph6MW5IVPjtDA7ASRUBQBAAFe0SFOqJTQaqo5nG+MU2D2m0S03oEwiWCNSFsqsCdFWpuyHJcpfiKof88qjqScJDW6gA9eF9dACletLvMNBR8pXIeseXgEjyQRLlqnziBqmDe2CkPtRd5fsgC9Xx+lC19nZ54brveUbgRlKC6DAmFb5R8ld+/Os8X4TonT5Jw8YOZ6jxTrmtnWguyrjkpFG9Tkl73iNfABfzDh41UVElL+xQABZ4TyvqWIKdrBOkrauOnZgiSCKqi366cNp2rt56SWBdzgE434x5rVdgTIXz1AJtk3GhM5IlNhbGfU7pnVcAWrHjEjmpwlS5WyAFwKFXP4RnUtUWPdelTcHGGaDHx1e3jDvcRzrOZh0q30112Q7x+t2CWi7JU1/R18jqki3nORLejM5+y0zKPum0tiGlBp/OST1WdQ8bg60UTKXaphGY7E3jfvUaPr/8KNBpLrj8Wjls0RVLgVHZbBSqs3Z66bCDI7cras2NWvAaPzTf75k8b+PZNam/6byfyZRPppzGwYQbGSSYH8TxBFQHCtLeLtZkPK1FE73+XiGUNKr0MvyVdOpsYd72ZFa0kJJrCHwz6Wup11/YNV/VrmVR7r27LXWkwZgY9YGZ0Qmvr241Aws7u4TYTSDdYDnBOJclrj1wD312XHXHQNsDOGoBKpiJgnbe9mdn5FBALr8VObYhpuv0vSl6ozZyRF7CID37scEjXYhN+TBP0Ly9fu2/SYELaTz5sfBhrUEdsNUak/QFJxYwSoCrELpRMD4VgNMuKTrpBM7lgfGorHfWzw+pUPEYs1WNMUB1HE8A8UUBpnxaLrbFHEZmAvp7y6goTKczP7rTYMhHxVzlJOGpTWkh1wKfVdXTJX2UxfDNSfojAUEtxy7uzsNISoWOix2oYA8jFawEMNt5bttTUCcoHOoGk4LEEVe9QXrZXmeng9rt6mhd3h3SIB12myL9cFsY3eM8I5d4NKrh3upk4wNDDxeLjQK2NO1lNqJ7LZE3EQ8wXpCzhnJVh1DqnXag1lDzi/H5hunyP52jhCfHDSRfupeV+lteXiHzkkRBAXoYSVRdoEiVd3CEJMbdjkcQksx40Gt1He+PjxVoIfAHsAEM4nABRo95iHEVbJoEDnUzSoZQXQSrx7HWtdg2ogHsulOyay5bHgTaIfmM7xJU2l2AOZ+RSJSzgGTJ5e1pvFU+N2NvAzA6ZQuao5C69y+JJvOuc4hBJ2cNtJ9tKxjzbrlB56M3PcodrDAvMb6Jy+eogAHAPqanPOrIH0CKTSEH/tRW/ccaQHnYiCJFSvs80dYxikug31Ez307RYOdV1yDoph5HGh83nlP/DzYRoAXn0u00QAtsg5DWAF6xG95NoHw8C67JNrDkc8vWHqFNrIc5qYpOX5Wyc3doU6Oo9VmmhjjHYdOC9ZRASo6/cAmkrjtTmJjDcCVSoDdHdyVSZNjmy4oC54v77dzKfjEJ7P5tnUiTDcUuaCa/KCY7o93IXJPZJg4TMosXp6ETYi6w8b6TpXuuikK8DjYFnijxQfpMWjZDOusGiQxghDJiiNdM9CUtBL3AUUzDQoutznpGxvZiHlp5iJEiUqy0LimT+K0SYy7skiIhw5kxT1FpU/kJyVErpkk1SYbEAkeERPbJKB2vY1zW/DFxbKgusWjFwG7eYCGA1QmMmZWA/vCgHzg8mBVYlPmuG+SuaUGmHTBB0DXSJ5bDb9oTwRH3ARB5DhCV7UvwnhVjt77JCYnjalk6a43AOMuk5KZd4AjKUDdqBsWrdRnWs5suvffwpPFQkRieGUmPsqtyPLJPKiEC6VUxR/W8djcXJFkcV1myRwoSFaXbaRCDDO6tr2pEiKmWf/addVyf8gJjIsbOJQS4ZOYcrc7jjKygC0x+v+BMv5h0QL5eYo++URfbKTAJeEICN5bW84yYTKmLBSlNiNcpb544M8yYE1O7WijY6tqajcoNNjZQYXxsT0kaP0eI76qkx5Jo4YAhJ+mR101JYJ8594VzwRjTPiJVIPkO0tbtpeqO8sFGi7Id+DWAEXEBOw7o0DYSLcJ7pFJ1n7gbohHpPei50687aUK8b8NnLLJBkV2XQPrZ1JTcr085sOB3zDO0MvxiUwhm2A/B3kFpwaOaDsnWywHTLIJ5/sDPqsBBg5JbcozlZzR/2NmSZadyskWVR1O90MynbDgBUJB4+dk+vgHGGGQWFjzRREg8jksI/aN5TarNRW2MsbkAkOik/gVNATdrksgw3tpfZp5jj7OiNYQNJLdnarw/euTvn8+GcXxws08gT8Abxzp0qlOf5E4/1hYkfmOSkAO4mvN2v8SJ56g5xrU3cdsvmcuDmp02gTKirKReMdB/HDzOhgtgGFf/qHe3rwcx/vD7yqbAECBd2f1/2baeXX0M5nHbzRIXwZEzpXDmjaWO3zhSmJ86a1OSOuTF8DNZdl4Ik+QKampuIMpOsdLUOYRVjFzSODuZonmt4se0oGXlCQ8JR02TNecMBQnI1pKp6SCTNypIxc2ULcmsaSHN+UgTVMVXQe2faZHVzqgWbFSJ2G3kUafAYo9kiF1NmC8YruAhcGsKdNdnG0AsMgid8ut3D8aAPxhLSuATz1mhf1plBgp3zo3y22nkdVJyKXX4Yj4zAliSqpdA0qIOFOY7mYZFm0U/9H3sA+qmAFPRhYlAAlSqTaoPsRFSPfSXS3OezWkbTwWHEtgnARMKlVlJK3K2L3+60VqaqZqquFiXDXb5xSdNLdBrSJKUVh3J/eyapFkTolasXmdydL2LO28drSV+TMyFqpblui2v+LNF+a7ZdXwA0xFceSvvVis7xlWj+4aWRKQFjrjnIEg7xDgXYFOCHfro3KFvpopAHiWBnGUd3lrRGUX5fF7qr7PyNilpoKSr4QDbSI2QI2UF19hibAWOMnK8gPME7JwA+dHpCYfO+vhrVMTrCg5MMKeNR32/vDyXEKlMmDqVS95Zed5L5fEWmCCixgnvUjO0dS4/R3CGQSyfHJoxL4kL2o1aJBs4gL8kjTs1AIAEOOFohEEDecK01yTlx3Mmv5EWBigDHNkecPAxzYZMZtJuue2zlj6mDZpjMy7dC/0TakrPYF+KXRbql0GyrXdbZfixCQL6qKgSUJWeTOkwdCSwqk9FADvHxJAYQ7D9Jc3VSCt522KgTMoiXwKbO6jHobUwLpjUch8eaBhkSB51oA/yxSnQpEvaE+NtoNStmnKGU0pzLusN9L2YAdri8CfTwX05NcajKstMoBDrRwgtKl7M2gzzulQpMARIl2rPDevdgwKbtlDaawtr+7WQtnaPSDCVX3F3xjCtMQCQxlGr0/IBgzHIJOmLmgARqj11LXjMsM6kxZk2Zt7jG0a3xknmo1VXeeOAu90Gn+LVpvuXD9gJnWUD/+MtHIM1FxjTAn5o7ozck5d6to9lCnYAIBW45y0smFePJqKKxq5kPyalX3uoI3RDFakZVIAzc7pBWdSA3VcWvUH6ppmPLkJ8fSojKd45HTifY7G+YktamIP+vdQeMdTX8y3tUSXcFXGybsnMdY1jj2nZGQF8CjrgE+qV5LHw1PJxm5D6JDZIGZ1rU6jMuI3S3onTYk41ehLjLzYK3F4VADr3EI3ERXmUO6szcVbkNU1Me6ooFS3xR0rKhvMug8B7Row8IKyotorxgzC0GdaMsY80BjUuH9M7JXajVt2kbbustBrdYujd7kf9MSpQ4g4deqisxeq3kwtwtC41uYrcZQPGZycm7ejMHssKcBWiG30SKQNown/GIwxVHVfdSovUBvfgKbzVKRZtLmo+YOc6GaI6XPLeINfUMThiUO+on9bl5n1D3iK5T2Vw9Z2Sil9mPBcY8QTj3DF/mkEcTQz9onZM/yC4yTyAnSH2hv0CYxqAk9U4wWbMO7NfosZzUcn7c83VsJhZudM5ADZwPDOtjTU2Sx55/TXuOj6C9eR8op7TWMFxCOrOQU2T5+SOyrLkymLoNeKUJ3G5j7ogm1WAKjyFMtqoD4BiTccsYKOUDOEMMklElBg1MzbgkHzyj8083u2QM6mY31jJdhaoF6ANe7K0CupFn145Uy6qiDMCK6jcYRO707r0yh+tgapogGVu6AdqHkKco3zVcfoQI3oDbMWL8YffVyYFhgDpyuz3y7vVmmWnMgVbklOEDblcjgHHt2l5kpvOL2thiKo9TMliHJHfaCEadIJ2ZkmSGA5cDOozMHEt0BXL7PqtOZijJqs6jBb30CMCSVXtdqGjPWgdknmzIKaVBw4g7pe9lcMcOOl1LahqV1GHgJ5ZnbHDcwW1tn8IcTrHZJmeTQU1vrDw9M6PXMIy3GkpxSZLdiCNLGAN2FmkDPbD8S5G74xqYcflbHAS0bu8Xk+pB5I61PKQjpEf9A7So61sFPcBiwno1jHrtMbZ3vwZaa1l3PkGUiRcfS9Jerks1TtszupqBxKlcXf93UZXFQTj6wysSgA7FeZTVp7WrvGyGCN5aStPSWVNNkm7B0eh6qOyQxoZF/MtgIREIi1Gf059OY2aIuCrKKlmqWRnZatUSytuv8Z3pMhFuhnp0hixgCM/2BQmP76+XYqCwuzsM3qA1c4gItmR7ZWr1+gcIcKB6Vk7PDUje4a63VtebqjttMYpzCy5uE2R7J44rBU7Jc4xwnZqVB3CeUol0bLd3bAXsIsP1AY5dJj3NiVAy7jI6BBbxqsDRNqhP34D9KgPh7W6pCpZHsyrCNEcWwKT/L6UA0wvjhlQgWsMi67Nod+w7XG1ua6xuj8IpOpNMNYBgs+Dup6Y1ouq97c1gsJzckG66nXRWGMDKqlKTDbYG4XxtnVwu9rvaDjrD5khm19400NROhkoE8ARJUS0XSuKxjRHYQjQYJupMZUkXKgntWs0JJlhj2ti4/YcO9z2tvZItu0RdOMdReVOp8XqPcMpTm+ab8uk2w1lg4ripjQr8KBZlboptOEfG2M4V/INB6VnXeAfm2c4HxqGIQWgQIt7HNJjSIHLhQKaBPNiRvdOnvEzjsQKyoGCFoh0RTv6qw6O3Dje2xt20DnjZCfLBDv5OufeNnJhwt0N6WB201J7qOlgUVyLtwdyRiUjowm+op2wXssGCxbPkZAtre1xBn1ivGAVOQ6o1NhRFBioTPoBtvkUKg0qTwlQ/tpJoIxJGUePS72CBaVfcK9SvkhtSPdbKkm+m5dIpXqNqX3aI23kByyShMoXqWQJnImjM4HEWKB73osWVKsuqWBDJuJxkzWFXWYnFfWOGUmOyI0yk3FiDVF/1Cqqn91LZARx7tF4elXSo3HFDDn5ocDq5KqkhCmB1+nckruOT0ov4Vhh9iM4iuVSWl12NYX9iSla2araFxQ25StbwkSrr8hO6r667ZN6aH5KTLbG8eaSzm0q6gBScX3zGpdL86NWmU2Uf0El7zCx2okUa0OgRAhAGwjqBjE4gB7caPfj9MO7I4CJBEHM0JokQ9B0E+5Stg+5bNb2Tc8L2OYlSazq8F5Jk6Bvop+Jz8iEaS1XBRilioe0E8mRO1ygjhpLOGOAwbpYwetAm5NoRvWGkXSpGQWpski/ggMGABOV549at4LTjYmG6jGO2563Yl68Kwdk0HFrVS5KAXiorMqj57zskKIXTd7zTgE6MmfgJrvuamidYl3YPWaoGpIP6a4iNfrKzV+wvVcdsINHDztwjbkzPtzxguYuAod6b2gR4R550D1u46aRBLBLEo+nSMNWN4uyb9M7SgaNT79s/ELCxOZPTEs8csI1t9tH6ToZeI4UaFTzOYd+998KaqWma5mHASAA1gsN9BWbgxXtDgVqXGiOIX0cguQJIMUkL4b2uZQ6oH5OPQCakY4x/vD7yqPAd2j1u/IIPWzxA0sBFBfmsmdtJrugRUIsMDyVLyraUa4ybSoG99hV1b/WwpKYQXtUmd1anCvAHHFORJyIeyTp/EgJMdjfEEhoVG9LPHaJUQcYKP9GXof33Cs+SKBQIOGehaPKL3gcqsul+Un9Tslolet8bs0OzkjlywveUmyPHwG0QbO+C5nqjYQGA+K0GDykNHHHrkcB/qhT3kBYvCfh9a7TcxKSP6oxFTHE7BZGkJQVEGI/1eModbBz8lHgTIQ/6PDhhtowlYMNiw45aIypTnnZJQGgWsBcUZWv1mKNQ9iYzuFiS3Dot6ihlCnKQFnM3YbOFFsvL9rInOzWHrbXGbSZ1Yqlzy/aGbkUr0zrHdkZju7cmEHuis70YZ3DUMX0Q/ZRASUkBtM69X4iLVVGyRuX5MGKXeBuAYYUMJ0WwxXUiJQT40FMLCBjr5jCvcprUa7cz9aKmiH0OJEZ5dL3eINDaoWkhn7KyO5nTM4cYgg1IPZFDD5XtWrjzRQ3tw0wOWgKY8ffK8YpY0pVab5nigOY4ndgCFv5XsQab81KRdRlK0V1kK5vIezWmDv+Revo1zO1JTuvl4c+wnV0dHDAO4+XUUAGDPGy5gqAx7crMEIrAHmBHY5TmNk7Z/lxSWNpfCNQZ2x2UPeKgaeozzE/MUdiU4Ub7OBkvJU2xmeVQiKEi+xuc1/wkxdTtL77jU7856Hmhp3STuy1KIG6o57MMasX0tG0iSMtmGf61bfVsp1fbafs1jyYN1jPw8GxW58Nf115FGjN9Fde24ctvtQpoJnUDad7rH8skwTWyBbMCFMw92BQuR8MZncwNWumZdGCYfczURK575isygswgxqQlolmcval2THtKzFpptCF8srLI58yEkiQJyWAVyPAnFfXs1oAwg0kGdWJ83IqoLOe2GUeILCQrepsoOmsmGlfFLsnojUAPHKGSQj2Pm3lqFzU2Lot+ltzJ22rj8jTD1JUTUivotxjHbuyxARY4u2IMCKpQQYjHgVyoMS2mviz5AdMTlqeqcbERO/c+knlqG2UkpVHu6nsskuPmrZHypsd5wfcWF6NFp9lG3ntaJckuZwZtezslNXWSjZSEdDXCzGWFbsjd9lpMXTZtWWryFHEAxYanYJ6GXu+SFDn05IW4FmSvhDDDQ2LsseB6ewWvI/V/zWBA1ex07W7C5dKLE4VxAHZeY3j82IKmT7axwK/ea9XBYxciqhYfiYQTFyC+e1W/q7ueyUY1YxR/dPmy7pUAWlLOqux26Nc6oT6FBIz4mOgzrtHYBMI1UIeOFDqkY8nuMAPWsC4dvVjqUVir5Uc54CY8G4wQ+w8BPpgtyOnFQ3JkGS3nhH5UT5zU8idN9AJu/OCBkhB3mzYVDQWp9fH7fhjHuF2gtEFPc9x182GDX3aHpBw4bFuTHNFcDzRHiP8Ji3giU2m4B67PS+NFdFjU8932lpygl7YwJa1cYYDm0HnO+Z0XN1vat7YabntLQUsUg8f++0PH4DflAsIxbb2QtvyAFR3WMQDQIEW9/QAFDYsYkiBi0IBzegs+K5WchEyZErGmBWX06g+tC893YvAhau8DYl5Q3+cncrk5L6TSdYXKRgHFRbTsTvH304XeJgPpBZIperS607yQ15CowAOyV2T2h0AaScBZoBFdGp0vNHeFsXIGsYMfXt24gB93KMNHduhbe0x7bxCx247vdQZmIP+PmXH0lyiJNrHEMuJv/luNFVpYINDiOnj707fLPzs+PpBwM0SO8Vs3QsgEyCIrVtVdC3JUcOqjctZQ2ZE9cY1tWZcpwRSAnb3vwNhFDU7gaSqvJCXRJZReXNTha2+JvUSQJuDk+AIISdpa0GM+qbuD0iGC26RM/tiqgFDe+WqfTo9KXAkJlsDGYohLWC3HbsKfnO/3f6H+9yr+EgMVUIKVC6W/EDXRYCWvPqhmdYeABFsvCAFaUpiGmVjAEKSABkphTd+e4jpfAOHCIpKe7oGxcG+CLswPzJAnuvWUS9UyE5IfauXlFGZZ/UcA33ABxINpEWhHQII1N0lSYAkVYRqf5sDUjrmUwqj/BgAvNRrd86dYy7hO+Taypu78Re90un51hwuzi/KYlOmOrpq9375Lrtq/yGbm9/jNmHMfzzrpb7mZxSpsp3GUbKGUBM7IoB73PiJz3kz2OQD2LC10KJEjDHYd/D8hydHNg76wyTKxYFOpPtgpWyNRVryAfhR83502Jr6wn9RHi2g7S1wdCEtuvA6DXN4cFBgCJAeHP0wrMUOKXCxwFEslkWuqF0+GDGY9cEnaTEn2rVDhUt8pC8qAAOYM3Y4O7NPsdTWN/HwVET5XJMHRrAsHP0Cdd0eS4y6pCZBYtG5NRtiloqVCT8gl2WJuJtiZvDqF5j9ziXTqrPVFXlXk/c/nRMUVdfYwWSR4+yNABZb9WJHtS7VPtRA2gMqMtMCW6t+bk5LDYV40IK8eBakfK3UaTEL6L8Tx4OIEJRrti6ykT4xHt/xupXb1ivo7l6gJGVotWJrnPZfKXcAsuSqdA6KBJLYx04LZEzKbXdWhxVWxyX9kESmOk0/f2cCdjijkiBtLqqVOjtodE0HHc9gO6WWlmXUnIYJUx/qDBFAaEb1Lk8r7gNZYVUmk5KNWHZacChIRQK1gmQAJpt3jvoBCDoFqss5TAQ8wlXl0hubprqACn2LJzxx7/48fGrcRGAkJrS9uYAUgAaMak5qXBnlQ9m40NcL4/nwhXqgAyPdIQ1u/13VzGNs/8DxQ7VYETjS2Bdii1JXcszojKUx9UenwHPGcUbzVUbAI6W2hFqE8V+XaqAfCEz5MLGxkZ0y63Mv5ruTLMbkFZBA2qBCBjiSW3xnhGOOHuWS/2C+oEXnz52To5wZm90z5+8T8yEbLb1a2+tZO2GSYLP9GWPBtRA0j++2r6kL8zGAobWl1F5S+E1ctwn0nzsZGVvzoxxqviZJ3Pa3bmvci/mL+rvUVe9yVlIjRmuE1ReznGFely4FhgDp0u27Yc0vMgXYlUPHe1KT5ZgmzeSUz2TKAgSTjtEvC+LWALCAQQ9qEEz4fi4K9jDaQRwkcCAsu8gwO3//Z//Vvvzej9nXPvVFm94zaxNTkx2ziLWgfu0BZqSp0tX+sPmbHebAxKh5HuJ5Ps0oPS5i+U16KDPOh3nkjY+zF/38y23vkYOemoUPwMji26mu3YqA5iVJjQBdzTIakQGywaC5lZrfqFBV2UVvxkN/H7UJ6EHPqAYNhraVcvsVKnmVEfXJABXG5mtP7qw4wbOqQUNuJvrn1kZsRuBocyJrlSNSklmp2cx5uXWXNGP1gNRhBsh7e80u7A79PSqnDHV5tFvW2Uq5rMYcLJEY6fUVqdpJxW6zIBufBdkmwWRrPH4n6slbhsRD/5uBS4BAVnXdlATUvYE1QFAzUtsF4LxSkqoqdkRKlxLjDsxBQqRdBO/fTSQ3evcI7ggBIjVCBDnSkXRGHylIXn8w/SnyE0NaBlCqHuty5IBL7pRoSDlNpwoxs/Zv5YFkieLipo8zwRqf2DmintYpD2qa1buUVTugT1I9i5pvYDdV0bzD4BWdRqRSOOLltNrVXpVuvwFXWf0FKa9Avhj+nTCyeKLkWADePDaheKcvxwAofsiNj7a9mT0+B0El3HkTItUvtOWAZ5+/OhCQ+0FSRSmxxA4Re9wiFXZIg/WwJNEauGHLoEemPR6hQo5jBOrdPr/3SHbBjyhrQhKjrP6YZ6DYhfbNBVdqmMGDjgJDgPSg65JhhS4GBQZdIpJMCa6ky2IoyvJqNZXSqRQN6USUiCAVYiJHYsTBrp1CmGRD6TByHKaHLQy68oMsWew43vyeD9j/+4tvtS9+8Yv2mMc8plMxD9p7MHflctne9p/eZq9+/IvtP9/5QZuYmfLFp+uiK3KhChXtCWLjAiANJ9h3Wjxx3XpuZEUG99NOW6jO7j4GtkkXuLhuRX+f/OgDvmEwe/UH7aD/sMmRbpxi9w6+xIbM3aU3h7dPLq3b9KqkRXtyVp2Rx0P9K8nmJyMPauLOv6Mrcl32PIW0mNaaVABzm7YHZnpcdTy/YiOrOnyyWrGVWUm7BOI2dIDydwIg0Z9JZjqAX1Qxcd3re+UOhJNxtvWS3j3seGqS0hDooorU7PhzGx29756ewhQAIykBfAdRAhRIfwAWaKiNCXjnACVi+EE0jKFgg+FJHXDVVBaSk7Tccg8UVD9AUFbnGWFz5IdNKyHViZKndqkBu95HR8bt0WOzNqf55YyV7S65rljWRgIp/WBTASTmNh+SgED9sZ3gClgqk7lukAAoGtdYQUrFeULY0jAP9lL5a8+X+kInQOROgFV7Pg/63xoTxeU1q01O2uY4Ww7BRyiuyfXIN9YYw4AKRiKffPccvx4nfjDmoGC3vuOwYq1Qmv+2y+ljHv2/2XToXkYrPS1gwyvAi9Ca1tP+V7w/eAAE2EVq9E/VigF989rEQtsiaGuE97sVo/MVbUOdjr9A/87xhneHFBgCpOEYuPQooLl4RGeQuOFxW+1dlUPe5djlRGWt50SvdSbmwZKjfV87UzgsRiBrh2fv0aGqBTFiYfqnmLgEcKDdmGx78GLXOwRGHFYupu0d3+z0bSfsb/7Df7ZCoWATE/LHfAmGSTEIr//l11thtWDvfN1/tFf/8Ru8/SyC/GvvEyyVsLVqD9CMHuy2gHJ/YX3Vk803QBKcSFbnSa0LoTAGctq5BtDGMunneL21vNZdGGf+AbLCwYpbY3b7Rd7wPil5wZhFpa4mD1WH8lbPS1IkBwipYs1yRUkgxbiuTSg2DSRRW4i3Bh0zbcn7/mRMV3X2VrE+aeM6T6WoM1YmF1ddklGT84PViQ0rHE5bPaveopqxQn1zvrgR2CxYqRdtj85pQuXHD9jUveV6QRsZ61JtE8OtvupGR2rDmUdIUqAlh6rC2KN6ti6VO+5xlhFqcw5CGoxrCmAkJxUOUMQAZpQGF8qc1wUrV9a8Aljw2UXF+2gRAACEocqXBgDvJChfQNVYRnZgJcCfSlGZKeog8JQMdIUEfnZEbqUPCvjT+GM64HpOY/z+EZ1hBZhXh92txp2yZU9KfpuSjiElY4DWdKgxcTJyTa+fXQP0HhcDigQIpxgFSccAR2OyV+uRbFt+HFEQzznb9vA7fMOBo9rnYSeN6lBvxtB9X/mWTV+tc9aOj7u6NCqeJTQDGsOU+c/BttaaqHHAmgV45XeYHztk3rjl4737Y3eN3+HEiB4ptj4if+bNQQNWT9qSGjT6lng+Lnl/dxkYu9hk4eGSNZk1BIDYLwCs0A6g5Avs8n5FDZ9f4hTYOvte4o0ZVv/KoQBMjavetM2vgJY8tgl6voEXKJiCAUNdh3sWK+NinnJ2YuG4HZo5pXOFxIB7QSETn9S12lVlb8LE3G+CRSrC7umg4fZP3WI/9mM/dsmCo2Q73/jGN9rVj3yY1eU5DAaQ3cYkIoB27Pzhltt385OJB7ym+xfXC5733Jh2bvUPhmNKvVOTjZQUlJo5hb5yFmVLv9E/qDdil9LqKeWkzP3cnEb/u6E7ucFsto07fpJ/rrBh0wtiIiVBKB6SqqbUrSbu1uG8okFVfERlUmcL6cDXdc7PasuD9Kgzsf+LpLLTYs8YLWt85rNrallbBko/SECKUK6NW1n0quhw1LWRmp07oJZrXNenxq0i1TtvT4sYg2T7bYmzKoCEShsOQVZ0VtF5gaOi7NGoGsytO2tRZ2Djg1fAZtA93IRXSzjHkB2Yzi7CPTfqbOm8zvDSc0YCgfHiXKuuaTdgLA0o0pV7SeS5AmVicF8UQEoOAPKqqZyq1Pj88Fil3VGgrlL329AhLeHQadVR48e95kmClQwAsILG6aIk3JxWwB44GwWT2hSYEqNK7IpcTtc1P50fEZDU+0XtqSPz4Zg2DlI6VqBQmdIclrHJLAdH07LQRl14oN3jojvSn4KkiWv6q4vegMd2iVZMc6l9Q0vUKl39ENRygQEaH3j0Q2x6Zo/TjRwB1bzTSDwJvFnYqmr7rjGGGo5GRH/GoduzCuwGe7JQJz5JXWnMUeTSKcR4zB04yEj2E886p2rlRBxfr7y01v1eV64yqUGXl8vywEy2NhR7pQvP2PzaXaAt8f0lB5wrcdZTzR0Ioe6anMtbZZCOs59YF5LpWzGGV0MKtCgwBEgtWgyvLjEKNN3XNuqNCgy87LIM613krgVrJyEzWhYoutdOLj9EthcZO7V4xPZv3G+z44u+mNW1oNZxlyt7kwl5T2OKDaxkp1LEnGmSRr0iGbDv6RbY2a/LTmLfnr3dolxS92FGx8fHnXGcmMLUvsXsjaitnAUfTrmHWd19gEHcBiaUIdrlBIaBlKx8rxM+CJsR7LxcXUhLNAANW4FtC6biUi+klckAwAAkJTkOOUSziaW6TS+LWd6Tt+Ks2lsRQ7lUsuVZSWym5XI9pfFCVorbaRiktHC7O2vVmwW+IP18xhB1IGBPVuCw3/WMTejA41A7f7SjjxExa9lMWap+OavpLCQ8Ha5Jnc6DiEXdYpk7ypjISgsgaafZjvNpJECKtKRzmmRG454T3buWAAqAoi6HCxu6xokB9jqx1jCqvKvY4dBPLg2SNCaF5KMBdlBzAngxJnmHOasLoMwBkUiMUC2DBmqO/1Ed5pSyQIIPKG40Aky22zcpgdsTMchi4hipz/eIxkZGdmrR7ojotCMZKAenC3RQUSCHQzo5QJT6h3/UVYy2xvIxga1Fufm/Q3MacyKqg76ppORjOrQ4n1mzldKs+l5n4Ohw6RE5Zon0Q1qG6hLjYLksdUu5uUcCwplQzLmRhsm6XWrXDkhRO0y1xsQFt0H9NXVgTlJreffUcJQ8Q0CJEaZ5XZnTR9CYocFf/OSKZ9isrmsuYl7MaJMvxwymcQhoKUrtG2U0YvYKzIUApABTQinhHoAsbL74hoDH2JoXv1BPZkwlvYX2Ko8SShpvSMpwMS95owPCMPP2Bku0Dbfl1YRn0l5lbX/WmrGhH3Wh7hkBfySdtEGufdQLLap5HMb29syGd4YU2EaBIUDaRpLhjUuFAr6jr0U72hHB4KwJHIVlaBet0Kw5kVqxfZP32ZmVq8Q8pOy+xcNW0db/nuxJZYhSDeoQUonpOcUGxwIsanEJYqmobegMi6psDRpMWrKGWam7pLUr7LYVMGGXSUDFCUYP5ipKc/iN2gle+ggXtlhxynxWNmN5UThSO7IhnPYukKqFEukQz2GJJ1OSwIj52JS7a1fFlLoUKXqNG+qIBz4HVthLOaNM7UNIl8QcrYiJnpcEZk4LMF2ITYkYsPKsgHtDeOb3Y6LEN/VC+gmNqCeMFS5nARtxL7Rcy9lScU6uw9fEpCoWnO8uwojQ3LQko+MHilKdkk1PQX0jQBFAxi4yJAnEU7+6Khc9qnrDTO8m0H4C7A//MOTmj2sM4Tdw172m91zXaXl5S+VE74bUBqlSZH55Vx0cqQ9QC+O9g2KAoBySJDFohKrS8D77QZ3KJ46i+E2aquaWEhJGfYf7fCo/tZmAxCeFxzm1Gaa7mYk/7f8xikOHxmrM+4F0Q50cgE1jvnCQo2u6HXW6OzZX7NEjs1KwG2vuxNc1/1WLK6KRpFkqFjBDfcaoUyOouWIiy+6Cfqm0R1Ud0SbQkj71fogmOVUE4Lkqlbpqw1YOppo8OjmMiPkO8k3fsjmiwgYIou3AcQfIrhEFkEm2KQ78bdB28NTdYzIG7/7s1y119KF2+KpDcvuNmve6Nj2kZqtx0/oL7riRC7GiQAzIEUnCCCuJ7nL34X0YYFEYZ91Lbz1BpTvkGvIEYGGv6bRXKZy7xDyDB7pR/cW1jDT0M5s0Wa1VLlVX2n6BeuO8qKB5VFtB+pNTD4El5jTKYr0MLdyaE+nCOYJsXg3evpgL+baHmAvgi4N4c0L2Z9QPGbUTeqPFwBhvUbs9h+HvIQVaFBgCpBYthleXIAVQq4kAKe64bp82B28YzMJM9pwMbdO2WNgnhmjUFtb2S1UvY/umTmvC156Udmdh2LTmuXe0JBvIIgTjX+S5ioXdqmv7e7k8Ywure61ak90AW7NtYVRqMdl0xQrlKekrtD28DH6i7lQSsPBzWrSYxjNs+jWNvuy0uIZ0ARwdysz6bmtgvqSKonKwe4DKsCLo1ZMPC6rvnuoBv91FuC5Qz4A5ZIcWJgb2gudbQ2As8HyU065ncVO2O+pjAuWs52SnIUnReEEMghiwUdSlpHZVmpACk5iFDl3uafmgXjkM4cVQJEcGrEVeoAkpZE0u21dK01bR+JnSjv+FBvj6sZRstKa1a32/XNTLlffYjNrCVvduA8wmAMFfiO0UHCRb5IzjYtDot0Kb9JX+pWNGJTHKjOta7x8OFWDaeRexsUFy1JwHBMqDREbMkeoGY4T3uehkAVrT1xilM8YYmzCjjAGa4K6x9e3eKDWeHBTrt4MIjQHS4tCFwsmLFkegpstdBUAfngPJEFA35sRUvWigAptClFPW71s3luT+vmaPGZtzZw2bNXkEKy3L8YbUAJV+RVIhGM9OFiKApHyqaBvjnJUmgLUhKxgxkrR9dZ02aVxADeUDyHJwFDrW67HbD6RgTlfGSpdAP8dz7i6WhMfzpDxEYVozkOs4IbvUof22Uin4CGxL1pqdGHcZqW+mBbw4S4x5ZX0Em7IwZhiDIYeQEzMNc1NdIMTBt4++UDLUIe5uXscASEI+1BvvimH0hDw5s4/G+xjXN5JrPH+i3uevru65zZ2gN+fdoVbKWOjeY6GsSAkU50oC2PzmgG5U2nin2wENdeOdQz1vTWqzkTYht/6fIb/utQp9pjroAocM2ZQUUnUd60kJreudlt6/fsMYlz4FhgDp0u/DK7YFPqWx0PLHKjRQCMxvkgUmn6AnHjIA1OzLn7Zcalng6KCY0klbKs1ppzltV82dsmwuSKlgkFGBQi0hePPhTBYxxZJYMPEydRereTtX2Gsl6fwzOafGYNzDpM5ySeCzroWkUBr3c4n8Zp+Pj3/845aVMfhNN93UjHn33Xfb+973Pnvyk59sT3nKU5r3ufjYxz5mt956qz3/+c+3Y8eObXnGjz/8wz+0l7/85W77VCwW7S//8i+3xfme7/kee8QjHtG8n0zTvNnlAhYSUBlDoED81e1boMR3/FA5a2cVdOq5DNUPZSM4ai3g0BcDfsqIf5TgdFY+Kzpvg1+B+iaPhOGwWeygUE9Rr7rHLdiK5AIaVFNgIVQXtqAbgSvxmLY6LWZEUqlsWRIrAaZ1zjvSuUeU1MonpgrfsCks3p0OKIYxRR2QOIyj1eJsaE83MdTWrPv/Uv40vSaJ0vp9AnEZjeWcvP1Fbqp/Dq0YDXJciPoVNAIQHkzPuMrOxuZiQ3KUKEZ1ZlMkI5uiGJAIoG6HBzi3KdGDUTk3cGcLAhm821lJjPJ6T9nRpuPpZwdHQgp85zXO6F/AEA4gYKDzAl4ADJhXNmGQ6AHgUM3DyJtdcwBNVYCC75GElCbWbeBv6iSAx0Gx7n1OQIjRi5SLf8iiqRt3Gbc+5vT75IicWGzmbFr12qjKMx/gSmFV4KiglnULzFdI0kbTcuUuvpFRreY3wSUFIA1jXgX0uTSQCBcaREco3gkk8Z646qRAFK1MqQ8vZDwlqzottTfmaSAj6rQw/ZTSqUXQ19cEPaV8aDOq9xCpBLZZqJHB2AMbSgLI7mpeuWH385gnXm/TI9rhUjtJx3jeVJwwf5FzCIx1ZDfYGskIStOJHGy4xkErToy702/ybm8Zd2LO4Xn4zfhe13ol15s60qDm0iNgUhhpcmypMY8jhHBIdzjIdZD6tMpAW0C01pSJtAi6JetGnTjgGPVVVOJ2EsK2BDmQZ+9ALAdUXj4pUHtkc0QbmXrIpgdjEmka/4g/DEMKDAHScAxckhTgYFH8SLGzWh6p6rv/lMa0V92Q3YU8eE2kVzQxigGRIsDjph9ie8enm4sCBGEZX62u2dcLp+zE2v1iPg7ad+2btf0Te6WewllIgWGn/IXqqt22eq+taoKfT0/aEyceKmlQXup0m/a1xaodnh6za+bGnQtBNWpUDC5qJjVnfgNTdmK5YvfLg1V2b38PWJ///OfthS98of3Wb/1WEyD9/u//vr397W+3V77ylfZLv/RL9r3f+732K7/yK963T3/60x34PO1pT7NnP/vZDn4e//jHN/v9zW9+s73+9a+3H/zBH/R41WrVPvrRjzafV6Rq8xd/8Rf2gQ98oAmQ2tM0I/e46L+MbU/MogYjxwIaF3kYD1ywT4u7R6WqqLOKgn0+MXiKylSLIdBlMwSWcetYib9ghmCAczZhs3JtvVBfEXNc84UVNol/7BIj/Sq6dIOUoVWoWm2IqS1IirQmm6VQb9l3SP2PPAvaIQVQR8ahWSGWYmUR29a6H67IZ0QM8NLaHnkf005sbk32R2tqXCi3Pf5Of4/mRd9DUiE7ocNTT6gex+Rtj3OQIlF2muEFxIc2MGMwjnDrqMWopX0DoKJS0iGTAklIWNzBASprLoHBnkZOHsSozsiuA3ouyKbGpSQiYU3OM9z5gMQsYxpTgWEMrBeABBVMGKfplBTZVKd1Mb7Ex06E+o6qHzh8FgaYg2N3y9DjyKQOMGgQ3hlztQWghsMI7MSY7xgp9HyAdWYHxIwfkctv5rEKEh49VPXElIomzFHKL0rUnJB6jrRgUqAcXhHpAnIzDoxelx7oRKYoSZLsVShH+aX0HjjAJ/KOggYQY7QtGXmuq61UDffp8Tl1dJsy2q+/ILEKzxmKZMPfToclPTmpvt87Nu2MOOmhXUEqZ7zfACVCyDfAAjZl2LQY17vLBgX2hSmNIVy/B0cznsTpsiGHJtiCVZTfiMbX0h332cbcjM3MzmoqCuvLtNqJulxZQDr2GyqMjKv4GrNBwkHajLedtjHUJnwyvn2e0s9IelQm11UegK5TCCMq2NgtyynK9GjeN6bIgbowBlETxDsom1y+MdApoy73qAfgR0oSnk97NJ5PqI8YF2xcDBJIw3lNFY1ZaDdoIB0lVNQO5na9ud5GaMA/+gSX9rmm04lBcx7GuxwpMARIl2OvXgFtYhcX1hMgg1oNxphxou/WfMEaO1c8qN34STs2e4d2gcs2mc7aVaOz9tH3fsgWzi04M8Ekum//HrvuCTfYs44/xv5p9FYtlGftodJB+uBf/a3OulhVWfIGpR3Wg9I1f+wTrren73+sfX71Dptjp/JM3f77h95vRx/9KHvyk26Q+9+y3fLhT9iJO79pGZhndmZhtqSGtSHJ0b6D++17vvd/sGt0Rs5XzyyYHT7QrQn21re+1X73d3/Xrr766i1x3va2tzmIedKTnmSvfvWr7eDBgw6WTp48affee69985vf9Pik+7mf+zn7yEc+4gvS8573PG9zJtNaZGa1uP/Zn/1ZM38A14/8yI/Yc5/73K5pmpG/DRdpMc2jkszRLzDQGOKy4+eMTkMqxbMLC7ACYmi0m8uhlmMYDSnTs7UlB2cwHuwgE3JinpC0lMRoV+T+GLUkZ7GURVrqlPOjU1rwYTLEUCkdjDaMWlTJ80waHzCfOItA2gEgSDJHtIkxu1bOS/VyUmNHAHzynFRFJMEU43ZRggpJS83OjomhvlvnR92jXI9KV18SMG/WRSlksExgSh30igq+yy+WbpB+xR12diIvmw/Z3YgBR80J99ikxXB8LpVVvrI5E7i5r7JmCxoz0B3JE+CKzZWa1NLSoi/p6c+6vvVq2rw8/c2lBB7UE+yibyClUnwYZr7p/3X9uW2SNl4GqnAbOQAH3u/6jsGBFqDEN1RQfxuxuY2sPWpkxua0E49bY6RKM7qexp5OBY+qTmwQjAp9zG4KFGoMo9aaBEiM45zGJZIplweIJhjMpeT1rlCUF0iN32k5pWnSnSroH5I5d76huaufHRJx3XOl+gBmvZWZqudNktRCczbAj3a2gyPyx5sfcZHYoBLJP8BDRX3ToFYkVc9vmPtZlx5hpxXoS3um9X7mNSaW5AETJyCUxXvNuXWAAUBkAK3BNg8vnNQ15hELJS9UdcelvrWpXZo7T55xkD41LZme8iB4HK1VWeXBHLBWLnp5m2onXUygnpSPGiezxYUEyov5kg+2QFmp8ALA+dctUBXGNODxYGba65KkNhtVZUmZAEjdAhQmH+qQ7Cd+o8oXoGij0Y1MSEP7Oa9uTQe1h15qPOzzhWtv1FD51wrM1fxqlROvAMTh4PHYBmoWAvVlo4O/igAl6tQ7qUsjm+HXZUSBIUC6jDrzSmpKmLjCpzMTAzSeXf6JzLKDkqXyHkmNTvscWpKnpr9539/ZfadO2sFDhz2nxfPnLTf+V/Zzr/tZe8KTHm23Lt9tldUl+7v/+l5bXSnYXoEaPNotLS3avr3z9pqf/ym7/nGPsNsV58Tpc/ZX7/kv9rx/81y79slPEANct29842v2pU9/wb1cnT+/4IzW3v37nNl46EMfZt/9vKdp7Rix0/fdZ8d7AKTjx4/bLbfcYq997WubLT537pydOnXKrr/+er83NTVlR44cUZnfcLW6G2+8sRmXg2dRtSMgfXnVq15lP/RDP2Sk6RQ+/elPO/CiTMIgaTrls/t7WliVGDU44EZQ0Yg7vq3Fbff5kxL2EumFGB39wURy/tG0jMHG0iN2rr7qjHRchBlvMB3TaUkxU1KxwqCanWgNxxndm0/JmMdzDaxOYA6C8oY/aPtg17QsxmlMjFxymWd0w2ZkZSs0kyvK61zBpnJIPpOx2jLbxU/K0TFSZg+Rnc098ip1j3b4BZjGsg8cSEL95kBmRmxkPLNKbEt4vQdqUQq32GJAYbaRPpCUnfM9YnZncf+rsX6ytGoLlZKcFgTG3NXZFD8ySFV2sHXQKx7pcO5wZPaA7ctNux1J1aVUUr4UkEpJtdU9i3GGlNTaUI1zjlRjZtC5KNmo9jTuLU5MHwEbFZjWCQH342MT9tCRKQEGtU9SRYJDc5W7UVO9ZYOEkxfaM6/xedVm1pYk3cCtdAyU5eNbN3iXmBPZuU+ny7JtW7ZSVU5G5Awkn4ZRjZRRPaS6t0Hb5YjCncyAnhsAJ+atwp0JZ8OK6/BbMjldu/tzgA7tUj8BkHBEgbdDd6rRiE+J0e6IakMFNg5gZ9nrTzLdutUzEHdG71ReqrjtNOYZskoOmUb9jnKRwhHPywjVDw4uBHTa0ycLJr6TWIR+zHc93oFRO4gMbRHlvcP0S9ImFdUMoT4p945aEkABkO8mkCf9mwQHlI3d5JhoXZbkG5DZ7eUiJVKVszpAmsPQkzOsS1cFHAJIDJUPn+SGSiFSXwFB0Yu5Gu902ONSvnusawBG/dwWSL8bVTs2M4LKdCtLVGWn1KeRuWVjJDrjQSW+V4jtAUiuSurfjU698hg+u3woEMfQ5dOiYUuuCApsnZ4HazLqbTPZBf0timGCEWsxmuzgX3PNo+xX3/zrYopzds9tt9kbfuVNAk5/b6+78TrtZIr5UjEpMV/XSSr0S//+9WIm6nbbV261t//O79n7/vof7FXXPEEG0qrZ6KJU7CT10CK4UpNnPe3+vuqnftw2f1K70AJXf/A7b5W0atl+481vsKnZKWeCqrJNqkkHXWtYz/DiF7/Ynyd3hffu3et2R+94xzvsJ37iJ9ze6DbV/6677rIXvehFrmr3rW99y22PiHPmzBkrSSUpn8/bS1/60p7lvelNb7LXvOY1NjMTmH4kTf3S9MxwFw8dvGjhhf789QqMi35x2tMDfNhNxkiZsprpldmkVJi4vyZpI65sk4F4LPzjklCMI8/UGJmUagahwTL5Nb+QJhE3qDQ1bjefagHXrmVKzARSlGRgJ3Q+X5Zb5lX3xpdkWpPxOl17/XyMA9SareoU1e+lAUlHJJm4N22VE2J2pG43ltGA7J+0a579H8hrltq8Pz0rOUgER7B3LYld/zwCOxi95lFdzvDZL7A6o37lrBbA0ZLAEYAA1Vrsa0ZkTM8mB0DJA0y6Au+WMKmVi2U7ZQti6iUvLsvepCgwJKHAutTxHDAhPRKYgnnGJgqPeqr2rujFLvhmw7YM1bPIYFMzmLU9IxN2GMCuuuLzyxlsxqqkKutqV02SsQ1U1xSfKWSjIXUZ05AFZMWATMftXnTD4wp8oO6L1MdBkaRONRklZSRRGpXTBu8JtQ9gUxOjyXle0HlTYO3U4cgAAEAASURBVIA3ZcvZU7oDrUYFLgnQNaoN4kBjU8AIJh3pUFoDG2C0LvVEgFQMgCPUnLxyuulODPRdVh/y7gwaeP+QeACQ8AjZKcR3lPebTqMW8R7XAO3BPe4pgQgKkORcpdh/uuuB8QzoQc2uLnoriuLzsTW4dE/lVjUXYPtGmu2xtqaJv6gztlLd4uMEJiWQnRVwwUtesMJq0T7m43UVraEF1zFwzfxWl4QS0M542NA1MZjfADhIgtR6TzsuYArtV2XzybNQs1Z+Md/4zRNsntYlpQWGDRpin8X4jBmkQCmVWZO5aV2gjsOw04iEO9A8pht+DynQToEhQGqnyPD3JUEBGEp2S+tiKpgMmbxHYDC0+DCtdwtx9z0t70JbpmBNnJxhMoNqhNQs1g4csow8ZKEGQmAXKgTF070R7a6XR9YEqh5h8/v22vmFBTEW2r0VCIuBWmyOlOyW4u12jxiKCbmifsRY4xBBJurMiH1l/V47W+XE+xF7tIxBxF/sKmAT9LrXvc44nPXaa691W6MDBw7YoUOH7A1veIM985nPVN1G7GUve5mhQgc46hdQzcMW6Z3vfGe/qN/25y2qbi+KBRK1D3TK2W12lbweYyCZA4s2AIczR9oXWuJxD6YSo/yadnY7BeIAsojDd3s+0B1bBuwXGKv0dXugfZ3UX7gPk5bSwBjTGOpGh3A/fPIuYMfjzJaAArumndT7OtUBT3YZMWfV++WlTUctjXEkV7dC2zPYxW+kGOz2ojaZbD+vh9si7SJPqAsYxZYEdaF711atIPfXeBaDcQ3SAFEJmsLMimlHfQxPixoGUrWTlzypmtUkTXKnD0q3LsaWQ6eZNTYBCTJqX9fz6Go8My5wpPwYKwDl4AygAbza2kD92kmKbY4z1XpAfYiA6h6gKZ+TF0ypNp3SQbnpklS+BMo21LagDogkJgAjYEBZY+WkWN87pFx3DssXqeJpT99rAE1JE9ofKsV80/ytMgFJZfUFDmmysomJdfX6KQN3kS2pKZJk0nKQcjO95xXmS6RDERxREu1FZW0Tb3moP6oegO8RxUOaBEhyF+magymUPJHl4k2NdwY36zsLcl0u1UjGFW3oFTq9VSENFemVsu2ZaHHr52+x/UcP2uFjRx1gEYMsGNtIU9bVn2Ou/9U5Y+jEnIS6GfMJcxqOfwbZ4KAsCoNSnSAheVOqqyhrjCPhKQuMdJJWMYe0B+5wzIG2CT0jBNkhz7DixnW3RU+txYqA6wNUl/sF8gK8R1W70OZONemeE7E5LgHPedR3vaxc1C9jOpg7tL572uGTIQXaKTAESO0UGf6+JCiwXF9rMBmaVrV41uSGe7k659IhzhRiF3hDzEK3wGTMXwgs8vIIdfK0/V9/8Cfahdu0f/nav7gU6Ade+mJbXi9ZSeor0lxXdNkdiEEpSAI0qt3CT372c3bfyVP2LNkQTeR05sWGziBp7LzijGFcW9Gjcqd7HkZAqYO9SigVY+9VGcUuSAceCcbOloKQR/zEc90nPvEJW1uTEf/EhF133XX2sIc9zB9jk8QfqkBIkv7mb/4mJuv5/a53vcu+7/u+z+bn53vGezA8ZHEORrva+RZDgXpVTkAXdQtGQauvt9aW56jWtBb1rc/9F8yadtY3xLAANtg9TQZKgJkJbrq3PovxsJliR7vkxv3xbusbpog8OtWVuqHeAuPTeURjVwITAlMQ/mFDQZ40fF27vIMGx/c6tHREYxNJBtsNnVs0aI594inzcArK1lIgcSfGrU9uzcdrksaeEGONhAiFJVTwXL2rGSNcwIg7gw/DrkI3ZbsDDQC0Y5IGc+bSunbbGVt4GYOxZyw4VUQj1O2ygCMBL6jvbsRFe/Fl2rwBuNOuVttg3AAW2DjQp83+1AXAgXmLHkT6UivK5kn36pLaVrWhc7dSlCRdOKi8MwJs1A95I71UVrqTauedACM5LaHHN9V+L75RCPkSl38EgDfSGt6ByIAzZ2VTHAzLWUiiAZb1ygTQhoTM1eEEJsmXTSO+lXxLQMWuqWa35QlxFTkRH4kRtpwAVAdvIk5OknfAPcwyUiPO1xl0FLo7dNVpUptRU3I2QNsuZvC+4U1UGYBwfbXqJnocffhDLD856eA7lkvdsZWpCewgYdPDbTSLceM3+fIGI1Fh88cPPvfSYozt37SUeJwxJ7+NLr3ZHsur7nNDXvNjRkCJzZPorIL4lO1SvA6JeZYMgbrMEtsDYwqX4oBcNg4GCeQTpU1At5oGmK+c/s3TWOLW3HjCBtSk6MU8SABTV9bqvsHApgfv0DAMKbATCgwB0k6oNYz7oKJAnCoBQuubGVsoHNJBmnttKrts0zmpuY3IXgOdaTEyHTcglUEdlSjtLvGvKBWa27/+Da1fMoyXq2uYocJq2fYLvOQyYoJ0GCjPbv3SLfbTr3iN8hQwE6PyXd99o73oh/4nW9w4J2a04IxSWGbiJ0oH4a+dgNzlWWhL+9PBfz/1qU+13/7t37ZnPOMZ9qEPfchdgF999dUOiJ71rGcZKne4Bf+93/s991Y3SM7//M//7JKoQeJ+J+NAOwdCMCzqaP6taWH2E+m1c4lDj5S+WaKTC3lI5zCib/VRFZnUH7vZ4ZylIMFE554zjLBJ6hpUKMCKv079TO8jqSSPZP1iftyD8ekUSItaHruurZYEdhK2RQo9W5ifTnlsuacKurQURg79rG9zgInCScW6PEOG9sN0U2/RC7uuXQZoVhFjjZQIhwoxcD/2gYMF/QhgQk/ETEd+2llyeXAbkUe/qg6lrUgVLJVXP+sd8kNnJc1DMONqWAKSeDrLaxxk1I9QjbG2UVEbND/gRAK346AJxmkehlFjFelALJs2B8DBtyTj2nxxkKF81vUbTccV7fjfL6D2VXlOA1TkJcUar0nyogJx631eI5P8aJ+XrzphlwUI4S4ABIld6FWl4x4gSfFCPULiUQG7UTGT1CkZxqSSiHocUH0DaSZqc6qbbjaj0Qa3yYppicNGFap1+nL7omYPhGQOYryOoe4AI+pJ6bhcx8nJIIF5vi61PYDLTBbPfq16DZK+XxzeNc4FOreuTTD94/wevCNKIdHLpMIHjx3xfqYuBNK41FFt4M6G70CEJwDy5oDjVlug1fQl47emsTxIIL7bQ+rC3dIzJ3ou21OTPyBsQkCSvsbxB3HZyMFBQWs+2Z623x3qwXznmxy+Puv9Vl1Ci/qlbjjj0YxAHfnb0PyH2h2A2Z2o8EsPoCrPsbEKB223wBpjdL0sF/7yIpuTEw08+YXY/csfxhhSAAq0Vo4hPYYUuEQpwGQs9gX+Q4tzyhYFklbKc5ZLF3VC/IKNZ1a0Iy5mRBMks2pY+PWtxcCvWbyU9uEPP26/+Xv/h21mpNIib3JvfN0b7F3veKe98XFvstmsPDwJIMGAH9Yi+G/+x39t37zjDvvER262JzzxBpvdP29fXLxFHswmvyMvFSp2P/MzP2O5nPS+xcS8+93v9u+rr77aXvGKV9gNN9xg4+PjUgm8xn75l395oJ7GmcPP/uzPDhT3wRaJMQFDwhkc7iVOruDxgJeRyg3LNIH+h5mCiRkksBADlCbEVuTElfrvBhvBdafAmFzbLNoZGT0jhehUFvdQQaFe7fm4Eb2YARb3ZC0ZvaigIXnEixaBe80Aw6O3Avfi7RKvZpxOF7wiaBKmtaOfUxvRo/k2BupcwHOVjkDZJ89ZeKaEsrgF3onNSacqurQi8QD64b3NzwASWIBXLYvxWhcT3h6gpLuWV/NHJ0Rj/QG2vBP0cERStlExXR7oZD1AKlRCwijmuCrpT1kbLs4Aq6yMAADli+939IKECjW+QkUwXm70yWIsK5ZeYANVu01JqUgA2MAVeU1SldiPxEXpqqIztxaEbhyQuJqaZ+1V8gxVbkq2kMwHjA4AKJIBGFeGSk7PfdRQ/W1Bbwd1bQvYHLkcinL1HICE2pzTRnFRSSRvD/5MP9mdQv1YEqh2CVIjZutLeTKueSvdVXmDqd1alfAW7cG7oPLGxoXDdVHpoz4zmXF30d2xAa2Sdny1qnF6rrasMROAO5swi+uS1ajPJmSrOC7b1bs+9w15Jd1ne6XeTD8CpAAea5LqUM/gAS7Uf1KOZzKS1PWqJzGRvvC95f3uUXvi4nqc9Q77KjZx2IZj+PqgSqSlq7iNmuuI2kdagFWg91aqJ5L1vSTfeFg3442+wXPgoPNtsq3UgnkXxw/ZBsAkf94HB+v65J0ONApVA4vV1vRcgzQ7AciUhF1uylErjMMzxBx+DinQnQJDgNSdNsMnlwgFMIrNiwGenz6jwzR1yGRdLk3FfBR1OGupKj10eWjKpMUu6j6AiKUGlTqu8lmpzTR39cSY6LogDnF6eka2RfN24q67bXVNnq+mGguUZteDhw7aC7//xXb69Em7/bY77W/f//d2w3fdaEcm5lXe9sPuXIqFBABG4SKFpBtusnzmM59pX/rSl+RVb8ltjJLF/MZv/IafcwQj1c32CNW89hC93bXfj787pYnPHtjvsDRioMweYXJZ55oF0ZlddQEqJUkmISyrLZ5ukHqTHwxHDN0WXMbaMkzV+rIYuWAnF9Mkv2F/wu5q8i7XQQLEKfOABtpCS2EWsLXCHqCj5Erl4so2eJDqVrv2shK/q5ISrKskV69K3P82XVJDQFJNUpr98gAIU4fkgDZDmwsN5A8wGhdAdtfS+s29ivoEW8ZuIZYcmX+Pp4SkjSH2CUISt4sUEMCtP23Jy/V4NpuT++fIzAmQya6oKAcpFdkvYePEO5kSMMpNyIMhtjnKmL/NsuqlYwAAYuzeBDscRjfjm38hHuMwhQ2VGEDycokOlVOFcDyTahyUi0QmHDoriYaYVWw3gSGcx0Pe1F86laQcKAB03Fug2hvmVDIQI6vyeIY7dIQevgGl+15nsJMADJJ5b4CnCB/MxoA3zuDhzCIY6XEBiylJxtbFYCNrqzXqiiwB9bk9GiuA26K8kFYcmCFpS4Uzq9oLSJS100vqLhmnLdQKDjwC9UMTqDeSQNypj24W7Hx1xcbW85bbkPdDvYerG0VXMwvvb6CRqKBe1CHiWmeQ6gX1s/gs1M6BpNLzj7mBf+q1gatObqh3Asw4AHY+NeUAA++LlL21tJDtpGh6sQIjtdYAkuTJfIUNYHu5yd/J96pTPaBFMgT1SYATFN0e6ui5qoARiV+D5BY7UqRk22Nzh3eER4Hq2/Mb3rnyKDAESFden1+GLdYukc6GOThz2uanzgoYTdqKgBJnx9Q3xEJKfWfv5FlbFWAq6l5ZbmzXZbOEat6qDI6lp6JZcdMWFxftUx/7pDwsZe3O2+6wL33hyzqI9Yk2OzdnZyunRTfZobBIazFeqxUtPztpz37es+0df/IO+8SHPmLPfskL7F6p2ZU4w57dUxY4/VXEcJaqslXQ2TIcLMi9qILR3hlf+fKX7fQ999gv/MIvtD8a6DcOGDqF5DlHnZ5/u+6x0Hey/bjY5cG0sMDpbN5ti3Asa0zMU9iL1Y6iAwx2V4MaR4xz0b5Vj8Jm2c6uL7lKSGSqOuUPM4EbWs58aQWYYlQFy/5Nev5xoCIHI0bGgoU9GbDBKIopStoUJJ/3uw67srKbg1dyDBhL6pfywp9T5/tqiwIyOWcqL2bJ5EVz+IZmVb2fACRvL+JjPXCmVM/6BUA1QAuAwTeMqAM63nnlNap+nJrK2aTAkaCHFeUem918PN7VygJF+h2BA4fajk9OSMqtQ4/Vd6Maj4/NH7Ej03MOeKiX9npcVakgicV9lUW7u3hW84+kU4ATVRYANyYJE9Ki9oBDGVzXI+Wg7bDYpEEiiUIe0h0HVVvGXnsunX87vXAoQRANREC/xF5pRO8a+07YgDkG1bjlOd7v1KItIIlUnBu2R2dOcTirV1T3sJEZV9tJQQiMa/h0z3vQSyAMsIQ6prQNw4GmKruZiae88A/eT/51CvHdpu8PPPFq0dPsVH3R60v8+O4m09JmvGKykTEpuWly7PEs2h7xTgCOmBtQtWxRI5lb92vKnpHnupnRCQeggq2aI2VTB4BtUrZ7ep5E+nMVejh89kpFuREOcb4TasCRTsl0gEsH6BoTqAnvRA0v5tOqX7wTvsvyfST/O3IGopprfLKxxDuLVVMyDfVCPZbxxjjiMNxkq7fmOvx1JVFgCJCupN6+jNvK1O3ue7UzOq3zPKZ1Xky5lpGq3azAiNQgJEHKZ6TKIwBVFTgqVcYdQKW0KLOzNTk1bnd98y5721ve5pNpWm57b3rKjfbyH/93tmRFW9EO90Ed0jg5pUU8L9fBYlZO1xbsKU9/in3uk5+yT3zsn+y7n/E9dmz/frt99LwYpElLi0FaFRg7tfIQl16hjb4+KV1pqcFNTGrHuMFQxG5hkXz2c59jH/7HD8Zbl/Q3XvDYFc+MB9fXF68xYQc2LsDky5LNIozQo+y7pHEJDN8sgiy+8XvCz1VqGNtfpIq1mAe5wNUi7Ko/MHFeu+6FwPKxMOP9LDh6YPc3gCOXfHl6Ga/reTw1PraulauWfTEBRQEq1Gt2HZR0oyJaTYqm8L7wZA9QgH60d6le8H7qxFDtriqBWuwdo24JY+o2RpK4YKegDnJQ0y1v3lP4f/qJQD/kJZ2hftzBPgIyAVRQ5cnIXhE7I8DJmp9PJIU4Mc94dsPjHIl41/2AW80D2DceSOcF1ke10z9vjxRAAtS0Bxjwh6f2yd33jH1h+U47U1/yuUtTHpWQyp82AKTWlQw4gpE8S/HwXsZhqYAq1UV1YMzVYZS14YNjtU18mNMJyiLJsCfza7/uHE8lqE6SoYnZ3GfF9UlJdZbEnHLANuVotvZKB4k9qq/7JTXiO1A4lEI9k7+5C835h+RoU/REaofzjADsAYD0hbdQsZIbDiHP3XxSZ9TEKKNnUMSVe85bZlKqc5M6QyjotHVN4vmqDyoaSzmpf3knKfao+omtHGwnAc3IfPDIiO1jfB0jZaBFt0Acznia1RoXnS5gl4UTg0xKjoZ00HUYuSGHZOsY2e71UTdJG8CFJGmit6todiu0cR8gwrlyzLnUPQys7YmYq5A0UdcRueEGKHdv0fb08Q50iDThnoaE/iRRlOYH85iPGdU9jI6Yyl9Fp/W4bzoFRzl4DfT5oRVteHWFUkAq7v3e+iuUMsNmP2gpwAL4x/d/qG/9wiQPM7CVaXC2pqFiNzUybk+bfJTVl9bcOx2MhHu/m5CK3fS43b+xYF9Y/aYYnrQ9Lf9oKywsiwGS+t7UqH1h7S574vjVNlXW0l/QwXo6K6iY3bRx6T2vLa7qbJS8nZcK3ydX7hKztK6dzpx99+TDbWyFHWVJDOYm7Oa1O6THvurM8fX5Y7a/lLOHHjhmb3nLW+wXf/EX+7bxwRoBdZ/jVx+3Z/y7F9mLfuZHd13NdgaARdC91Yl+HGTYHuhbFjd2fN32QR3KgovKDie5B4gklSsxHxxOykLO8plcXNvz7Peb/GGeWFZhltk7ldxH7tuXnFnrlz48x3g/7V6YUM1BcgTzQN60AIkX7YUtTzIyIa0AmcqN0qbBytsey2m3JincCUkj9tUtc0BUGVyrZ3uGD4I7zhA2GE1AK8AT6S22Mu45TdIOHBlsCRAYwiugGoT0BVslVLwI9FNO9+IGB7ZHnLUE8zoOs8s403hjl35VNkYVqdUROPNn3e2NpDYlxw3ZqbwOaM0IFOWkWpjXuU3zdix7MEhRPMXWjxqSKAEsPPR9buV2+3rhHtWT+guMSYLUiyEHuE1oOx2btjUxxrjN9v6WUwN3E44USuqnDrDUdoBPGrspfbef/7W1Vtt/QVe9CJKcTdp9K0dkC1qSBP+0GOWW+jHz7IjyR6V5Xmh8T0OtbntuW+/wnjK3ADZxmMCBpnzDxdCenCRVR/J7ZZS/VSqzNZed/tq0M1KTXZKb9V7zBPS/62Nftekje2326D61b+u6061UJN+To3Iqob6kVwDgE5JmMIZY62Dj6YP7qwt+FhrxiI8LePoSANUYrs0iqCcSmQNSQ0SC0ykwXyChIi1lMTcyT/LHP58tVbf4jzzIF5uqotznI4dpL7e9HJ5vn69asTjkNQAk+k9+YgXo4kZWK1b3K/J3Ca4kcbyrADney9rahp29fd1mj2szY4acR33zKEiHtudHuQA5aEDbUE0kvGr/s3S/bX7Ynnx45zKlwLDnL9OOHTaLiVlLpivXa73WL/YCIu8Tpkyp2G2W7FM6p2hSDgxkfe9xmHA3N1esuFqUi28tivrNQnJz+Ta5cEVtZsMWV1eUtmyfEcCZl3H5qCbhysaiLeog2GkZD+cmOVdHeegQx1l5w0rJiJcl4JbKCctJAkUZq4XTtlDXYTMK6IZ/tXiv7ctO25/f/mH79Rf+r/aFr37ZHnn8YTYnFb9LJeBGfP/BA/arv/K/22ve+qv29H/7gl1XnT7D/iD0WsiG6yLbg/qG2WUxTwb6HBCBisrWpRn2KSzVfNYEoIr6xu0y7AWqdv0W+2Q5XDOG3DZEO7uoa7kTEB6ob4vuP46cB81VjIfGGECLfU7U61opQ/26gyO5Qm6q4lGBnQXekep61ukj2apsZgQE3INdqwY7y/HBExsg7JJFsT7uLlmgpVSXYwRJMTYBFvrzoEHBe+6qr2o2zhLoACjgO+jqD+RyjJ0wisIzmEQOjcUtd04AA/BEn1cFmgo6GiCCo1BGYHdx552VhCGl+EiNGMMj8sI5p0OoJEfSGAjjJimdQQ0uquViD+O2U5JQpVxqpLHbp6tQqVtbLzvQjvX3OjU+kE5hNzQi+68ItHAiocarNN6cTqmSOcSMNNcKvNR1QHYuvWIHp09IqiYXOrKDSQaRWpytpKsClPRP2KgIMSir23sTwNG6ragPz9dWXApGbGaBUdFT3KzGb6PjkgXu4pp5Hi9/eJ5jw6VfgIaHbniYDsrVm9omyeuVlne9LIZc0FoH9AYpMdIbAgw7Iy2n31MpnRemcQIzj8QDEpZ1oO850QGQGEYXqUJgTgvSm3hn6zcACpsth0PaRGQMhWHE59YeT/7CYxwHpru0WuMqpNmad/w14Kjx6NQf6U1K0v1+gfFBfNrN2syciYsJNsEm0lkrr0iiquGAip2DfPUfarDUlbO8mqsBN/SuIxVr0gpQqIrvpO796jt8fmlSYAiQLs1+G9Z6QAowyTEHzqenbF96WpOvzhURI3Cuuqrzh2QrpH/n9X1OO5FMuJy8vi8zI49EWog2UJXJ+DN26M/oQNeUDofdn52xvdlZm9W9s5Vlu6t0xhcXlhpfdLQTNZ2WVyCVy9KvPU5nwOfSUrvTwlmU69/7a0tS6xmx45mDSgtjtikD32W7u3LORiY37Sff99t28hO32te/cqdNpVedEV8TU8DCMKkdZyy/y2JqOa8EhnxVmKEgHmRdagrK1vKpus3J5onWF7VLvFRxFsLqpaJ95k/+o80cPGQv+skfFnMW3ECz0HRjSpTJwOHs8ik7fGjDfu3Df2yPvO7agdNtjxikIpwTlVycg0MNX9UcILGotTMG5JVME/LeutzBlCzjrld0n2L3XjutgwZygtlG5QVGGIaW4EBa98rageROpGer5MD4+V4tTVAA5MVAO/CQ1XgUb+tb40N/nQKAirNGAGqxvE7xet2rynnJ2ZX9Go8bdiBzUsWNaJzoS7QJb0+v1A/uZ2w8pPWupMX0OBCRrQFjBga9roNQAbYVAW4OgUVli5cnJQBDJ9B6du7HFAeQ5C+5EtIbYr38E/sizkjjGWe2IE0iFOWspaJnMfjmjOhJ3lk5ZGiWoULGqyN2VHWalBpvSZspY+Lq0rInSgIkd1EskORjQ2lgwFFfHUVyFAvp840NCweV0jAYRPf6lhx/Aiwjcu89KgY4K+DCjjzSCdyAy2fHtnLC+PCmNz6QkolZlZ0VdMQT33iK8+o619BpovJXBdxymm9xOQJ1OSAX4ITUNFlqcPywbotylsDczTsMgAiuzBn9krioKCQceQGJLsX2oVJ4rO60RXXrhDwFjmiO5H3fPqdsz2rMwVEDdG9/3PEONWdzJK2+nNEuXZNRT8RWFwhASx3cG9WqCTZbM5Is02ak18lQllTFx6/TMfkkXDvtnOb63egiygkj3y86fhCHtQ6nDmOSCpb1/oR0HaMPfJMqIDXPqF/ZOGhWqkMOAKmi2scGWojHiA4bjZvq+5qMUVlfx+TkpCgpGw4xoodFtGpLVWl7yJnG3MSiQCJ2UMyw/BPw8usOhQ5vXXEUGAKkK67Lr5wG+0Suifb6iavt4bl9dv7kGTu3sGT7Zqft+quutRPri/b51Tt9dxAG6NG5g3b91HEdArtk9584rwPmsnbdsUfpfJGSfXr5X+R6oWKPyh+yR0qvfmFxyabkpOFEftJuKd0llYic7BKyfi7G4/PHrSIVOzmhsvE9++xLpRN2MD1jV23M2OK5BXvI3AHbP4FLY+0WFjZtqVBwm6XS1H6p433DD7R7+PwR++GXPMNWnrPkBtXTs1N218iymL1Ru6o+JW91skDVGrIuJxQpMReTs3tUzxH7h3ulCqKF/QVX5e2wFgXOdsrNzds/nC3aHct1u/MDf+2M/A+//GX26lf8b1pAtCDNZe2Tq7fZssBI2LG8OGNkVYBuQwwZ51PQFzsJLFWo0pEOpsAZOjFcq3KyUankbG5qwUo6EJNDfTnjiMV10DKifQ+LMTvX7LTS7iQIafALXnqLHQktYFFGYoMUsBUP1T5UrcJObrxPvqhoUA4MOlIgjPhZ/lmUC5Jg1iLj66WFMto/8WAFW05+zfrAkKtUmKPAOLWn6v97Q1KCldKM6Dotu4SqlTITlpnQ2F0Rs3lAwAAvaoMStn9xD3gMJC0bGodIdrCJAHQAKkQw2asJZEgddlQvakVtlMdmSZVESUlmCPShS4gEelBrou98RCouGyucjbRWLTsYGBNgAUwUYBYFhFCFAwA0g66RHOGxLqXzhEBoSFmQDI3LVnJTTP/ZUR0YrflkavagA6SYFobNVQLJTvUfF4B95DpbL5N2WjWSk2se+JiKabp+N6rkh7nKNbZn2YgcDmpFXS/YjaD6JTbT841SrahWSBJoSTsJnJGEah278yFP0dGHDlTsEhSRNMsjkuUq8r6UDuJGsqc8RBarpsMBq4B/6ruuPxhjNoooBenZGCqS6hvqQrkAGaQ9G0J19NduAylLNXkGVN+PjWHFxdvXOyB5O/W5O2zqqr02c3R+R1Ik+m9Nc8fUaEVzfHeJYPPdb1SF38GbJeOvBZCYD6AD9nzzI3q3BZKgT3vodK89TqffpKMMAJpLk1T35GZPpzSD3KM9qP6NSrrlGxkqIwauGAuoybHxEerees5v1PPod3f+iIojj/XnzkE0qCobObtfap+of+ZSJdszwaqJWiOu0ENevPNc7ZY2SjoMlwkFhgDpMunIYTO2U4AF/vqJ43a0Om5/9LY/sI/JQ11NO5wZeY668cYn2o//1KvspulHyMboW3Y0s8cemzti73/P++39f/leW15e8QX42sdea6/48ZfbUx96jf2TQFJGE+lXv/BFe/sf/In921e+zB71nCfYdEUqdbrPhAo7US2W7a2/+zYv61ff8ms2I9UIdts+f/Pn7I/+0x/ZT732NXbtM26w0krR3v2u99hH/vG/25NvepL95C+9xvZLenVKnryuUn3uuf2b9uY3vsV3U1/50/+LHb7p4VYrVe2Df/dBe8+7/8LLckZBDM2xq4/bD/7oy+351zzGPnhqSaoYY/bf3vNf7LM332yv/c3fsqnMnOpXsLv+6UNOqBu/6yZ786//mjzrZey1v/HLdnh8Tofs4uo7LBIeaYcftH9r6uBuGuNbJGvti3v37IPEhAWe/HCysVSatcXCvFTBBAZzOoxXu//s2C9L1JHSLmZeICkNA9w9U38Co1eUamS072GMhIU4JCQ9NkAy5ff+jAAqZgsDhoOOreDI+V0HKjDOLLgEZyAEDuM5RTGPuPCGvOV6VhZL7ZSLcfmGbkiqVjfXnMkPgAtmXao5qst2uidTd7+mlqTF0yNSo9p6ypZ0fti+vIDyqpjfVTGHe0LbkFQl+09kU4ApD23l125DzJs8oVmkX3t+lB+fJ+ncHi/5m9o5cGGzQLSCgUINB1CMhAI1N1qR1vlpm5ztoz9AZ2Q2KY++RmsLT2KAKpFKEiL1miRHABxsd6K0B1Dkzhjg8BOBA6ZTcjcMSCIomv6QntTtNkmaRrXpcXBT3vvKazZWOOtzTyYnTxkqH8BFfGBZrbwq+4pztqdctD1Ss1oTg3qPpD7fUq1X9Y0aHn0S1eRItS1AFMVhLmQAANhwzz0m6dqoGgoznWSosX3bJ6n1mt417HBiW5EScR3z8TJDRQUOKMQL2lZ88gbRR9Q+VJlRU5yWmllWAKEgqdJiVVtSeF1RNm435qBT9RUwyrh9T2gntoRp1SWo3Mp7oOxzLnRcKjsBsrQ0DTS3ZNdEz639mWxD81ptmTy8x7LTOdElgOzmswEu2AJhPsOb2uB2L5uKK9Ct8TzioMEHSrO0pfqab63s6+AEoxlpgAvoiY0lIaW1Jdm1bPQhpFpRn/mA8lj9P6Ao73F7AARBB86JQgWa95N3sKJ5m3eYFN1GFnM5G1BaHfzdRNMiJzd2VW0E1jTOMrIVzGULAr949UPqjgMMzlcK0krWU9T1hmFIASgwBEjDcXBZUgBmaq/Upo6NzMoN95/Yhz/8cfuhl73UrtVBqXfefqf9+Tvepclx037uV3/Rivmr7CHZefvw+/7R/vQP/2971nOeZc95zrPt7Nmz9u7/5932u7/1f9pv/s5v2qMmD/uuf007nKurOvhTjA1ME96XkgEmCclNtSq1NUl8ONfFd5+1wK+uSjWkqgP8pHynvX8xRBVbERj7yi1fsbvvvNuOPGKvMyFzNm5/98kP2MlTJ2WDtMcPi2TpI++yzllZl9rcC3/gBXb8YVfbwplz9v+9/2/tT9/+dvuFN/0HOySvcetaDIhHPaPKAEzGiU99zOb27tUiN2p33nGHbK8m7Ktf+ro99l890e4o3ec7dDCFOw3s4rKYjSlfzpFyZwXaiWfBQb0BIMKBhVuX7+6lJOONSgWRvlrfCJKifAYmTTmLUyUe6o8sqqOSpODyl93+ZPpWKWHxA2zEFsKco3/Ob1dXA65I3YX8CABepA8APJ7jlpfyYnqPpNIAKwF0hSd8IlHE61znugTmIBj+b80t5Ln1k/GMNKQCIFSdYO59MReT3T/11rziL+qFiuVEZs2Wx2bFUIyKcRiXoxF2V5etvizQMEdbR21OKqPzUlEN0hXRUWNpSVKP5fU1r8duxgz1IF3MG0DMQZwlMUHt+dF+3EA/TFLeKdXldGXB7qqc8b6K7en2HekDveLZR3o7fbxiwO5nBcFgY4NTo+SU+hNWT/IT0dlBlSRtQUqhHW7tlpfEDPIcG6Z2z3EAhy08lsZ+qqESF+sImMBRgzKVCm7N7hyr2rRsGY+6V00xo6UFRZWEU2OoKilVraT5pqQ+qRQ07tk9F9jS3DOnd25e79VDNZ/crbF5x8aaLB81dlVvZd090Pn6A5SMaIxGkIckHSaTtNjxHR8/4F7QGMvn6sv2+cI3xQjL2oMIeh9czU95VDWPuTv/xmB3gNJevsaMqzIqHQAC2jlNNVfxPgOIVmxNc2pKdl3qAYEg6E9RqNxt6qIJPCheTchqjoHcqDaqp2SfI6fZO5hnuhEICfGSJIsFbe5kMoyI/oG5ef6Rh10KFu3F+qdqxYBmqDoXZI80K8beadx63PEKGrDRkpNUtCjk0CB/My6jOXjTrAvkSnVc4Eu3Bg7Uic2CJZ3ntKSjLfZITXxajo2SgTI5FHZ76clYW6+pV1XtBNRurzM5SW1cc11Ncy/yd+bdKKHqVf2QmzYJNChcpc6pI0mXwBZK9Lg53TdxRhJJDqQGTMkNPoZKDaLQh/z1AmFbWzL8dTlTYJD3/nJu/7BtlykFmID3S63txDfvsQ9/6KP23H/9HPvhH/0RW9xYtcded53dd+qUffyjn7B7777Hjl99lVWWivaBv/0He/gjH2Y//fM/bRuTKbtOthnT03l70xt+x27++M321B94jp0pyrWuZnQYCRYwJmsm+PZJGwbI7Rb8uWIoAnFgMFnQSelTv/LIj8u1qaJ89hOfsf/52h+2Uk62LfKq97nPfM727dvnjHlrsQxlZrNZe6LOaHrSDU+2cmHNFhYWJFn6gK2eO2XpQ8dVUlhg4xlE1PHMV75gpeVFe+5LXmJf/Pxn7djRo3IYkbfP/dMn7YanPdUPXry/FlQOFH3gwAKdF3gBdKGSkhGjvSaQMZqDtQ6qawXUR9yugJ1Vlr9AN55vDzAk2vnT4gi4gkGam1iQjr7OyVk+JHsFPAyRQ0gLgOIfu4zYLE3KWyCSvlhOM389B8iE0sNdfhW0EMMow6BHYBSoHHLgrA5Po4rACLTXWNlqsQ+uhuMz0gOu+E1NtwUlQlKBGmEsa1ucDjfIj51m1PMIsTz/sZsPZZCWal1GDHq5LhcB0sfP5as2OiEmYVkAt7Ju0+NZe1zmqKWXRP/7z6o/BFb27LHHXXXE7qjcb19fOylVSoCU+lqNdTsxxCyKF9sGuCTQl9SaL1owLcb7MamrbEre8yqS3uyZmLAvyTukPydNIw9y2iM7wuo9i3Zy4R6buHqvTeTybr+C2lfIN+RMHeI7RmnJ4MXrBv1ZEu3xNIfqXU7SE1Q119WOTTHGOb2dBK+28kvudKPmWtP4xJ6nHRzxnvLObegbBk3ThDP3AIlOISdpdi6P564xu1e0zwsEH1TpSmylwnl94flOKmVVAVGAPRmKtj6/qJEwjSpG2ylmj5IUbG81b19Tf57igKBIlA4FkxdMZCYvmxep/TVD6Cb/iVOAw9k9NiuGGCC1JEMk6kmUSEcIBNCra8OmWpJqlBh1VPQ6BuY+xcdOSa+GQsNWhwylWofSYEX2mTVJh6mTz5/NglSm0icDj+rq7ILevUlJufbIGx6SwVA/nibf9GTK3tdIXc4LqI+qb0aK0xrT1DNIT3qlpE/u/9K3LD8/bZP7ZdPIINxhYD5iDgPIsOE0aPBNOI2Ndjsk0vO2IXm5T3av+7XJMSFXID2GhhfJzIXkdUXAaLG25k4kmNHo/9D7rYGCiwSc3uwk0DNsVPXrIeZebYG1xluPQqA287Ordmv+Z/zw/lIGoJ+NTN980ZyCV8WK5jsEnTjiiPRgow8nGNAredBtj2KHjy5jCgz+Bl7GRBg27fKjAIsCZ4mcvPd2q0nX/rHXPc4WNlftM4u32eMmjtqP/cQr7ftf8gPS99c5SeIwzss26N6Tp+wFL3q+pSay9qFzX/YF99jDH2575+fsa1+51Z75oue6vne/Sb0fNcOyiTSDnSq5NpV90aOvebTd8sUv2/cvf589cuKgfe62m93O6Kbvvsk+ffNntmXJDuX5c+ft9JlTdvLECbvta7fa1Q89boeP7LNy9rzlajNaHLYu0Pfc/CHP54YnPNG++OlP2796wfOdofngf3uf3X/XPTZ35JDdW14RWNDSqIWFBX+QgGQon5JnPiUawaZDqw0LDmfAbEp1h1xgMFe08LMbD4MPcyx+WJKZcIhga7mNJeKmVsa2YhiDxGbEpqQakZm/S3Vm1VOu+mLfeLU8rrJlkZHX+TmjVbcPyuoJakIOZB2qEDd4naP/GB8ErpHiAJIANJ0CccJC3elpyANw5hVq5qs2A2JCMVsSQhEOrWUh323okO1usxLwXHdXzNiz7Zk6r3O+tHM7IQZ/RX9rYnjl0r5cKNp73/1eu+Wfv2BXHTvqgPxxj7/evu8VL7XNcQEK9f+U7JdgcE+WzqltJTsqu7/57JQzWotSDUPyslcMWgbbEdH6nBycnJcUanVlxT781x+28bkZu/Elz9HACU2Z1271Iyau0iHQGVdnw9bi1rs/b/fecbfdNP9Uu2bvUTsml85Fqbox5mYzky5VWais2j3lM+7prBedeMY7yK49ZwIhKcyoLIAD9i7RCQG1ASDQw7gRxmU2Uo5NvSftTDtxcV1d15wDYODw1qw2WwBO7Ey3B94Z7Y17mSuqx71yApOX1GJSYKRGHfRsQ0wf70sAR2EjQL4cHIih3oY0j/bjdAFNsJzABmprm2oHI5rRHkZpKB1X3zh5yGhjhrbiGQ5Q53VUVMY7782kwCtSpGpFzKKk5bg+7nQGDmkBNByA6xNHKKbjJ5KgMdkWMX85fVVBVA3HtcGCLdaqaLee1dvZBoY6ZqabUGg+NeUODKABFKa1HJaMvRKqzYGp75ZD6z5zAk5SFiUVRUaXS2lcTSy7lLWZcSt6x6tasSIVO6VWRajHTgN1gImn/pkBpUiUwQYP4DA6G2gvF8DDZgwHMc/LSyWHxyLV3x40HpirG8CopHqElgRVZHQhfDcvkRA60w+dcktEa14SD2l4cLDQvN3xYtA8Y2LiV7SpsJGXFsC5vJWX5d5+b2iBHwRL69QE+YrUuy4HIhrnrC9JMAqYmhbgrm+2JEsx/+H3lUWBIUC6svr7immt7+SKPViQUwZ01sflOQq9dhaufymecs8/GxOy4Sift9n1CaufP+dM0cT0tC3K9fY5qbOk8qiByJmCDo1dXlx2IBUnbBZiX5AbN/jNH1MxbEmMxze7VMm1qFgftVNlLUTSb6c+GTlZuPEpT7Z3/umf21e//JX/n733ALCzqvP+f9Pv9MnMJJNk0hspJCEQQqQHEEE6CNgAsayvZV1d9t21vLbd1b+6rvq6f13XtaFYKYuiIk2lEwgEQgqkkJ5JMpne+/v9/J77zDxz596ZSYBdk8xJ5t7nPs/p5zzn/L7n1+zkU1bamqefswkV423m7Jn2+MNPeM7hB21rbmm2b37lm77y94hIypPDyQ9/5ANWJDDX07TVcmXqNNPl5gcquPuJP+p0V8Sd9I6w3nbq6We6GeL77/4ve2HNGjtr5vXWBocsZ484OJxlqh0ym0t5qQItDfSv1GoRW/rQFioisleiS3I82aLTPwguCDxgEifeYW6cOUIMuJEEbVSDQ0Dcob/TLUMGBDBRjk7H2Yr7t2P1X6t0wGqbxVGQDtXEcXsUR34sBHokiOcEIp8QSZQbgi3PMP4BQcCGnas6BGMYfTryNfkyF7yCkegiAZTzYL0oj6uaABER5WO2vF6hS4TtgW17rLBseAt9feKIwKVI6xSsTKu2+iZxqGQ8pHaLLC3uVE+fXCkfLJLhlw+fM885yy676mp7ft1zdtcv7rAly5ba9OkzJK65xR55YYPAU6UtWrZExLl8gG3eb3949g+WIw7D8pWnWkVBke3etdX27z9grbJ0Nm/5QuuLdVq1DI4cEtjPF2FTXXVQemYCVyWT7KScKbZt9SbbsW27zZ0/15aedJLtlsVBiGw4Bhl7JDRTV2snzpprXUr75KNPW0tDky1ZfpItnjLdNrbs1rss/ZFh+jjsfUYK0dBMRA5FbGaJ4wNw6HGDAdL90TuGblFajt4M7ZoQhaLiHeQPyV6TPV16PdkSpOX9JqSaV7wbnKRD2KJHh+3LbHGwQp9LzPNeATIXL1NmgCZNNndG6yKh7ldJ70W2+C8CPRkSTUsTN0cvoBYe/dZfDrpFenkAN+jXAU4yMYctQIWori4UP7CIB1gB2PMOw0ESU8vaJD6HXkabgLRzUMNOC5qmNgYGKHLF/WPOoZcF8Muk8QlrB+9JWX6p0vTaIXGz23WIQu/kUaJQX4nmSF16m78f8exTftF3ALgizTV//xSTsW7UmFfLtxx1xlqg3KQOqUeqTNswl690YcjJkJ6Z8hxNAPBNPnXuaKIOG4d2cZiEKW84QyMF4iONkC9A28/tTpKIvmH8q2W9k3WwWO4oglVxIDI6jQBE9DSZs+G7QxkEdoXgXvBUkNnn7+h6yLPwnNylQTzP4O5r+Mm0kyXYnlzp5e3XQUC+9jwd4rBXYaXWj+dghCm4GJ9GHO7lQFuDZ278I7gc+zxOe2AMIB2nA388NBuCOibiDA5Ru8AIhH6jRFWmZJfZ9Dw58tO+yYm3mB7WJFETrZAyzQsRIOt0DbMDMZtMbQ1OUOjEWM+jp8r6qW1J/0SwBJAosCiUjq3ZeOjSYr2vNcO6RNS1x+9zOpmRLoIUMRgt11hoqqgot2nTpkjs7wkbVznNNq7fZOedf45v/P3+deJ5QpDkyW/TDe+5weYvXGBN0mH69V13S1/q51Y5Y4pVTCsVsUvkYFPjs/FglR14eaMtf8MbbNv6jVY2YYKIQfR6uq10/ASJ3D1lZ192qY3LLLVdIpAri/bSWFnXUidh6laEVrIA94iNZHDQVqNbbvJcRCJia10CA05mKc8w0EuAE8ToIHiHBp1aclovpe1QT2gQsaIM0KGpKN5v+eIuHZT43e6a6TZp3D7Xq4E+C0oLRdLCzX1wScRBnAL/HkcagvEfSA1BoWnjiv/hxstT7nNK/Wq4RwOlJL9iPt3+9/9mWx5fZ1U799hiAYZhQzBNgijqU+YXlsQkQeb0LcR5lghoiF/CT354qw4TREaqnM0bNokYlm6UiGjAN8Q3ZpeJjw4c3AXa3PdvehdlFZJ4pMVQCtYX4baAIro7RNirnLt+8Ss7cPCAzV003/7mgx+yp55cbaVlZfabu++xhkMNEkeNOdH70kub7MXnX7QTZs62CSXl9oc//MGqpDOYpjps3bbV3nj5xTZpVqk1tsjGm8AT3JfhOKLhG4t1LHQ5UPwPDDionaKX01V3xMBYSxC/4cQ8XW2lr6IHCKwPcJtoU5rEzdKYBD4Rop0cdHX0E+CTqwUml3y9x4Knzm0UVwtA0dXepndI4nT54pSp79rRg1Rfpildlsz6B8YLdBjULuCmseoU4MjUM8BRruoSE0eC4wWIU4AJ48DaRgD88dLCOeIORCRiUy0CG+1dMsOdI7FVcSg4XcdqIu0DlETntoNCnQZ1tQUmlfvwpaXxCPtW0a1ULhLK4PQpn0LphdTIGmi7dDVZRzjkyYxlyX0BY0BNh+8zFmw4f53iiAQ8SZUtYrdOBh8CK2dx8Vn1H6r+wwXaQZvdHLTaFoZB6014M9W3img52CjOnMrLlaNaDoyOIFAXDo5aBFJY+0LwN1JW6F82ybJnwPVJHpsaAXLqZN0OLlF0/DSovlbTeu5Ha8+vgANVb5OyxnmdOOBhXR/oreRlJt6F2874vJ4B3bWsydp3tnVa0wH5GJuqeShQRF8C/gmYQGeOcUAR0zqUpb/DGu/XswFjef9F9MAYQPqLGIaxShxWD2hF5kQXXyGDVvFIJpyCsghPqpzsi+AhnUwvzVgup615dkJhpW15bK2tfmq1XfHW623cjInWIbGIgsIC27lrh4iUmE3NLdFfjtUc2OdcqDeccaq4KRIPa4OQCDYP9tF86btMzCzx7YSNAiKCjcUJJ30jtrSvNcfycyEegwU6JmImW/o0nU4csi0J8BQV+yn7Xbf/lxXe93ud4vbZSaefYZteeKG/VcCQkBjDn9O0mdOtctFM6+vstfPluPb/ynLeuhdfstNmnS05f0ipge7Z+PD9/nuJTuG3bd4q4rbLPvHhj/i9ToHHgoJC27lxk81deKJtqu+2mlYBp9g+VQ4iUJuLKp+GCWSonHgAFMA98vaGNyPfbDbUGfEF/KrIzIErePsJXiQeBFeWRGzwIJ9ss6UvBkqNJIxcFsaaRCR2ST9lqu07NM0mlopzEmtU3QPwFqRPlYtOG0XYdqP7oM0zWR0iRQ25JNdov4QR2H4BgGzI0TzhVmANL1VtwvRH8o1+xz+f+T6bOXma7di8TZwG+YM5ygLvzsc//nG76pIr7f5HHnADJYiT1tbV2GSJ3G19eautfmK1nbnqbLv06ivsqUefsD0HDtqK01Za0bgie/ihP9orijNn5ikOarp16OF+dTS/RgqMCetGm/To8kXsB9bdxBHVPHKRJw0k3KM6nfAjcha858FIcu2iYwJRcGjhEAfAQxyObM3hyLsT1oM06O8gJlcsVwHF4vaEIZwfegWtQYcrW1Veq0QfT8jTu9IuricirIA2/cPnEuDGReX0nmJ+u0e+YHqlYwg3inkIlwqikDp1K34IjiiPevQpTa/eZ9YjDjXQ0epVXlmaQ4g5Ls2bbjMkNlnVWWc7O2tsX1uNH1zAbfP2qow0GVYAHPRId83BMqJy8XbTnhyNQbr60te8bHGoCmTeuqHVMnJkOU+cbXQHS8TZ6NSYweUYLgRjpXrqgAWdHfoXjoADOCVklcZkdGGfgJd4BGE9EvMkHuJeh9ob3HG4xws7PzHyML8p/9Cm3VY0tdxKpo53Tt8w0Ud4BBepzd1HjJqLJJCZL4MDGA9ivFOFsGmhHmM0Hn0RPo/e55on9HWVxPTQBzwScBSMGZqgqeuXWO6R/GY+Z8oPYNpEva/75HtQHCVE7WhFuBbDLWONZgd264E6jMvRfh7Ap1S9cCS1GUtztPbAyDvG0dqysXof0z0gA0gu5w8Bk2zjg2xolKjA7FkzrHLKZPvjAw/ZyrNOt3MmnmQHq6rtttt+bnXivFz57vfZluZGqywvs6XLTrKnHnvCNjz5pF1z5unWVl9rt951l4OxZStWSE+lXVwgLGwFAcI9T5vSQlnBgzhh8UXRv0dxKiaMt+eefd72bNlo10pXo1a+lR56/hlxfmI2YUK5i7aF+bBEZ4iQWHLKUrvrl3fag/91r5197lk2TTpBG9eu8cKQF0eZHGtYbMQQGJzgxwTA6htrbf26Dbovp6fFBQ6ughpSJbhanbbpzwFAiuXkWoFEYa5717vdOh6n/9WHDtjdP/2ZPb/6Sbt62TI5ws2wA80T1JpeG5dzUISUiB3RKukqK10gkZNR6g7hHyht09u0fmgIQRJPOeVFrwHuCfUPA5tUi5xkZqYhFx8AGjYt8uQZf8E2FpRCOfzmO9zOKQfRuvGFB21PbaU1y1dSQUxikYoJkEsWBtIGAIzfA7VKliL5Pa+b5kJi8DGCuuXosj/QDxJ90r1A3K//wWtysfr2B23x/IX24H0PvCb5/U9kwvz+8pe/bPtkSOUzH/+MXfmWq+LcKB0yCHxU7dpt9RKdhUEBIdTc0mI7tu/QO1Zr+RKlLSousUoZIHEdMA0L+fnYKi7XIwVGEo5iJ3ptmq+54tYgwqTCfH7INqH0hPKkP9VoDXHxT/IMuUfoL3WLgxOAo6COYZleOu9vfL74HGbKC1DVifg8JA5AvkAC70GXAMshcby3djbaDolF9cUybHbBeDcoAXsvXfEyxYVGtDVTBxCZAnQ1wlc7ROw3KW2mAFJ3trhEyh9xOrhQvFSIDkbBEXUDQKaL60f/sK5hBbNJYpc9KgduWrqAD3pjWDHDGMLc7ArbkVFtG7v2uIUzQIkDIs1rN1whUUS4kMFbSgkqmjbKQXeO9JUQ+6MzY1oPe7VGIQqHVT7eV4ystEq0zU1/j+KNBAShrwifyMWoI2kwwtEocbusHIlKy9yzGqinA+8q1x3SYUMfDge0zi2V1MFo5knQqoFPxrRi8XTLENA7Uu5RmBvzlb2mSfMru4/5EKxN0bqHccNv5hJjNNow8pswNCfqBUg6pLkV03jB+YuOcTQFY4LOKZwmRJiDFujQQff8fYyMQzTda3at6ZclK5x9LdIxPai6SkgkU6J2cFzxzwe3MRxn+rXVD0ZaXHcZfaUj6Z/XrO5jGf1F9MAYQPqLGIaxShxuDzR0VEhpv9aJdxdlYbHVisYi3CuKoKcnW8Cn02aWFdjbbr7Jvv3Vr9vffuhjNmHSZDtUtV9OHjvsfbJWl15cao+8UmNn66TpmnfeaLt37rJ//fznpfszy0XXamtq7YYbr7MFy060x+teknhIoW/0mM/D06L+AABAAElEQVS+7fs/trtvv8uJDXwvrDzjDfbuD75HQKrL3nzFm23jpk32T5/8J5sqpfYWxT8kAu6q6660mfNm2bqOPTZZXj+6xMnBRC41nzihwhYsWmCPP/qknfqG0yReJqtaOl3ucLn+gLjDChQEDkYlvvGVr8uZrRRRJXpTX9tgpynN0pOX2r6ORnlkl6lvnSR2StejT7pX6x75s1Wo7bt27LA5KuPMSy62HeISIQUyX6IcG55ZY6sff8LOu+Zqm1mUJ65Xl9U0T9QpYUxmUffJT4sE5HQijvXdDHHu8BifK4KjRMq+gDCIptKYHD2icAXxpw0dAu9AqwxJyCJUEKQ7IW4SFsNa5VAzCIExBrc6p3SQVPBbGMOy7FxX9M+SnxmsM1WrXZtbq5S/dCh0Et2mPBKtwMFJWlrRaHMLZO1OopS726qkmNzQv9mxMdPXyJzjwJbfnLaqug6kIJ2IEYaAIAnuhPej9yA6MUHr1pHCRPFvWhMYaiDlAFGmc34HloGYSZhrQuIj/Lnn2c32vz/y0SNM/ZeV7FOf+pS988Yb7O3vvslu/9kvHVRAhK88+wyBoCLb/sp2e+Lhx6ysZJwtlKjpOavOtaWnLJNui/QJNSer+ppFISF+dnhcNEaEOQHfhfkaEIG6qUkSjhaHFeUyjZ7enSHuDj58FF/vZbc4Jz3i7BAP56mADrcSp7QQi4iowcXhjN/z0n1EEjlgadT7sra3zranyaqi3pEOrDb21rspdbjlk6WfUyyuC/EaRHRKcldmAGMyJiA9Izmd7ZTO4Rb51Dogc8y8I+nKIzi48ar7IUevODNRIhsCcQAcKT8FZiqij90OEjtlOl/viYhKDlNcZJL3W/+nyMJdh/SSXpQjbAxw0CBAQpBnoM+nanCTbL0SrRLXO5TeYBPSx3lfkChXXK6BnuWOzMprPWnXYsO7NVwgHXo3e7tq9UarjiorbB9zBe5cvUyfwyHKkxhvXrYcLGjsqCNctvbuDqvRuoJpbYdzSg+wTccE+eGKyKmZOcXSItNYvhaBtgHamAc4IseUt8NA5R/0aNjSoDTNPI2DQG386WtRh2R5UK8OjUuXdGkLdWDHnI6OHwAIcCShTJ8TWaq3XLv6eg34ztA7BUQaGKlkpbw295jHudrbm14R4N8va6gz4LKm6VCxUcZd2ocUwhzo1t7SK5DudSzRjfClHxJ77Max3gNjAOlYH+FjsH3agq2qbrLVy/np+MIqnfjI6pZEtDq6dPIoM7ftHXna+GLa0OW0ta3FLjl9pf3j175mTz38iFUfqLKlixfbKWedY6VzZtpv9+4VSdFmG5v32IWTp9k/fuUf7bE//tm2bt5m+YVFtlJW5BYKHD3XvF3WuWrcTOqsmTPtppvfAQ3iBDCbFXvpzDmzrV4npM+17rClC2bYP33pn0XAPWy7du6VufB5dvKKZTZfAObljir34zIzVmarzjnd5s2aaSXFxRIxidnV115hC+efYItVJt7gF5+4yG686XqbOWOqb+iczp66fKkIFrF0VDAnrpgKnjJzltIstursNnul+YCdljvbTj/jNJs8ucK2bnzJWnXK/ubLL7fzLzjfFoijVS09gd9sr5WoX5pdNy3PLrv+Gtuy7gXLkNJ3eX6hehjZcm0krfLB1JNjEwr3SIekVT5ZJNcN6BI3KbtQct4AHgG5aWnj7PH7Hpffpj0iELSnaNOcN3+OzT31RKsVJ4+bbI6c9gJsOBEFKGBN6RQ5883rlmlwEVvPtG53RfCp8ks1P3uybXp2vUSonhRnIN/OuXCVXTRnqeurSLHEauV1/qmWrS7q4Ru0+iOL/pGoZPOWasnYCyAvECDWSX+m6siG3A2Rpw0c55fUnc2c+4g4wcUjAFwgtMjTxVvUHkSOEEnhHumQZUd0qVHtQacoSiB4JvpgXsBRzJBCGP6QCE7SKD+RriIagjNVf/BafUjkKqZ5dCwE2lFfW2efueUT1iK/Yhecv0pjJAtvBQV2qhwdl44bZ1tefsnOPvNMmyrwf+sPfmiZP7nNpuhAYtUlF5hNz/cxOLK+CE7wG8XZTKZnxzgCnuB2cKLeonGGY4Kj1Qw5VSWkichGLwinqQCMHB2iOGdIYCoxoOOHLmOrCPoWWdtMl+6JXiGJyGWKg5Wvw6BcK8sr8Hdni9ahhg4ZnxAwykI3iiDxUN4xDkSwoAeBny1XANl+uMD8FmGqe261Tu+O+z8imerHfUAMHB6Ag78PWlk65Hi2T85tc7JiDny8HH0A+gFCWPwrTyu0fHFra+RlhiXJucvKw0P8K0wX3JMeqAAc71C5/D7xLia+O5QvV6nyjyWjD+oP3j3uYX6dPnHB3UjeXFIfuBSsKYrg3Cz6Aa4e2i61MlVdp3IzOzQ+Ao6yVai7Alcc/LCK6mUNswToBu3wwrzao/kgzZ6ntljhpFIrmlKmur56oMT6jqhdk/aodK2R2ZpDMXE3ACD8IRIc9iFrK2tRsPKMpsZBHNapwWnCnhjokyDmwCdjRt3gcmVqLQ1TkBfWJjGT7/qF+k3cXI0o70GzACkrLhz0ZCJ+AyW8NlfsOTLraIUVmdawT9zmAzKB/8xa65YzdTiWzPfEoOMFC4/U+j52phqkeTAWjssekMVPZtBYGOuBo6cHIF7/dm2VNjVtlTo1zZZlsy5ZTOsRSOIeW7z7YlGTmN0V8umyYkKBTZTsfoZu9CkNJ3Mbm/ZowW7WhoN1u14RMDk2v3CqVUpYWQdPHiB+trRUyWzwIf2WbyVt6gtzp8jy3GB9GZbZbhE++9rq7KXOPU74z8+fIiKgEBTjO02rTve2NCuv1mpfnOfkT5Ijxgl6FhiPOCQxmmmS8ceMcL1Ea+pUt2mxchFIMefG7Gg94JsPaSC+wqWdqjZp89/desh2tFVrY+q1OXKoOS2meNqjP/exT9jPvvVD+9ZdP7EVF15hdbKg90JNg+1oksiBNvV5xX22qLRIm5a4MhI3eaGm1Xbq8F2PgqA+zZLvoYriKhFqclYpyxOZIjKmFVVIT0PnhOr7iW0x+8RH/8HmzJ9ts2fPcDA0a84sW3rqqTrZFuUkwp0Nc39ngzWrrvhXyZGlvQIBh9bqBvvhj34gDt7brKc0255v3mGLsqfYThkZ+NEPf2wXCNQ1NzfbC8+9aJ/8P//glrnu/s2v7V0f/Cvb3VNrz8lvjlvHU0dk67TylJwZ9tCt91hLW6u985a/0bg0y0IY3tURo5CRAIndjM8udqMCmjROyEAkocyuKO6od4/Ge1KOALhEczCfLFV/je0h95FREZNpeAGqLhmI2Kq5gVVEiIWwu+K91v8F52CcHFgijuhEnMqALMPfCYRfshDc5TORfEwWe+DeL//mG/bp9/2tnX/++QM3j9KrHeJ2XvfW6+07t35PhxUixGN5etdl/EFEVp9EuOiZTpkfxx8SYGr3nj3i1LbahMoJ1pjfYxtb97huQapxGalbGBvEQuFm8If4UnS8vHwRpAc7661ODlwxn80LxzsXGIXQdbxwwBHW8dC9AExFnRUPVw/E9ch3YqxAczbPDrQ12379Qd87h4rC9FzTUaBHHBEZpYBLhH+zIgFJqtQhLjXzsz/oJnM6EAEUsSruFG2BowKHCLFllizcJKwommML5RYBGINIKPmkC3SQHeBvjzg3Tzdusb2ttd5u50bFDxoQ4wM0eSX6Cw8u6JcKvV+FWdLP8n+6EXZWPC59fbC7werVt51qA6bLM/FNRLx4v4bZAvjgttNXgD7WLtbjqCgh7aJ9JHbgJA4Vh1xkRZb4cCJAyEPAg2+EyRQifcfPFIF6Vb+0R+bqCyyvXNz0/gU0RYIjuE2fUBvGix0AzjvW7mLi5qNH06q/0dSWOOQEyIcDRKJwjgRlBOU4GPaYyStLPYpk7TDgCQUHPrhXcAM9+o7WhRybdODAIZUboRCgiz5PXsKrv8tYFgvENe5OF4BdLz26dLtSh4XjdMCSetUOyk0GoF59jcZyOFp6YIyDdLSM1Fg9Iz2ghRggJIKb7/bOmG9wUWAURmaB29ecbne3NllJrM2K85riuilyhqkNME9e0ntkqQ2/G50ieHFSub5tt5/KsWtweuliAfFNHxOpDzduDOTrk6zu3OIksUHg5om2TdqAglMqNge4FBDynCJDYL/UtNe2SASM+BAyAJtX5L+FwLkFgGK7fpeIuGav9eJkcu+gdKc41UaGmrohrlMvwIcsf3CaaPZye5Xy3q/nPe5ANlNy/13LSuzB6g22V9w3OECiA7zcTXVptlGmloMSuImOjFcj+FC+nd054tpNlTGLHHGYauRYt9leXi2FZJlFXyDOFQNQWFRgl1z+Zjtt6Qq3tqUWy0Rwsz0s/a8nH3nMSqXndc1119rSSVPtwYcess0bX7YGlQth99STz0i5uMdu/MB7rEy+ciB4nl+73k6SUYn3v+9/WYPMmt991+32xGNP2Esvv2xrn11rJaVldsnbrvKTVJSz2aw96IvTwVwRRKU6dX3okXX25IP3SYG/WH6uLrfpFZX2p/sftJ0iwA8eOGQT5Ix3nrh2T8o3FNy4KyVmuFzcxV3bd9r37v6xNTW12BlnnWnnnHuu7d27235053esav9+O2npSRJVXGUdsW7bqv72k+1It4WXnJRC6EEIZmnsAaKdOnllTiQGWoBuF6ewENMYc8A0b7K4iWkP5/e3v/1tu+mmm5wzF6bbsmWL3XvvvbZC+nYrV64Mb8sfV73deeedPmevuuoqKy93bWd/nioNDx8W93Tjxo12ySWXyELjtP78ampq7De/+Y3nd80111iJfJGlCsLeVl8pnbjeBhFWtaLi9K7ogKNVHFCGO0/AqFtzBd9JhRPEFZyYZxu6qu1Qc0NKzl6qshLvM5/0hlmNdFhadFAyTtzOAh0IQJgCIHhfAFAQpxjDSDVGjHlMY8473KG5wAHPqIPevQIBlWIdkrQJJDR0ymmsSlIXOEelT1Y2WePSxG3ubkO8T+BInKMSGV0BELRiKEKFOfGrYmkT8QdxkxAp0/oGmCBemkSnNFWdQ4ooLEQyVsGUzFolrsvaJZes4tTLLLsMGzTowAMdJfKIEpTezBRthVtVL85yIHKLNUNqNjjwvgDSmnUY5JYIORQiUkJEF29UG1jM6FkOJDjAggMGsFIDPGPE7XQKpvcPUTzxldhDPIXeOeUNuCNv7mL1D4MS6M+0a36lGttojVmzJ5yoeY7hDPXR6xGoW9h8xooDPGwb4n9utCHsozKBfvogaNtA+mhbmasc5CC+lyxQB/T1siQCSCAXgHS31mPnJGmfClwsBBwnYgSjEfRztCzP4HX4YA+nYhOm5Niujjo7eeUF2qvkJzDek+GcZfzCa6oxxjt4HQbjKMtSy+BYGOuBo60H+qw4v06LmTYiNJAVerXQcx18axGOr8IZGZ1yflkrXaTdMv+8ywpzDyldlzZJzkQ5EdYnhge0wSMSgZgVi3ZUpIq4YfANis1c1p3i62v4yL99m2FD1v4IIQVxjLlcTs0I0bzcfGs8azZ+CIIwOBHjd1RWnCrwslW3Dm3uAB82ejQKOtDnUXpOuL18ZRJeVe+osurt++yEM0+ybFmXKpKOTnmB/Nv0xwwOOkkLYe7fYSZhZfTNtobI4qGGiba7qswO/fEVO3ncLCuo6bFXntngJXZIqftF+cJ55LmnbM3aZ6ypvk4+nB63O391p1165RU2XqbF/3/pgjXU1srv0lq3RnbRmy6S7tYZbm1wscQPMwRQOrTp9+joZvkbVsgf1Br70le/bC9t32zXvuNtds1b3mLzpEM1aWqlLVy62Pu3R/3LRo7OiIMJEdE96hs4Qger9tijD9xrF1x5sZf/yx/9RLpgBx1gNTe22tlnn20bZPb8zjvusjPOOcvNT9/9qzusZud+6ZfdaWUygX722efYwxK7XP3I43b/7x+wGhkIuOzSy2zrK9vsuSfWWGVuqQPW4TZ7xo7ncJBadXKaSk+AOYlhAKwjYrYXEcRiAWR8nJDHSGHkGGZf+tKX7EMf+pC1tiJMEoSvSQT1+uuvd8Lui1/8ol1xxRX+oKGhwU4VF3CT9Ol27dpliyWeCsAhpErDM/qVcurq6sQBvMCef/55bhv5AcBeeOEFB2PEwxx4qoCO2Ybm3batdb/tbK/W30Hb3XHIauSrDCezu8QxrRIXY58sq73cstdebNql59UCR1LAHkV/OREUUmxJKkF/Mm6M2T5Z79rbJfE2P6UPEnEgwWEFRHliIAbvGdYZEW1r0UFAq7g0AI7RjBP5ZYtTW5IjL0GayzV6v9o014M6aYmBcBeXRAtEAG50jf+zcfkySCCuEFyqHgGnDInJFYr7hNPePIE52sP6yKFQpvSk+HbDDbrnhiZE3NN36O1gse6QACJpAIM54lhgZKVaXB3Wtk6BEEAsor9R4jKxLxJ/s6Shw8h6A8DpX7ATIroYGf0rwwnpAny0NRoAIhirod6EPAHVYnEUuYfOlItRgUzjoUfm5EkTXWtZh9N0oELHkgvcPge0us6DQyOwNJq5RPurN+6WQYD6flAWlvtqv2lB2Aofv3iG1Gs0dRtcvsZS8xUxR9LS5iDPaM5BCuJhjp29LFngbof6GWgdDeQEuMSfE1x73mNEABE5pjz2MOL8dwTqiGhfniRICorlmyxSKGPWIH2kFvnQI+w/cMDWrXtRer+BFdhI1LHL47AHxjhIx+GgH+1NZo+cJIegxXm1riPT3RNYc8rETLN89uRl9epUVyeEAkI98jeUKZBEgNs0sM34rZQfxBwuQMhqf9HGDJGSOmaQT5Lc1AiA2XCBzSswJBDEYkPBTwc+Qup1ZA7xFWyOwLxkZZhtePBpT7zwvFP9m74rK6h2jlBja7FOhgdvbMPVh42lV+CjtrnYSpozrbKiTHpf7baxbq9zs9p1qv+YOEXobxVKZ6j48kvlX2mtnX/hG+0UGbCYJvG7F9eus5c2b5H+SKktWLrETj7zDdJb2mVlDz5ksxaeYNv6DroY3vj0YnFtzrLxFaV2zx2/tq/985clujfbbrnlb8VVWio/URts6vyZtq59pwhOswWyJBiTvkWz6oNZ8l4s7qmtUydPtquuv9o2PP+CDHDskYNS6YtIf2NcaaktW36KLVmwyPbXVFtbS6udc+Y5fpL84D332ctbt9qGF1+24rLxtk2OSgET27a94tyTF9ets+raGrtaelvlkyqk4xRYPmoSoecn8MN1op4lHat4GkRVOK0fIB5Q7hf47ZN4luZ2q3Qmhks/XNH4vXnTm96k/pFoTcT8N8TxN7/5TfclNH/+fPvwhz9sU2UFbqv64I477nBxva9+9auedWVlpYObc845J2WaRhEceyTu9sorr3iamTNn2sc+9jH705/+5KDq0ksvtW984xv+7LLLLrPbb7/dbrjhhhRVD4wbJH3oU94/4q91/Dpp5KE36QcnzvUIH07JXqEwVfieYckSHbo8GS8ZhyNVHco0y0hDMn0K3m64EIQWiXMBWA43AMDqxbWp7pIWirghcIwHtZIfuoe4W6n0GCHuMwV4OrQoQYxCBC/OneoitwAe1o5XJKoL57pL4+5+YZx7goidgJHyc06KVzRNYLPGspsyXdQOQyw4Zi2XiWeszPWKzVzYl2vZXeKIqm7DAaSQKB2oO1fxXwIsfer/gWdBL/EO4GcOgBkYQQlzCZ5HP0mLqGWh5nWX5OLwD+UACet86hN/M1UOAVAJMGSB4J0AHFF3cndwpPLoBwJfSAHw3nUDrAQEGZMhlY1Hbj0kfUeBuT6J2R3pe0pWYfA+UHl5OjABoAJFwsM7uNC9jFkIThM7MMxkyHcgLoluk7x9qS2pEwblSzxUImrNis/6lhioD4YyECGNdgy5EhsuZFgC7wQ+7eCMD81JD1+ngJVF3ttB9VO7m2XB9pZb/s7e9ra3ac2bYj/7+S/Ehe20SRMn2g033WiF4sSOheO3B4LV+/ht/1jLj9IeQDk6P6/bynIPBhuXuElspJxwAl7C0CLRgxYR9a95iGcZnDxq25BYxehWfCXU/5HAEeQCzlMRQQk3EjYrCDG+AUcErocLGx56xh/PP/sUj8umDZAcX3RAhIScMsqoRaivlSwfQCVkBaVlZcoSlMDn+GIRQydMttt+fZdMp+bbyRef4UkRsbvp/e+2E08+Gf/qlil/Su069Y7lSofKhTSkfC2Hk8Gpt0QxdKJ+UFa70DGA8ONkFyeWbiGsL9+efuoxWfybZ5/49Gdtz8Fd9vUv/KvdK4egi5cs9raQnvhTcsrshK5Sq9qxz06ZP8+aOiEA5P9ExNK2rdvtu9/6vl142eU2N7/MXlq31gGCnzyLQKRtiDKifwABic4Hz7pF8EFAQwthivi8N15gSxcttoKifCurHG/PPLbaHpPRjzdfeZnNOn2xZbdJmV4n4hBSRxoYG8Qtw7GN5gMBlyNzv3LvqX+pOBBKT4VTBNr13ve+1zlFhdLpCQPgADAT6GcEXB44P7QfUEMagFJbW5vdfPPNGsPAMECqNE8//bRzicL8Fy1a5KJ2/N6wYYO99a1vDR/ZGeIerlmzZhiA1B/1iC6cs+DjyHsXvDNkRNuYh+jroM8Xf51GLIMxgrRD7AidQvL0vKLvoV5JuESIWnUo604BiRHF6vqXj/hFvKoiJeWoVZ+a64FI2EAVmRP+pzrliIjP1QEBgKdDcdvhqiqqJIh9TSxCB0MOVIulLn9G4Qk2MbvEdf1qBbx8xmneZCY5sEGnZ3vbQQcJy6WPRD4F0huKCbBjpGSWzH2jb7K2bbt0sRr7KxeuSjQDi5Nw0OCiYyyCVYv+RhcRy2y54hA5355xiowRmdHfGFRpE8BsFyeCOwGRjvQAGAdxQb0xHCqon5tE3HZK9A+RPMT2AP+IGvInqzf+blM2In6AHXQp4TQDKjGAgM+2qHgxy3qj1rDOTjh/+kEddWKRWE/qylyrXDFPbeVX6veQp6MJKk0AF901nPRyaKJ6Kl/qiLh2o+YFYuEe6OhRBqLSlmZxdHoFanK1rvhClyI99aDMPtUDLlAiSCK/dh3c0X+AOMYsGgb/CgzXJOYRjf96XFMHuIk+9yIF/PrX90iiQA6mde/JJ5+yJeKQX3zRm+yfv/AFa5Zo9RhAinTWcXj56t/i47DTxpr8P98DnKjlp+nEUGJIOBYskhhSjuSgnXsAUR//Q4mVTfS1DICSfmCirBFRcbOw0Z11uAKHqQ6PEDspzJBCuggHNqcwcB+58WI9I/TXIYyQ8N0hhe0tT66ziXOnWdnUCToZC0+wRVBltluFQFK6/KgAgsK/QEwRUUUtDQIOeTkdNrWo1ZZPqrdzpjTaqspmO2lCjy0970Q7/a+ushU3XmzjJk+UI00RQKIm2tpbbU3zFvtd9TNWlS5z2xKHe/LhR61u/yHbLCMLNRKvmzVrpggOnUCLoIDQ4BS+XVbK2urq7cTsqbIUWOjE1CMPPWzf/b/fsj37d7quEqAlUz5pINqaGyX209RuJ+fNEoGVbVUSjfjyF//F1j73nB3cvds2ygfVzNmz7YAciGImfaFAVYu4QI3oWqlT6We4B/Qhp7AQUgQXW9J3efl4q5w22aZOqbSLLn6TjR9frjrUCyjcJTPxB+36t19vZdKpWv/CeideACac8XJiP9K4eEEpPhByTBUQiAkOAKKzYiA2bRpmajnXiJPSEAgNpBQ5F1B1TkAifnfdddfZ3LlzpXO1177yla/Yb3/7W3vwwQedi3fwYKAnlyoN4nn333+/bd++3fv1Bz/4gZEGgLVDel9lZWX9RaMofUBj93oE5heGBzBGAG0bDRCzLpoV6TAIO9aKhKjRZH4d9HMAlEIl9jASejxdmm+drTJsLDP77RLVwXHnkArEE1APnPuSxv9khY5v5mEY4A5lAn7iY8R9r4NzDgAHAYGv19WBRKvAEZOc+YJIJ4Rwm3SXWhqaXMSxW1zUWenldm7+ApuXpXdXWM6J/7DAQd+spTIfLmMk65p3ikAOuPHolWTq4KlXImtT0kpsSe50N2BCPtQNYrlIYqElMtXPN2SzmqoQ9C7gBO2omp5G16EM+3RQ0R4bX3MxmyyLpUUSN+Xdwins+MxiOyE2SVy8fAc66hxxs8VZF/eysUn6aqoXfQ4wg4ME14c1OkvcnQzpJ+lGfz0LZI0vT0CJXoW70S4gh9gYXLh6rWftMlzDSoH4NbpKycCR11uN6GyWEYJ2xm6kWeQphv3AOmhRel58TaGHglzhjDE/mA9w+1LWZ9jc6R5ZFdWBTpMOk0YCLLSG+iDymOwN4aAJTtFwax8tcLFMcXMOJ5Dnq+1NDgEAb9GwVmK/AM0zzjhT4ne5vh+EwLaopPiI+zVaxtj10d0DYxyko3v8jtvaJ1syky2iEJw4EJQhcN8QX02HUSb5sUmw4XKK3B+0+gOUdFsn0yLI2DFSBKwkpQpwD4oEgJD9TmwjWzoid8Xp+daY0SrTtc06VQ3EBpLl+NKjMmcq4uvEC1boVFTiGQACKXVr5Vfxyiun2aZIN6tb4miIKULaIELXJweZGRJRnJDbbVPys6UkHlojCogcTlW1s7hYEnXEl1OOvPAtnD/XKmQ44RAbrwip/dZo57/xPKs5sN++8KnPyTxzob3rfe+SE90KOcsdLxBSpvJ6pKRfZPPnzbFf/vDn9pHP/G+TMUKrUftueM+77Oc/+ql94ZOflxiJRIUWL7QLL7pQJsubrVgWun516y/spo++3xr7Wm3R9Eq76i1X2q3f/oH7nVl82nI79exV1irrd/PmzLKv/p9PWcXECpsxc4YsoeXIN9UMOdUtEuDK0v0J7gwYYqq0dJzNmjvLZs+dbRe/+c12+y9+aff812/ln2q+vfXa62yZHOn+7Gc/swfue9BmTp9mF11+sZxyYjmK3mMbTjYS6q9RBFIy7uSTOPaeXOOGSEynQFgyJ7MMy6sJAJi3v/3tnsWtt97q33Cd0EHCqAMBDhLt/+hHP+q/k6WZNGmSfe5zn7Nzzz3XiYwbb7zRDTHg7wbuU6cMB4SBawx9vB4hJOQ0HYcE59SJ8wA4JnD4gJ4X77cgjQjkbudwAnhSEaHhSENo9hOpWgMgvnv03gHOuI/ltRxxIZ0wj9eENATmHOJliBzpZfB7Qb7MgnjQRWBEINDXAfCRL2mJhC4i3KUWEZ7MC5TjASSIPWEUpqa1wQ4Ivmfo3c5CtFLpAD1lAhzL82frgMJsU5ssMQq0QHQrN/1xQBIQ0dQCruXGFjmFlTjptNxyOYwtlBc36frooAM/boVyjloqsNLQI10O1SdXa0aW/mBjIdaHT6MQPAFcOJBgbepQmzPyJK4r0ENzkgXeBQ6LZsoqJ7pB0+TfrFjijRxGYOlzTct2295xQCBQXDNxVbSgYUff12j6PF8ACE4M+dOONu8/6UCpn7LUXoBQSze82cEThTGCc8dQ4aA7XXn1j3OSivLswAs7rGhquZVMHR/oqSaJl+wWo818BVoxAuwxcNYSOcLeRSqnI0P95+LRKTotWSEp7jm3sa9N67zmf3z9SRaV3oFbyJwK950wHrXAPQK6RdTbJ0/8YVhD5ibGdEYCY2GelKdZqIPPQHQPYxBwb8P8wnij+eYd8W1X7wlznD3rrv+6yyZWyA3G1i3xeZ/mh17U3XWQ4u/oaPIfi3Ns9sAYQDo2x3WsVZEeQGSrXRudtvvI3cO71PYYcKoy8eiA41Ly6hNBIAtO4ZIdX7nTONUT1REoH4++HJJDmLBJJdaUMgpE2AP2tMZbcVq+5et0tr632YESBgoGh7R+/aMTLzjNTQLjO4k6QWx5UD4FMZkn9h8DJUKQYLJhYlaxuHRZw4sHKVmtTiFnSAH2lo/8tW+ehySS0yD/KFva98tPS4a980PvsY7mdq9Dh46rt0upftXVl4gM7bEtTVWuO3TjX7/fOqSs3yERvrrWZqvqrbGM4un2/k98xNrFKYK4Sc/Psq3KO0eW9P7hC5/1TQwnkJgOJ5x79cV27sVv9DamF+TaSy27LEvE119/6mNOxGW6aJjar3+nzZohOqrNajPa7A2rzvSTzUPqy1mLT7A5S+aLAOi1E85YYv+08iSdTMtKkwhATuInlc+0Ty/9vHOlcABa09fip+th7wGc8XkTDYwdz5OCnkhE5lgw9mFukYd+ySYvTpUIOzf6kSpaYrJR/EZvCN0guEbf/e53A50cpUMXafny5f05LFmyxJ599ln/nSoNDz/4wQ/6H4QwnKR77rnH06DDVFVV5dd8cD1jxoz+36/lBQcWwtV+Up6YL8SsO2iVXheEMP3KvHDOiMBETKJLTdItaudQQayZZIcaLAFu+U1EPoALUUVGHi5FWqGILHFwYZvAlQIMOFcjUhHi5Qg89Yp471Qc53apvPgLqe/B8yioswh9EetMqJBYZy0ChBAf4hQ9GvSdqBuc2ZpOgYL8YptaXGE5EncFKAGyAEmALDfVLy4uFu84MCiN5UsEL18GJbpkAbTODUPQNgDXFpnOb5PCO+4Q0tUvmfSPfKMJQrjJfqzroe+DcQgk9uASQYAD/RRd7027+gE/asE6lJ2fZ23pXVYvYFWWUag8IYmHBt6dKdmlNjmrRCWxfgXjhvn1cwsXShcq217o2Gl9MR3YyO8YoBYz6Jn6Bqhlqm/gprUJtGL0PB8QqbLatC8E9RtKeNO/fb7wSLBNfR7299DaBXeYR+XzK7XmyKIb6UYReIXh9OEYGO4V8wVLiazzieNPdrQBZ7CBAOUoChhFFGoKuGnRIGGQIQLNk6ZG9Dtdcwi9MOofDe3iImGKnzbxjLkpgWWvN0YbDgccBeKFgFvE5pFYzXbHwfhe8vkULXiEa812d99AvzGXmBfvf5+cukv3dOeu3Ta+vNQmSu/oWenM4vIDkflsvZtj4fjugTGAdHyP/1HbehbMxMU5VWMCiz34oIGLNLqNK5oX5WRpQ0WsIyg3IHrK9TsQyUAJNZIvl9pcUbYXJSBiZHQ1JRbbSZsI8ZhECCEVuDcAjgZMCbPIcypWll5kBdLrQfclKIVTSMmnaxNd/9DTFivIs9krFqk+7NmqTwL94aJ1KsMj+HfwAVDL0qnuSDX3uolgeUaWm1bmi7slgxhF2r3OzpxoG7prbYNMpm/vOOimkPtae3WCqHqqT3Kkr8M3myZhb2et6yq0ShQoUMhOs7Utr4gg2+s6SWCOtppOWUSS0Q2Vxwky91oQYdLmvkuWzQ5IB6KAfNUvHXVdrlQM6MCqGcQNegSQahBqneKaHWqRkQr11rwSbeqcJIuYxwcV/dopwgnQmSenn+godDWrrqo7+WHWGVK4S+3p0D00ghhySCwlHRToH8RBoZfcFDmFK6b3q/LtkUEJfqSLoISQJv/hg3yfCKBni4BH8Tg674I6DJ861VNE70455RT7+te/PigKZrjhGGESHIV2zH3DESKkSgMgWrVqlW3evNk5RuR57bXXehrMhAPAyLdFzovvuusuu+222/zZ6/HhXN1hMnaiVx3HiMRHJSDq9M5myVkr84X3KTEg4uRidAI+gIwsEVNpORq/OHjJ1CFERmG+O27tFGcOcT5COEY5Mk9emJfnYKbVuRRh6SwdzCNiDgSIb8TxAGJhncOnnOhDTGKaGpPiBPfdJZ9Q7Sq7S5yPzDxZd5O+IGCgXhzPBoG/Bjm1rmtrlP+0WmsV3ww9vFyJsJbK2AFirNUt9Vbf3ORAMi1XM1ltA5rwPU4AqrxPDpn1T+YLLF3iuzGBrGyZn2zNCN5p9K6ciyUwhCn2LvoBDo/etWwBtSxZ1QSk0il1MvlNG4rEHU8mEg1hfUj6UuUCRACbaMBIAJb1uhEtVP/kkC8gVeXwPtOWFq0RvN9hLyNCB5lNHcN70TzD6yjXL7yX8lvvcUGFfOsoz9EGgBvGDfBHh+sFRP0CfaOBHJgJtL9N0gIAkNGCjIEcRns1+nqjFyXTSAJVeHSjX4PA+4IhIdY95iVjQ/8eLqDhjWQ+wCUkkD/guUDiljjdbtbhFhyp0QbGBGuM+Avsligm6+aUKdM9+Xvf8y4rKiyRVMMEP7B4ees26US+Y1j3A6Mtdyze0d0DYwDp6B6/47b2LMyw+weTEcm7IyBSdRqkVZoFmxNOduXRpA1zDBZ5nbhGUnHKN0Egaa84ImwGQ/LzG0ohrghe4H2VJ0MROtrlw6wHfbOdcBqM2EeuZL5zBFLgHPEv2GYGRVczZJxCW1VMYiTRULtxvdVXHbJll57l5nEHiICR203NMrUxjUafBmKtUid8ZZKqeKCh1S4qECDI0omoiP9lmRKFkQLwc12HZIxBHCTv86B8V3BXOWFt6hFX1H5H2eE9vps1zk36I/AMAAGBUCPRmvBeEF+gCAJCojLhfcbKiQ3VBTPNbNxh3gDDWE6P1TSV2bpDaTa9pEH9zYkygEvEnAgq6Jw6Kba7M0WdOHIuyhhwghsEcgtzDOs3MK5cIbePeBBSP+kSXWyQk92u7pi4UuLMSZYwTWIymKzPz25zAmAgdbyIJF+0CyKhR2mZd9EwmvTR+FxjJOH3v/+9/4XW5biPr6Kbb77ZVq9ebSeccIIDpPPOO8+NNgyXBst0pEMcMU8gYMGCBfbxj3+cLB0oke+8efPkfDjLuUxRDpVHepUfIZhQN4kWH0xMR7MOLNhpkBWHNQHFfmJDzANGAOIop2MynLkQxSyIPsGJheB3XRAZAQAcUTZie70Ckw4EYhKKzJFYJDpJEkVDZDFb94qL5Pg2O0eOmfWui3ODLoQXovIDDrQIZgqlXN0LdeQCRfNoK1SM6gLXKARHOIbFdHGHrErCEcoulEEFzXU/IFK15DnWYt3iSPeKY6O27u6rsT6xexCBLJUzXt7TPdLjOSRw5JyxONgI67e/q95eaNlpJ2VMtXyBIj+AEmFfrsOa4g7AFqJ9OoSQWF0HomsCkYjhYRQDMbUs+kTcnQzYe/EJS/9DwGaoHrKVN6ivaS3RsCCIueaY2hS+dbyLq5u32rZOGevRWsj5A7pGPu5KRH83Ke/oe+L9Sd/SufEQzhm+GWf0lsK6hXH4Zs4gFkzd6ZvwHuXBZdz79BYrrCixgsll/tsjpPigdNoBXyVNawO6lByRRGtGCQiWcQDGuhStc4psR3V7oOXR6EF7ondSXZPeRTkFYkI/SUF7MNgAQA5+hTmG36nyG3pfXFeNBf/CsSYOuTLf0EfjIDEZF2toXvE7Slw8s8L+/Pijev+Kbeas2c71nTd3vkdg7M85Z5X/caNVpr9zc5mLh1/7eIljX0d5D4wBpKN8AI/X6uMgDxO6OqcdsQtYVCH2i7WpIVaC/DQEcGARbsTkWqBFNOl0skVWlIpkGKIfbGg3RuAO87fVXYh5JVlIdStNRESaRMt6RRyzxPfh1E/ELSecyQKxglNRiYRoe0SkoDC9U1aqELFDV4gYAyH4Nfjemgce8winvekc12kKYgd+eMgvuukM5BTGovxucaFkDlvGLwiDcw/i8Yn+Qr7GYBKiLdrcV9f32coS9YtAEsTK3DSZBJfew2qJzFW7OGKQNrF8iP5kgXjJniSLH41LGjhmBdLnErkkUUEZ8NA/Nm+PpwgxDFUUH7Ca5jLbXjdO1weVJhAHoi7kAfxgrqTL4SycpZjATraAedKRUwK4DhAOnSonU3FNYiE1ohc6uqU3pL8OWdLi1Jo9N5bVJi5CowxmCAAKsDE36WfKHTYoMeA8UwrcIrsF6hBWFBdB95KdvifLC+5NGAAoToyHNxK+v//97zu3hzgF0v0ijJTms5/9rH3iE59wwh7COwwYHPj5z3/uxgIAT4Ck1zq4AQY4FeqnNJlxS0bgQOgCbmgTBHW3lhHmPGod3CMN8yUQucOXmR5EDjUgjiH04VTwdiDS5eUKcJC3j0M8D4jpWBHAQKBWZWbpMAOra60SNWsXmAnBD/0AyHJxLs0COHauz+gzFqI96azz8pk3qrZEyDqtoalJoKvDyyvOL7TJeYXiGDXaU3LuXN5V4JwfdITQJ3pFwKIxs8sKNBaF8qEE8XlAwOhgU73AlayCigMNFyXsLwrh/eFQCNPehZ1ZAmI6MBBA7JZ8XZ1AjswtuiW9XgC82tspwxNw2TJFbOKw2k2q09jIRCdP3rP6tmYByOAdiurf8ByAwMFIscScObRgjLaJO72j81DgJBugy0GV7oehK+EAIbw/5FtJAn9KcRHkJF0N17AbQzf0geqCZTwfO/V7HwBJmWaofWm6H6nCkKLCG8RnD+rSfEForkBzkBUe3nWL3BWEoK4PcW3FHU2eYd6pvpkn1DSY11pzPKLGSVeMPQBttIG84OaxzvY5eAtSBr0ffI42r8R4pIYzRf0CDdiB/CiXX3Cx0K11E+yKORBDD5OEPnFxS5ZOlWGQXvvBnT+zSQVldrJcRixatNCKSwRo1cEA6gMH99tqOQ3fsHGT/d3f/Z30awOrnUmyHLt1jPfAGEA6xgf4mGyeVsieHi2OUrI+nLDpyeftmXv+bL/97i/svLe8WUuqxNF8A2XJHTmwGOdA9CaEkPDmFHS4RRoChuc58pGxQIYT5p9zUkqQFBbBZokuBL5WMiW+gsz9OJ2ewUlJBEphGr5X3/+o/1x+wRmu5BrWK0dEC9sgJ2/DBWDCQYE+NvCyTJ00K02yXkLWPIeGKcyX6H2Rfr8sgmihrG5xzksflwtGrkqfZM8LJG3ta9Bperu9LAMSj/zoHlnXm2hlUyoibYEUem0CRAAcgDAwPigRM+bRUrB42NUjsTn3o4V574EaBH0cxKaV9AMACHO7qQJp6DeIZMAZ1sxmLJxjS6QL1iVuIqIy/eUr07A8CHNIodESKXAOZOvQnYnCHWB+KvnrEvIlnnW4IeprKTFtsXz2vF7BgYSIenR6IHoh9BMDxBAELq+/6xgpQrrAGwcpiMSGoIVxypQYJCblu8QZcgAjYt8PNzRN+K0oDo7gDFM2+g0a/EFF8gv/OJk6LED/plWcEKyRkSYMgIjQIARx+uBEiZgjhFMSi4+JlDKvH+JGXWpvsyw1dqnNgLfivAKbHCuwIonN4aR2h5zqvtC0XW8js1fzUmKa3THpLQnA5gm0QSDXyqhJQ0uTXCjkWa7+MCONHomDNq19AB4C96r66gVOxNmQWGyGDgYAmugjZUssFaKevgNAxugTcYwQzdMETxHE0ZJF0pgYyd16P3QG4Zb7omCHPqzVoU1FT5FAJiuPSey5wDkvHfJ552Oh/gzHJkVBSW97XQE80tcaGjQfBIwQWwQcEZgfENP8zAA464K5NOnkWXqot1jPPOg+fcV7iUgxY5fhc4baB4Er1kkAIlZXO5U33DdPp2e859F+iCc77C/WI7jZHPIwA8gzHI7gmzHjaqBuyQoJngYHCNQZIPN6BPrL557qmaxG1JS2ZOkAAv1QjDiE7UlZH0UoX6ExWjTVevY024Mb1tgDjz9scybPsHIZ6Nn8yjbbX9dgBfMrbPLly31NSJnX2INjvgeG7hzHfJPHGngs9EBrV6H1ZEuERCvniIuiGvzM7x62f7npHwyTw2fNXmYrV678H+kGCKhdu3bZBz7wQbv8EzfbG955UUA4DFObcHuACKqWeAviaeXZ2JBC7G5o65tkynrTMy/YvJMW2eSJk10XZyAWMu9YK8pwUbFk6cOqkKZWJ8IQ+xNksAFwMDiIuNK9wPCrclKCSQJJeQIQ+8Rxm4K1P6+hTPMKKkzLKrLtzfX2sVmX2yVXXW5LKubY1IqpNqNyxuBsj7FfWHp75DeP233fvcM+8It/ljgT/ZjYl8E8hrsEp2q4cYl2DyQN8XMlikl49J4H7brzL7Pzzz8/Gu2ovHbAKKKUU+rwNH1UDVHXBgQ9nA8RqMrDiedIYtfl0Zzkfxi8z/V+Zml8XHxOAAZjBlkCSH0Sf2qT/pvrEilOuojifsMNmvdOwOIfJ8ws5TcEvPIXB4d/1A3OE8QgdQy5RLQdgBeK5ZF/Nro1AnuJZVBvN8qgNOk6NMrUe1eYkytwJEtz4tDxXqLn1KkL9IVwppwpMJAjABQTkMoTUQ7xXCeT1l0S+ZtQVGp5uo+DWvwWheVRb4AO6wIBkJUjwMf4AErgDHWIUFUizXHSBf3oejxUIkwYJB/0WSxwVCTnu22d0hHRP8QQw4KdG6cfvVr/ABJh6JLoXqkMO5RlFYjbLWSlOuhUpj9dGG+03/R9n0AeICYMPg4RH0jhfb4Zt6COis9/pavdss9ixfn6K1BNNfc0f0LxScyEp6vfo/mH+VEiHLJsAY5uN5cdz1r3B2oTxj68b3qMgyI4LoDgsAfDb3ILyhhaEneAevQDA+htol36zaEM+p/RfBTpsAJpKSP8jiamXABYlt69VIF0rH/4yuqRODdpUgXagN5mJyA/R9IFJ0ywioXTrKO2xapf3m27m+R8/tQpVtG22AonxKxg0ug4ganKG7t/9PfAGEA6+sfw+GuBVtTKvA6JcWjDxmz1CGH7upft6+/5lPtbQRHzLyHgKwZxpXFTK8RJWuYgKdkmEa1rsH2hlyNrb+1dNk6mdkvjInDReM88+JifYK6UeB3mBLDiBAEVpCcmomIidGRsAD8YwwXqhOleuDHjM4t8gwzjkx9bF1tuuDGxjxZny5CBiMrOHgwaBKeLkD3bZG3uezf/oyv3o/h/PIVb7BZjzP9uybX2xXW/SMrVgMMFAfJqwtUfu8nuf+B+e9/73vdqsvmLSPv444/blAWz/JS4DZV6J9JGXzWIdiyteeBr4AVImkm7iCcxTGTsAJPTEP0CqnCDVC6irVivbFUcF8KM1MWJR+XvIIky9AwfTHCBnCOkfFIFB24O0vxjUDTX19GdbukokQ9coUSgF03gAEbGIjiwyEWMT+UCjOo6ZcmuQ8K6ugYEZAtk5ch6HIALvSVgR7vAGAYCysXZg8NxSMrsGFgYUnMRo9F79LFzh+L9BQjoEaDIwGhFGDHSV9H6cs2woPOEHiXgExG5zq5eywV8RMYMcep23SsX9xxXB+gBoTOWI7Hjyqxxtq+zzkWt+gGm+h5wTH/RD6kCnB5aFI4dRiMCMBCkcPBKcuoSCdxKExhFDDDdgbHu6H/jnlqeWE6hdFf0HEt6aeIEwqV0/TESpgi8+4iO44CXOfRaBuaz4GNiM1IWQTUZgjaJlQPc3Ay9UofrPAkjw5Myn2QPaCd9zp6CjijikpjVR4c0mj91YA7yHGBHv7JCcj86C8N6hAYdkpXp9zQheYc71CZ8NrXqoAB9vYLimE09fYGDfE0sq9neZi21eh9KKXMsHM89MDYDjufRP4rbLl1eiYWMTE6ymK69/3H7l6/+i1up+UtpMiJLP/nJT2z9H56UnoFqpc3cPcprIxhpa2RzgEir7Wp0sBTdLGjfU/c94s1ccaEMNLApSAyBfkgM3Of0d6TySNco2X8MY0TLgvYsxGlRQsDqG65sczMCkUPy35XWas8+t865V8cbOAq759e//rXNnTfX9m/eGd4a9M1shlhNRcYkG8NBGejHhe++xu64/Q45tL0j8dFR9fvRRx91a3mrbrjcRUQhko4kQPiGxO9I6SG+EH/k0CAUGwqAUsAhwdxwtnTIECPD8ECXnJHi1LU77twVnSF/mbxMvdIijDH13SkdHTgJowqiShHn6pYhBXQmqDvAKFticP3m+YfLSJNESaTD0mGvNNTY+gN7bXv1QauXE+YOmTRmDsUK8l0/ibpCjKMMPy4r16ZIHC9HxH5dl6zcjXBwElYB8JGGQQN98567GGEuEG10gXjM+VpZ0wv14lwkUus77eCdCPRlEJfNkBW7QieqXV8IEKG/yTL/jcPwgNMUlMsjQNRwgTy68Z2ksYyCouh8AWBhjj0rhnik/gQu3Xy49MkyxJ0DHDJHaDBgavKpc6xoCgYadC8e4Oq53lWqTqHjFKgzB1mDDgJSpQmSjPozwIijy4zqYNAG0+us+XBxeDei4IWCR5fbQBXJl/0DAzNFMieOw3O3hqd3G9Pm+fqtN20gga4otUkHgo3yn1TX0yyupizRSYKCw6TEQP7D/wXgSm+xYgbloOvbqMMA/LFhfh49s9wizedOWTVt0ewjw7Fw3PbAke06x213jTX8aOmBcJmFpX5w736bufLNf3FVnz59uvW1ckqrhVt+JfJ1vlWiDRhztizcIwUs3tXLWWye/PuEGwsnos889JiVyK/D/JMX+4YhGJRETCnQdMEhIQQhG04U/CSWjSUlxO1iIhLQq4Fw4TObk1HpRUAOsGV16gR4p+xY9cm/THG3CAsRT03S7dktnacD23bZ7BmzErM+rn6vWHGa1ew+YFMWzU7SbnShRLBJf4tTdQL9LOysT06hRYD2P0mSXLfyiwvtG0/9yj7xvk/bD3/6YystLrGiuL7Pq9rrQ3okTvfB1UAfJUce6J2STV6dUd8N39fVTz5lFZMn2u9//Vv70iM/sVkL53oeeIbBMSZipmHcUWc+yojkSx9hxAUDBFkSPZNQkpuK5v2CSETpH3E/LLJBPDlhrYSkdUMGYkEBZAIrd9LzaZdom95x128SUY1VOcSsnAhPqJdbe2uRur501qIEO+JmOJsdVT+rTqwL6DchkoZ4LBb14KxA4GNeGwKfwNwiINZZJ9Pf/FFuONT+MN5Gj6sHfAOKyI82IN7En+cjgNAt8UQ/cgmy9vsjfbDu0Of5OYUSDRSRrP7LlF5J0KtaZ5Q/JaB/WYB+k/o+1BGjPsUSr5ogbnptT5Mb06A6Dtw81dDS4VL1CoTC5fNBVAJvFy9Y0JQhiahBv0ilnlKnwCGvDLBozYXDQpN9XlCBoQzBIXlyg/U6AHbxgqlTJKCX5uOeol6RqCkvSercQNULTl3U+EVioiBuhwOjxGev5jet4pAjX1ILrG50tPdXPFPvX90Y3PrgIXshgnzsMnCJAmuN1JTYh9sxWMcD8AWzPEwd5qSpYdmylpGZJ2ulh/RjZryCY1/HZQ+MAaTjctiP3Uaz4LHhd+mvO63NWfcQBFGC4y+l9WyOcHC07rucenVHg+UIVCCmgtWs6Clkqjpz4t0knxAl8h/CJr9pzTprrK23C992hRMwpGNjQUQBYincEIL8OM3TKahOOJsFkoYnPgNT2TXdDbLaJyVpKWWrd+0pGXIo1Mluhaz7jVNeh1Qf1UBH0/ESIKq06UOUQOQVFgZW0IKnx9+nz08ReMkC44c9uhadlmb6HOBOQJBDnENYFMqCVwBtk+UQ3Js8Z5p95p5v2YbnX7S9O3ZbR35gRW7w2KdOn/hEh8jWdUin4PmqQ6nqpOqvufthe/53j9q577nC5qxcnJjkiH9PKVxqlYtm2b/+y3tt/DidxCsniBfeE3TnMC7iauFUIh4C8jn89dp8ByBDJrg1IlkywYzyPGPRLa4oJvB79c5gzhsrc7zHrpsEYax1B+AA5wFCHzE2zKEAJjuaxU1Kx2GyDg6w5iaw5IS84vOOuCEAgZlBa5WeuagggCTetGREZGKr4VjwByjqFehmzgQiYWEuQb8G6QIQnpgHdXJLemqfD4IikBrRP9asbI1JocaENnRKRKoJy2vqo1FxuhIKS5flOvo0U+JzgThVEMEJZ5WKHzocVyMajOlw+shBGqub6jElu8x2yppdFzpQCowB9SKeO26ONxsQ65y+OBBBpM6N/Sj+SAEgSD3gx3PwQ4pWGVMAMPN+ss5WPbfNiirl3mDqeO/v4fJ0QxwAbY1TtHiu8eXmINoB0nC5jO4Z/YAV1m6JPOf34ZctftKRkJy2YOX0cAKrFIGxShZ4ig4UXCJ6TSOSLJruD53Z3GHm40suAKTBjBgaM2mW8ZIoM0yhue5HCNSBu3KToUPCAdDF/NZBlEQgmqu0CoTJkmc/dvcY74ExgHSMD/Dx1DyWPAibJm1au+pLtbgVSVk5sQAAQABJREFUW1Fuo76TbwZ/CX2T1tEjE9LSM4hbfcIRoBzcaGFXayACQ/n2FJVla66Xk8WCbM4GM2z1fQ97zNMuPLs/BZs3f/TP0CBZcKVD3KFFxAVmsNkTksXlfq1E7SAK8nQS2CRLXO1SXO8V92tTRr3rHXEI6349FHdgUwryI+8Bg89DazJ2hx5AkbhbDiEHRiEcC+4ACzh/5Xq4kJ0fs7mnL7ZpKxcmHcvh0kafMQV76kQAV4l4nSrT+qU6bBBzc/zMyQ6Q8LV18mUDcy2a9tVcJ4JA3gdOoGPirsHFgSBnVvMP4B+Ycx6pV0Zfo7DPSQFodb2QMLkeQmCmS863T0Q9onScyodGFQBLOXni6gogZYljw8EAFum6dR9uDvE65aMoTXqEWNIDMAVgBst7AmIS+aJ8WoM+kBtmEKEMUQ6BiU4IYnHROoZVS/wGJGToXY1SenAsIAixZAbHlxP6pD0XFpD0IWaWs8TRyZJvoi5rkvhek0zHU9dM6Tcpa5+rYRZhvZwkRTdIgG9wA9K0nrTKHD9uEwpVXQhZuCuyrCfOdVVvrerZZTMzx1ueDmcAUbwLGAlA1wgwoaMexR94NwCW6P4MCnpOnegXuHpD6zEodv8P5h99hvAgukTkgX+sdoFPB1z6nauDuEmzKq0vX/1NRUYIAGvaGQ3hodjIqaOpRn9NfXt0cFiAwQYGCTQWD1xxAJFiNoTRBn3T73kSmaMVwd4xuD1EJl9ACEBnuFkbpBycHtCJOF5Uv2hwDEoIygg+B3YdymUtRWSRd4fy+ce7wyzhkzUlT3ULc9CFT1zeEWdi+o2xj+O1B8YA0vE68sdgu1nc4ahwQlRWWG17a6bZLvm4aWovStlaHGQePHhw0PPKykp74xvf6Pc2bNhg9913n82fP9/vhX5bEPF45JFHbOPGja58P2XKlP48tmzZYvfee6+tWLFiRGt5WXLYOLMxz2rK0sR3kaf5fu6CFnCnAJStxNXY0PtDZFNjYe9Quw921lupxExWP/CIK3QvX3V6f3S2gm5OgVMGtg15geeUThsG3CSIk0iJkZQyEa4+bhM4omxItnRVFEe4nZmIBQZ5kWDgil+Y74WoHTnQrzkSGzzttNP6I9fX19s999zj93FEGvrWGW4campq3NkphMg111wzyDP6SGOUqg533nmncwyuuuoqKy8v9/F/+umn++sZXrzjHe9I6eOHrTpfJ+XoG7jzziQ9ndh3Yb5OUPn4D9eTEJfioqrdyccwzG3kby9KFsmYg701UqQvFKAX0T71xDky0V5hG/60xtplpQ/RLQiQ1yswh8GMaZprgBGcKDPDCAAlDCzg5BdRUPouVf8F8clN/8hPDUyst3M81XcQ54hVpWyVHlCXTAGlXoCMABHgqEumr9saZX1LFt4yJVbn3CR0VRBtk84e5VIG9dYHmVAtB1S5ReIEK4K3QLeDx3rPVE5M3AvmDqJhgdK8Jxv5wwnCaDTAprhL+uvR2uHu2aKPw2v6R/+oQ2KAuM5XfWLKo6a90X0vAfzoz5iI0RyBD5xdd2o941+Yh/emDoPcXLjiwr0B4PQhEihA0yGfTGkCNd5HSlUtjnW9DmUAQhhiWJ+22yZnlThXqEX8PfzEoXAP95tyosHXTE5sIsG5TvgqShCng8MNMZ5qsBmtNtURHhmGPPCXBTBiXQXr5eqAKldGLvJmTpK+pricAiLDBR99gF1/zwwX+7V7Rm8EImsyf09744H76Bohkj7awJjyHgY+5oJ8GYfEQDxMm2AwaLjAe8gY8F6wfrG3FEl8MspRjKYP5qZia7JoBgRSCtq/sjQnCdADOF2nrxFh532WgKu3k+fBOhxytbgTBA2zdbT2WaH2ZCUZC8dxD4wN/3E8+MdC08OFHaemKHMG5oBlmCCz06aW7bTJ5bvktFQmYFOEtWvX2p///Of+P5xb/upXv/LYAKNLL73UTxlxlnnttdf253LmmWfa9773PWtvb3fg9OMf/9iffe1rX7Prr7/eiegvfvGLDp76EyW9kAns5l6bUp1uFenFSRZkLe/aSHtl2an/T746kHUPAxtQg/wkvbjrJdu67iVbuHKp5ZcEvouI4xtEhE5gY3HRvjCD/m8MOsihruQLoid2/Y/jF2RFHv1ZsoqwL/qGH490hF9r1qyxyy+/3J599tn+HLZt22YLFiywzZs3G89nzZpl1dXV/jzVODQ0NDhAfeGFFxysnn322T5WJBppjJLVgfxOPfVU27Rpk5tpX7x4sQHA9uzZ0z93mEf/8R//YX//93/vRG5/AyIX9BpWuHAIebiLb0BohqRmJNPES0WBXGTcX3XQIGcWStdsok5iW8Rx2C8aX0Qh82flZedZlzghBx/bbCWyLkbbXpMyEypNnpxAV8ZK9Ffm1tYgoAKSmDZKf0+ch8k5ZVaZUy7wGfO6JGTT/xO/XicVzLblRXNEbI9zkNP/MH7B+9WFnpWU+BNP+RPjqjAHQYjyIlKXVyRDAnkx1yVqa2y2donWoV8kCk5VVS859yLgDJHGdZZ0D3DhgE0UtxP38d/cw0ABHAxdOmFLX7+aQJvggHRADaYIlJusGHocEBQTcdza0W714hwBjmiHA0LVn6MQCFCsz0H46md/AFSih4WIGYYunAOjsoqz82y83BcgBocfIDhKdQJHcAghnJlzzQJFm7v226buKtvdXWuH9BxwnAiOKMyrn6SbvO8i9ylPSHHEcSYJ/Uad2zsExnVIhjg0QDhXXDpMv29fs9nq91QHoI9GR9rd3wHkAyhUu7yS0Qf/TdfR95R2sZsEuqgpKpxQL2IBRHKdexSkKZIUQhR0RZNg6jxaZvQZ1zxDhK5EemYlssyKRAN/ATgaGCxK8vrqok37fZPMu9fLeAOGG1oEhjD3jnGJBn1jYCIsk2+AIYd7YU2Yv0hdAFPDwJzn0E3ZWUfuwB4bPh/7Pr56YIyDdHyN9zHTWrcypVNAzJB2SHSLpWxgmWMjk+hYRreNy6uT48LUMtWf+tSn+vtk9erV9sc//tG+9KUv+b1PfvKTDoLwKfORj3xEvos+YI2NjbZ+/Xq3uPTTn/7U4y1btsw9bsM1+OY3v2l/+MMfnOP04Q9/2KZOnWpbt261OXPm9JeTeOGLuBS5i/Z2WX1phjWLEzPQlmDzCdJAJECEihxQ+zhrCwklvtc9uNqjzV21zPZ01PjpW0Hc63xJep41SRwOMQg4TnCK8IUUpg/rRI6cv8HhaNRpeLjBhM+HfKui5NGnI9U+iQay1YZiIkPijnDjG9/4hn31q1+1mTNnDor5rW99yz74wQ/apz/9ab/PGABYAT1YvkochxtvvNFBEOCWPAlwnW6//XZ7+9vfPuwYparDv//7v7tvIepHgMsI+Lrwwgv9j3uA5ZNPPtn+8z//04ZzkjowtqQafWAmIIKZKUI0EPIJ0kZnCHcgADgNZuwSxzdIcRifmmciA62vQPOiXOI5dTJcMC7DTp443SZde5P97ts/t/V3PWYfuu7dchpabS8275YIT8DFES2pkFi7wWVDxBICZ7kDcTHPDVHVI25DpojxKQIyZR0B8JlRWC5dHlm3krW1ve01suTYYROyi21qRqmLeVZnNtvGjn0inqUL53kHBBifGF6ozBxn+fuwLNcrP2El1iALi1jJyhBI8XowlxFtxWKdGkE8LJE5YPAch/lQe4iXJbE6/hxcwS3S/SFcioHmpsyQ7oHbkyM9FQK/s0SUZypD/Brx+3ADaeCzd0OkD5c4IXPaBQjiL0/yRxiC2N/cYM0CSQA6t7YnjhnxAF6hWKKXwmRQnb0Pla/nlaM8BEA52S/KxopemftVa5IvJvRIARwAI4BwGBxsqdWjO1ygvDBl6m8slwUm4UeOHNY7TUYeyBynwJhHz1ZdGR04g4AtACNOfd16XULR7gBVaytcLAfHo6gk45RJPKVhVWYuv5rA2GTrHQLQwGcGaMB9HW2gtXCPwvEgHYdq7CluxCSSEXEDDh/gPliVIo8HXXovaj5gdiixhfQ9gIzDAvRu6zRPWOs8TSSX4JA0ciN+SbzgDQo+3ay/plaODl94u/pULpzN+t06zFBb+rJH3x+e9djHMdcDYwDpmBvS46NB6N2wzCVbIKM9AMEzGjKiQyeCN910k333u9+1srIyB0KI1yFa953vfMdOPPFE5w6Q9+mnn27PP/98fzE7d+50QojN8JVXXgnk2vUUrkNdXV1AJPXHTnUhQlA4rrwxw7rKqTOhT4SRNl+drGGSOxsLQJzO6jS6ubHJWnN00potQlLEJIv/+gcDUa9FF5wmhdx2a5WjxxydrhWKI8RG1qJjMUQOOG1FPCU3Tc7wBISGBuT54yfEih9sLENjDdwJCBGIQQdJ6FONYtMfSB9czZgxw9atW2e33HLLoEdwfOBahAFHu9OmTUs5DsRj7N761reGSeyMM85w7tMNN9ww7BilqsOf/vQne+973+vms3H8evPNN7u4X38BuvjMZz7jIpX4Oxop+KzUhuyU80iR488hLSBsMeLAph6Oi5OR4Q/dhYAKDG703xxlCUOjQTw1txWJ6NEJ/7hqy+zIsFkZFWZ7WuyR+/9kMYnW3ffb39sPv/Ede9vN77TC4hNsT1etnJG2iMMQC7g9OinP0BzmxDlLoldY6usWhyA3K8/FLus7Gh3wF8nUdKbioXeDqBp6A0WKw0l9bpf06x5/yjIkKnP66W+QhamDllOQa9MnjLdtbQdUTsxeXP287dq6zZaec6qVTS7y+Y5Bh1I5Ei3PKXHDFx0qO1dibs+uWS3OTruddsUqm5U/0cW02iWiBxgrUXzWlRr57apW3bB5daQ96e/BcGJ6Q7s84Y7eLd3hk2/eMcTWukSAI2oHMPEy9HC07xxADXAE58S5GCw2So/FNEx2O/cqUgsv20UItYpo/clRHEDNwbZmq5VzWWXiZsOzxD1znR7SAhTiwWuuvAlw5siD8rgPB00jbsVZ4kBqjjWrXU7gUg7rnQxkAPaTBQevAiqUxDWijA5IgqI8CZfok1AdB2rJMtLz/none55wz+uNoQoFd/6qdnTCIVEdpi6fZ20ysQ6HKbBONzgx/d0tM/Fwz/rBUaS+g2MP/pUtcADXA7FcxMeYo0caXDdHdcDwCWAWEcbRBvoRU90csvlAxhMybnANg34e3CjuNWndQkyUdjggYRKkCMlaRl2d865kGE1hT0s5pinyjd7mPcBwRZv6s1DrR4beiZodgontmVY0XbqgsmSnSRlNMnZ9nPXAGEA6zgb8WGlusGyNBvqMrsW//OUvraioyC666CJPgOgUvoquvvpqW7Vqld16662GnhFcCEK4oe7evds+97nP2b/9278Nug9B/6EPfciuu+46mzt3rj8b6YPtoqhd+hU9hdZbnKdfnPAN5vJwQhmrb7eSgxIZ0Kl2u/RLW3O1sGd32kuPPGfjKsfb5Pkz+otyRWJZmguDEzvxjQnHfJkiODH1PXgbCMQRhlq9C3NJ8k3lPRNtWYixS0VktARbmNuVV17plxAaiSHsb8YJEBVyjcL7ieOwY8cOB7phPuPGjesHtWGaZGOUqg579+61r3zlK7Zo0SInhBDFfO655/p9awGE4XS9+OKLYZHDfkPcHJYeSX9uoREHLJMFIRjTMILualMf5EslfDTCt8NyJQ+4OUHk7p4saxJA6pOvkAz9FXXlW7rEPVc/8oSD1uve8Tb78fd+aBs3bLTH7/2jXXrZ5ZYr09ZFZTPkzFgaIo3tNr60zA7UHBTQarWDVXtt0pTJVlxcZpvXbbaCwnw7Q4cQGC9AFxDwWVtdY7PmzLIcGS/YJsAzbcZ0qxhfarkrTtVRdLdt3fKy3fO739v0WTPtwqvfbBU5RU6MtrZKvEa6ah0yk50ho/kF0l+ojJXapN5Cq962zw8sps+ZaWXlZbZBBw8dGZ1WllVkJc2y7qX3bkLFDGtRHbet3+r6Y0tnTbXdefW2pa3KAecI3fe6PIYAxChDurizAMZOATx8HLlYWvw14T3D2INeOBftgvPiICRFjUgGCALk9Ep3MNB71F0BWCUdFPxdkY4V4COccHCv62SxrkV6iNCPWIKDe5Spb0R0HZAMyoUCtZppTexsbfe1M0PcowxxobjPAU6eDmsAwgBjXn+sOAL8ORzCeSp1DgPvjv9pLcRCX6+4UPQBAI3+4n2IBnStODCI5hF97qa0uRFJBqcewEYqX48iz6Jp4XQ1Cax4UJymPXUSM5S5CBnpYDyieQKOegBHSkOZOP/1ONEMU1xTPBgTYJEnoIA1vTZxkwE6QZuTJxxoM1cDPUN+rO+NOjQj/WgDMeESIVI4kFvQTIAbOkzcT5YjY9CtMZYzAwdKWFBlDgZAJ3kNgloHbZZGnwoKaou4ZS7gTuUFZruDOiTPZfi7ALtWzeWuXRnW3ZZhZdP1XhRIKmWMgTR8xx0HT8cA0nEwyGNNHLkHEIsC0ISBTay2ttbF7QBIXSK6Jk2aZBDiiM0R4FIgxoXoF3ozYYDIQ5SLALA6nJCmTT+zUYtzsbYZ2PxKrH3ag28WTRJnqWmVUrg2WN3Il6x0fluajAVscKeUK95y/qDigqTxDAY9CU5U4ShBQHC6z9bDdtsuggTP5hAhyVNGMlId2Pj1PxKUEyCJ/Sx+chx5eMSX6Pcg/vjggw8agCcMycYBIw84/wsD1wDgMBzuGEHcoYP07W9/27OAg4TD249+9KP+G6e/zBP0o0YM6jORuHEuz4ixk0aIjgvjxtwIAgMSXo/+u1cn9W3dMtmsJLGsdhGoEmzSxOvozLbWPTI/v+4JEXTyMp9fbX2TTzN889TVNdjpZ53hAAngvvSUk+2e3/7GqnX/Pf/rvfbi+k22+k9P2FXXXGn/8Z3vW1NzkxXJSem27TskojhF1t1kAa2+wS66+E22RDpdX/r/viKv9oWqf6/t21Nlc2bNtMamJpswqcKulZGN9Xrfqvbvt2yd3r/80ss+vkv2LLW0mSXWCzjQPwflaj9zt1z6LEWtGfa7u++2jaoLhHuh8r/qqsvVxixrE4G6fu0L9tTjT9ryJUvNFvTYr2UIZNeOnZKS6rOFS0+0s658o4vv7emoHfldGH13H1ZMwK4fdOidhJgL/PcMZBFwfnRy74BB4ybQk6a2YQBhOKAUACsBGi0kLmYGKICojwQHRvoNUMEgA/2KTx0MgFAvTH5D6ONMFRPcuQI9cFOIFw1wjjrlNLejVaBKa0KudNbS8ZUmPZMy6ZxA8DqAUDoIbK+b4ADrEkAJSBTkmWYTlXZKb6416S06JD9wtX1t1psrYluif4n1pw6AnV7l3yMwkWicweuYpN1wybokWhk4+FVbAGzCiP1keLybooc5tKtm8z7LLS+20tkTBtWln3PEQkl2ApPJ6ur1SfJBb6q7+/cCOPwZOgCIqU1dmhdu/F4R6COqFvShysFHnSqOeJ5S+DNABQY0qEh05UhSbMKtQBcQq29wisK+oG5tSCco3+HyC2cWtWTfaVetMZlPfoxzmF9YKPmidwcQEvz2tpM/XJ8OONDiImG7Fd0ib5OL2pPq8AIMzZZ61V3SG6UzBMq19zbpHRquLYdXwljso7UHxgDS0TpyY/V+zXoAHSH0ijCuEIbQKt3y5cv9Ftbr5s2bZxh1ACChr4QlMzhHWEgLA/oxgCa4RojrJZNBD+PyvWundDZ0qhaNh/lfa5ElOZ0Kp+tENb0jQB+clmbUtfmpre90Su/gSTvPc39+yrM9UeJ1hxPYrJq1uWE4oEsbXLsDI0SK+DeKoEgQMDoMVAg2p8C/h7YXpDaOgJOUrNQvfOELdtttt9nDDz/s4nVhnFTjgI5QVVVVGM2vZ8yY4b8Pd4xIxJiHc4HfS5YsGWRI4kc/+pF9/vOf59GwASeg21/aanPfHMyrYSP/Nz5MQ+9GIOlAk8TnpHsTk2GTnJx2a24Wd7HpoK2Ub6VT9S488MSfraG10c6+8DyJoTbZH+97yGKxmN17z+/sq1/6iot+MZ8JgMouOAIi3MeNK7Grrr3CZs2Ybbf97CeWn1do77jpRrv/gXtt49qNtnDhAptcOclufO+7pF+Tbt//3n/a8tNW2PwTTrB7f3+vbRdHkEOKwuIie8PpK6Xfk2OV06fZhBNm2PqWnVaWVqyZHAR32qnJB/cVvaJTlp9ky5Yvs4b6Rnv84Uds57btmrRpAkfrbL18Ra04bbmded65MubxB2sVkL7xr95j+/ftt+dkEGT35u2Wt2yypWG08TUITlA7pavMVLfREskh4CC+/nv9oZj9N8S7brpJa751H/9MLsYl8IJO4HAHFVjqc25OivZxgJIrgMT7DQcLrgl6NlQj5BxhwQ1wBNmMg9po8HnQJjtjrGvUWbFyFBdxxsA3jiOP/iRuOVCEMWtboUAAgAwDAgWKf0Jaic3JKDRJF1tjW5OI5XRblyf/a1kicKnQkCA9IfUJfvF6ZFAE/gV6Q/iEAjjQZ1FROFYwdL4Q7UMck6Z6QByRZqmMgJs2tDDm+aRls9R+9Y0qAzcsHN+A4xdkRvpQzDCe+4hflIZYXabS4oeJivCJmFu2+hL3CRJc9frCv5GwocfQFOuP65XXL4Qa+yTuFugp8nz4wIgxB/I0BxD1DvMhFbXAWEKLpBEOJ1AtegPRPrhKMc2fPBlaCVpFvlqDuKfWMj7hMPAeBCb+B0pz0V3Vj7ohxhdC6YEYw18BhHoaVKKsdebki3ukwgKLqwMgcPgcxp4eqz0wBpCO1ZEda9eoewCLaRhagNALQ3FxsV1wwQWGdTo4S1hSQ+8I09P79u1zpX+s3f0/9s4DMK7qyvtHZUYa9S7LlnvDgDG9BBM6gVACBEj7kk0hm0LKJoFkN9kkhN2QvqR8CZDCLoRAQkvoZSF0Qi822GDcuy3J6qMuff/fefOkkTSS5ZJ8YOvamnnz3q3n3nfv6ee4444Li/j3Bz7wATvkkEPsiiuuGHR/pB+bxRH/862323kXnNufJU2cywxx7YW34I5MbmUD1M/RCB0WOj2GpeeeeNo58nMWihO+A4mDBzsNjHRpharDQ2rM1fT3J7jAjsFkAIzr7z75EPagh4NxoDFXTUaID1TrnnzySSspKekvO9o8QLxCoEK84sjhtttucwKLwjs6R5ShHiRG2KmB7ODuG2cQJKRTqNZhm7a91NXeabf/7nqbJUca0w6cs73s/7DnuFbOzWqxMiF2NU0V1tYZE5Ig1alou4LDttorL79um7dssXpxb+cWHiL1tyx734ffZ6e95wzbpPfh8UcetauuvtJmz50TIH/quXsrcwwtUAGLyIBfelhWWFpmRZLmgTyCrIJQkiJRJBEianrkzUou1MvKFWxTz8G63dMYiBKILkQ8Egl9b+yud09mpXLSEC5DaiMfv9P7MmzZ0hWS9r6qptOdSKLOdqnjvbposZVPqLSyigm+5hvq5Eb6pcVWs3GLS2oqKitczXZn1BUZT5hAnMG6IBRc6qKOjSTtCMuM9k1ZEPde6QC5Op2Q5lQJGOBuGhfH2Lu4uhz7xw4kkNMsERK4s0YNCcmafjK5bj+EDQ52MTHBlNvAPiTmaIbxEgBX1Bo/fYPJjMnrWyQqRSts5XR/UJdQ5xNyD4yUvaAvaqWZJSIE+qxEkoQCES5IoxrjzT62elEGLVFQ4iHV0JaSV601nY7NFfuRYNalwHOZqjctEu50iQ6wGaq/SC088Ts5JX5DeKYJIR/cb2XkuTbtQDVPedi3k+oAEfd1rDYIEryjCbhCLAJz1NxIYfWMIFBB89v994NfYb4gN6pwELn8gonAVfAEdll4HZQUKefqcARqpcXgrQprDeY6dMYxcHfsV/SbFnHVzlrGGyX2iqjfQfAM9C0Ad/LaClsJYQChBMGNRztGMtbEOWWt2pti8uqYLrfgvKtab9taiKWoHiaWx1jrG8+350BgnEDac+ZyrxpJuCkGg2bbDnaxYHsPtl12trHsbbhuxgnD0ITnMmyI8JiGNOKaa66xyspKd+OMm2lUqsIEcfX4448bcZX4C72n8fyOO+5wgirMm/yN5Oia3/y3HXfS8VYq5N/7CxKiA0y7fLA5B2zA5GKDrjes32Dr1663A4493N0Le7lBObb/I2wqdc7tQxG49+fSBRxAMTcTnGw9FY5EvJOdSUhmhtoU4WxhwoQJ7u576DygPodLduCO1A/pH17wkADhwntH54g+o1KHtGquJBoQSCeccII7beAZMZWIiYRzj+0lOO54SrrqI9+yr977cyuZVOmH+dhW6vZq37XnEEkF2U2K6YJHNyHfkipxr7dQnNmCGbZ+daNVF+1vEREdt//pFkmBZKN33vn2UUmCIJAe+t+HJFlbIElBu9x/Kz6Ngoe6miPYrtY0s+8rQEixq4nxG0SNta4VI7yTbI4Yg4SCxDnC5oWCwkEt5FP/hPhXyTX+towBGzs83+VJIacqUuWBTN98dYmYGyvtmGPeadNnTJeU6B5vL1MBTk87691OoD33zNNWWVZi5SLcDj3iEDv9nDOtuLTEbah6Yxn2ZrfUCr2H+hhLUmbGhPe7QP1U34mXI13MA1xch5KFsVQ3NA9lcWThSdcj1YXUyIOaCqF2oDIPO5CcgFXBDnH4O/AYpnljv3JHDqqH53gUy3biKMHlZ9w+X8Gk0aL/YackhzKIlGNZClKqMl1CinHWEUpxgJETfOpvifKViRjK0VrLUPu9emfk3kAShyCuDW6yO7PTbYPUQeWPsH/vcWKWDtAPrQWCx7IPoZIGwa6V4/9hPPWyvnUnOUUkjUGCRJ98zuiyV8d6DNyNp0lqlYF+M6WTKgDeW19ZZXkV8pI4UYwcnqkeKmAt8N7jtQ/NADwcqhI9G3uiOiQu7Wo/R5UH4xkoT0ujJd4lPJgiicIzYFQESJ6IznTGq7EBYaSvwBBVa3qHm3a807E/jVQ/eQArjDba2JnE2CCSYGKUpsVE7AXE0dC6XDqk/qVK3EWihupdfIjdWqr8fk+D7G6RtE+q6hkKZdDKJqR7nV2yZ9P+Mp72bgiME0h79/y/bUdfIeNqdI/RjQcZx0MbqmJ4usE4G1yAgwD3vdtLl156acosuObGEL+2ttYlF6FxP8b6/KVKAbKX6knqexOmTrJFz71kP//t1fbFn/y7DOEVsLVVQfy0YfvJnKoYg9Mh4SSJToUn/xa4997vXUcE53GqMjt5L+AgErNnpMMC6OtA0fEIvAch+ioCt1485AApGePhicQoOa1atSr556DrkeYBg/Ebb7zRDfNzcqSokeDYQiSNZY6G9oHyEMpIoyifl5fX3w8cNySr8/U/SHGBMf2h555gz9/2V7vqw9+yb9z1S6l1KGYOiIngExIAKYr+Y25pzqJyXhCSu3BQQfwKpyq+UHGZ2aaYbB4ybcacmfaXP95m6+RRsL29w+GLlLVqQpXskO6yX/3i57Zl02YrLiwS0hvEiuH9caRbc8P8gNA4Qqo4MtjRZBFUlbWtaw+yCuItpDYq+xbyZ8reJdIntRsRZp1CNF9+/jmbPLPaSiYWerkMPYdZcOefbrOi4kKbIGbGlOoplosK4N13q3zEttVts6myf4oKQa0QgX2QCKK/3vegPf/cC24HtXLlcvvD7661bK2ZcpU/7CRJBQfM3UacA5cSaUBICEDMkZgwPk/+6gREDQ4NRnyVwvxj+EZtDkcGI60X3JJDBOIeHHwSRw87nFSwo1tG8KjrhcRRAqnnPccmKVsERSDLCGpnzME6Dn67GpvKYMvjgXJ1G/sv30vFuW9VUN1ougINg4SrPTxy5qqSsr4sKxIhAFHS1tEm5x0igwRX1g/OKuKZfbYk0mZb01CpGgBpt9Zir0usgvYjWaw5Qcknwz+8jlBIFOQKPll6gZMJkH2VgbjRfyR1EGiU7kmTmrPG3KNzp18t2udXD5UhX4RRdmGubPSkmqrySM+6FTepS17tIJJIuADvVn0R2d7s6FqgKdxTI+WCiBhrBcxJXGqK2OpwzbxASBBniHFBbOFa26lJ/fZ7+iZxPVKiP8Qoi+qvW3XHJeEaa0DwoXWylhu623yuyjILnREzFD5IMkfrD8+yhQPAXMEJ0Wh5aZ85720VPBTzKCPGaPSnQh09WVaYK8YLa2A87bUQ0J4UbB17LQTGB/62hEBDR4s1tCvCug6ero5Oyy8vdvfCVZlF1l7fItuHLiuuKLUVHTV2SuWBdvGXv2IEbn0rJVTGvvXTy235a2/YWqkBXXb3VTb3qAWyOxKS2txledtEKHVqg2bfVmKrFu5ohQpCmSMubJ0M2NvlLOlzn/uKvfrY8/adZ6618qlVnnd3fWTJJSsuUBNdSFltTPZLEFCbuxtkrCsj7KG51XFUW279zm/stTuess1JtkEpK9yDb170L5+3ngUltviBZ+2pP95nB59ytH3t+h8KmVKEdycytZ6FFI4G7/9f4OntENKxXt7eYgX2jn2mWldti722eAn26/abK6+2e+642+54+B4rKSyR2t0mmzCx0ooKi62qvNI2bt1seSUFlinVvMZt9W6kXigiplWu8Dvkbnui1NzWbl5vZSJaHFGqrVPA1QJ3C94sD4EFsTy3f2mXJKNMqm9bt9RIFU4EWFWpbSsGcTarjOdYzbqN1tzY7Ih1fl6+zZ45Swhpl7229HWPTVVUUmiVJWXKnyHkvN0KtG+0NDZZR3PcqionWLukj4uXvCoEtsdm7Dvb2orT7fW2DWK+sK4HJ45OCKM+Ib4g7/S7PyVl5n1ALQ6EGnXTEOVMytJfbFcu6ANSCurFeUIkQ9IajROiow1JTaLyHW3XbQpVFuLE/9RCVJOOy2ZGDTIq+YwINkkB1UhLNxKKoDUYWMRLatce7USW8uXEpBenupBKdSpkAdIwVM6oGzbB3PQiOzBdanUizgnWi0SDv04RU8xLu+iCJdkijjIGG4bhaKJNe78T4qozTTAvzM6RoCZTnhgVcFYqmarGVfgCNb7BkMCWJzdBNGCt1CKVwk7ZvVEoGLfqZANOwAJAM698hwn7Kb2+QZnEA8bPGsGGrkfEEvMfzZFLezkpod4dTUAWghJm4NBAqqnqYv0hUQmkKsG84BTDveGhZOddGFlClKrOVPdoBxugsRAmqcqH93iP8uW8Y4KIJL01Dl/eNRzbcL6MTiIF04GHvkYFjB01r/atnjbVu1wEe6zHsqaKUJLjkM5eEbeyw4xmdtiFFce7BC3s2/j33gWBcQnS3jXfe8Ro2SwXP/OS/f7GG+Syt8QdHbz7zNPt/HPOtTvuvcvuU1wWvCpVy7D+Ixf9s533Lx9TPnG/32KJeD5Z+TH7+A8utkvP+oz99pIf2w8fuVaHJmos4uxJzSk5cY5xCBXk5lhlaaGVFeXZJhGKrz/9ilXOnrzbiSPaQ32CNgchf0md4oDHCJr4FJUiTrf01aeWJInrO+vI+VbcvHdvOfWNDVaeV20f/tGXrX7dFnvxgSft2m/+3D723S+JWSkPYOJQu11GAsbI50Loc9jvODqVNFm7eCla2TIK5Mmuts1erF1rU/VOzT1FziaEcx1du9oJpGv/8ie7+Hvfsmn7TRAXttNqhLRu7d1oaZXptq6rVoiyXNQX5okYbLcl8a1WGJN0Ly+ifHKoMSHDNvSsc9ui4vI829Bd6x668spiVtPX7Mgkdkcr21aI2Mq2wspquZtu9WCx4KQdsS7L3a/citIqfKQQL8t6trnEYcLRc4UsCbmWTc7qXsVQ05rF+9eytjq5h45aTl6WbVbbmTmZVv6OOQ71jR3NtlHPcafMO5AqQfij1udpUBbNnNrgPU5T0Fn3FKl3SZfKrz8BDZU1CILdleijI/JqEyKBtiJIfNRH7Hdk3WFNQpRbkCZ5X1lPgzqdsis+hqQneIUjtQp+jvwnnhGjSi1L4qSVqj0adTmQb7xxZojr4/dVljmA0+Nwoy79sb8EiH+GTZC9S+C9Tv0DflpDwBLVvJasbnsjvdlq0gcTR3SBsSOhc6c3qjYqoksVqD25CVd7GZJyeNJ1MILgZ/jJWJq1ZnDsAYtCQ5AqYCDxCwQJ9JMUfPLVhyMGiCTuKtOmF1dbTlm+CPcyy1H7qCfibrQvS6i+XJtbrojDXUz0HVU7aQi6BzjWlgY6Sq0ak+DAqMN9HMkcGheUhdjNkCojUiVgGOQMqxu5Xld3U7YwvwchlxQpAZ2wgh3+pp8tIrTiIpIK1CdXK9Ra43ssifZH7nVQg6qVS28RQ6tEpGqKMss1jxC3DiPeGzmd2NWBjKWz43ne0hDYu7GVt/TUjHduNAjUiavcIgnKNy79ptTgnrM7br7Tzjr1dPvLzbfb2Re8R56rDrXrrvkf27Z1i73z3SfZZ4493y78xCcUf6VwtGr/Yc+wzfj2f3zHzr/007bvOw6yY84/1R6/+T578Gc32Qffe45ltgWIk+vBJ/UKhAE3x3BqM0UEvvTgcx44dt8TD08cfgNHw8DVQAXU5/e3s/mTh4B+cCrDQ3WgloErPCrhFQnknSjnlRERSZ2SJEm9YRAaogpnHr6f/frj37GV//m9sbnDHmhmj7hCBe1ZqYV95t/kkEMG4p+75j/sP077jN1z9Z9s4qypdspHNe8QxyIfSEJb5NlJ0BVijX4/xEEQz2U7k7c7ocVCENIEsuA2LQUyrG9StPlacfZzt5g8LJPBJh073+0qHrv9f+3Yf/2A7gxPXo0W4Eatj/B6s66TU3h/Y2d9fx6xpJOzBPc7aEHojL5A6bhe2VYjvdrBeQcVTPHD2+sM6up/TAxqpbDuQes4eJR4rpZdhRQaJFD/ciRTRAnf3i3lDF1kE+TZW9IjegkRATHcBqGh792RXO1LCD4tofxGe7lSxZqdlm8Te7MtrrVVI+RvgwJJb5VjlnatKx8nH2NMcOexa2cMyaVQfyKeFd7bAtfjgVe7DCGeCk4QqJiJQ58h2xcvp/HTXxxIRPSN6/Aq2Z+UyScbKD/SNggeJFhQK52C65L0uJgwg9Xqwm47s0aqbWmS0qDKCnFD0Fb6BcGIBAs1tzBmVFgu/EYShnJdt2JOJY8NpxAQdy4aUj0uoUrMJapyfZJQOiTU3/amuOWKAZCrfrttjgbag3OIxPwy56yVoI5k6IW9GNs3JV1dTgcBdkSjEUmMBXfarL9O5Q/3c74hOjoT9DLr3IlMdh6NhWCwIWGV3CvaphwEFnWw1ljvqAkHqyI5985dU2+bHMJQN3ZTvB1jhRb5RpUcKYMTR6tFQMfV98mdYtIEqoYQSBExqXwFjLXBnRvieKm3AQTGCaS3wSSNd3EwBIKNvcvm7jfPqstlqD99itspIDU68eQT7N477rHly5bb8XJ8UD2l2g4oj9i3fvdjW7hwoX3jG99wl82hTcrgmv/+vwiG2SG1wPPOO88+/t0v24ITj7Q0Bd785Fc+ay/c85jdcMVv7PQjjrESScaGJogbDrlsqWZw6HHYPvi/j3i2Q2QrUSTOa0yZiA3RpoN+q9yvcmCxzxMPI02GzZk6w7Av7tDZ0C09/pEShyWxQPgG3iOldKmkcIh5f/QZkxeiCdFiA/GFSCKF50x+WZF97sbLbT85xHjg/vvd2x8H8p6eUH164IEHPOjwp675luUIgQKmUQUD/tqNP7FvvutCu+Zff2ITpk+yfY49REgKHF1ixUTdkxPwwdgcb2FS0gmQGiEornqkev5eEOwT5tS2VepncbmWpxH+hOx1bRNXXjGTOhRjCDqAB9hRzT/ucHvx/idsy+trbNK86TwYnryz/pFYGInr5Jw7msfLBtKKgdWWXOF2rpPb207WoY9hWPA+8Y13sQBQA7lQgcrSfaSswVvCMxoM3ikkSMzj7kiB+lcAT5cg0Se9nVVpsqfqEeEg4qAwkqW4Q7k2S+1vTGu1NxREeovseLCwCUoGPeFXn/YMUM30EewwBuXXGkf9zYmZxGB4tyEOWuVxrk1Bg91pBcSh9qGo1IQhfvz9V0XAp1iqvPtakTyZBfZpVINTC+wY00R4dQrQjWmyoRG8ktsmn6s6Cvn3+yIQAWkHxFGHkF2V61U9uD6HoB0t9cjGTRZTmiJQciVV1CH34J1yPILtUVQBYL0/wdNgKrV/Sx/LbeTmLNxPxJEIC8EeCSHWmx3AQX3DDougvPQtU3uve6LTs51NrChcdbcI9niZg5kVdGh4jYw6IsKU/SN5tSW3zp7EmcKa5Ftd11wMeHYNa6U80iKNRldI2yi3u9WCpRYoyZ8T2mojuZ9hP3bqW2NCra5TxFGfiKOMyQpaW578Zmp0u62xnerheKG3EATGCaS30GSMd2WMENAexoGDKgVCd745aDs72+zAQxfYQUcdakteWWRX/Ojn9vVvf90K55bbye890/YpmWqXff3bOsgybNLMqeIKKv6CDg0Mu/GqVC63wnXb6sTh63GvZCtXrLKiItlJyBvXVMVcwXvZGqnFTZw0UQegjhxtpBh792jT7dCBMdI2zsHjHC0dOk/c+7Cd/KGz7KvX/8gOO3mhZSlAXU5Dj1X25NknLvyY/eJnv7Rf/fIq+3f1e2gCT8GlamNLm5WViMJRekAEUr4cBlx09Ck6mAkciJJLmpxWdNmiuo1CEAIOcQYEkoCVCRKhejqkbbK1WFHgc/14G9oUR544lHKHK4kGSJaKDE+CeTTAkPufUQ7O44RokdV1C7lWf4N4G0EN+x5/qH30qn+1i7//TXv5ob9Z5eSJQdmUDfRX67AOzq3Bp1fyL9reXjVJNfZfMm/J9fQ/2E0Xa5avssNOPNq+c9+vrerAGVqzAfKFVKh0xgS7+H++Z/9x3hfsvz72dbvs3l9b+RwFUQUZE+TD8fjIBG8IJbxs9chNMY4x/h5SJaDRJbug+ucUA2hDh00swTvfAPT7HHmU6GhZACBsfOrbm23arOlOIL101+MjE0i7CaZvpWrCYKqp+oS0BZscOPFw5XEwACSRViAx6da37w16LyGu9H+XE/Pnrmv0orsjBb33HZJY96ht1Oy8CbU7QURToQiSdUKCl1uLNWpFsc4oD8rYLTuMbhHCmfIcE8kMpJojdQ6E2pHq/gzBQJq72uUNUHIqbKMEg4jce+NMgzRgzwMiHrUD0outtE/2jiqq6hweoka0x+Zbr1x54+o72o3HQtTrwjdDJJwIP/+pQtRJeXctnsjjwhvtQ57o1ghA9jGLQOqW97zsDHlylO4VY6L+qNT7nDgS4eMjSzQPAdcX1T1Jt2BgdNQ2S02z13BlzrmQLdW1THWvTTZY3ajjsfmKMGSAjHGErgR9HcMnM0WMp1aYYa6aiNRuAOGnm/SXbwioTsEzcNjBndTJx6dSLMmgZHCHX1zFJdnBVXjwi7vJV8HvXf2knU7NWY/2mlRSrO3Vn4rpwFEVSo76WvWOSHKUlUQcDa3T99yhN8d/71UQGCeQ9qrp3oMGqx003Pz9QNePTqlWXP2Lq+yohe+waTOmS90729U9iMTdmBa3Y0883m7d7yY78bSTbMa06ToAemyfmXPtDzfcqKCXTbbwmHfYH/5woy04YL594EPvt+9/90f2g+9/337339e4J7uvXXKJffs7l9nU6QoaevjhtuiVxXay6kqfUGBrpN6TODoHgKw+YXiPKkJIhlyUeErfs6RGV7C12znQSIfOOe9su/uue+1/73/QzjzrdFtw0PCYRnAgN9TW+9i3bNpgG2QMf9aZp1p5VFIJDl0ONtWVpsM4r1mcMv3gsAmgpc8E3KJSK5rQIiJLsR8aFfshzOVZE7kh+lCbINI5zhqGJpAwCC/qTE70AiJpYqTUy7cLBo3dra5XTr4D3nWU/yWXYUB+IMFhDeiHIY+BGAcx6ks0SG4v5Hfd45Tu471rRxJqSHmZyNwGiJGwPGgG8NxdCS4r0ea7ZAdCL1kvICH7LjzE/vm//tWu/MJ37YcfvNguf+Aa2TEUM7qUiT65TYZIKJCyNiG2BNLcXQmVoo4tjVbRHLUPXPghqaUOl2YObqvP1q1TwOO/9NlfMm6wl+950s645CODs+yFvwLEDqFboEqnkGDOMHBPd3o//X0VkYRKGtgyRvuZ8ugXEg47DTItWfYbiLAGrbWtsrnqVVwyiLM8EdbTeqVu16M1r3lGwjHb8q1C9h6v9zXZ2l45MxDhzn4QyVBcGLk7jrcVyBNgXN7nkjyC8uqp/v6kS5hUg+7pISp0HhiVN0zqb1ERDriVVvWeqAGSTbu1PNdJqsQz7deRTElq9JchT3ywfGplD7aqfZPUEWFE8fbrj73C6Z6kfugphFiaEzc0M/j99ba95eEfvFdZ8qjX1lmq+gmO26I7Mt7Pz1afqVN1qSkPRCyiifeZ8aWJmYH3O4Llrl22zoqqZX9UJUflgneXXvQ2aQygiudJ5ZE4pofSsyHdQBLm7XB/cNeH5Bz4STbmmnMmInVc9hViCBFoFc2BUC0XOEMkodbpe+dAFSmvXLqpnIGSddAZ7rWL+faPSLAOIPwCZxTIwMYGEFYDcMgWsct+65PWTxxpNJIcOXFUwXodPhLWTIHeB87usbY5vJbxO3sCBDIuVdoTBjI+hr0LAoj4iRs0dTqETrc8I+XYAQcuEBd7hr3w9PO27PU37fSzz7AFRxxs62VoLa0Oq8gqkKpElxM7WxT0cvOGLVapQJHE0Xlj6RsKALvZ3nHkEapzmtvI4Fp45pxZNm/+vlYjV98zRHQtPOZoe3Xxq/Le9Zrts88+Nmd/PettcpWDoYcxM4IhK7ripOTt3TmJOtyzm0FGgoSaznS1ce/d99nrry+z0886I1DbSTwPv9jUW+T29vY/32VPPfWMffFz/2zzD9g3UQmbfq81N7dag1SjfP/3BnQf1RNxOvuKsqy3Mt/SynOdm4lB7EiJgxQJEC54sYUJ+0p+jlloGVRwwsCFQ+sBsUBKh8ekLnEDOzVvKZMqBjEAufFGhhxcwDaEL30a8jioUjeTEaZ+RCNlg4NvIikDsWB8cB9BBDp1RLLOuIkO/64m8CtagTjCNW6OVOiIRUKaPn+u1maHO214/ZlFbpOGbcZYEggtSNDuSqhJdW2LW2VXrtQgD3OkF8Q3lNQCkB4Z2rvnNt1nXHDZ65ob7MU3FtvaRW/aYe89QW7BC3ZXl96W9WD8HgNh1ZrmXWEdQRx1yXNbtwIGd2m+e3QNvPVISYQv9kv629UEwtypfYA6ee97hJXj/6tZaxrnE42tzZYj/C8qJB5iO18MjTKpuLGKGqQay76lYpIeiUhS0ODmNgXiFZEVlSSJ/QUJDYQd0nZUx1gLg7BNDTe0s4GIyFT8rygEoK4hHNQ9T7x3sxXLanZaoQgM2clkF8rFeomIRXmfE3HEG4nkHocOlMMzWXM3EinBEI9wIgDoaAA/VUm9SGmk2gcl4sQSz/lz2IpMYMGOkAQttSMbu7ZSz5el8QIfL6M+dEta2ieVOmBAWzCHiN1DgFLyZOXnWFaB3NDTBxE72jqljpqQzNEHnSnAwxPcEf0P8gXrolfu60keB8/HpQZG7q7nDT+oCoYWewHSZRJSS4bL+tOVjwVvfr4ePUfqD5pkl0UCGkg/2R0JnYH0KKg7dcndexeFQCRetM1a4XssAOEN4rzi3UIK1dMeqNX1tkjddWKHZVVSU1AbNSYn4FSpwNOl6fk2PbvcYZb8fPx674HAuJvvvWeu95iRchC82bJV3M+I4iY0W0EkR0Ers+S2V2oR4poVStWMPBwSG+K17ukKScGkrBLLl9tXIpxnNIkoEJIH0gcakZ2d76ddnzb/ni7ZXOgw75EEqhkDUe2jBVkxj70CspEviQMJFbQNkhw1dMW1pabebDmwmmUMTRv0KTlXmg7Igo3tlqU4DKhpWA5uwtLsu1/9jj14x332ma9+3t537rluOzSoII0rfe7TX7DFi1615559yGZOmezSk9Z4u9XKbXFzSxD13iVGQtTEGrXeInlQypMLU6m4OJda7cNN3CjvYsNiGAVNeJ85bNBfz08P4ksNHod+CQHMl6tvPNmNQLp4bXBe13fh5Q6T7WRIJBoLv2hACcTLOxD83PFPMAOSBjAa0klfnOOqAxViA9WOkOtK8VwhPzlCIBPd4tYupXDkQ+uDCPnJR//Nnr37EVv43lPsC1dftt12QNTiQmiZv92VsNWIr6i16k0Re/8F77N4PC6Cfalt2VprB4kJEZWK6itLljiin5WVZbOmT7NYdq498OTDduMjt9sdV/zezv73T9gpn3vf7urS264e5pZYNbkihGGGtHR1WlxuxQM3z3rNZS/p0oehSLAjtOEK2fVhg7SDVoLeshd0StWrtbVF/ei2iZLazI9V2JT8YhEueguUIZ7Ra4t7622l1GNBo3HB3aMNMN6RJ4cH2ZIitVtelrxYsE+GhBHdHLqYdYu4VW7zo3YZEQhujt6xDu0DqN7iLW5qRqEtSCu2PO0vkWz1I5obECPUqYRrbEI20Leo7HyebHnTlrZukGQLQkUEkt5tJDi48qYT2P2wfp0YAqFWGzua0oRQN3aUWqOIpNKczRaLtAI9VQ+TAKcM2I1Rq4gO1R+V1C8/EhMiLds8wZdzocuJIpB01BS1+4u4zNTZpA+HxaA+qd5uEco92IhGRbCKiAp7zRaW5lJxLgaVGvTD9131yffVRL6QCGLuIXLQpEAe5ypyIpJSTNmgOvlBvbB00CKgjlAbYmhG6gpYTBBjYctDc+3a7yxJy2PqB2OA3BtLQrOgUftX80pJ66VWl14Zt0h5sDadchxSCeOAaVUdlZt5McWOLdjHxz0k2/jPvQQCu84W3UsANT7Mtw4EQCQfe2VdwHlTt7JyIlYxRfr1EAF6FkoznOutzZoDAjJobUetSYPC0qQnnl6Dq99gTF4mwdXrFTIgZ08KqlIohELRtFWfHxLtfkT6dar6R4IOeUGwOY4gljjAaY9/UvG3tqJMay9W3/Pk7lgSBXXWPvWTf7O/PfKEXXvlNXbCB8+0cqmeiA3pjNGwneamZnvt1SU2Z+5si3en2QpJv7CLireJLBTXjLg6ivgpFTq5vS0WUZirw5l7Ss6dDE54P2zgfsY9yGtYewAaDlskHaigYayLqhwIufMSdXJ3S9UC3l6WriFAGdOwlLgFqDlocfyQcNA3LGv/jcS8pAsRH1OiDeAK1zg5Cc6ewAxHSfS7XURGh8YTzEz/0tDotHaA5xi7Mkoz/Y+G9LL/Psjs56+81L591qftiVsfsKqZU+z8r17Y/3zYhcZHxBmXcg17uHtugKAuee01u/2Ov9jE6sm27I3X7bTTTrV2SSdrFasIz3ydkroiaQKdmnf0QXbnT6+3l+5+Yq8mkELoY8jeibMLxVeCoEAqiDTFVUFHWghh4d3wzf4VosIwHDoJuCq7RF6N2mzZVBZ0WZG2nTK5mAf5z5X9zby+QmvuiNtaEUl9Mdkgqc/5sUbLFWHU1UNcI73vIpwyIyKekO6I4eSb05DxuOMEea3z9177a44QT2TOvE/sx5IV2cy+XBGRMdn3QBxpn0uqg74TpJV7vJfduiaWj7+P3Ne7qS1Vr77GQ0gEveaQgi6hUXsDb71Kqw6XAo0BpjinKIiKkSMJapcChqJayAkCQo1Uq5e2JOnp1b4CIdYrIqlXiDjSmuV/e00IeK4VTtJ4YLjQTz3PlO2VRGpJfUrqiMrhYlr/A6cUSY/oNxIrCgbqwz7IpBzBpefT/CbHd0puDUkQwdSRhgXnz7AqUt5g/wP2rYJ7eD00I1MGgwkiitSsdgIHDv5zt32wzzGOHBFKEDH0Z7SkoVqvVMl71mfL26YkgZWtll7CPI6G9jKPAbE3Wt3jz/YOCAQY094x1vFR7kEQKKjus4rpcis9VS6mhdhuWd4lJCRQh8BlLiofECPpHGIcjoxdp0ifPBKl1SLRYeMP/lDDQPUFRl+34qv0TC2xnvyAOHq5JBcAAEAASURBVKJYcDBwFVwHRA5cssDFafAk9SftcnhghFwgRADdZgiOHCQuIojSinItuyhfOveoWqmjIlxKysvso1//vMWlJnfV5T+3bvojO6c+cRI5jEjPPvOcj/Godxzpv1s19qZWkTDiQpLPCqVGN7XIeicXWZpivDgE/BQNa/BizkTLU7/yPNhrsB3ACcyVwW+VvNFVR0sVQyXfx5AvgrEgPcclSfkimPIyYpalfhNF3QP6USWwhiAB1vrTLLgkT4oZbivTIc7lbk8AWXMIpzVBA+5UE8wnyddKogbugcz9fXiiiUaSvrLk3etr1//YSqrK7eYf/taeFKEU0bwWrd5ksToM1BNJsCVwIkjP37NvuKNvbmm1mbPn2iknnczylBfGLjvtXafawnccZdUTq2Qrd3DYK8UnKrSZR+xva156w+o3yu32DiTeM5A6n84dKPdWzMoYUHPDhXenJBLpkhhFRWxENL9/d+JIc4QKnEslhDT7e6j9DW9sqPWxpmOSjhcX5luXJNf1kNnaL5GAICGPyM11jhDLNNTXNBDeCoiGdI0jS8EzUbvzpGd4ogtUQfWDQSclCCQKq0rtH6gaYpMZSK0hlpAcocqUnSt7naik2zSUlHwPTzByuA2DKeindm6ICgV6Stdfht77QDVRfRGck73MQRBkaW8rlI1mUVaurkGOh3Q0qc3wkpOhOFarzmsPAw5JCccM6ZJmueqdVizJiQ7Nd05pgcXy5VhdAZFhUMHkIRwD6tOjtep1CpYOpKS2+i8Fm15U+yBGh8CJPPQFeHOOMd9DE237XqYzMdznhubZ3u9U5bgXFXusSOcaEkLiVxXoXMAGdXcnxoAWAgQYUrqREoSRNkWL13dbjfCCDnmty5wgL4QijpxBgeqyZxpeA5ALVPlGm63h5cbv7JkQGI2U3jNHPD6qtz8EtHfVxxrcKLZUKhpV2RHbvEYBKbUZlkyT2lq+PAjpkKjpafQNNcLhzD+QaOmXp8s0IkdOf7ISdu2Oz2vT7KvMM5MamnMakw7mXQVY8nHFMSmebD/i4XUnZ0g09p5PfsDu/f2t9tBNd9npHznPFiw83LoVxDKzJm59TR32t6ee9pxHJggk+twrbqZJUtRbkhOo63EI+GGZooFEOzzBRmhSZpm1ZwoZ7oZ47HMCiaIQB/SZfAHqmiioL+CKVzUShzJHCpxDotAThDM4inWE6hnl+WQediwNbXWE0mrc5w0kT1xrkrscTrQ9Qqkx3e4DMdNoIAKDmsdUbKczFU8os6/d8BP71umfsisvuszOfteJdrCIZlQyG6ZU2sv/9G5rkB0ZjhmAKXAfKQG9APoj5Rj9Pu7wcxTccvWa1UI6pCK5bp0jo42NjbZ06euWn19gFfL+uK1uW39FB56x0JY/vdidNRx/4dn990e6oI85Uj+Kar3C3EBZkPXDO/x2TsAd20cmKIi9o2t+/wOGRdtu2yTE3Jk/YqD0ylEABEQsW8wNSbHwlNgqVbCGNCGcYojk6V1G5bhTKm0SJOl90ruU1NfgcshqY2zaO3n3kJDBEgnHh7SZPyRO7ey7en+6XKVZTCBcj8u+IyemdS1JSzJSD2HULWkWjg2olz/cZvfovZ4ulcDyLEm4ZIe0pm2rYgBl28SY1KGwT9LetbZ9m5wI4HQG9TYcsGTZnNyJVpZZoNGl24r4FlsW3+R2NENGohIDibcqmi5JiPZUGGzEZAp2wSBPQCTpDoSPnkMgKYtV7TdVyLtU/3bw/NgeARX2zJ04SF1PJJGvq/C+f6t9hyMTNdrgBhXatR/MKc4p2OtJfEJgoJVA4GAYYpwE/YuCTLshAevkFP5GYNehOG2tNWIgSaUumiviqFREUo6Yp5IqYlfsE5VcOOmaagN8Ienm+OVeC4FxAmmvnfq398A5kFq6O6ytu9aKI7lWMTNmdWvSrW61UFmMMAsVjVu2LskSCzY/Dtu+Cm2C4pDmt8l2Rptorr77CiRxEWEBEjoIK/g7gCk4SkavGDWRL/7km/bFUz9sP7/kP+3Xj9/qXqB6JknSFG22Z59+1grlgnyfeXO9ol5OiOKY9YjI4yj3MSRjN6M0R3+c0yqvP52SBiEhC2xwBC9heOlCQpAqBUl1CyMYOgZkLEg0cMKAGgTPgXdyol/ZQoa6aEccwKHPk/NClAXBDXWoqfXR8iaXo108H7ljCQhGpdHKQrI5mBwIAbEhlFL9HyilM1cEEp/b07Nz9JAmvcdDYeQPxvgxZf+ZdvnHz7NLfnm9PSL1yUNLcbUtweD6rXbolbfaHV85R4TgQB9TVQvc8HKHXRVz4pJVZUxG9FKVS76HfcUB8w+Q+mrUXn7pFausqnDnKLVyWrJy9Wo78/TTkrP79UFnHmO3/PuV9vLdj9v2CCTWRODtjcCQUhmEsB7DusVt9JN/uNc2vPimPX7TfXb02ScN60fqG8kw25UZSl37WO6itlg6Y6Idcu5xNnGkeFFhRXR3h7upVQ0zSNIhQIkjCLeBkRc5pBkgiV2qF0IC1HVderNl6aKKkLJ631knGSKMeesgrthbRrPho6s8ZwsSbaXuUmvQ7ZDwwa5PXfJ1yLO4CKZOuc4OCAwn57xEr/ZfVP2ojDUHkYazBxJ7d6Q5w+pqttmMCdVSy4tIAlVgazdvEgFmNrW8SkRSe+AUgb7Qpr7zJN248/nHrThXRveTJ4sQz9C5gOMEPfRPfes/sOJO8nVUgWmDG3pONuXx6eA6JI6oRUPulbRp89I1llEYs/yyAj2HyvTc1LpriWq8c/ApNL/OBKITA9W6ep3g4Pv/wO2/2xVN42EudDQTNhSeDjjmydJ50iH1vLjOhfB+mG9nv2GysbeFSVuGdYsoEu1tbRKyt0t7Pisnw4qm66gsSLMmrYm0Logjp/rDYiN+YzvI2kgC7Yh5xx/s2RAYJ5D27Pndo0fHFgYqW9PVrAO3wwqnyJB4Q4bVrBO3cnOfxQsk/SiSTjEqZ+x2ibNKmiLWpUB9dQU9Vp+fZqWdGVaam2Oolg/KmPi5m444atuhtP+RB9spH3iPPXDj7XbbVdfb+Z/7qHfv9aVLrVGOGN516imOPMDd7JPUrLdCBs7e2Z3rMQcY8AxLAzIMqnt1wEHYhIn7MqkOfwquUptxdS/01IMUfg9kCq4gfDzgqU4zWhvpGMKteK5UY0aqZ2i94W96n1wn7eEtrp1TNDEwH6eusZ/q6s4QIkXsE0x/5SkrIhfcWiCZWgx8h8ntHgI8Lbw1/Ft14vkOIhEuZFQwg8NKsRCmwwulvhOVnciFLb12tly/l4njH6Z0IZA59S02aelaW7f/1PD2sG+QCNz8ErhXKJUztCGUcN0O8cs8D5CBIlIEC+BCP4O+CooJ4GOIjue1xuZGO0TqdIVSzVq+/E0rLMi3yVOmafqDEt4JlSmprrQpC2bb8mdes+baBiGLRcP6F96gRRDyVhBxXY9lviGOrv3k9+Ropcsu+/Z3bNFhJ9pRRx0VVvmW/wZeixYvsi+c9Fn7yl0/takL5nifhzoUgCBAKsOfS1FchXR7i1BVqRyqZ560XjJFaHhK3ApgHswZtbXq3XjFttmr1iBpsmyFskRAaC7SexPOAsYyKaoHgiHiRNnAexMuIsbcjoMD1ooQ/JquJns2vsRmRMvlYlwqxnpfUM2NSVoZy5a6HYkFqPz8C9/pRWvesD+98LB98ZQLbL9JM+yxZS/Zfz9+t5198DFWWVZupZE8KxHDjLcZ8q9JDnLw2rZiy3qrkLv6GZOqrTqnVFItvNVlODMIaRROTgpFSBGYdFtHi+Uo2GtMUpAuvS/+LCrvdKoVIqm+s1n9b7EOHDHIBosxtai1OP3N1Tsv2HfJKQfwcDfl6BaOIbnEW/2GkPSUeK1cfU9jgXmHtI3aXDooJlpy2h4Rm5x391wTAJk+0NHhY+Qu+0pUe3mbK1funlZZD+wVyPN5Z1q2SGJUqzUflZRIRGrBRMXOKlKsOBHt9bL/65Rr+0jEoTamDqRpTMNHM6ai45n2MAgMYD172MDGh7P3QAAkGCcDHX2Nlj8py8qkJtdUJ8RiowLjSY08U/hZZom4otGBbY+rkJioy1LZ3gYrTZOdj27CbSdx8EXxnKMNnk35/0f65He+bE/e/ZBd+/1f2gnnnW6lleX21ENPeFeOPOoIjgjry9ZBP1GSI05WEJDdnJDGdMHVTST0zFHPCZEWDkeQ3LElDsxMeb2LCXERMaGjzm26VDiUbDA3BCLMFp+QfzsC++TRc00fs0Uk5EjVxlW2gpsupYCo60hH4gV3U/2XrQFEk6+NIZzfkEAaWEGpR0tpPAN29LUrQCQ6+YqRgpctIT78C8sn9zNVTbEGORIRQlQRSyCLSZlA0gq3Ntq6pHuDL3GcQWyWcN2qVyqDOmRUSJXwU41cHHzNK/OGDUGWiCmWTrfix0DgdapAe7vQmk4IxnSbPLnazp/0Xps4sdrdLu8v9/YLFizQM82aCnbKQ1s83moZQkxIB757oa195U1bdP/f7OgPDZcykSeYVyASQCOEDc9GS3dd/j/WKycrzz3/gmc75ZRTRsv+lny2cOFCO+rIo+zggw+2bz95jZVNrRJyl4yYQRxpfcr+DLWqqKQ/rla1g6MZSnQNLQ7hRSwkZgDCuUWILMh+nxye8Gw0pDszgcmH+6XXrUn0fWhoQ/rNfOMBDjU+1FbfaFmnALXrXf1tSnaZzcybICJEHki1nmgbIgAX3/zxTuX5u0CwXYKySqK5bpn9/sn77N0HHGUL9zlIr2+vTU0vty31dVbTUm8Ti8psdlGV1rx2EVSr9PZV4ClP5Zvl2axcYR9a5Pk0kisJuYjPltZWz5shVWbiu9W3NIlxViiiL8M2NtTa2m1bZMeUbweWT7d18vz5evMGST21d2h+GB38tViemFR6BZy3wgulPvWBcI9hcfdCQGobSkuoLLIvIhbx6vWBPVOg5Ms7R5MwmLTnj6Fu5R6UgDFbnq+P7ZWnLVKKfCluBXkTnxR1KaCvMZhiu5YoD1HGTkrf25vECJU6XVaxQn1IyJ4hQqi1N2qr64u1r0vTPLtZzkWInaUf2+us6maP5nwbS95dG8l46bcDBMbjIL0dZmm8j4MgwCb5QuvKQfdATDmA8XTTI32RnKJ068gVctGmI6VWUoJG7Y553VIxCdlzg4oLoVUwU3Eb+WtWXCD/620T4dTteuxsnCMmOpRIYzkIw7xj+Y5JspWdE7On7nnYuh55xj69bK398OY7rFbR6b/87xfL8FtOJaoU00g2BcGpmVSruPJZ2xo4u+VGPEnik5Sl/5I8+jeWGBecMxCOA+g+xtcBEhOeQblb623CK8stf1OddYkr3C0EDzDxnLlCjQEJC/WAzOMKORnRoi8YiZMnrLO/r9u5CNUDsa0iFk0Yw4h2Qbz4B2LPQYh6CO6GhStAquk+yBltCx6Cn8NUz+kDNg0DqoYpOpGYfGDBWBkD14Hb8AA+ECY8C6jzEBrD68IL4fSHX/B2hz7t1ZhWHzTD6iemDuAKUQkHHPnV8BTAACQDuONgg6CK/TDRCLMoK7d9m1ZtsG0btliJ4o2VlZW5vREcdhCemOKOReTGuVME1Ib16+2JZ56yZY0breTgaY7g5ZcW2qPX3CFnAd12+HknDusGkMR5CbDH+D6A8LBsAax0O3kN3HXZ7+yJRx5XH4YTj8NreOveqaqqstqGbba2dpMkbnOE8IVvlGAiNbz2lrh1ySEG7rIjkgK5y+yk4YRzNhg6SRnGcAlcsd8JnRe4LY0WqKvWuYqaWtEcDU0Qzawv1jjc/O2lIIfqElcfJxVhwFZU6poURHpTV4PVZMrFqIgAJEAu5SdGlN7BTQoNsLVH4RwkxVles85WbF1vpflFdv2zD9jB0+bYyfOPkPSm07IkKbjxyfvt9pcfs9c3rbV7Fv/NirPzbE7ZZHt6xWJJxrJtaskE+93jd9jSjasU/DZmVz/6FystKLLqwlL78X032OINK+yQSXNttebkmqfutH3KJ9sza5bafz95j725WXW++qQ1iXFw0KQ5Ysq1W7NCQvCmAyPmb9NLK7VliOgUk86JS39f9GwMBwOEFkQhnvvwOOiBcAFcArwZMKVQZQyBrftOjPbfCB+M/s2c9cgLH5JJidKUOdG/pHp65BCi14lTNAgCd+9qbHjF2iiZy2TSfmgmSrEnI7fe1cQ5TEgJiPNeeW9t2sC50W35E2AiRKxRmgC1nfI8GG2xkvw6RbVo1b4dqGxur23AzHlQlJHrar/kn5ZV5mfF9sqOP98zITAuQdoz53UvGBXbbuLkSBqttnprk259u7igGXmSHswQgtoqruUaqUusEw99Doa/wxFHylFb8K0DL3GN+2dU+Koicvvtd5MaS1zCF2vsVQhGHWxIKgpkgOw90wdnyvBeDq9jtDuf2GeuPVJcZH95daldNX++rZV63cKKcjvijnts8Zc+Li91uMcd3ErF4y/Y5Dv+ahmKy8GTptlTbeWHz7KuohTBO71omiDWLbutNiE+SD5wo5o6IcEIVBxSP5/350ds6hOLrEdcW4ejuKArzj3R1hxzgIyvgRb/SM7/1GEkskNSnm6NgcMuTMA+YJ+GYwvsVQKJXphr+Hee675LCVCIf5scGYx0LFMriAuqM2LfK8YHgXV1lwfizjpn2JECrR/Z+yBJQyI02oyysjjEMUz2sQtYgddDIQmSzuiR7nd6HvBOpDxww8mbnLrE1d6y/wyrWLpaqp8DI6BrPeIwvz5rX80TXhsT/U0UBn3KFiKFBQl5R0rBM1b74OT3NQ+x8gKreuc8e+O5N+21P15nk0oq7KAFB9qUKVMtL0+qrHJbvXL1KjlqWGrLhThalYzuT1Cf5DGxTyKqylmTrWruVHvjiZetranVYgqeGSb6iFOGfHlEBAYgx6mIJPrGWsRAnxTYUclltgiH4uJiv/d2/9h3zj722JZFirUTFXPCdXzlfU4SbXmw7BJxiZc494ImxDg5QaBk6Y93B7stVGGHzmVy/tGuWfPBWpR0UZQJ9eFcwVfHCJVG9F4wj90g9ap8hGz9zcIQAY2GMcA89mZKIlSQh5M4EYMB8hzPlMt6rWkkTO46XO9OQ2er1bQ3WrUcMThBrfFuaW20nzz0RyvMybN3zjlYzmXkwbO7zVWkK4pK7JL5H7KppRPtqodvtadWvGqHV8/T+yCpkYiZXz95u+9dnzryVJtUVG63vfyobW6qsVW1eVbf1mxrGjZbTVuTLduy1omwvFiuEy3/dMy7bcGE2fbwm8/bXS8+Zu+YPV/MKTFgNG8umQYAAmJWqTx+FshtuWz33AZp1LewHzx+AfOhVx4Eh+7l/lC3YeBkSCrN/uvbkmDnMZ8Ek+1OQFJTvYK32/lpLlymI6leeg/qgJpREcvUlSEX7pomt0ENVP9UwbCJxkujpM1ae1nqA/tYQDSrgqTEL+4HCthUsnOJ9RiTujSMLQjS+GZJ6pu7pDWifTRX5wdUdVqblWQ06Tlg5Ewf3JfRW5Y6qgqy54yncQgAgXECaXwdvC0hQABGNme4UkO3wPB3oPqgQys/w9or5VttXZZ1NXSbPFdz2vQntmwOezjqbL5wuwI3osFmjh47brmLhNCl4pYKfbZtOnw79c8D6UUU4yM9z5HkXtXlSJ423p05GqJ1DTZTrp5vOeE4e7OpSU7qMu1vZ56mwIQRy65vtMl/fcLWnTtYxaj8yZdsisqki/NHAh75K9bZvJ9eZ4u/8WkPFOsP+Eh0Ki4t8S2dTRp3gLznCHPBHblzNfuzBZmB1WB0bQCck//2qk158lUXkGQKwQvTrFsftK5JVVYv43S83HWIiA0TtVJnpk79LiHnIdoO6kXck+TEARYVck3+VImyGHWTB44y8YviIpJGT4GaEcbbga2SZjmMqaT+9MkbEyhcZ5psi0R84NR8pLmkffrYDWGkXMScGuSaF8xGBtbEwBJuqdTl9bFGhta5+AMn26G/vt0K121xD4XU1S33wvd/5DSr6yu3tAa5Is6rlcQngCVtI3ELVOtGHjFoAysjhPtIOfPKi2z2uw+z9sa41byx0W556GHFyemxMhHrzW2tMrJPt8o5k+2AY4+3lmy535UXMYijMKFmd+8Vf7DF//u0Hf7eE/02s8ZYIcBdWqmOEPyROCsuvdBzxsF7CDGKvRpSOxAj5rG2u0USle1IQ8MOvA2+nTuv8Wah+ijYoU7WK7sJrDcytE7wEJeeULliOBD0rD8kPjGkCZKyNgmThUBytSmBP5XEZyRQMFud2ic6paJM8v1N68zfI9pOEKc8C965gEkR9TUeINjMKW07Qq11PVRaQhvcyxHyDWEX17vfpsxZqtulx9IeZNlUKpzA/OxKGf4LnVbbXerXNtTcehUaoS+wR4QgrJMt3IFTZ1ut9sMHlz5rZx92rIdPKMspsnlVU+2uRU9ZfbzJJT7l+SW+rpC+3fvK0xpnj132nk9aYX6+dUv9bUbFJFu/TcG+pXI3W2XX1m60lXUbbfHGlbbvhGnye5Nnh86YZ/e9+ozd88rfrK61wWpbm6xTNkZ9EmA6rIE5ANJ31bzJjDb4MeyNJtMoScW8nsQncOtPgi+Ejcd7QpIt2AUEmHIITkivEsX6i6S6cDfgeuBMB82JpsMTTEO2puTkNlT+fGSCgSIwgOL6a9caxIYtFaHEvA/h5SQ3Neo1cIDplKc93eMfiTjqaJbd11bZkeX0WXaBvOiJOCLkASuYgQhcO5XYb4aAYafqGS+0Z0BgnEDaM+ZxrxtFDp7VEodtEK50ZBBwcCswtrXXy+KlRrYWhZIiaZMNNt6AMCJKN7YxIAYiCywqQqFd8ZWQBIA01EmKFMvCNcGQV0aVcIZEVF+3EGk5yLWtMkBuyZCLWDVMxHgC2xVl5nssJA4iEP+xprJnF3vWSVK1449UnTvAjS977lVbfw4EEtu6atbJUH3nX/uJI/KTIJaiTS1W+uJrVnvEguCmugEUmsW33SriCLsfxo/3IeKTMNYeIRGMH5QaBFZDdG7sIIRe92K6q1PXpj328rC2g8aEAEmq1argp+lC6rpEbDgXM3yob5CfoYn+DErqM7EwMjRXqaBIbg7obPUHe7KYPObhHjiZIBtUX/8PiAsh7ZovENVBidNWA++WSkpXmqRIcFlHSMyvm3MLFnFx4uU/bnBO1YWQDHsJVI2AAQR5YOw8OGu34uY8/cULrGj5OsveXGNNcuG+ce5E6xLXuqCzwTY1TLLWzhwry6+xQgXyZP5RdxkCsf5KmWtsOZAU4kabNnmPRsoP8k6K5sesdPYMy4xNtki27IzSOmxaQbEVVZW62hdEdFSG7qgPxrWWwjk78PSjnUB66a4n+gkkX6dqMMxD48wV3HPsCEG2Ylp/zCHvFTPB+sOlOcyGLCHPe1pij3BJjCSFrDEBWIifqAZXQRSxACGkfxCNTlSIOMrRdUzrFZghfQMj7JY6HvB0idNQbDcF0GAC+NvtyPbAKmC5E1Ms2f6IvbZAqkf5uG/WzKCG2q6FHNMeiRODFgWWZb24p7Ah3hWpGel6h+rIVr+QWjAiCON8xWCD2VWanmuTIsXutpuuIsGqb2+wPDmKYF92ybM6xvs5Q9Khi455r3vhu/z+661K6nFnz3+niJstdvXDf7EDp822U/Y70h5+43nbULdVrYmQk1RqSlml+thnjy570SaXV1p1cYUdWD3H/vzSI7Zk82o796BjrTyv0J5b/Zqtb6yx9yw4xm2MfvbQTVLHy7EzD1hoW5tq7fYXnwgWpsOU0SX2C13WLFlnseICy62Q2rPvE4lnnnf0D38nkOIwAUppgoEn/UQa4ompFpzZWdLkSCZDDDN/5xOETpBp5E/mNHleR845+EnSKAc/SPzy5+ovhBLEOhIlnDOwbugaTMSxQyKolHmDFQfjCm95MJ5Y4JjDNm/iPOqy4gmCml6VZu0Pu6rCB/yjaoe1yTkKjHe0zwlwjH/tIRDY806bPWRixocxOgTYPF3lQpxBpAyhxMcPGRUNv0EASHDD0iu05a2MSoqksmXBxktAuyAuEeij/iUOJ+5HFQQVPfNAjaDLakX4VEVKdHCFxwWHfa81yyA/UI8JWgWhI5idt6ueNKuOuNRmQC6KMvIc+fOHI3yEtasaizQ2q4aRU5r09FvUPgcR6E5HU4NF4kHbQ0ulCQHL2bC1/zbjbexrs5rOxuDAVUscDoVyoCDnrapNKh26E2wSIgoSHeHQGHpwQNzkK3e21KlSJbiH0W2NXg4oUS9SmeSxQTiF8za0DvJx1OLZDsnC0PbJT54o3qfU9/7nQshyJEnCBS/erBhzqgSHO1Pto/ITxN9J7plKaF1AL7R3dcgeRIe/oJK6JvVDdQE/VPzaRVC1yz6CuC6+tsJCqgtuLsgwhHSI/6TqW4PU1fpmThLyoXqEjLJSc6JxIYYbraNLxEQkmG+qRqUQF8A4pghGwKoIiMp2IRRIbULCFJXGDPUtWWUx7F44er5Rd2prkGRRTk6KpxfLliPqiKzbqYDQK0HQlIsJsEXqOu3exzSbvP8sK5sywZY88rx1ak1GFSQV+IcE94AcMiG9RTVQ6xgiE3VGZpT2E6+kI4JSykuMi1ZHTtu2bbM///nP9olPfGJQpkcffdSWLFlip59+utQFp/Q/W7Nmjd1+++122GGHDfKIB2L92GOPeZn3vOc9Vl1d3V+moaHBbr31VicMzjnnHLfTCh/Sxv3332+zZ8+2M844I7yd8huisFUhCwjuGqoz+TplUQgnRIoDZz7mhFGm3gHs9vT+gJBCtLN+kD5hs6MWCBGAof+ISQDFxoSxpUPMIH1IJGxfqCdDiLQ+wttOtBaLiIFYQRrALCgwghVGRLx2Eay4y1rd913/NtFflgv6hUSIiDmMtzQzzw7JmW4TIkV6U9SUxtqrTSLcf9kvuzsk7de7CzMrgsqa3itQ7Yj6xb47r3qmvXvBUXb3K0/Z7NJJwfukluZPmmUTS0qtRVKhTt47SqnNI2fMtyNm7Cci6jZ7aNGzdsERJ9ssSZDqW5ttsxw7VBWUWnVppf35+UcsXzZ25fnFkkS12FbZiZ150H6ed3ndOnmvC/d2VTwkNW+LW1osqj0Hpzl6GL5QQ/Kl/Kl5wIHEsKT58mr0wZynSTLfm9gwgIm3M6zQ7rsBAcbp4vvUdqr1GVIfXaKkUwWinhS8z6kL4wCHzZV1zruPfSjnCaweZzj1M0v0W+CJb5V9XnOP7I60bvIy/YzmLNnVFBBj8tyqtcx5jgfDHZvAXe3BePm3GgRSvI1vtS6O92ccAqkhwKEBYUBQOriQeUKe4UjirrUoM/iDS8kmDVGTK1fYmXLt3bdF6Gu9JEZNQtgaRWA1ibBo0UHaLkRDHEYQMn1pbwSVS2yR2vmbZZ9T19tkrSJIWvs65O1JxIV+b+lq9AOYw4EUHGf8Cu6A5lFTg1T11sutHoRWULNnDz7UkAdV9MOQH3D6FcRxYqmQ3h5b1dySlLm/iNVNKLYNqnNtR42t66izrYp03yuEIlUikGxcutph2/QTpBkEmj6SMPDPljpT4kj2eyEMwm+/meKD5+0VpSo7ONW1d8jdbo/FJ1X6AzYdOIzFSA7UblivOwBI9CO5BnrGcYnNCupjIyXGAH97aOLAzZekJFfjwtEC+Yb2kTKsEVC/EEkbWg/3cQ/cIQP6VOWT8/M8ONwjVqi1mBuJyfPf8L6xWrqFHIRzklxH8jWOJqaJwz5ZLpF9roRM5slDU2lBTT+BRH7mDRUm1E1QW2vRHw5HGvUHoR8SR0FeJJyB1JA5dymqiLrAeYZU3AQrDKHbt6mPcnaSWyDvhRIUIuWAoz80IfkpV0BOGBchfA48faF1tXXY5uvus9K1Nf5igaxCnIVrLuiLfgn+zSKwtshurr4tarXxLKtTgJtW0Uphv0dY2oO6AuFy3nnn2e9///tB99/5znfa97//fauvr7eTTjrJXn75ZX/+s5/9zE4++WS3q/ra175ml19+eX85vM399re/lUe/ds9z3XXX+TMC5UJMYYO1du1amy/bwLq6On9277332qmnniqvfnG75JJL7Otf/3p/fSNeADDfbzSD7AGCL4FdQ5VFnFmEKofI1oBVm9YNXtRAMDGoR4LTK+IGBw8jJfY3bJs81lA4S2qvV3DHIQSEbEernNNozpxg668oYCDxE0keUivWGkhznt5J1I+Ddzmc+f6CfsE7TBmkC5MipfaO3Lk2JbNUBJD2pFbFyVG/YZv0SPe0VX1obZSkUrHqnNkQzXJvk+y56bLJwg14XNdvNK+zE+cfbgdNmW33LXnWSuRsYbKkQj974I/25T9eYc+tXar3SrubGqcM0q1pJRPt/xx1mi3auFwOGZZbYXa+za2YImcPc61E0qNpRZU2Z+JkO2TqPrIjilhZYbEdNnM/+9MzD9lX/vgz++uS5x0VZ0+J6bxJXsOAc8qh0624WuqvSI8E151Ovh5UWt+sfd+T1CZ7SIbUbHElDhEL8YjjBsb490oQ474v7kADdIf1AeOSv1SQCO8BxzztkezvJQpXDNE8WSofE6PFVuASbtZeMMCO5m5rUggPOSCUnSTxvBRYwZkpO9C5FFnpa0x7H/sSavI4e+JcHE97NwTGJUh79/y/bUefrJIEcolamJ8Svo+y3QWJSOs85yAHOY5NUsyEjeJ6bmDTHUDywF3hpqKCoVNZp5KQuEwhHdkyLXXOlg4nuXvdKj5pd2adDiUh2nBflReOqrtdEueevHmSwICMw9lt6GpVO0FvOExBK+rkkYkmSoVMevLHvUJie2x5vSQCitGUkRHXQdhsK/Yptc8/9Ig9u2WrrTj/XCvFW51SOL6bT/iA9bRErCBXkiN56+kTArH6gGk2dfEay0BCobRoW709tHGTfV6umdcfNNO5uCAj9Lsyo9CJh3p5kmoVEi3Ux/uNR3T93+G04d3vtDlX/WkQcvCOu+4RgRCx677wMSvQUYu1w0QpolWKGFuV0WarvV24y0BoABEbaDxQx8Hb1miEBHCGdKGeEOZhHYzFpYLYviDVAbEEIU1CYkB6skUBcA8VtORn1EMdELFwpTEy93nnwSjJlURUL+sBwqNFKmid2F+FE6iycMO71B/6l3S7v1b4t5OFPMxRIM/2tJgI2HRb2dOkmVKfhCgPTcAIaVNyZeQanpOSkgSob3mSOMHBDxPIdrPs9VoVY6SnK92KCvQnhASvgCzeVHVxL0f14MK9o7vJ0oV0f0RukR/U/Zo/Pminrmq01uI8e+RjJ1r3RNbxAMHINDR0RGxFvZyhaEwREfq5WW1WmdMlGysEKUFe5my09NJLL9lZZ51l8+bNk4c9VlqQXnzxRVu/fr2tXLnSb0yfPt2+9KUv2cMPP2y/+MUv7I9//KMdeuih9tnPftYmTJjgkqcVK1ZYq1w//+EPf/AyBx10kF188cX2kY98xK688ko78cQT7cc//rE/mzRpkr3yyit2wgkn2Fe+8hW78cYb7eijj7aLLrrIpk2b5oTSqI4lBACIl155F3MpjvaCTCHCAnUC1lLf1bprEHHaoLzKpTUsAkm2MEgnRfEEUiQRSul4vpPEJZUqFQg167yHirVAsI9zjVL99nZV3lW4RKS2qT/ZeSIs9O4GcshgfSR/shJQroR4AZGHSBopsffBgtg/u9qKe7OsvSOwDexAWhQXIq1wC6FbbwibZhH3soq0OrmQx1FDVUeJzZsy3eZUTZFEKWLPNyyzquxS+z9Hn24tbS2SAJXZF05+v62RHRFEQ1Es36UAJXkF9r4jT/Hx1mvvnT15qn2p6IOWg2MMIcIfPPpdUgsWwZkhVUGN46ITLhDTIWobu+psY7ze3nv4CXb8nEO8rvJ8Maxkb5qXlWMrOrYAwYHhauidzXJyoz06XYyocOYGMoztCvjzDrs0kfNIf7wfuPlO1x4C8RVImoL30J/5fPqMjq2RMebizOSdbyEC8E6kkVYDUIORUhQRYaQ9DeKf3hPcF2Ld7TZ1h7XNPV4E7jfKax1Ec8EEedDUPk79EG+srV1J1FEcEfNJew81jdTvXWljvOzbDwLjBNLbb872+h5zLCzInRJsYtosOxWw7/WOzf3c8ABA2ub0DCSX/BBUHCRZ+TJinyWkgFDy/UmkUoeQVPTk45BN0nUH4dCGjO0J31PyKm1mZZlza1et22ar6mtUvZDFTklBRBhBTKVn9YirH7GDZGcT6xCXL5Zui9I2utQIxIF/fqBqE64TQQKHvkhqK6B8qLptlZ1TZ3qhra2bKHOefPW52B745uft1c1b7JQZU/uJI7rdKUT+2rMvtI1FgoPMT5rbCsQBrbXcWKs9e85RVljTZEWb632EN6xabb98bal1Hne4nVBR7X1IPk5y07ItJtW05sxca5R0q00ES6688ekk1l8AP68o8eGEg8DHeAYlVdo0b6at/NCZNu3m+yxdXGGAfvasmfarRa/axf/yLfvzbddZVLZcLqtR3bN7c4UsyTkCNjmar6dl39IiLnPAjaYNDkBJtpg//Rst8bQHwka2GakSz+mzu//WgYy6GdIW5zJTQO2jmpYl5Avrs7iQT7ddGtIs/YAbjhRse30K+wEUGUO+JEnIAr1eDLq0dkA+sefgOf8GEsEQMyQ1itlsEUcZQpTy1O+DxGfNFHG+RLG7RgLJkJkZqDLpauKyjTbztQ2WKylR85xpVnfo/nJqoTEJY25u6LKGjRpjrmxPqsVY0HvjijaazyHg8BqdtlKjIHbBSk+zQ+56zmY3dtlPjzzMjq6okPpin+UqyO1JV99n9339g4rfFUoDIWyFIMsurSi3x2LRNnc8kSavf12SMLQomC/EJQnPhqna94f6YG3eeeedtnHjRvvRj34U3rZnn33WDj/88P7f++23n6vN1dbWel5iOpHyZbyPGt0bb7xhSJxCKRPPUMMLiWYIqwsvvNBuueUWlzx97GMfs6wsedISgQFhFQauLSoqspkzZ3pbEEwjJZwSwG/BmQBEeATmBowZ/Q4TiCFMl2a5Vm8nSGkCcWTdumMSqXZlQk2qHkeukSykSDh+EJhc4sTLhS0cv3skeYJICpOq1RagPYt5VbsQ8mEK4JDYG2iGfPxjcvhTmVQJu0B3Y52YRdT8IMapr62t3fcAiJZXOzfYBq3vLg2nV7ZS9AGufqOk+NihNUmVt04BW7dpz6wVsyAnGrOaeLOrAOYUyZOi+lvTJ0m91lCNnCrgHI79va6lQXY7eg+zZMep4cTr1/rex360Tep03CwCUda7Vtve5O9lbbRJzhryfd/Y0FcnaZYYLO21tk12m6jjhkPlu29zXLZ5+ZYjO6Qm7aPYTAUASQWN1PeYZyc0NX+92hdJ7uxFbfW5tCSwleU+8MZqBkKGkBSAfncln0YnGHxmd0u1ENEZoucLBf9SwRkiyYlB9RzixNUnWec6Orol6RSwLd6m4NYt2iMkTe7rVAy9yWLjZQdMrgIxlXo0dvb9nU2MzpmagqSUMne2mvFyeyAExgmkPXBS9/QhcfjffOXvfZiF+Xl2xnlnW4XE8tt65OFKuzoa8Rh2CvcU/1H60DqoUMVDBQjvSxy2cAs5vAicieuFjlinmLDKJxU8RO3i0YlIEfGlPO1CoufmltraZ14XwpBp+xwxxzZs2aTTSXIYqYFgw5HRIzsX2RCkdwv5V2iMm/7nejv65KOtcFapNYgA4RTFGN+9cqlvqKlsUzT2iBAalL7qdN0njlhRtlT4pPbR2l5gj/3qR/aqpC8V8w6wWb+72X4g7nKhPDjVFYmLmRM4agCJ4ZSMd0i60BWzSWmbpWoSt5cv/rBVyWC4cN1WO/vog+w3F33d/u91t9jh//IJqUrlDVoiHBAcyoVSUEPS4zrYMr5eV7PJPUb1YwA0RUl90Cxt+2/uKcWkCjOtcpKlHb7AMg46wKatl8qRkLHLK8ps1Uc+Y/fe/5B97vNfs99dfYXK8S9IFVKRBKmGKz5FNlpLurcJphEr1bxUirsorXvbIqSkQ0gPibZHSmEU9LDuVPl4RnvYEXVniAuv+aXOQG1IkkYRIdhDocaC/r3HI4GTq8QnyNf2JBmeOcWHq4RGsMURkSskVzif4KjDXwR2m3qB0wRHjvScPiqspc2Qu6yI5jhET5mrTBAX3SPPzqQjb3nKZsmFtyfVU/riUqt85Dlb+sUPW1NnhjXKQ1RMscTKqwPJEoQJbeG4g/Ua9M6/vArQwGat/3q9Qz1pUo8ScjPn6TfEme+zT8yZ7Xn4gEiKtnfaxEUrbJvWCTWh748dYYbmojg37nndRa/mgATx5Fxk/zX6B4FXSRBIITHDb+yHUHVbtWqV2x5dc801tnXrVsuVwxNU5fj9qU99yrBRWrZsma1evdoJpNCL27p16+zSSy91aRP1bdiwwX74wx8ahBbt/Nu//ZshpULiBJEVliMvkqPNmzdzOWqCcJEemMPEV5vqHZQSU836Q/1ODTsBg3OUPhFTxEpydauh5QZVoh9aPxAJaSKMnQeist2o1CE9Uln+MP6PaY8hJhbKRqy+UM2RNxfOPnsYnHfem0ANTHXT5RGWJLfdng3iTgE9s9RGO2rN3l+tfRF4aZKa9cixypTuiTY1o9olJfU9rbYivlnMm7htaNOeovwwU9JVHsINpzgx2XnmIaWVndbWjgYn5ui190ft6i22KbEqeaarthYxPhY3r9ae2+SPJTTyvcyZMirS5LGNoPmC9bdFziLwbjkvt9pVt9erD+uk0sy6DYfKmTIhWmQnHr2v9guNLTvbFreuUX+3OcMtzKeubD9pbGH+VI5rkitANRYJD/3z+QkLJmfayWuqgiyWuZrgNGQtJurkPvZsEHDeay1hvtGk6B+E8vqakXdGzuRyVOfEjGNs3Pf1rDY629WW5qKjTcSPCCL2xk6t0U4xSPq0NxAENlaleS9CQo7TcK176vb1k+jQTn6xht0Prewnx9M4BEIIjBNIISTGv98+ENABMmPuPHZGy5cKSJ6kHVN0ME4Ul13sJMtTYNJ2HYJtrXFFSc+yzYpRBKdyWna5YiKJCBIS0pWdZmviW606S2i4iJwOqXFEVBfeshQC0wmqTiFyGSJgXuxcLSTA7Jknn5b0I9umHaN4L4qBgVedaYoPMydrguvtox8fkQSpu7nDasSZ7pSqy/ycSVYt0gPEuEsGzVHp2HdJ557yG3rj9mK94p2IuGrplu9xjatP0hTJUmzpnTfY89f8XIaok+zMn12nfuRZs+istmLZs8iTWFF0vZDGiAiYEiEr0oUXkp0hDwMxqX6VSXUvIre48fnzrHX+PkIOzN7/5gq77ge/st//8Er79H9eknKuOawCKUa6vbJ+mf3ynhul9tSi3uio1Pg5iLIjWXbw1Lm2smajostvFVKr2jml9EFMkJP2P9I+c+xZNlF65TZlkj8CzbjmNz+z0858v910y+02dWq1ffPrX+nvQ4D4BwfsvLRCKxZSVo6qluYBKyWQ72pJF9ZKvXGrEHV4hSBs3qzXkkAoBD8I4OBkHnjqWVJ8QGhE5Qcc1B+98zatAWoN4u6gDqmWNeYEXdZfAzW7el5SD/ofjuECxCBPRBLuLJAkUX+fkIx2Ee1pIsogkhyemrkK2dBlq48Do4UwEuKgtoN/AUIyhmb7s0x+ba3NfP5NR2rCm2l6P2Kba23C7Q/bGnnzwiFDdkWv1fY2CjYdCQIFO5hAvQfOL3+ZYhj0iimwMa61KAI+P0dEv1jE+XINDnGUMul2bm2j1FV7vD6cOsA8YBb7vXUlFUzMbtKdHb8kKOulInCOO+44vStpriaHdIdgs9glffWrX7XLLrvM9t13X7dPqqwM7OVo6bXXXnNHC9/85jddfY97SD0grH71q1/x05Ag3XDDDXbBBReI+y3MLimh6ldQkCL+WFIev3RwMavDE3dBgF2Ko9fRJTuS9KGWh4WjhuR9gqkzlgQMMqQyjNpSR7P45iKQfD2pDaRYuTnaZ7JiInY1L+pQltYkXh5JILS0q2b9GsYG+2vQc91nACm6wTzCbHqhZZVFCiUZTa90N+ZkdacQ2mvveuNZe3nDm06sUcmk4nJ75+yDbEHeNFscX2P1UlnmFQc5hjjK0PojHEG2pAgz5CJ8RqxCcDC3vWuRzWeTiKpNbQ1SnZWnPDFf7pOr7n0rptsUmEwiqiAsYjo/qMtVZzXYdJgP6hRhB3jX+DErZ4I11TfZ4po37LDp+1mjApBulifJMLGHFSqQbZscS/zmkb/YaQcutMxi7V6qx1UYExkDGAXACT7DGnb8O0P9i4g47hDsXSVYVSCJTAX7Ha89KME0M78jJeaUtcf8e0p8RRJaAjAzPegse6kqS9caIuYXxCdrsLVVdrbySAdxlK6zD82NaJbGpfM5Mz9dHjpFMIth1cHeKIEzdrmt/n4F0HPJpiaJX0zVzqWgNGEEdsdes3N9GC/1VoTAOIH0VpyV8T6NCgG4hwtPPsU3xGydQG3y3PaL7/2XNuJOm3/AAjtGhtVX/u43MvRtkj1BlX38nz/hHL0//M+NtuzV18RpzZIR97l2+KGH2KLXFtttN95kbXFFR9fvD17wAbvjzjvs2ZdeFHraa5/87D9bTl7gXhsCCOKKhkEaqmVIOqurxO676TYhUUuk959l7zn7DJs/d38RC6D26bZ5laKv33qHXfC+98kzUq5dd/21tn7deptYPdHO+OCHrbIn1x556El5nmuwtMlyozxzrq146mn763e/ZtG8fDv759dZUUWh5coeKTva6N7LohGx2XTYcHjF0pqssbXEmuNY9+go06G9tSHHioXkuE0JfRVCce6nP2x3X3uL/fnq6+2Mj15g1TOmBHgMZ4P+OBiU1ROE0PrazR5LBIKIxFgKxVGeo8jyV5/3Nbvp5QftJ4/e5AhAXAbsXKCatXLLOisSNRkTBzFZ4SNXLspvvvF3dsIp59iPfvJLmzZ1in34Q+d73ckfeZJQzE0r8CMZoiCso7gvU2RmoTVJBa9V/cVJQKuIpnbhA10CRKf6LDrX5RsBEpJc6wjXDFjl2uRBrLlT3qf4qb9ecce5dsD499APtaBy5A3yDX2+/d+SUQlpk0qW/sFVpx89glubOKPpCtKYI8KoAAJJhO7g8QSzhEl8mSR+wKjVVdECAmP7LZtNe2mlqxANzZsumJa/uMQ6Djja0iql8imJZjfsY6UAccCph35rnnENz9h7urNta3OFq55OKKqTF0GkEHonFSyzV+8pEqOhqU/3m4qlzqm4SSTG949ATLAv4g9kDkkSqngkCJ3HH3/cpT9IlA444ABXi+PZM888Y3iow07pve99L7c8Tda7is1SmCjzwgsv2Oc//3l3zoAkibpImzZtsmnTpvn1znwAQZDgNiHznajB6S9w3hCuPr71NxzUozen/NgpReROnuJdbYG6KQ4NCnPydU+MI0mScXBSjJ2I1pyve+G63jJSAqU+sfpdTTXRjdEaRRpbJyXTJ+LLbX8FgZ2eXuoSqI3d9VbQU2QPKa5RXKp2h0ybJ0ZQtj2zeqk99uZLdvEpH7IjKuaK4BFbQf1i/92mmFjE0yrLDjyDVmYqNIG4J0i/StynpggyqSP2afuGcMDDI/G0sN+ZKMYYjgFYezna43Cpva693laLaca7NzWnwh3/MNJ6MYlwFtAmlgbwAswlWYVWlVUie0CgooC2kpzyDselzlfXuE1Ecid+LPtBATFARC8YCpC5xHsLJNHUxt+OJ4jDLq0LAvtyFgB+VCTdZhbKzCeJetUWr7Ey7ahDB+BDX0dL/Sqb2MLRpg9Jo9Rc92j9eOKenmVqbjJFJCFh7ZQKdt1aLSY9c/tGEUWRmNTlpFbYJY0BVhcQlIxM6oNBjEEPYuwVBh8Qn4OZZUkPx3BJt9BWyNX8/iP2oDF0aTzLWwgC4wTSW2gyxrsyNgjAvX1MnqLgqE6fNs0mV1XaC8+9YB/99Mfs2MOOtkeefNzmzp1thx9xlP38ip/a4w89YvvsO9seue8B+9YPL7Mli5baE48+ZvvOnWvX/Oo3duIZp9qcWbPtJz/4sc2ft6+tWb3OGuXp6jNf/JxFCmToq8N7aOoT1ZGflmO1m7ZYbV2tffzTF9rLL7xsN1z7J/vP/9jHD/B1QsJuv/kvdsSRh1tFabn993XXSlLVbZ+S4fbNt9xsd998k50qF8BdWXE7/B2H212PPiLiZr3dd8kX/dB437d/ZHMLcyzWsFFG63IqoMMPbp6c8PpmnqbgeFJAkA3PFovJKD5N0jOYmpt0KDWrzogOb2DlZ5YIiXM+c5H99tvftv/64uX2pZ/93NvIlE5iNFeSuELZ3mTrSOLEIOlAhxDlN9zULBF/nzvmfDt5xiFCSArs/QtOsf0mzLDvPXy9vbj2dUmsAmSAw1k+/aRWKO9WHHFJh2tlZbnd8qdr7ORTz7cvfvkbVq3AsccftzBoL/FJWyFR1N8XPcNch1TUJ2SNPnpXEwe/fjbpQF2SDsKdyKirMHEHjrNq0b+BxOHfKJe9jULUyEO1HJJI+9zoN6nvXkqZ4KKDFKF6NLylsO4A4QcpgrCEiPGWQ9gm2vJFQh6cg+ikB+nDdTZeEoWjyR4tXUhZt8ggtumgMJ9IyfYTCjgvs9glL2v7Wm1R3zahbyAVI/cq7F1UiPBIuTKEfGeUy5GEVE4B+lCkISgX3IUQ6uyRBEl9qyisEXEkuVZCLa5bdlzLD5tlM19Y0e8shPbpf48kF2vmT9N1MKawX3/Pbwii448/3tXnsBW64oor7PzzAwIdT3U/+MEP7Nhjj7UHH3zQbYmmT5/uanpnnnmm3XTTTXbccccN6h7EEhKjf/qnf3K7I9x947wBiSplfvnLX7pU6r777vN71LezCaKEd4J3A+mOQ1FEMdx51phzQKicyRFI/Z5fDsC3rbnV3njiZXvgF3+yw849gdwDiTpUF2uPNRgTwYBEp10IL8bzuNZnXbkKl0q57ZO+MyS1py1shlpEIKCO7CsG5DxFYhyOpMNMUZY7JW0pldQf9SZCFUwtqLLXl7zs7rXj9SL+NU+zujLsrleX2lNFz9i733mC1TTViyDfZgU5eXbU1H2tLt5oT4vJ1dLWpphGM2xB1WwxuzTWrQqMXTnFiqWuvK29xZZtXGtzyibbvmVTrFLBY9Nkg7qtpt4lcqtr1lt+ZsyOmrWvTS0qcVXs1Yqp9OjaxSLwzQ6VxIgyEdnjYcxUJHsnPK29vnmNPbtukZD9NM8zrbTKNrVu8H0TkIaJ/SRLNqMxdgNdSzbiax9pYJvG3uGqjck7U1hy5O+gfnmJ07wB1/7m1F93cODVBXBWM0p6oJTGgJI753d3/SNTKptI9mEu0Rl1S8xEtY/02+2wIFxFIopQZc30yClN3QbllQrdhJmSKOUAi055eI3Ldb2Uat3WitWkcBzaB7tF4RH/zitPdJdhBHvrzvWf/YfAs6WRAicy/5H70c71eLzUPxoC4wTSPxri4+3tFgisXL7MD/PivGybKvfRlROr7MRT32X52bl28BGH2qMPP2z3SxLUquCo9bLb+X/sfQVgXeXd/hO9cfe0TVJ399JSBQoULVJkQ/ahGzJkY4x92Ma3wRgM2XAvMrS4tKXe0pa6W6SNu94kN8n/ed6Tk9ykSSqU/yjN2+bec895z3teO+/70+cXG5WAiLhYfPLex+g7eBAu/uWlyM7Mwt7de9GHWp7s/dlGqr4vI9046Z900nhE9k7AuuK9xla9p2+zyY0WaZm1NJAJ6EZJ8gBC/H7z+dcoKiwwEjMxJeXl5Xjl+VcxcuwYnHf+BYQAzqOj+GoksJ7ffrMQJYWlKGMk+HoXTf6oMaimXX5FSTmev+9BmuuV49r7/4Qxp9BpXqYJTA1kQGQdXeOgtkZUDJORBpq60GTJq5zy2BHwAABAAElEQVQbDzdws/lRekkCJ9ZXoNckYFkfClIxk+AJi95/FxuWLcWO9SsxaMwYXqMGIpe+AMX1iE4i0htj/Fil65nWBqTHRVJKOyVlGFJIBChFUsI8MLY7eoR2wRpsNcSTte9S4kp7cadXLSJpMhFLkyw/bpZ2mf369sbrrzyN8y68EpdfcSO++vwd9O/Xx5SpuntSkudJwquemyRL4Xn2NX3HvMTskfGrp6+KqZh1h/kU3ka2oRst/w23S4awi6IzcDht3uXkLUh2wV2rTTLtKiNYhsqTVkNAAEkB0ey3MPqtVdPvIQvF1CwZB3heE8KdLyXQMm1R37SdaEbCf+G+gdQwEsaYI1DFOqcRgr2UZnw2IaNvMU0iFMXtWfiGVokyG1HsrAoSDAV0aOvvGYEUMuMqt6kneZ/u8icB253S8hoGjdxQR4LPnViyijvoM6dnPGL3ZrdgXJRJrHRRQhwQwnpxzOy62gX4Vjgx5Ov16ELfNqX9/bpi7dTRFCJwvrkxR3b+1WePgR/NSWXSV0cCypMEuJNmrAuuIoodTVH/f6aUlBRjBickugCajwnl7ve//72pgkzsbr75ZvhRYyEGR6h1+n7ssceQl5dnGCu7rspTRWJcJnXSLvWhkEXADFOnTjWgDcqn8sQkPffcc6acl156ia5FP3yr1XgIOdOT74LQKuUzpPfXzAnr5TOHtVxLdE0aBhGkVeWVuL3PeThr9rnwowxhuHdXVbNl0vvTekiaqtw4E+wJIUcSk3hChzov588jTU3lWzfKSX9W33GmOA+hKhDZzo/E8eS4fnj1gcexacZa7EtoIBhNGIO6TkRGcTb+vehDs8ZFB4bgr1tW4ZKRMzC4a3c8t+wjXDL6VEzpOQzf7FiNFfs243/Gz8K/F8/DqQNHIz4sBg9/+RoDLAehJ9e0VRTy7CvKxFXjZmHrgVTe/zFiGAy5jAFwF+/ZjN9Nv5ha9Vx8tGkpbp16EdYV7MTc775CUlQ8Ne1lWLZ7I347fQ7BH+h/xnXC/e2ROa7Wdwm2fDhOAlTQmyxtbFtomYfTjVp/ZBLYXrLWJ2Y6imFpr8yOzotJE1NdTyGdFg8x214E/xASI5tuhECebLcETGL3i3MJglNMZjPBE2W+5Sh2VlLYY4VP0O5q959ES85Gxts+Z9dDTRNzrdxH00ytpxG+ISZunvwc7TL0rdfJ/m0/r/P7xOuBVkvUidcBnS3+cXqgrKwMK1asOKhwSXF9KElqnf7zn/9AxEvPnj1bXzrotwjWa269HkUN1JJQYu3MYRR3LspCvSlrIJPx9LOIJuLcKaefgTL6HMle3kHo1Wt+cy0OpB/A0gWLsH7Fd7j44gvg6++HLslJJPC80bN3DwzrOwBv7XvHSKsKiJCk+EICd1AyCyYXThmbdPeLRzwl+BtXrce89z7EVddfg+KiAnz24RcknpmTK2wf+jMUFxZjHc31uifxGfKT6tIFyb0Jw90ryTB1gdGhyCKk9475X+KVl55HIR3HL//ddZh98wUopY+SJGRWovkVJfrldUKAazxjX2r83fwlvRIhcr3LEOMVRqklHa4DLcSwW//xB9xAaPA3H3kU01Z+YCSalaVEd9rfgLw0MUk0c2Bzudehd1w3DIrviezyIvSI6IKt+ek0ZaNfVUx30i7VWJO5A9mV+ZjeZyxKiQAVRylrWlkOO0psXT2yKOUu4fj0pPF4AGttbdrA5JMnULP3F9zwmzsx+6KrseCr9xGXEEtGhKYujGGVTf+t2KgIg3bUwDK8yNxk5+UjKpLobWy8SzuuOBwWKMYmz7OWc4HQxo09YwSmjZ0hCXgkmYvtqzYgJjEOEYlhOOAkTDvvE4NSQ6ZLkkNtyoH0ZYhzBaFwWxr8I0OQGBdNn7QMnmfoWZrDSTBubd4qXE/RSGgQeFY7amNJinuU3BCJ3Su3Yse2HRg7dQJiuoaihPFdlEtJz2weW+tc60/N6SJK1tdSQ1hO36x+3mHEWbKkz3Ze1ULkVhyBHHYStauMZFhzHe1czd9iqvZPGIz+y3fAg74nnhL1MpmpxAZuO3+cQcNqXYZvZTXOePxj+BPG2IaP7/XdTnTdmo5Pb5mFavr9tU71NKdZ9MupCMkpRnhWEZkjmuOlxNLhWuThj5tOP/106M89/S+1pwJTkImdfI/sNHnyZINWp/hJ8kuyk0AY9NdW0hr2wgsvGLM8ve9BQc3AJ7179zYoeGKuoqOj27r9B5+TD5I3tXTG90eaH66JQqOrIzy34hjV0nzJR3DT7Ov/m3o9HnzwQdx9990/+Ln/rQIeuPd+o9mbeM35+Ov9d6F/bBIep4mv4LZvnHg+ekQm4P113+IrMkNDu/RE39hk7KIWaWhCT2zcvwuDErojLiiC7zHBe8Q48n0NozDt+olnYUL3oXht9ZdYl7aDQWPLqbFajuHd++D8YVPMM19cNA+FDCarpODhEmrIN+rmUy5GHJmonPIS/PWTV5Can4k+4QnGBLXxjWrqLiOkomCmSougYWq1ZnDdkUaJdTFhI5py//cPpJ0UeqCEd6zgQRVS7K0GIR6aZZirWePibrfJh4yRF9de+XEauHquO9LSMcw0qsqIkJnLNgfThDesiuAu9HFsXE8PfpL7mtuyGnqmJT5sef5wf4X7BIJeiFRiNTKafDitthmcnYAx8s9TnbQctFWpw31IZ77jugd+/J3quO6ezsofbQ8oJogCLj777LMt/hRwsXWSL8A///lP7N69u/WlNn+LuMysKMCXud/jO8bCEOoaRalWXn6Xl5fR/p+gBsWl2LFzt2GQtu3Yhleeeg69e6VgxOjhyMw4gMjwSCTG0/m2tAR9BvZBQU4uy+DCz4XXrPfcCSmYN/ebTYIEay79CXK37kPIXtqcZxajhtJZKW6oNMGO7TtRWiLHXcZpIJLVxZfNxulnzaQm6SXa99OufsQIg2bVI4WxiEi4lDBCu3dYIPqeOtKY9qTt2odpF5yJK35/kzFbcdHsSlYF9p8sFViFpj9D1YqybeNP9ZeDcqGrzGoPN2Uxin2GD8Ypc85G6vbd+PCZuaadAQwAGtmVtvUsPz+dEjtKbhvIjA2J7Y0nzr4V90z/hWEO/vT5s5i/Y62BGP5q13d4dNHbOL3/eDx19i14+aK7MIvHAh0wQ8EKaHFxUsu205OBP7XJuG20l10yG7+74zfYfyATsy+5mqYywnCjNLG8Ak8+9TTWrF0HP0qFPYgAuG3HTjz4l/8zWjlHAJmEABI6/jR5oZamjuY/Dn8GeCQAR7J/LJL8YigVDKbmxhuJ9BHo5hcFz4p6LFywGKmpqYTZ9kNXxk5JoTN3d/849AiKR6/ARAwKScbg4GR4Ez1pBcE40nanmfKGh/ZEF/9o2qj7oCv9Fvozb/+ArjymBxAJrUAi8PXgcwcSdr4vATmSHNHo4kWiac9+vPPm20QwCzVEd12jmQl7wSQxIGJWDkoiltxWZeUREuPmhiKsqMtFIRkm3dsy0f+Kk6BZBtryqvsvmZQEM5bL9tuvRtGg3lDwYE2fotg4rL7xImR2EZiAzrRMAxdubMEc6aoYJb9yJwYu2NQyc6tfpbFhSBuaAmmujgVzlLEntdUTDv+nL+MDuTNH7ne6M0fu5zs6lp+RO3PknvdwmCPDWIvzPkQyxCBRAiWZd0/SdIlREnMkFE35dRg/FGZSqRs/W46pk6cc18yR2qtxU1DebCKJStAkAj2tIBe9IroijJDR9WR6e8Z3QRk1EYqvNDqlP9KLsrEhaw/9C6swhIySUDblu6V+kXhCPoDBMiekhldopjJ/q2LeEgp7uoXHI6MqD7lEsLtm8jmY0mu40fyI0dH+E0A/rS82r8B9817AMwveR1ZxPoFM+A4S6MVAcbd+hbQgy5+PY2RtLtSqiKnlc38Qc6TntP5Th7WTDCPTum6t8tYRuEMMdlvrgJ1VZoXSCJm9khXQ0u4gQxRKgKDkwASiviYgpBGtU3M83CuQRsEUk7HsYgZ6lf9VQCyfcQxE9Idojl3lpm+NXxCZtQiG0lDdFLzYXVgVwj0gNIum65n0RT3Swpue0nnwc+iBYzA9fw7d0NmGY90Du3btMhC4ssXvKCl4o5iotrRKHd2nazaB6UdkuTETxhlpaQ1NPa4gKMPbr80lQZyGESOHIY6+LsOHDsf6bbvwr38+T4ImENfcci1CYiJw3W9/jbdfeRsb16zDwIF9ERQail79eiOITuYNBi1HdL1Fkg4Y1B9LFi3Be+++Z57dt3cfnHHqTOzeuxevvfY6enZPwdjx44w5zdDhQxAdGYVBg0ZQs1SCPWmpuOTSOXh17ut46vEnkcA6nX7emSjgBvyP2x7E8s8XYvD4kbjjqQfYMm5Q2lBbJWsRpyZGG1Kra239FClVZByZuXFRM2OXePWfbsHij77CKw89jekXzUJwWCgCiBiErkBBRj0y99K0q4CQuvSHqqCJ2dC4nvAc7mXMTST9rCAR8OGmJbSrZ6BXmrnsLtyPflHJWJuxAxXlNdi/rwwRDAgaHm356RBAGGmMeE7wdURI/NpYk7t/fyt27kvDB+8SxGLO1fjwzZeJ9hWDnj26Y8HCRZg4cSLjgLjwHf3LEhMSEBMTTwbzAJmn71kWnevHjCYDEony1L0op1N8JueSUAbHjB8LDzJN5dTefffdKkoyaY5CKaUCooa5AlCYlokNW3cghj5Ro4YMJlFZjZ3btyPLecCgeUnqnpeViU0LlpOZCEG/YQPhIrKSs6AEW9bz2dzcBw4fhAS2WURpJeNNbdm8FgFk6IaOGGb8Fr5dt5YO21WIpn+cf3AA0muoWTPtbhw5fnlRu6a5JSLDgwQu7UUs8z0+X8keL+u4Aen1FUTnqsVg70giIwYaokRslqSvldS0uSSRNv1rbm/5wcIUdyuUUlPFvaoOIcF52dnIzyRBXdOAMDLIFQzMWk0nePu9ci8gcdv+Js2R+3kxSbq2dtZo99M/6nFMl3i01vb8qA/8EQvfzbnrH2uBOXT0GAk3jC8H6WtymYawdl8EDMNNAl8MUwOZCekZPby8kbUjDTOGjuqo6OPmWt++fVFWUMSWmU4gYI0vSqsJFyLzNRK5mSXyKaJfDrXJ/eNT8OmWZXhvw0JE+ocZvyb5AqnPRJxrHdP7Jb8q9a3RiPC8CaTL96+CjFaIoxuC6W+0vzAPrkBpGSj04fuq92Puii/M+3bzjIsJV+6DBz9+2Zz3pmDOk/6J7mNjOlh7CLUSCh9gXly9p6Yu1louTbghxnnusBPrK5NaVt60RfeZedDo53M45ZheUEdYnUHtvMoSE8f/ZCaN3497ncgYqZ6Wqae0loxDxOcHEkQnmhruQGr0wmjaLc29qlZFDX0gHSqD6umBxXzFhTQ3JLKOb3wVARnEM7ZkTg6nzlYetVT+otKge5nxNxqfQxSg9iogdxQRDYXYKpAcWRGYxPoSGJYhP1guEX+003amE7sHOhmkE3v8f7TWi0GSfX5HSbb7DzzwgHF0lp2+iMXDTQdq80kWyuysBiV0KD/jitnIon/J7vIsDOzXDbc9dI8R2ElCXulswHckVidceAGmnH+uWdwLaI73Ud5uDEgOw2/uv53MELdWhyeRjErQf+oIluyBHc5MbgBE1eGTMmsLMZRxjYbNGG/sqFVT/dVwW5xz01Woq2H8HF9KcUW5U/sy8ZwZxtk0k34hp1xMEySapBHbCOded5mMx1kHT+TUleCxvz+K+S/QxKxHV9w79zEyioynxKebTbxVZyjekuzX6+jAKm2B7K+1hEsaquVcyVrSVXuLyBbxnM94HwZamv492iCi4mNw6e3X4IX7H8fLf34Sv3n4brOZ+Qd5gtZz1GzRJLGAxDSZDBWrjSQ5NBYB3Ax1v6SoFc5q9KPTkkixvy98C89deCcdpxk3hcSC0Y5lkYGlvUJ0hIP1BQEEarGHdalh/kg69quGdbShv/nWX2PD+i1YvXgFfvHL68kszcW4MWPx2ONP0P8jl7k8sHHDRlwy5yIU0PTuUTKXwaEh3LzryKwuZWybu/DlJ19g5cpVGDN6FDZt2oSSvELMPO00PP7IYwbtLi4uDts2bcEZM0/F1k0bMffNucb0aTWZp/S9qejXvx8effhxJKekYPSo4fQNKzOmcSV04k5LT8OZRWdg4ICBeIEmkCKs/Al/vGLJclx/3bUoKSnDs/Q1iY2LYSwqJ76n5utC+noUk5kqKytFRloGUob0NYSbGaCmD40QCVr+1ZK50a8AQuMGcIzNFDKzTtY63Pb5R4gOc1xIv6RVrlyUeEUYtD8CFGtEDIGgvNYsaHpI04EIu0AGnA31JOPPf3JfKMljAEYnpbsMBFvjV02wiirWou0SFGenvXQstELtld3W+eRR/dCrVy/jH9TW9ePlnObqu++/h2vffvCQVTboafTpk0md7XtkHN7dtE9isn1pJurtyznDfCL+HfT5stH0DvmQ4yCDEShw/RE64sk9B+PV1d9g2f7N6E2Tui+3rUTX6DjGeQukSbEf4hmC4Y1ln+PWaRchKtAynbQZImultFZLo93le13D98ef/dc3LgnL9m5Et6g45KEIz9PE7rIx0826Z623zMv9oo6AB6VV5diXnomMghy+n5Y/jN5XMQctEt8/E9OIzxEMvEzYlCxTSTJUPC8Cn7kM/9Ti3vZ+iCHmu+yilp7qKx4xcb86kiThjIQ8WtNNcqu3YTgaTzeVKd6UydNF/yKizmmDEMgMP4i06s8guwFqAfdeaujIGEUTi7OKvrXl9KmsqSS6ZRE1nmG18CPSjoSAFZynWo8ONymnCTHA5xEPz9AMWplU1woyOjVcHzsqTcxUNP2OaHfAu4Qaqh3S7Q42pSaAgbFLOBbtCZsOt7Kd+Y77HuhkkI77IfxpNkAMktCi5Ai9ndJ5OUX/+te/RmJiYlOFX3nlFeMwLUQoMUjtpeXLl5ugjvb1QNr77xrYYBxeFb9mZfmuRsZB8SAaMD8vlZtQJEoriE5jNivCE/N8iINusjQxqiMyUqnM1xqCsLeiCInB6bRL5yZRQb9gahrkjySCtYaLp0UwNmCXM9s42ougle2yxR6JgKWNNRddEaB1ldZCK+ZGG7GWXifNN8gdGIamltJ/mTjJPEEb03efLcbbf3oaQZGhuGHug3AFa2uxGB7b+dRus54nu3nFXpJdgpGh8jl0x+az1G6dYa0Vp4aFqP7aeCRZFSJQXk0JfYuIpkQCXOdn3/BLfPLyfzDvxbcx6+qLkNy3p3mUnx+le3FBCMl0YCf9RvYVZCMwVnF5WC82T/eq/hEEaUgJS0RiWBTWpm9jvhzsyT9ADQ6BGboFojizAYUHCMWdVYVUmjcWlxYghAEz67jpBBBwgrhFIvlRkJmKa371K8aT+Rfmf7MAd9z5B2raaNJHYu/tt99FOP2OMmnWKODtbTt3ohdBHkJIAGVn5lA7tBZLly5FPv22FLDzpJMmmMjzi4lQqDgce/bsw6133kZfpgbCOqdh/ffrkZWdg2rGpxowaAi2b9uCb76eb2CFQ+h7MnnGZPjQybikhEzywH6Yfe75+HbJIgJ57DFMUS0Jid/ffRcqSyrwLlEIvyRCmTRM3QhZ/msiD+7cuQdvv/wqzQYPYNqpM1BRWYEpZ5+CXKLr5RCkQVGdJO+0k0ZSY1rLftWMkwOzSB5JLgUDbhLHUnNF0Z/KONclvmUoVmysy0cBfdQiPRycYy7kellxbGxG2X6G/a3zdumSlleUulBBa9DQGNYhsA551BxZBJpmYHPyIupiJAP+5ncjqZNbTHMka47bOerI6KcNTLJ/tvj2pI9C8oZ9Tf5HqUNSUElUxtHvrzDodpIou+irsHXSAGw8ZViLezv68cunf4d/X3Q3fnHVFbjisl8YBqCJwOvoxp/INcF+7923F3fcfgduevdvCI2NMFoMEcsdJQV3VTLMj953ThwJcMQ8uSe9O5Lwe8hH5GeWxCD5UDNWTJ+gETSj219ZhA+/X0yBzZfoGhmLOWNPFcwjTeNKMDK5L3IIud07MZnrIldjTt2kqFhE0Pw52D+AgDNxRqtcx/c6lJqfOGqjPdjH546cjIpVX+Bpms4Joe/k3kMxsmt/otalIp5WAX4UYp09YiKeXzoPD336Cu+LQmJEFM3uyJwyzl031iOI5VuQAy0HwDBjWkiZNNoyrxOzpDHV+HscIYMjbspbflGExjaJgoyOZ5GVzf40qHoMwCrTN9WhwaixGq+2fNXtW8y31gouUyapDB/+KWitni1QBSfXquLqCsY4oo8RmQ0vrqt+foxZFU3RWBRNQbl3SbskQd+R1FcP1F4rLZB79cT4BLLtErpp320r6TlRNL8OIC6o1lHunPxn7Zt2Y8Rr1vh7ozKOgeUL6evamU7oHmAA5Ma39YTuhs7GH8seEECDHKSHDh2KOXPmoLCwkATlu8Ys5vXXXzc2+5s3bzYO0y+++KKR5p9xxhm46aabcOqp3OBapV+RgFacEjslJSdj1GOPIzool6hrCu5Jh3tqbWpq/FBcGYZSZwg1BwIzIAFBxCU/rypEhBRi4/v/wdZPVmD9gmXoOWwEixOjogVXRD83KK6Oh1qsdV0bgp3MIs0PfQv2WEuzvlWWp1bbDlJBRrYhjELjGKzWYYEoWCYcFnNj32ocsEkEjTp7CqZcNqspr67zSfw021XTL6sN1qeuCCJVG72CfCrau5gnpSXzvsa9v7gFI6aMx98+eM40QjRaNTe4r9Yvw8sLPiLREYdbJ12Ms+hf9Nx3nyCejs4XDZmKb9M24F/L3jcMT1RgMHbTIXobCYj+XXrgD7N/xe3KG5+/8AHmPfuKQevLycnBaTNPM/2jB9lsQh2pFtm7axmqrKw05omh4WGMqE6zGUFOk4BQkt+IiGAhiCmJUJIGUtJxBeKUPb8Y8mqay7lI8PjSL6OavghipsWwOukDJom7gDxcJBx1zAumfCGMqQy/Rsf9avrJOakNysrKNuZ6Y0eORrfkZMbM2oib7roNpfRt+/brBUilz1h0FOOp0ETx7IvPR0Z6Bj555wP0IdhHQpeu+Oijebjg15dji0cuGfJKY2riL5Q+jRmfLVyrSko8xbBI2hpkNHymeQd9aC47yegKTtnMOeaQ7FXST5Wn0T4UaeRLsxch9PlTelpSQI1RTh1CkhhU01FhAiRbpTQ/uueqnRg1b5UxjbHpJpkC2cAO0s6WRoXgs9+cQehuoVNpPlrJn4FiT/3XZwjgtwfHWHl1X1lEMELyCUnf/Bhz397hPbD84oluZzs+VGDT5XO/QOa6XXQW55P1Iv+IqYzmmlnb0xAQGoSuA3qYNUD9ZbdDT5fwQESXaVAHdVn95RJMueocDDtnEuJ6dRONy/lLRodz0maSjNkX56nlp8IMytSY5GNkwBnYZtVAfiyGKXLLY+f96vG3cErXkbj++uvtU21+K+CtIMvdtU1paWmcwx+ZOFHjxo1rcd+iRYuwdetWaN3u1q1b0zWZPsqnVO+ikPzc/b0UcPfLL7+ETOVmzJhhzKo/++yzFsIvFSQhmq63lbp3745Vm1ZjacF2Etz+GBSeDG9qM7RmhZBRAP0uU2nOKoI9jkA6An7xJLHuUZ5Pk64wWifS58gwEdwvuH7Ucz0oqS2nCZ2EXrQ2oMef0C4jSUjXU9MvLS8lF0S7rCRipDApqfGV4Ix97kONnotom370bZIgSiZ8Xlz7TVwivjCbytORVVPINbKRCeDUqKM5oIl7xqcZFFJeE4OmNV7ABh5GONdWy4/NOcM481lNE9etWK3BChwsJqNFaufV8mJ9BVoRRFRFtT2MPj1+XMNk4VBBX9LiQieKsj0YuJ1md3EUvIW6TMDXCsaIqmQft1Nsi0e3/qF3TOMgbXjzG9GcSwJTJ9fU1kk7sfygYn1CzTtjXzf7I99a+XnWU9Dk4hql8BgBnDe++0sxse9ozhd7t7Lv6vw+UXqgU4N0ooz0/8d2ymlZqHQREXSmp524kiLUawOeP3++2fxkWido3cNxZL788ssxbdq0phYEUWr/NRmhKjJEMaG51Ji4iD4UQd+YIC7uUrtTu+RdR5V/OcICiij9r8SaNz/D3N8+ahgtx/85EB8f31TeT/1ARJKYzNvuuB13vfAu/rbkdbNBq97aMLTbuW8W1sZjfeqKLxkjwX5rk6iifX4AtQ5KE88iJO6EkVi7cDmWf7YQE2ZORglNIfJpqlhK+HFDnHFzCCHaUxDNJ26aONtIOxXtfFLSYIxO6GuCL2YU5+HWj55gnaxaiJj/au77ePSOe3CA2pQE+g8dj0maJDnulxWX4LbbbqfJXBnK8otQU+pEZvp+pBDiXQTl9j274HIykCHz5+XnYcKk8ewntriRMBIzpyRNj4wy5cysiPBVJERsBkesjm5xH0fdYyeRWCbQpO4lAaJ80jVZOkc7V8ffNSTiikkM+pKw8aOUtIyrf3kp6xGluEgtn5y4LQNj319u/A1al1oZH416MkSFg3ph56SBJFZk7knigu2VTFimKSe9tQSBxfRnatQ4SZuk1Jo50jk9ufv3e/D96SPgDGFUz8NIvgxuOvnqsw8j57HJIuLxCQKRbF/8PYZfOgMzrp9tiGVpAEVYSxtq/EHM+9jxMy/FnWZuCKJbzI60zfIvks+HBAtiksQgSbNgGKF66hOJJmbPI4uRou9ZI4HvokbUx0E9toQsqg77vw1eqd1KCZZc6H6KC2UzSI8//riJ5XT11Vfjd7/7HU6jyeof/vAHU8akSZNMPvkITp8+3cSJkjBsz5491OKeZODOJZzQ+r5x40azxosxuu6668w5of/J7/TDDz8kwuc6yNrATsp3JmPDtccgaRzWF6Uip6EM/tRArCRIj7cYf65pAVz76T5C01OCMahPK/LJnMuUl9pVmjg7nRQusG8sBoC+ShTMZPOd3OpdiboqmoMRACaEjjHSKmQz3pKTa6XM5SrpV1lF8Bl/aq686WtT6SLDxTEKojmZNPp1VbrDGkfFqvMnOIH0GGW11PWyHhoSJVkbWLDs/MGTGvtamirrnBAHJQyykd80J+z7zM3/Hz40v6Sl1FyrJ6BEE6OkirTiZgTpLY1RIBk6MY3ah4ooBApnrYWiWFXmRBVNtf2oSQvtwXffwZAK7MMKMoMuzfUf0J7m/a1lD+mXzMHl26neaxRX8LuBwikHIr0JytCqV8UAs+dp0cD5Qg1+HQWlsjLxIuPMCOIHtfsHVLvz1uOwBzoZpONw0H7qVdZCK78P9yTJn5ghmZfMmzcP+fQn+frrr82f8iny/Ntvv22Q7G688Ub3W00AR/cT2nS+WUezK5cDWYVdDENUR2meNEHeDKga6FuB8IBC+PtVcLFrwNbF6/Hhgy8ZgsLWSLiXdzwci8n48vMv0Jt+XZ8/8w7OuGHOYVe7mVUieU7JnRX93dIi3fjQ73HdyRfgmXseRt/pIwgrXWGksYpczq5DubMMH25eZPxruoTHYF3GduwtzkGv6ESM7tYXaYW5eH/jt8gozCJpp6Ch1BJQEzTv33ORnp5+3DJH6txQAnZoXorRv/+BBxFF85xH/+8RakBD4SBs+qkMMFxIhmn5mtV4+IE/m/FISU5Gf5r7bd+23ZiPuhOq2qgVe6mazJFt927RHtQmkWjwoc+WHzfn9ogH3a9/R59o80+TzxISMmE0E/XxbSDTx5oo8q57RfmAQd9saJc4cBHSO2vaWJT1SibogyDc6ehMBknEournou9V7J6sVqTIoWstc7ztEwccOuN/IYfWtF8+cQcenHwNPn7oJfSbNAxdqEmS8kq6vJak2mFUkOVJoGDM41iGtKNCqBNjJCLO8mNpHGu9iK2SCHQfMqn1LKdGc6qS7ysZJaNJkjaK16Up4VLZbhKDJY29mAlbkGVnfuKJJ/DWW29h5MiRuOGGG8x6LmZJAg8B6+zdu9dkTUlJwa233oqFCxcahkp577nnHnOtlHHexAzJzFrM1fPPP28EXbIUkEZL192hxxVXasGCBSaOlF2P1t/S0O2rL4SLQv1yMiolNA0VYlr3gBg4CF5Ry/5gr1IL4IAfGZIahiGoo6lXHQneOjJJ6lf1ObHmsIP3pvpQi0tNvw/7Ps43lGbSLiLbBaHCpwYbK1KNZtWAO7DUcppf1zdQcMR5rtewqrrEVK+J6Obp7HWpDCcQDUdUsGLK8i63xDG2xoNnxQDzmYIctxU6Pjz2IcPhlLmbHuCedC/bpQLZxIOSe+42LrfIb/IaBty6S3PFFNp4o9pjM0rSbsn0zr0h0rgHEIghgAyjbtGfTOZqyYh6sf/qiRrawDno0UBD6nAaBxM4SeAPFRQIafx+aLKq2VhZt8LUGgeZHAWWVV+5yPwK8VDtCaLvpTToba2f9jnbJ1RvYB2FFZ3EsVvnnqCHnXPgBB34H7PZqampUMyRBx98EF0pZVcSY6S4IDKfSGJMIEWdd09r1qwxxHRycrL76XaPAx3lRmMkaamkgj4MVBnsV0rGqIiBXi1fDZkSCbkrbelm/P3hR5rMtdot9Di48Oknn2D2L+YcEYNkN0syNUn5K0lQ+UtKxn+9BvXD6b+cjU/pj/Tmky9i+g2MDUUCIMSXcV24B5XSlOnTrcvx2bYV3HxoUsJdaESXvvhq+yr8rbqcmyIlb9z2JPnUtqRtfO3W9Yik6Zk99vbzj8dvBRWdTcn6rsx9uPh/LsW+7XvMFp9AM6FsOnv5Mr7RTXfehN1bd8MvmMFheyfRsbsScd274lxCmTfQ1KiumgRGY9JmbJEl9hnrW+eqZQbJDV1aodZ5RMRKon2wb1rLcg71S+NTyuC4eo6Dzsgl9JurI4qdlxyu3R7alqZHZdMmG8F70hG07wC1SN7YefX5yOoVx7qTQWK9fWkq6CNi/VAVaeO6zPB+yik0NhKXPvpbPHvlfXjx+odw11dPU/Jvach/UL3ZWSLabV8im1FqKrODzvQkk+THeFMyHa1lnK2acssEU9Df0gb5iPpuJ4kpk/nyRRddRF+64KZcEl5lZmZiyJAh5pyudenSxcR2klnd6NGjm/LK90/nlB599FHD6NkXJSCR+Z0YIZnXybTu3//+N9FCB+KZZ56xs5lvaZxkYSDNUmRkZItr7j+kWammxYDQ4LTahFL2P8g3Bmv37sI7GxfRF8lpmMMAmnpN7jccp/cZTUCAUNSX5HBOllII4YEMWhdsp8NpoY9M6HwY504x0PwJ0ODAcys/R0p4LEYOGEz/JB/zvmkhFACKzEsN0EJjhSztYXPtNEw+9LOR5v2gF4D11utla9mVQZoak3hNwbEVo8mbz6jmtdZDrntlnkfVlbWPsc52HjEFBryHjF4tmd52NZl8jsyPm15z/lZSOXq+iXmkX40F6wnenFsCYamjRkm+rg4JRPjnx/zKZq9n5PWoraOvbQUDFDO/ixo58XP+YVq3iFxH7VHzKqinHl1SncRIWitkY0XditIZjpI5IyY5hIyRTMuteja13O2Olocmh8aDPqz1YbS0OPgRLW/o/PWz7oFOBulnPbz/ncaJyVHEeW2Gt99+O00bnHTCf5qQzOFGgiiic/DgwS0q98477xhY57Z8kFpk5A/uIUiMzEBuSRzKqwPJGNGUzr+QtuBijLhoU5IYQIJddsRmG6mqOyxTvtbP+Sn+FvFQzZhBR54swIYySvkYKcpI07Sx+vPv3N9fgfnvfYbP/vEGxl44A/ExcXRw7oftSbsZ3yPP5JXoU5uHfKSK6QAdzE3SgzbdFESaAZH3lR/N8Ib17idxIrUszQTXkdf1p3WHzLnWlhKooT4JUYPiSCjVYxvRErcw2KHgbPuGeyB2RKLxPVhdxbgrtIOP9A6CI8yXJm0FqGSfH8o/SL0rP4ZKangCyGRYZit2P1ima2KQjkWStLeoroyCBPoLcADry0kIEXK3kV4yjxCYgqPqYFt+XZRCw0NO5Xyv+v77beT+8Qp4EDhD0mHV3yM8kOALJNpownQkKXVo9yPJ/l/JO3TmBEy4dCaWvfE53rvvWVz80K+PfT1soozflvKomRg+6GGNgyZtkrcIbDJsLgo1ZIYnnxbvDhgkaY3kI9o6RUVFGb8j+Ydee+21kL/RTgKkSPB19tlnG23Qvn37DPOjPLkESZFvoPyNDHPAAmUNIPO6N954w2icxKydd955UKBwgfOI4ZIZtp2UPyQkxJjy2efa+tZ7YvWGWXiQQsj6UBLC6dRkVzHw8ZwR05EcHY9dBQfw8vJPaYbtxMXDpiMsujtqqitRxbAB4TQJTawqQCLXshhHCFksWR94MIaPENhkCkdAH6LZjQ3qY94J+XBur+B+Q6AbHdvDYxbEph/W+xPXtyuFBPSF5Lsq38emyyzfmwifbSe2idcFYCOWwwy6fdx4gxUImMFL6Rfl4runssS46A5vMkv+ZBqq6Nsjs10xUSzu4MSTBgaej5Dppl05TSGZ09VT5SXfTM0d+5oK0bO9CPDjR4FjkEzw+E+CFvWF1g8JR4LZX45ab65hfP/JkNSWUfwWUgWnL/2OVKdWScy5xlHtdn9Wq2wH/RSDKjO6Q92k2SEGVt2guh5VipKQsK2OPKrSOm86Dnugk0E6DgfteKiyzC7uv/9+nHvuuaa6MrF78sknjdnRsai/ABBiw7IMZLQvtUdKBhyBkkWLOWpEXuN5LcZmQzC5ju8PtUXahCNLlmanjMSrjBy05IvYdlKqV6J9MswHp992Kd6/91l8RPOhKx+9HQnhEfjbWdfAl+AFQfKBcDPz0cZfTWjq5fX5yCOSmhyTtZ8T+JWbawh2rdnHzb5ROnpkFf1J5tYGK+ffDCLRZVTnm71ZfRhJ1MFalw/20Qchg4ASkmlb+z3h4qsLeWyNkwiKw0ki/uQgLl+FAAagtaLZcOw43iK4ZB5kbfmHU1pHeSxtVIUHjf1IbHiUk+CJbFl2Zu9EhGUXd0i7qA9kMBO3miiG00byqLF2JNx2nDEO/T5a2gTooNoI8a6WRLvNeOl+eyZvmTyQ8LqWb5zy/pTT7Puvw64VG7H4pXkYOG00Bk5v1qgci3qLyRAqWZ27jZbMupp66+CnmDWBk09gLz5kfDSX6vhbcMtHk+SXdOedd5o1XP6j8jWKjY01vpv33nsvJk+ebIhbWQLIT88djEHaId3/zTffGKGYtFHyodQ5MUgCX5EPaEZGRpOW+TlC5bc2rW6r3oagZtv0TjBUNLpSmODHvlHvRASFYABBYvpEd8Fwmv+mE4Fzb34WCqtKja/RRxuXEGkzEz1iuuC0AaORHJ6Ar7cQ6r8kD/uLczGz7xgDmKJJH8o4OTv2pxrwmcl9hhto6PyaMj6luT+1DnKgxI9YifcVplKgxBh6/gwA7nGIMWu8i19cP1lUFZmLpoLaGGsBebDJTHxrGpkjHdfyZh8JV2qdNGWTmSXXYfoztUXbq/+kqfSg9rtBfkaaH43rlOaQzC7lN+jNmE3uBSgotkzXGM2C6xPDA9AkWFDnMr8TcxTAAELVZaw/y6qpUlwimm1GEByI320labK8FftN649bBh1LAyT/odZ36re0QS3vcLvZ7VB5hHQn88jW5bhla/dQGirtkUdzb7uFdl447nqgk0E67obs+KiwzCnmzp1rfI0UBFb+HB2lTz/9tKPLbV7TIubrxbgHRtomAp3QnNSISHPUubC5dxnjT3DzlSO9TWBbm1Lz1jTl6nOw5JVPDDLYpKtmIYCmMyO9EwmHK6flg1M5GSTfmlL4y+6/1kEfpWDGmwqgFNMX+eWVTWNy8J3NZxYvXmzQrsaMGdN0UpJoW5osbaLtNK4MHaFq6Xpb5bV3jwgB+TsITVHPkalQR0n9ZpnUNPeZiAGHjwxiRKbos/naQXk7KrzFNRIYJHYa6F/RQIQoTzqFVzU4jZTWHrsW2Y/ih+TOYvqM438ASWmiNUgy7cVguHpxUgiY0G+JZTZ1qOIFvhBYWEZaim+jqDyTPJA+cSgl3F7o/ely+FKjIV+ZdMKBrzpvHJLX78XA+RvhV1mNqiA/rD9tOFKJYtcykZATMddYV3ONddM7r6eIAfhvJQd9sK58+i48fObNeO2WR/DHhc8gODr8mFZHRKwBcRABK/8Z/gmBTP4fkuh3mDiMmiuClN63cSfQZXiH2du6OGrUKANoIx88vYPS+PfoYY2R/Iz0J6GTNElCrbPTn//8ZwipVFonG91O2iIl+TMpaT/o3bu3AWiQGe7u3bvNeyhTv8NJAlIIo4Y2hT4uwcLIb5wKMoOroRmawFBkElZYXsrYbFyTiGz5ArVJYdRQzeg3Cu+uWUj/oSpcM+5sfLdnM5anbSVa2VBEh4QZglo+Rt/t34J3VhFQqP8oBt71ZEDvcpLsLY3ExKQ1UMgk5DkxtXr781JzEZpIcKJgf8tkra1pKqZB9xomh3eRIZFQxNNImVROWzdZPSPGp2WSvxqJeTKd0iyJyaknk6RO8ZQpmirlnhqLNn5UbJcH55eQ/FSGaQDzypSOd3N5Y014v0Bl/FjXcmO+Z+ljVKzKdpBhiaJQzIPjIJCRBkKG1xYxoEEwY0r5e1Hn5EHfI4UyEKC3lQRkwcz8o1aK+7V85RTbSD6MxkSX95QRLKiYPmLuPkt6pi/bdKikfP4EkFBIDdboUNkPuq53p5RoobkEKzqa+w8qsPPEcdsDh1hpj9t2dVb8J9IDMtc4FHP0Q6pqEaYWQSC/mh/CHMkMUASBexKB/c9//hMrVqxwP22ORQT861//MmAErS9KYioHZTvJTv/ll18+6E/SVCXB47722msGEcqGsrbv/aHfcvmVGUTTDthGgV60NZ99//Vmg333j/9q3BgEEa7Nu+Wfixt6dlUDUksjkJ6bhLS8JOQUxxDQIZDiRZo2cnOhMUgbT2k+JZ+zs846C2vXrm06qXhZCgAq0xwBeAg5S74JSkLVErKV+kaoWn/5y1+a7tNBW+V1dM8111yDv/71r0ayLam2Ym0dSRIzbv0TwXJsl1Ft8NL0ldGpvIyACtbYHUnt2s4r0iuWhjLjPWPRxzMUEfSxcASQCJIfWQXbQFMdMTxjPlhpAnGqHodMJA6jE3uityOecL9+JHjoHE/JrTdBU/YO649377wUb91xAd6471Isvexk1Pr7Yte4vvjgjxdi7l8uwwd/mI197swR6RkTmNgRjfFBvXBycF9+90Yfv0REE4UqhGadQXyGZWbTXDuRQSJm3Ama1ufs661JJnOec1wACYI5NoQev8mhND+g1VHS0N44845fENWQ7+2tf2911VTm4HNHcEZMkAjQehKl1fQtEjJYHUEYVEc28rDSohfnYeMXRzav7YKFRqf1TcyRNEGC7U5JSTEMUc+ePY1WXuf+8Y9/GPQ73af1TcKNZcuWNTFHOq/1XxqoV199VT8N2t369ethC0a0BgwbNsyYZZsMHXxI8NCdaHPjQntiQNQAms71gadfCE3DfLGXGqMnl3+A//3qJdz43j+wm9qiid2HoCt9im6efB4uHHIy47ZFIyk6getVASrIJAnC+bRBY3HthHPQKyaJDKgPtmTuxr8WvodxPQZiUv/h2O3MQSY1wloH3d8Jo53gWNRzDRcinYYlcWgyQrpEGi2NmKDWSeMn4YwYGb2PKq+ODE2dk+c6mG+ty3H/LYajitojE2OJF/RYzZs6aaPJJLto4mb+yDzW0OxVgYbtOSTGzov+NtI8ymxP7ffiO21fN/XjWu4k8yUGVMnuAxMqgSZ3mpKyTZRWqrqS/kqEXXeEMy8FSBqvYJYnc277PgMwQv14lE8IuvjSV9UnCnHeYYj0CkEwTSb9iEIYzeNYR5hl3s3K6J8AbOSh2VwD1aZlUlUE003vYx4d3P8tcx/8S2MiEJ08V6lZg4+mjINL7TxzvPbAodnx47VlnfU+oXpAC5ucao98SbS66VhB3ao0MTuzZ882RISQn5SE/PTtt9+aY33s2LHDEAqXXHJJh/C4TTcc9YGihdNBlpubvUG1V9SgGWPQ7+QR2LZoLdZ8shinnXtJm1nVx9kVHoTCDedmLOkpNXlED3T4EB3NqwRRDRnIbDTbaKuAxx57DI888oghuNyvi8C69NJLDeOi8zLPFJMpaXV7qFoy+2mvvPbuEViIGDAxvyIQJM1+6KGHWkjC3evlfiySRtJOST6l4VASgVBJiafM4CySx/2Ooz8WUWCRXUdfhn2nxkzBeXt6hKCXF4P8IhhOLxey6SewsaiS8cM4fiQMgrJL6Dt0sM+AylEZ7nNIv4VWtaC4EmNqfCgpDkZOaTk7RIQSkJ8n52yaujgi4SvncPLPDX6UCdM5XpJgQzTJJIfSZKErSlwtB+wejhh0qQnG+uXrsWf7LnTvkYyBo4chODQa+6uL+FRfai7JQNLssdrMbWryWA+SeYYoEyKgwCxkEiSDHBGyxsmeLdBvEW76bXwoSPwJ3UoxbSQ5l4mjhAIyjxShaQx0yDi2lU75zUXYunANNn/zHRbR3O7kK88y2SwmRmXwvnbubau8Fud4r57vIkHbQOLUwVgyAl5QDC8PSvw5cQ0DZUyp+AzL9Ky5hNUfLMQ7dz8FfwKHHE3SeiiYbvmSym/ljTfeMN8pKSm48sorDUMjX1IFABdKndJ9991n/JTcQRYUokGMkQRJF154oXmfBdgj3yW9u0rbtm0zwA3mxyE+NOc8yYA7SERLv+hFSG17dIKoWeoZEo+Y4HCMTxyAEcm9ER8SRfS5Kry/aQk27t+LcAaE3Z27H1GBiofDxH4Ws11KLa0fgRv0zn23bxtL9qRGKZxEMj02hYLHMTBxi3iL+sOgDKoGlCtI9iSzM42BmAYb9U7FuyeZR4txMTfxRsMgcfEQ0I3m5BElZtcdaoOLcOd2bCW7DM2dBr5zrJl9ynx7cK2m2UXLcypF/6mhbCvpXVEV20r1LK+S60YYx0OvVk0Z10YKXXwCJJZTonkwhQ1OIgDKYlQ+cREUdIQxhpUPx1F9oGTppcyh1TAehhAfUyEJ8mipIIFRAH3N7PyNOQ/6EghHANcBe2021daHe9PstjSeE/CM6qo6kNUliI3TaLwOKrzzxAnXA50M0gk35D+/Bmu9k7O8tpwjTcca6lZxPaQZEeGg4KN2OuWUU6A/JYFWDB8+HLK7l6P0U089ZZiAtuBx7fuP9lsbvoLf2cneG/Rb+4MIeuuc9Sn/ij9PvRav3/c0bp95PhzcyNzv0X3aR4cQaKqc8UM2ckP0dJQhKKCE8T+cDNpYRxS3lpuy7nFPyckMukot0W233eZ+GqtXrzb9YJ+U2ZuIp45QtURktVVeR/eIQBs/frxhjvSsCRMmNBF59rPb+zYMEol4CxnJyiViWoFeZeLSYqNvr5D/wnn5iUVROptIDYwhm0gUFFPSu7/Umz5Ea9Fzz3b4BDEOSN9kEiitR9yqsGaRecMkYWZbG+h7UjrnUoSWlxvNbRcyjtFhDLDpxX5gEdnRZTRVKUePgFgSoWRKajwIy1yLTErvu8WFMap9IIlDIm/51GNXVTayaosQQYjlGJpqfv7BJ9i8aRPGThiHlStXY19aOk6fPQuDo7oZ7ZYn4RQpM0dOfakBhojzCaPmkgwSn1vpVUumy0VfRMvMRoFqjQkUJ66LpoQyGxIx6CR4hpOmon4kqPzIIIlIzaIkfj2D25a6yhHsS9NBOvTrPWkrqcwrnvydeV/eJ2BD7wlDEdezKyktvnXqADEuR74kmUfpmeKtDNEtvyLGyVFF1Bb9s7VbDYbQbvkQMW2v/OZv1A76Yczs6W1V/aBzrTXnkydPhrQ8EvbIx8g9CaFUcZPENLj7Hsncrr0krdP3339v3mXB5qvv7HTvvffah4f8likYdZTNplaaqySKxSCIGTp76CT0ju1mynFxromg3pCxC2vTduKWyRdicGIPItV9jG2ZqZzmnBe8lyUwkUjmQS21LGcOnYggvwB8un454hgYu0dkPJxlaQzqTDNH5tc9YsZriKZHjx0+3/LrFMrd/nV7EZIQiYikKGN61/Qu8Vm25sabDJbF0CosBfctapDqLbx4U5NDfZj4WI2MFh9p4OHt52h9spPVLvuXvg8+43716I5pQkdfxmAyL9IcySQ4Ipq+hny/5H9URVPHYqKdqn6B1DCHM5hsCBFhBG/eVBsyYPYWpXNN53msflYA2iqZHHMBsnay5hx6l5sSTyu/UwIEjo36xptmhOpj+STpd0lDpXlWMFEOFS9JjJdAa4gBaQQmml8ypZQgpbVJZdNzOg9OmB7oZJBOmKH++TZUa6SkdtocDPFwBE2VVO9YQt1q05VNvhyTH3744TZr8qc//Qljx441iFDK0B48bps382Tz9tBeDvfzigHhR4dT+iCxreoj2Z8b4oubu3pNm4TMuETcx/dJwiRKwr99/kP8L0E1/n77HSIBWjxTzw/k5nJqiCfGBrqQyft3c5Mp4gUXy64lIpq9YbvXxD4+55xzzKH6yj1JYySEq5kzZxpTuvfff9/4PXSEqqWglW2V19E92dnZLaCERbAJiUv1sQgX91o1H6vvBJssJCX3muu8ZKEKnCjEup9aUl1l6hLK+smfQESGTLicpRXo8c8nEVVOrRHPNVA505CRTTAFkgeSmLdqiH7PHzcBicFBWEXfraqISIwjVVlcXIQqQjkvXbYU+7OzkJudh4T4WJw35wI4SGAuWbQYKxYtQ0hYCKZOn4Ypg4dgOzWoL897jcE6azB63BgMmkw/NDIoAqYoOJCH7dt34BfXXIUBhJoesGUrdm/bQcz5Gkqgqxls+hts2bgZST26m/L6xHTDd8tWYOkSBrZlHU86+SSMGTcWm9Zt4LklRFd0YBwZ4irG5/p6/gIDYhAdE4kxo8cgpWcPLKYp2ZqV3yE8MgJjpp6C5LgUrGGf1NdlI9y7xLwrraYq66rO8UBE1xjM+dtNePG6h/DS9X/Bw0/cjfCSClSEBiGnRzwptJbSet112IkvqQAXpDkyEOAcyGbwBs5VjqEVw6a5xH1rt+HZq+838/jaV+7DZw+/hvml803coeZch3/Umjmy72wdN8k+f6hvvZc/JImxCqxhu/3YGW7Ui9Z96g35SaKcZrg2mI2WIn8iblZTg7Fw3zpsLqDP1MaliKRZnqGY9XJwcCsZGLvK5WcAD6ICQnHOsEn0qaTm6fuFuGrSLHQPisOuyhzDeCu/g/UQ6pzGxQAA8f3SmhocHwE/gjQYzrjVpBGBbszXdMCk9dYaw8bpZM4e+sOGgW9oRIfT+iOzNbXHzBMWIQbdQxyF2teYjK8u693RGmfnPdxvtUT+RZWM4VZbSdaVAagjQ4KRTwallP1XzD/WCjG+IWSMqBGiGZ+DggsBWFAvRQj4GhTnkTlh6IkGvv8NRMKrr+M709R3li+dwEakybLeOw091yhqjdV2O6s/gyUHRXFSsFIFhUTQY3gFT5p8+wUSYZVaLa8gCu88SlBHgUwxLQBiKFRRX1jgN9zlWL66S8KvEK8Axoyr4i9rrA63Pzrz/bx6wG2J+Xk1rLM1J04PaFO0lORuu4Fb81tImdzO6/BYQ91KM6QkBqk1A6DzRUVFRmO0idJx92RLVN3hcd2vH+2xNhARx0Ee1AQ1C20bl30t/uozbiLUgJggpmSUzrjtcnz37ny89vhLmDXnHExM6EkNgPLa+a27dGcozRrDGD89nFLdBa4sSg6JpkRUvHpt2EeYLrvsMiNlljN4UFAQTj/9dJRTO6Ekk5+2ULU6ekR798g/zF27p2M9r2PCgaY43JTlY6Nt+aCZxv7xIWCFHJtlXCJt0uEmjZEgmn+spJEQ6ZjFDb/AgxDknkHwIsESueAz+NOR3d4E7BGzCD7LLE21kmRcVMhnDJDrn5CINQeysKGwBFedez4qaVK3nIxJz1496HS/HkGh4Th5ylQs/nYhli9cguTkFCz40U3+ugAAQABJREFUYj5mnnUmg9KW4PN5n5l++uKLr5BE5iQ6Jgrzv/4GgTHhiBuYSMSxMjirKo2WKCY2GpVV5YjrEo+UlGR400bnk48+RlZ2DqadcRq+p+Zr1ZIViI2JJnO2HH0HDeDYAMuWLDMxbdJS05HBus468wyUFJVg6YrlSOreA8FBgVi1fAUSYxKRk5mDDZu2YcTkqUjduZuM3EKMPNUPSYSqz8mn8RChzL1C+A45OErsBgEnSNUgAtxD0UqpeRo2YwrGnbUCK+Z9i42/fRx3jhhCpQKD8oYFYP7VM1Ae3TFADat8UNLaIfM5X3++tPa7xOeLwKZO2JjdWX5KzS915vZUPHXpH1FLUIyrnrkbfcYPQfqMXRgakHxQ+cfjCb2nIoYLS6nVqvNHeCh9VMhAKvWJSzKxvYKp+ZFfp5WXJlM8HsL166oJs/Dx+iVIzcvCxN70dyLT6eDfoG49jP+NmAe9s0O69UJMUDgZUx/MGXsqPlz3LQoryhFBvyfF1KshU2IEKXxn/ej3JI2Di9Dh9rsT3aNlgHT3fjYAC2JQGk+qLZ78kNZF7N3hJ97I/2a94qRUcGBPEvWGSVLpZDSMmlSZ7MTnqK4yE9S8UTZdtetiZzu6b4IqUPNaXxOISCJj+9IXKaTen9pjvsf06InwCUAI/xRnqqt/JI17/QmiIWM2BhUns7LDKx+VhANXmAOvAGp0aQKo9liVZJ3JTDG6EiHMFWC7nusVkWpZlkAolIxYlI3pS/NKH9bDl2NXElmL9MpiQrvXoaKMAbELyYxl0FRSfRXmgn+cB+IDwxDNtVD+YwrQW0JN2N7KXBNMm92EYMZQOjb9Y6rZ+XEc9oC9Nx6HVe+scmcPWD0gAlO+A0KtcTd90lUxR4ItPZrUHoEtiNp7770XkydPNptUW1C37T1PQAwCBRDseevUGh639XX331q4j6RVrfNav+2zJADZh3J+l4OsX6Q3zrrzCrz1hyfwl/sfxu1P3oNuXqHoQiYokIyU8tpJJUjuVt3o96ErNUS1q5fJ0hEmSatldigTRDmHP/DAA01+Ch2harX3mPbuUeBK+SDZScxsSkqK/bPNb8UZCZZpCNtu99pBGXmhlAzd6o0bsDsrnTu3cjI/BZ+iSXzoAC3Jbi19BnRe/0XxBZKoG9KzHwb27WWd5+exThqjEmoRd9SVYDSZZXlwBGzawPYc3BpWFRXdkmialIF4mv+U0xl/pYPmMdR6njRiJDVGCzBl2jSMpDBg+Xer6AcitCwPREZHYfTY8ejTpw8yczORl1/IkjzRJakrTjplMqqdlRg7Ziz2bNuJHdu3ITohFvv2kmihr0RGagYiBtN8jneIERFToL5a9c0ieH/wEUazE6UtGUFtUJbDH9ldElFSTN8E+uhk0mQyISkRk06dbPq0oKQY+w9kwpfO5yPHjMY4apQWfPkNQqPIvE2bwlAD/qiorDDjkL0/E/nZucjNykNBXgHRA6tRy6Ci4ZFhDKJLc7x8B2pzKSXndFb8K/lwWMNGoQznuAfNinTiX9364NaE7ejKsr2N7wcQVFSBaS9+gw9vPouIhMzLfDZxyhYeMhkCmKZKLRJ/iplWUF2te6YyzFCQkYMnLr4LlcVluOThmzFk5njUsm+6j+qHe865Db+/83fG1KhFWcfZj6eefgpdBvfAGlc6Z603BtOfzsFOFUM/MXkg/waQMaqmUKWS4ATSk8KElZDT/kwGjJ3Ya6gBPXFyHOspCKqlxGhUvyFG87S9IB0lhPGe0H+YEQZtLkxFMOfZ7PHTTRenSnvEe8QcKRJQBAUMKX6xRiu/u+wAcoh45qKpXdbGNAREUVsSRx8nMlRNqzTraRH9plpNH6ql/HJU5mElPt+sKgRHML5OnAe+DNoqGG7NzBoyEdV8Z83E0NThc+15ItNAMVH6p9mj4LLGL4rZxHgcKsk8lbwKfbA055vnpY5qqUFqCKhEeYUXtXFkfrj2ydcokIyMg4ykg1YMSYHRaMitxOsfvIm0PRkIIGDL6WedjlFD+2NPbR6K6stVK7M2KfC4NE4SzNVwLCW88/QMoE9jLcFguH6xvU4ey/LBxPNjH8RQK/jGM+8iOioCo08/GREhQdT40T8qkqa4VSVklMjEFXLmlAbQPy0F1akFeP3TdyjMzEIU7znn/HPRuxvXJFcevDk3ZGlh+u5QHdN5/WfbA50M0s92aE+shpGU4WJJm3NtANoI+E/Jp7oBPs5DL/5t9VZ7BLbydgR121ZZ9jkBEciZuXVqCx63dR77t1p2MFlrXz36b22woscCySSdedUFWPzKx1j17jdYSdjvnOF9sZX23dH1DuPHQtmtIUzUs5V0/djvUc46sVbcWJy1AUdVv7///e8GJUvxsuT78OabbxpUP7VIqFpCnTv55JNboGp11Nr27pGZj2KuCFlQAA0KaCzEvPaS+lvMt7bL9vudmiNu5PspoV6xdR2JbxITzKy5KP68a1gUfjlqJgNa5uDF5R9yntpLr3qdRACJiiQS/SHc1I3/SnuVOcrzaoO0SJkNFdhLv50+dYzTQiluW0l5vdmWBQwYfNLEkzBu7Dj0oVTYQf+iwtwiQ5T4EGJZ5QkQQUn3qG8M8AGJOKFnGQJftBQ1IbVsn3L60S/GSLpJ4CkArx+J0CmnTENynx7UHFkaAm8yQfUEeigsKsW01d+xH2kqI4KX/7vS9+JaMjdLyyswbMRQdEvogo0bNpIQooEVn6k6GL7UEJJisgi8wACakk43cG6qzrWG0CXLSKarnpoePzqCB1GSPXAQnfoT4pHQqyvSfQlhH0qzHif9qaoI1UD/KTrYEfJZjBofwg8uNSzDhaDUYnQvLcO86VN5oTlJOxBUVI6YtDzkpMQaTZz81UzipJBmzvSROu9IEu+zndB1WynH5ImLfo+S7ALMuutKjJtzKv1BrDUvaVgfzPrt5eg7oB8++/hTM9+P5FE/hbwymbvjjjuM5v2eBc/S2b8BG5wH4CJi2gBXAryc1OJQs+NHJl6an+BQotqR+LeColomdzVEw1xdtJtzPx/1Do4drwdRYOFPwrpSc4SEtN67/UXFhnlyUlvlUck5T7MxMTo0AjMoaslBMejtxzniF24Ic/VPT78Y5JFB2ludh+L6LONrJG2NAD46Glo9r4bvoKwfPAS5bZiXQ/Q4x14+NZw4JqO+/AUyQmJedXZSg+ISEiPnttDtvPme6X2ytI2ar9wPmVft9mW7qPTm+mTFKxJQipD6Gmdoi4poPomp1EvsyecZ5s+9cayINGlCyWugP5Un3ylPAvf41dFElGtdKINSBzFm3F8efZymtmG49JeXYs8+ogU+/Rxu/8Md6JvUBRW14aiigCkkOMRo9YqKyXRWORETHcnA0yxTQZjYR1VlBNNgJeNo4lsmBojmcFXF5XBWlqG8rByBIdRWUZiXQq1VTl4urVwd6BYahS1+GUgLKkRvEDSGQDSP//2fGDpyBC6/8hIsXrAETz3+NP543x8xKqIntd2lNP8rhQc1Yh0OYote6vzxc+sBe5f+ubWrsz0nSA+IZLVITAXa4wZBqZIfF/AIRyhNF0jwc2P0PBLrBbd+a4/AljOytECKLt8a6tbt9oMOZfYh0zoBBLgnMU02PK78Yf7bSf3pS6nfVX++FQ/Ovhkf/OkZ/PbjR2ln7sI+ojWl0oHdXZPCbjejYDMQHpTQugeWPdz2XHvttTjvvPNMvBRJhUUUDRw40NzeHqpWR2W3d480VULRkx+YQB7kQC4kvI4S6WvjSG2IGBHIIg74J3pXm7WSbOiFMiZtjaSzIkb8SbSN7NoPk5OH4JJB0xiQMo9+N9XYnLuXqFq7TT7dK8bC8hFTX/44SVUmWDR215cgui4IISk9UL99qzHzafFEMjQ1Kcnw3puGCGpSIkJ9UFBZinRC4Ju3zRBRjbVkoXIal6ZWHWGTVw10mnfQ/CkhLg5Ll67A9g1bUUaCY8OqtZgwfhy6xiciNDwUg4cOQequPZwvnqjK9UQRGZJ+lOYmJMYh/ZVXMTA/z8Rqseunrlcau3cXdo+4AP4kvFKSGF+JAB+71m01jGlefj769OyFwoJCw7RK0h4TFY3N6zZj05p1CA4OwL7d+zCacXliY+PIiBWjd7++RjMjQpq8Gf1RKAVne6gwtfxdOLYeZLAoP+ef3UrVxIOO55bpjncjU6KzdlJw3ED6epnE8sTnCTWL/8k48mwjoWvnP9LvyqIyPHXJ3cjdewBTfnUOTrnxQricIrpZdz5bjMBpd1wGbwbhPfOic7Fr/VbEJtI3qlWyRrO9mWeLm6ybmlvf8ryummnAb/N8/jIMoH63V7RuYlI3KIveGfeUcyALid27oceoAXhk6/vwDaD/Cv8pbtCanB3Y35CF4cFJSAqLhz9R9eznaf1QiIAK+p3JnEtIaGkVuSjmG+BPTXAY52YsNbfaK/JqK+Hh50NNjNDpVI96+ljSvEraQdZH4AIJvhHo6ohClCOYWg3r3bbr6iCz0dU7muZj0Rh8ajfsq85FalWehb5G5sskdcxBiQAlfO89WJ7Gqc2k7jjo3uYTvvSlEcJcmbPC+PNZE0trFRkkgRWwNR6sn7e4eRYk9EhZAfjwt4oWEydWWkyS5rvOtU5qpw0wIXO+NrWgvLGB/qiuQmp76IbpS4Ymc91uFO7LgXegA5OmnYxdWTuQX5CP6265ESGMFdVzSH8yUQzN4ePAzi278Narr6Gc5rXXX3sdUqm9XrZ0KSo5ft1798B1V1+LhYu/xcply4x2MIvz4vyLL8TMGacYE9158xTnKohMVyrOO/ds+Nd74sP352Htd6s5B6ox/bQZGD19Akq8qhBDQc+aj5YjiOvPrIvOgyvEC3OSk/DWy3M55vVYvWQlvvz8MyPk+euf/8/s8a37pPP3idEDnQzSiTHOP69WcjEuKI8iQUOpHhc8fXvRvEFJxKmDzujBVNRr120Ip514kGWnfqSd0B6BnZLSPtRtR8/YtWsXVflRLQAClL8jeNyOyvuxrw2m4/zI007Cmi+W4vv3vsWI2VMNY6Tnum+k1tZrbdqSkIf6F3PDPzRXKsbQPckP6KuvvkJJSQk1KQw+6EY8Tp7cPqqWXUbr8jq6R2aRc+bMMXGv2nNEt8sVc1S0vxb5Owm3TF8ULwcJCREcpJ8YRB6OYBI4TSupyDfOO3aQiK1gX3+cN3ASLho81RQXGheEOyZfgn8sfQfr0ncYYkuEi/XPfuKP961xKyak8Y76Qow852x4/m27QcESoaQkVDQP+ug0TCYamM9KQ3S46ODuQXQvK7ikD+K7djHMjzQg8gPp078PQoOCkZzCGDBhFEw4vJDQJcGY/fQfOAijMtLx1kuvGoZoxozpGDJqOE1yGvDRe/Ow5KtF6DewD7r164EqBuMsyK9ACcEczrjwXLj+8aRByzMVc/tgt8NBE7rPSRSdMvNUDBkzAqUkcr/84ksjvZ409WQM47kN36+Hf00Q0e5q0XNoPxTQ/2/pwsUkHqkPIPHoTcJxzEnjUFZVgbkvvobAoACcNHUiCcgYmilJm8VxNgwNR6iRoGw5861KlUaGwqsN5khXdb4wINAQnwZQgZPC6mnr3h/y6WRspH9fdS8yNu/GiHMm45y7rzZEsdDb9Op4kXn0IkErTcXk/zkXJ199tnmnZBJpO/O7P1/5pHWoF1HvVkn5R3rSrM++R33XwHZ5ysyL55U0fxWk259MhiDWFVQ0hD4c4V5BRlBVVSNnfb47Ehxw7FW+t8zDKIjhaf603gAR6nmuMpQQ/VBruQEk4DkxEKqfeamYv56ainpqAVJdBBXhUu+gL0kXojR6kVsQY1RZWWX8j1RqEeOyrS3bZ8qV1jLMLxBd+CczrWLO7Vz6ucnPpZbaJ723QkBU/aRhimE8nsFByYjwCDZ+X0LJPngE9b5bLXDmlaB3cDT6R3ZBqjMPq4t3orCGAiVxw2wvq96UjBbG9DVL5IA1XeMzlMQEqs3G1EvvpfpJY8R/7Hn2CQOwsp8rXZUUzMgPqrEEcz+FNGyPtGh2jWWGJ5M3r8a5LLM6Ic05ea8gepqeb57e/FFH0zqVobLMeLMi6gP5WzbdpGdy7lSy7wvyGEnoQAmKd+Ri9szTsZj+gem702i3S/M4rhM+NK2rKa1GZt5+9BnUH/H0BUzdl4bCklLcdOst6EGBx5p1a3Dx5RdzLfHBow8+gvTTMlCQm2/iMcl6Y9niRcb/cMSgIfjP2+/ivEsuwMAhg/GPhx42Qqn1G9Zh5dKVuOY3N9BnrRBzn38V/YcM5PoUwPnoSeFJEdcjaqw8KfArz0E//0TccNNNxjxWe9CZ585Ct6RuBiSluSc6j060Hmja1k+0hne29/jugQCfChRVEH2sJoYmA5T4EWY6Koi2w1y8Q70V+8NaxE0rubkcTjoWULf2cwQwoD/3JNhqQUy3Th3B47bO6/5bG1rjXup++pge/+L+m7F+/kp8+OcXMPyMSbTnoHnFIZ5Q46zBvl17D5Gr/csdBRY+FDPTVqnt3ePjQ4CJVhDGbd0v0qfcEYAywmA3eDnhKZMrwtfKZEvwvD5E1KLwmOh9JKxIQflJKkrGqIaER9eIOM7LcPoG1JoYP9IUlddUkjijBDs0kgSFk11K0yAjQf6xR9OiZ0Tc1JCYqSspQOnok+DYvgUBRTQ9Yh3KuvdA2OXnISomFnMuupCUKJmJ6jJDjOm+BjI/Y08eR4KqDrmuEiT06YZZNEkTsTXmzKnGiT23oRyDJ44ioUwpMspx8gUzMeWs04xmxkmzm++d6UgY3Qu/G/lHEvRUP/p5G2Iy04POPvF12FJwAL3Du2EoiSeiL3CSt9EvJNauvO1G5NMEZxtR9PqNHY3hk8aSmKT2i3GWMulr1W1kXzNXa73qUVVQjjBKjM++cDYJuHxso5+YVwgp6ygHZsyZhVNnn2HepXISTNsrDqCYDuai44WcRfaA5bQ/6ysjQ5DVrxtid+4ngS55vJXqSIjmR0Yhu74rPLJq4RVGwtafJfH8D31x66kheeXXf8XuFZvQf8pIXPLILZYWzxDUVpdp1VPXSZtiByE12gAyFkQ0sBz2RXU3JtVLBLBMpOz8qqfGvXUy56Q55DtgBBlqknx72FdVZNCqOa+zyBgUoojmmkIiY152qA8JXplcKr5NKJmnEP7JrEsxxMSYKV8ENTxC6ytR/CG+QwLG8JXjPpk9aUbEJHnx3fUjiqYvwRqKiWy4omQn+jN/nItaJFqOGu0fmR4n/62r2EP49mJqn/wQy/c9wS/Y6AFLyQTnkykX8IJMQsvpI2eYWN4XQLO0MELiS2vk5PUDtQWGAQwlI+ZLO2R34U1T37APNm9dj+RuyUju3oumd7FI96TWihr3Ws4rH5rp8gFN2XVgAAj4bC9qPBr4XGP2KTUjz8n8U8nwIWJQObdl5qY1x9NHYDDsD74/dcznPj/FuAgQwrBjZq7pOhPH2h5tfcu3p4Jt0wjb55XNPbnoT6f4YMZkkXNGYyEm1jZlV14xbbW0jtA88wigto7maZ4ER6ikaWTGgX30CStFnH8y1xzm5VirFplpGfj4vY+wmhqeW27n3GUbevXtjeTkFPgE+1Fr1Bvzv/za8ikrK6NAo9rMwv6DBtDkLgYpvbpTC5yKzOz9CAwOxoBhg7lmRVNI0x3enGNbNmxBTlYO3pn7lpkvpSXlBsXSK6yxpVpv+a6yx41WTaNSSThygUkMGDII3y5cgEULFuKuO/5ghEHufdJ5fOL0QCeDdOKM9c+npVzjwvxquYllE0Y0GHkl0ZQSxVAa6aL2oog+BgwqxxXP3tbnvfwWelOiZ8NBH2lHtEdE2whKR1reD8lvpLnc/CTT04ZD2rLdza3959g9oxztbY3W3XHdu+L0ay/CvCffwPwn/4Mz7vxFY0DU9kuX1Dc7K7v9DMfZlRpXNcLiKmkWwo2fs0oEs+z3fUnUuEq8UEGEpOI0Mh20wa+v9ML45MH4n7FnYfX+HdiavY9xV+Yh3BGIvjFJ+DZ1HV5Z/SW6R8Tj6XPvQGZJPkusxyubvjTE+JF0jQgNQwTxJpIxh3WrRj6Yzsqjn/8UvjkFxsTPwAETmjfnwouxxZOmL9XeSKFJkszJxAiV0bQyl8RvmSTaNA8sqC3jtJEvjxWQNc9VzDlBPyFTD8vHRwygiD35BklSL0dq/a4igafgrnudOUaarTbUciJX0rlcRLd3IOe2dw225e1DJX0RprDM1jO0nkRmTo9kLGH/VtSRiFYsI/rGBQbS/IpSevkyidCWmaNSrG8oEukwnsc5uXbVGhKcHhg3cRySh/TGutK9bE85tV1EXiTxJjNd+VXpmZYGiT1mFWPKav0hRC1/ggBsuGw6Br/xDRK2phsABU++A7lJMVg4eyJdl+jbUewNVznNoYLIKNG3icoOahVUtuVPZN5I89H6CW3/nnvH49jw+XKCMAzAr567h74mhEcWN8RB8BITon/sJxGtImrdO1H9LC2QJOle1KIZhq3xMTo2ZZERMZok5pX2xj2Pycoi9ThD8LI/9e3ic8rJdIgYrSGDZMbbZFZtmPjh7Um/MwZ3reM9NbWlKOe4R5IR8XCpDK5qrLM/fSDjaAUgnxg52TMrmQWLSHdnklQv8RtiorIK85FZm41egQkY5N+VWkCCa1ATtIHxiw4wuLAjkMwRERbj/Ck8Yz0zqDUqoqCihgy2tGZiCMWs+NDUzoOMmPotsiGIniycVzSxExiE6lhPhkHBkdtikNQfQwYPp6lfoNH6aB2MInBAOpk4JxnAxl4wPdL0wXKFMioGjZwpG8PR4atstGz2oKmfKZCp4zuo11yiPzHumnvS7Knf9GyT2Fdqh8xKLSaGHaQO5J+L756LTJqvfjNp+unIvtWcdPsQM1pPBsrAaXNeuKrJxPK6t5hVlq+b5Xfp4vtbT4ZIAcMDk9kWj0qEs91hAX2xlGAswQlEzEyOI+CJExXlZcjL4Tj174s7KTD84513s9nUSIr5Y5+rNmnpaXj9xVdwyRWXEnUyBdk5NLPV85iEOKfpLB9PzbkA9nUd369awomr+2rJMKovvGhC2aVbF0ylxtoR5CBAji8S+TunNt1oOOPjo7Ftw3p4VJExi0lAVX4Znnv6n7hg9vl4/ulnMGPWaRgyYjgkROtMJ24PdDJIJ+7YH7ct16Le1RFtNsBYB4PU+aYjryKckqtIEmJOlHlREkTUHDtdfuf1JkCk/ft4/t69ezeC6Reyv5REBUWlySGEPm1vh2unoZIt+tLUQpuRNhluNTzkZqhj7c6t0nm3XYVv3/oMnz41F9MuPwsB8WFmw2+Vreln0pBejD3hb2ILxcTENJ0/Hg8EE7xq1Qr86qZTSVCItLSYkUpu0DVkH/wjfBEa5kUYaUrNs0hEFJNAJ2HXK7Ir4ukYnFtehIKsVFTQxCi9OBtvrZ+PpMgYzB46hUFPUwywwCfblqKwUvF2LCLgUP2kOog4CibKk+J11JEyKKBZUhWRnkS1aHz1jyQV/1pODr07E15baJgjDxI3Xvwzic7N8W+/ieKrr0NGWhliFn4FB2MaVYYGI5dw0cV9uxtiSnltEyTNnVJCh5fUOXm2+TkiBKvq6YjAZB3X0BFedbMIMtVNNSumaZCdxOgZApLFePmSaUisQxqdsHdndkfPjXtNgFTVXT49tdQErLpoJKqCaV5LYlXw65Jql9F0UESSKUd5OQ5KmSSQvaj5Gj1rMsadNpUZyJR50xfLmYXMGjrl897m+ll3q216FYxZF4PFtpW8OV5+ej4rVkONyOLLp8E7vxhBNLMqCyXMcQTh1CnM8KY2xDOUccg4N+qLfVBbzGf4krnUK8gh9yS0sWcAtSL+JLyNwEMtdUt8wYMLiNjHZ1SFBhpt7vK5XyCxXwpufuMvJABpwqeRJnEtZkEaB5nWWVoEtoE0nuX31NgmM1bWsYhSaSbcCX4de8l8jv+MJom/3a+bmvEZ6iM+1rRB56SJcZFYlRbVQd87JTFWItQl2BH6ni/N/lwk9GU+5qolFLqrCIwahQT/UAJl0DeGnenr4UstVDXN8/yJWuYk00o2ncyGmAHR9mKSNC5qLyl0g2RYz3bX8vlbSjNoMlaFAQHdkFFTRESyQvgG+SE6OAzxFFIIiS6nhmacBDOoYxkeLJM3WvVjMF5jRkhmpYyME8MII5LaCaFXOkmAa866z3PTQPNBloXchgQdIWFWENwqrg6pNQXYVZNNA0/d12pMm29mH2kOcW5ozikwsdpm3ku2T1NP/S9O0K0IIxgx48JR4vgKpryJidV5t/LtQ2nqxCRJk2XGk/m04tRwDoj3Ur/qWWLshCyp9ghWXn1SS+ZIyYexhsxdfIBaLOZIpnWGK+HYKa/6qYiIgCH9GWS3fzQZpgbsqy/AKEKq9x86CK+98CpOJUy/i8xMPmPShbCPyyoqTVPVSPlL6Z/8jNIy9mPvnjQyRgrJ29gqfklQJQY+Pjbe3P/xBx+jF4Ozr1qxij6JXTF23GisXLUSWTlZCK0OJUpmGqLiok1w39yqYgwbNwqLvpqPD976D0aMHI6F878lU1+DEJoMe3Ie5jCW2yaa6PZk0GFPgWJ0phOyB7zuZTohW97Z6OO6B9KqC0xQSS305Q1lCPAro+kDIYkZi8Hbx4lgbbYknZSiCCd8++XX48ILL0R0NG2hjtMkO/NxE8aj7+yL4Z00mlHeyxDoo22qZWprc7RziAgPInPkz95RUE5fEkcKHuowkkUSRNycRDC6Jx+HL4LoF7Lqk29RlJWPiefM+H/svQd8pFd1938kzUga9b5abS/eXa/XXq+7jW1cwRgMxrTQQ3BCCQHez5t/AuFDS+ElwEtJXgKEEkyL6bHBGGMDtsG44u719qqt6r1L/+/v3HmkmdFIqy1ebK/urmbmeZ5bz73PvacfV5/SQZitLem+60B/29Wvc0cLfwpJW2r/j/S3bBnmL1hga156gZ3+8ovTqtEBLrhLTWUYBC4HBDenfBiVnSbb39Rk5y5ebWtql9jckmocMmy3tfVLQXrMfvTonSBwg/a77Y9xyOfavPJau33zH+2ppl12yrLlligsdFwjrbGUC7VbBPFfGy+zKtST8pk7OV4Xl1dIp4gj2RkUgWTKIFvvhxAdIR7qb/H+Tjvj1ofAYTNXDQ9BlCpqSm3RTT+y+O49lkfsoHwQheqHnnLkrGv5Iu+J5lx/UheUa15x6gNKEz6VKbpO/Z16L/O+rlOT8ubh2WvfWtzxgtjEGMJAWbHtPnuV3fv6i60naazvg2IoUd3hO/QvuifioQNibA8I657RLtuJdGxr30FsU7ooN7ms94M6gwQlIH2TCIRkJqkR9vFeyjmMpFaDhfnWhZ1DPwSGkHghvSor5F6av7mlIHpFvDcYsY9JItEPqofUcbQNCROEk8q4JpZvXTm2+JFt9qKv/NLW3PWUrf7dervtGzfZf33/VqtZWG8fufmL2G/MdQmdXFnHQU5lXyRCxBFqIdq074SMptv7warj3QySaBFRoJ3cnyrpWeZzSQ1Up0sgVBd1KCmfCMJ83MKXwCAph7tfirv+Ylyfl7Ku5VBDu5WCfjox4PWI4cA/upCg3/lIHvuQbvUjtQViPpFSv9Ne4zSCmAjk9X65ZE/EHLY2wDtG27rfiTv7vdZpLXm9Fsc5RX1ZudVLRZb3rhFGRDfSLXdgIEmh6qJieXsTsaS3RMSA7Liw7BEnwscnFTh3+iMYJ9vR+hIDon24BylVq23FOcMtd95h67sabXNus20e2AcBCNEu2DiEpvlIwln7c6QlkIt0T8i5E7rRnCW/1eeoTklXRBw5TFRPRjNp7fNQ+4K8IIoE8vAMIoYgiqSapzMmkuSIOJJLb9UraZL6JcLbgaY2WAMipkSkSkopyaP6KwJdbfYRNLsHAreXudS3+nkJKr05zO8f738Y99r77cqXvRhi5nzPX8L7XY2b7YLKUpy7zLFHHnyUwLIxW3PaKXbyyautFCcMVcRNq5lb5wRSIU45TlqJKiMeGtc/9iQS4gO2+rQ1tnrNKuwiV1s9EqNH7n3Qdu/abWecc6ZVzKu23RDMzUjAa1F7Pu+Mc2zbpu0ElH7cGhY22Kvf9GdWjWRpIR71Hn/4MRh8LXbRBRf4fGeAdPbyBIEAjCVW+WyahcBzCAI6ZH/b8bQf0N0cho2Dzd57OQgYHIGdxmHWkChEdaOMnGF5P3nfw/bZd3/Yrn/79Wy+cz0+xnNlyNu2bXNbGbmmvvafP2kLrnqLVZW028qqTmxXwmGksehwh38M0j4I0gQ3NOOo1OFbjOpKASh1BJdsMBBC0gf3XcbW0WErpOgDl/+57Xhik33851+2+WevTKqNZKsh3Lvt8/9tj+DcYeGChcecMPWYHuO9oz0OaB3YSlGfxzc2Dni0ifxxlENrJcrnhTI+7rvnXtuzu9Fe89F32KXvelXG08mXQkuGgdmG7dutZcdB++TV77b5ci2Lit2//f5H9tYzX2wJVIu+cPcP7a8uvNYe3bPJtrfst49c+Va7acM99rUHf25XnneRu7TFp3U0lJSG5J43jn0diCcqSSL+ozkUQduN9CRSDdO4orH7mgAuImL64PaWPrTXXvrTW7MSSGMgmjm8N2O4rM6EjZCeJz7wV9YPAhEludXfN9Q6tfpQlPEovhXXTCpOoMCOJEtKJgldNPZJVWvgjFf9dVQxZSAqI067sujZdJ4WhfgJrpF60aR2Um64lEnEiNYgSe+KqwJBcCoJwY1iRema1zD0P5okvkdwWT3SippfFw+xocrFXmnxgV12+Y13ps3V0h/8RFXYy77wXkssn++/w4cqC4tcxITeXR3ttWWVVltdHQgA5RByzKYhpPdIU5AwsNNQv4gFOWvIrE8SkSIRbRosSbAXM6EXQlJERZSkhjcq9TGIlQR7U22sDM9y+Y7AVzNXVaMxbLh6cCrSZT2oekrKkdmWozBSTUtWqqHRNQdHeRyPdfSjk9hqB7pQBcXFWirKE9ZIIOxiOHCQuqlUyaT6mIfELgZzSKy2ubEKOyOxCM93BJGFCJC6WzeSqo19+2xj9z63M9K4DqxvtERlsZXPQRIB0+LIoRxB6Oi+Zdso9ohrBgCUXMYl+6oiiK8B5qMDL3HuHt8BprakYsm7BqGkNav1r0FIDVYu86WS6XPATTFehvohqCB4BHDBSiqKStFc+EXK9WJsupaWzEV1UWJN/DYgaW4mRpFsfzTvuwYPIt3rs9Ul82HkJbzv7paftjWhYkY1Dyh/MTZhBa7uW0ifqvJLeaqwtLgaR4rZPNBuVYXlxFJSsFcC2TJX67t3Wyv2YJqnQvbSFahjziuo8r7KNfquxk7b19tsq+bNsVoYgjo/F+QhEVRHZ9MJCYFZAumEnPbn9qB1FEYEUjuH576hNt8Ew6i0NQdHDXNjleSc2Kp3bNxqd/7iV9a4YbtV1B6ZO21ttkLawpbpx6u3ECElEWT1RC2r/aPdXjc8+LitOP8sKzrtSqtdeyHEUavVl7daJcb9oe4gI5C+vggb3ZMBdGq70nMvIh4E2tjer6if0YV6G/qrJyAzoKNCRlNV7tb/4RH72MvfZUtOW2n/cNt/oK4wQUCN15fxow8Xx7uf2OIczoxHR31ZCLdZB2AhKIx3Hs9W6LJZDoe2n6zCF3XYVxXYAGo/UgFywsgxqFBkqk504/p56dlrLL+m2G1tUtdRtjKab6mvPLVls92B16ZLCEr57vOvcyTgP+75H3vzuiutoaLWvvCHH1pPH66kQcSWo/tegtrPf93/czAYgvOuvAa32hzMVUMWKxMywwCYRNmKlDDXlbESl/zpZmp/NEf47AIBFdIqdCg9aR2AC1nPAdQCd3faG278dtraiHK7BztlzJJGQJb2XH2x7b/8/PGnskE6MNKGHQnc4aw1jmc9oh+qsxQ1K0nJlAZYjz2s8UwJp54J6Q2IdpBmSWIj5P0Z6Jaam5TEgXcCKfkSiQsv99K6FLdfzg9EKGVLTquIM08a6YVYaEOq1BGz6276iVXjgCI1bSA2TAFzcVNDnn2uIqgYrl2wAulL3B7Zvdl6BnA0IKJEk07ji+c02KVnnW+L5jV4rCDdlltpSVzGVbJSG5jBb41TkgapgQWpQmTHlGw0NO22NUUQZJJYiHjvgThKXbepTWndjkAoibCS2mhVPjZ7Y0VErCH+GP3tAPV9Glu3HTj90N40k/Wm3ggQUp0a5s+ZKOGmgKD/9Ae0Wve4iAKguvRN0wH8tIYUcFcqdIuL6uzkogVWFy+1Xf3Ntr6n0ZrdVi+0E1WtNr2wbv+JkhhIit1WSP9l3yfi1PtE17Q+ClgvkiJ34VZb+1bou6SlEEWsDanOSSLk9C37z2AvDBiITG0v+Xihk2ROEsRhnDM47cJFDMlhnvRNk7VlDl00mHqBfwlyhDNU0kMEqdzTTakFB/JZknCtBYr4+67vKKmM9kQRyi5ZhJCO7A21NyivbCfzyBPdl3RdErOI2NE6VL44e4vOhIFebCObuNcJk4hOJhbDkCrNtT+ve6Gf91Hbs98nFgTCyXNijXl2tM8bCECsYFwtDrPrv7MFyh6hIr/EKnJxVexbIINlJxRKOW/FInvF8jez4aZut4cHDKmkJcYwiMaTkIx5hcT2umE3SHkyyZNeEYe8gkiizAFiom38SAklSYXM9rBx78UZRXXZfqsqbk0e7ooJgn44m38wLg99EAGXmnSQBOJosuRIkMDEFSkAZbkIBwefwGgcfsnKVl+wzs5/xeV2702/tnv++1Y7+w0vSm0m6+8EahMrXrA267Ojvan+6RCVt6kK9JfgV7vkQNTAmAyvJV4ThHTKMx7Zzsjls+Yjc2zqC+csuVOT1A2JpwLnuh9Op3T4Z5J6cDn9my0Po8ZRbe8472X2F+dfbYvL51p1otTed+FrePZHbBsqXSXo//76v21Px0FbVDPf4jUgKtB4Q7vi2JtwwFfgHa8qx+aUBE6okIJw/Kf3QwbZxRCJhXDKJSnSn9TfPFdyHvvb8dLVAkLbUGBbz1xqSx7dkeZxzfNOQRxpzLJhyZWtQUoSTqP3TWXT4ZaS6Qh/CgGW6qcQmChpXSNbwMnDmJXtb7XT7njMqhtx/VuSsA14xdt86uIkMaL3Mv0diOp4xr6l4gQgXDqhdSTVpFFgI9UlPXMsPHvrWlY5SEBy4O4XlrKK8c6GVpJVdrZPKrAKN+pKa+Ha1yEdWlo1jzX2cqsuLrcv33eTPdy4CRWyHtw/a40jsRmAdIajniAgb5/sbrivNc0iQRIgok3vyOGlSJ1L8y5iSWPW3OhPe6vbqPFM70svTIlB1qJifGV756KWpX4VQ6VSeTp4S3tB2stZYGUwQQq4V8HnOfFaqx8ttqdH260FzYHAFopqoC/8TF2H3j9gEEMSpACy0UPtGcWSpGlbSN6U8M9tdOizFOekPCyVSfVa5bUedw00WwseHeMU7ASWeqb7423yo+lpSZBKrbi2lDnXGlQvjm/Se6lQF8XMh9zpayVo//PEl0bVhcrpGPGyRDxqDvNRDdU2qXXLY34AXanVcT0MY2IAAkl2QAKi3MtLiii7Pi0lh6KqVzPJa93NlrTawinFRkcS9PJY93Kc4vX4HXVB6yjsN+Pw9RKSI6mjyp0kePitM1ApyisCSxep9yPiKOQL8yZJq/qdl0DiuQhYwVwb2BkzfMjgAUk91cBm04kKgYnT50SFwOy4n7MQEFePaBYEmquxAdwHSzUsJoIJNMoPY/Y2bZg6EKRPPgAnTRvvkSYhiTGU5WUbLC7jKAa1vaOg3CAA0casHwVIamQXohNHCgdDeagFsRG7KsMM21d9GoO26E5FSB/LJ3L4Pisr7OCs40Dhb0ASA/5J0hMO6zAyEU3j/eGWdOfjEHWChI4Fz+sHkriJqos+el1R+fCd7fNNH3sPcZF+Zz/5P1+3U19+oSWIHfOnShqLkJrIQUEVnsqKcQ/mHo8UmV4DU9I3/wtA50XgDuZB9LBWdDhGxLLip8R7IUoGOSSZuiHYnMLNxW2Xehd6RM67ToVrqHzyp/pVVVRqCypqQBrjdmrtUpyItNtv9myx+ZV19qbTX0RIkH67e9tjcNeFWNIQ/+P4sygohTvaAbezBWSzNc8G2vKtGyIpD6lSYTGKdSATSsmRjTeuNoXGxVFTGeNPHFMhqt0gQD0Eb+xDEAFT3grn5NkDr3qBr81lD21xmzMZhStNN7YcEKKukxZ7vugDOQREGVxj4sz4+xY9OAbfPh4hsdQVjVWShCJmsRYXwRd9+eduzC4ueGlrtxNKtTsP+tgcgWc0x7pP0w1LTAjtRw5EfXEt5FKSEb2Nup4uqa+SlBVBECjnaAH7GVz6RLccYKQnvfX7Y2N22fKz7J3nv8JOqmxwda4lL22wbz38S/vG/bfgIa4nFKLdEBy0wEYx5JK76RF5J4PtLzUqUEPfyw7Vv/Qe8Dpo/4OAEKzFgJAqneLsaE+KJszHwYXsXKYf/UTtmnclSQt3WhexjYqAS9jPBceluNmuwwZvMy7mt4x1sq8LMQZRZpwi0ESsyS5MSfu+15fSuPa+EoiHBlS0RL4MkVf+E9VHdgTfT7RXu/8MxqO9XTZTgeEAMww7Js2Vz2+WUXXhTh4RnxXhAc+nPFq83qNn8IM+ihBCVsnkMC6YQL3sKbINcucdjCk4fhBgyAuDT04SInsy7YMxVAcFRyXFbfIzjryDeL2Ueh0PJ9Yx+ccgsgUClchB2hSV9Qqm+QgthM+psk3/dHKpqfJPdT+qYfy55olzMlbImVLLO7K7gHEDM90fzxSVmv0+USDAKzSbZiHw3IOA1IrECYxOY+kUo4zjl2FP0642imLGCNz/wXFO0oC4Y+x4Bahc+S9l42e48luTP9glpTJTCJHihwicVx20PXjwEoKeun+60wNQVR2iSnpWwAGPYy4kEbLtmVoSMXGYo/owkGtNvUVwYDlsC1oweO4AAUDVg01cSe33UldqO/6ADw/gF13wrZ4AAf8OxJy48+LGh37qO45qhaugpZTL9rN2wVy75q/fYD/57Dft1s99z6778PXZsh3nezmuy96PKozscyrw7iaCUPCM5gZNedSzgBeEUCkSR1E/gqHH+BgcxUsYQYc7A3InEDuYfXlBUMorF0UGa1DXATEVHpw1cT/wlJH4tTbZP9/+Lfv2g7+0utIqa+mTi3A411RUgAORHgzFNx/c6SpRkoL65EB8S9AQLwfhxBX0SD8EXBvrrCfP+rtYQwUjVlyFul05RJVUpITMpPVF11qrRLOH2OuibGcHCA5IToL6SiCOxiD8+hj7va+90B6++iyr2NtqV37tV+NwyjYuudXeu3yZdS5tSEP61LwYFMUQSZ0QSelkebaaZn6Pqt1VcXiDJgYpIunsG+8yudFWnijlggiuhODbft4q68LQW7YXjvSCGB63BEB8ShyroufALVd2Xd7R1N5m6ZGGSDkRVELB5Vls03krbc1vn0iT9KmkluUva2J2KW7jFb5A766IlDnFlbakvJ4QCCXYlsiOTERiSF69ruiMe6hDGukuwJEoAVIn5g6HSFJed1agBUuH9C6x8sInBJhLIpJDnmrkGisrPnQwI5Pelc6cQSRFg1bK/ilGk8YgIqCI/er0WDXSpEJ7aqzD9rEP5wPrIs6ACP4iItWbKAhqaESrSVJhHCtI7QznBFITVdJR4kFTxTjhXgK30MUQuAVIIguoWwTSMAST1PvETFId+pfWbTq4AOms2+hIepRcB1Hbz+g3Ax9DqigbHXVqJA/JHWq7GpckPzq/XLqZ7ITgJOc7Yzj58cC/mgsySxEtD8mn1q7SiFx7Aw/ZU3mAYe6rTm9EX6Qc9iIFXU4HRnj2XPsEDOy9rBGk7YO7AdJJjCCA4rk2lNn+HgMIzBJIxwCIs1UcXwjo3Ll/f8JOrsENKwifDk7dQ0bjB5h2at0VJ1GG5BEnUYeZ7rX1FkJ4YPwNRzWBNKEojutTgkkmmfOTBqPDUE4PiuJwy8VZoy25cU0njrjJyaF4LzrcdXhGKfolT3EjGOBLJ9yRSTok2yAhfVKTUklh5h2oy29sLsWcJt+qSlvxAEWkd69RI5hIqW1M3A2jT73W+OVFKKCU6o3qgSjiwFcSslMwhjqGy6v81jQfY/ay973Rfv3dn9lv//MndtGbr7baxQ3T5D8+jxzxAUbyTNYBwpQAplIrlESlH8KoF49KMu4Xl3NIMkbmSciR4BobgHvfDUolsCRB7F9OTGOIDg5ViMpTfDAQSNlHBPcWhKoCz13lxWXWgkE4bFrb3NxoGw7uAOEqQCWqGkPxFjvQ2Yzxs/TjQWyFePC7prQcD3ZJ+zBfMCCgBXD/G1Ano49F/TFU5FA/2osk5wAqUxjxJ0q07sXJp0eUce45mit9nbwJ/YwgPmoF1ZRHZSueAMVk4UrVSTitpKADuD8exp5guiTVl6cvvsi2nXGmzRFwvG8TJWLAWTYjWtNaZ8cq6R3KfI9UdwExdopbOrI2Ixfg8zbttR1L5iXHCDeYPuv9PR5J0hRvShsEoNCazBOwM1NKd/QTEHvS7wEh4qxLQfKJy9Za5Z4Wm79hD/tGGEccQvDn6xbb/OX1eAkbtN9sf9TObDjJKlHffHjvFrt/z9O2rGaerZt3Eq3nWgs2MoMg/b28E65OFJryRuWlTG6lpUolNStHfKPORPmm+NZY3YA/+Vz9FfEid9yyT4pBhDuSnWX4KiIiXhI3psylGJprv6/1KSScciJKNo20WClrvC6XALDjcAo7Xz1q1FVIjLcztj25va5mrDq0n2lV9zMZIpJSk6roZC9ox1aLBsJ8eQb6rnlL5u+FeBoU0s+1q2tyOBSxZySAmfZKzZFLlvgOLYTP4e4BvBSiFlgk+ZTGlN4+Nw4/UYXXQueTIJhcB2MWvMfcPTdzIXtL4rIBTPJql8uSuClYxZH+DGIv198dAuUq0GqMs077RQ5qyoU4UBhPGRUFQnmCOAqP9anV/9xMIu7z6oFfI6soWnTPzaHM9vooITBLIB0lAGeLH38IaPslrIw9tLfIVlUP2LxiuF5sx91wG0UQTWzMYZOOtmqVK9FBR/yU1r4CO9ibsA4sMguHURWKDeAZBy47EgJt7hMJjzccFqWK7DieJh+84iXKb1yqd7Hx7Ck/ZFcBZuwcUalDiFByYolvtdoLorKhNYG7ctqEMKotO8h9IQT6TO9X6lVKE44c6plGopJCtxScU9yxIozedWTKaHoIiZR8NAmbE4IiGEbHPTezpGBfMIgawrUffrvd8J5P2Y8/+hV75w0fz5L30LcyIX3oEjPJIUQSexuplyFhE1QDOhWObCHLXbjeLVHMDn86kzpD2YKRXNTsApmZWUpjEQzn4SHxlZdc7hKkKI84s1KfCnOtM3di5lROUsm5c+qssDDhiGpUTt8ifhSAtrosz0oxGu7FbqC7FelhO160kHq57r4oO1VJvbkgvIkSbDfqQZISFEbaqYXgiLsaSyb9VJGBYoyto5tZvvuryq3x5FNswdPrrbIR2C2eb73zqTyZVFaBPctwItGGu+PoXYueH/PvFNhNrpvxA2vZHQyAgEcG25PzPfN3XMJAPzTXIoKVNAdScxIhK+mJq99BJEfOJES8DjuSHjILCb/9dRdbQyMBfZ/cZO09/bbs4qvsRaeebcMb77dvPvAL27BvJ/ZtdbalZY9955FfWU1xhX30Ra+wZZVz7aHdG+0/H7oJV9MD4/Yc3pGUD0dwkQD4GuFjurWQUmzSTx+br7Pwtmn8YdSTsro0YxQK3ePu8Fh2UVjUAyskGLKdYk92pxYQYQfRAXgAz2Zn5tdYXQ5qcXQwen9E/MQhnlagdjeXfWw7AUoPjIl1pf0OFTNsrzIJpPHeUI+kypE4WLGaxKRywk190j/1C4jk0TdJVYZhbkl1TcSHqEkxt0QkyiGA4Kel2YYHS1F91UvnWD6xsI76fQCOIYisCEcIWhGP9GpcGqRGw+Q5gQQPDns21j5D89NlVHs68GT3kTrdAOraFHYPfSJEvTLqUC2SFMWQnAUnHP3sJSglK1Cqc460Y0yfVEcBdpBqS21KzVfrQoxE7+MUxdWezqApE3PjPVQDxyPRlTh76PBiuGLR+3g82p1t41kHgVkC6Vk3JbMdOhQEhOBf2r/bWoivsb+vxPZwgNUWSjUiJZjcFJVoK9YRU5sYsJq8Hg6DwF1z1EB2ozpw5IlHGUnihCqmTGYSMpOatHfnSSJA3cmiqY/Hf8tuI2i/TyDuyq8rBR99uq3QDvYo2jwR5kuboKXoFBxLqe7JIF4pED1y3SxyJvxLPTvEydc/PZcdiuwCdK2+KZ5HEdIwIQ5uwwQwZUStYKNTIhPk1Wj7sLcKLpbNznnV5XbXN262x2+71zb87hFbddE671u2jwge6n1AwfQpBIODlMMz1B5ArqvUsWSrbyb3UhGTzN8eYZ5K1E4c6VFRN4isBpitYZCD0UKQi7piQzhEzJtuONNJCSAFAvTVo/BLLoAXEn9jyeJFuplM6LazrgrhQMs6LUhGomdCICB2RnqS9g2hGwEOoUOSevYjLZAb5CIkQUXzQe7qIXCHmFHqVawQceM1120EjHUKGTVCRzxSlqmQKgW3TZV8dleVWncFsWraRdykJ82bCKIrv/JlR8yUQY4aWs5YbdsIGBy406x7+lAGh78blagQEym9niO5cmjSX40vWj+qR7GQumvKrbi5Y1J/83h/dp00F2lp5JXrSFo+yjLCOVkz6rWIAEewIi6+1jrvpO4HpJA8XLMgeLNRf+RftFZFSCmQqcofWFRjW+N9tmHzVntt7qCdh+fD6065yJ0v7GjdB2I7ZpsO7Lbtzfusrb+LuFoPWPHJF+H8o8kaO5ptaS2ixkMl5jZq+1BZsz3X3iGiSJIlYcVOCEIoZNbpql5IboqJi6T3YEDEBhIsqJBA0FLWHTpQjfZeMW2aRnrtd8QUWpdXbYuJ/yWVYG578teWMrq7hn26DmJ982iH7YEonHo/A+TqmyRnlJXr6ii+D/i935Mq7qj2TX9/whrU/Ojd0j3Z5Ih80tp0z23sz+rTvHOXW/eeNut8ep9VnNKAww2kL7Qx45SS1eOasZbmxiusJL8IyfeIHUQiKJuy6rhsnHKQEPK+04tKPOvJY5v2VKmeD0MkVeH1sgCbNvU1gtPenmZ7umWn9eNJ0914QxwHT4RYzaJFEanWaVmOInmXLE6wOlTSdCiMgdhvoqe0Q8Y4a3TGyE5wVDcFLX1lJm570N/M+9E169sD+kbXx+Ob/sYKWX3Z+ns82p9t41kBgVkC6VkxDbOdOFwICJ2oJ/p2nTweYXDbkyVg6qQ62e3yBuGS4Uq3pBPCA+Q4M+Vg3N9bEbPeElREUN9LcOjqmPbDMZk5lMooS93BJiqzxsnXaeW50PHbixrMrh5sPbA1KYwPEdywFVsCvAVhS5MQYu1xjSbqihASqc9IFUUef0IfIXx0jwPSY6FQRHt8QNl0UPkx5fcGRDyBoKg/U58DkkBhB4OKnvJH+XQ4v+af3mWffun77Icf/pJ96Ndf4iCd4BlHdepoVfDHhP8hY3OiCAP0JDErHFI9EgEnxF1qkv0c6LrzTCShbPJ6WAwiNdY1YMVNAxbrB3JZcACd6WM4RhjD1XdOCcFy6ZCQuk6IGaGyIoc1DwP8C32mHo2BQUnVKDXBt8WgnLZc9U/+9kQohblQvsQYkhzY4wo4KhiJ6BCiLaRHZfo1p6guJZDUFIzBpQXWkjwpCdnmqbWMdFoXRKwsNiQPVF9Tk9ZH6pqInv3qHS+2az57k8VQz0lNfXVVVvvHJ8OcpzAEqh592vrrqm3vSy7y7FpbUh8tRzrZLALtmCVfHGm1iZh8AKnKC798y7iTBmUYBfLJmQ4AAEAASURBVHHdfM4Ka1lQHfqbVuo4X4QXTkKGJMIZ3hoR5nL2ISmfG8ezzln0QdVLedXN5IsjqZPng+jz26yr0kLs63D+oTUhJLlIbv6Ty2yItbGsusFWzFlgT+/fAcOo3KrxflhVVOaItFfyjH6EfcKJEo1T3dbyDEMfb1lrWrGEyiHytG56+3tsQJKKfJyREP9GbheGCR8wxrjHWOORKp+c7KzP7bSKnARE0ATa4o4HeFfgc4GIG5Ik4oSxFkvycOIwIn94AX7jHRj/wVkAcaC3WHtZaj91nQOTLB+tAWd56TlJu9swjUjypfec/7yryQFGXxATxfVlqC3SLtJbJ4RVvebVX0cuVDA1pVy61EVjJ48kWPUlc+y0smXWjU1ZOXNfEm+xWmL+DPUOWSkhDk6P1eAoJWYdrCMF2K1GvXcvarzzkSruaW+yB3c/bpevOMu2te23A+2K8bPE9iZabKCvnbMAgggiJg81Ohc0YwOp+fO+JsejrqkvIQEXdT+5SMNwKMPjIuwq5V5E6osicFWPz43Kay8HHNpPtbc5fLVGnu0pGvazvZ+z/XvGIJD3MdIzVvtsxbMQeIYgsKtxR5D8Y2Af74G3pk0ZV53BXejkRuN4JytuQ42uGSQTL2F50Ec68MBV0v5y8cyTj0QhBiGVj91IPgd32unJlfZNEQt+mPBbKQaXuAikOzOvP5zqg4p0ePSA/MpVeD6GtbXF3VZTxF9i2O1k5HxC9jKZSciFDmfFupBBuhBUHTxCINU/kRg6gqJjSBIbeciSXY7Kpqb0q9Qn4bfqk3RCfMjUvJUNdda8Y59tuPthKyWu1KJ1Kx0HEGIuoq4c25TqOEganExJGNRHkZsiJMUNVb0ag/50L7gKBoHkOnLPOrk3R3enEOSqOlZuRQSgLGhGjYS1Q4NZKx0tzrfRhlJOf45+dZYkezEhp1IHCqXg1g4XgJzErXeQv+FiAhVCfJHfObKh2PinZkfOA9xAnXZFxniiMnkCE8dXdmxSxdS8Cy7RfKkL4tILToJRskv+HvQQKFYqbppxV92iXkkdJ5KIKMW2YrwZaQhvaesvPoW7rBlwmfa6CmteUm91W/Z4zkzoyDtgYn9TWkwkR3poW97HtFKiPmc0NeNLrSHBWRzx1CQJVWtFge1cs9AKeuGCQ9R1EJTz0Rets6cuf2bcyae2P91vwcm5+PQ9IlxEJQk2qUnX4tqLoeAce9aBsui3S2CUWdeaY2Ct0m3dnbZjTyMqZXm2qGqulUFgPHVgux3sbrPT6pdaS38ntpVdVldcZe19YR1sByl+eN8mm1NbY/U1EwF+U/ty7H6rl/qDiHCiTiphgcARQj3mXtNYe4wpoUCl7JUa38gADgAk1dY9CHtJSfXyyOZqzOHCOwKcEuzDWg+VMDdK2UW0soXgqy1fIw5AvRPYi/rTHNsv1gXrZaqk9vWX7HZaNr1biiFUrHeRcciWjCG43SLd83GMlw3DdqJohHMjF7fgRXPKbbhv0NoIHJtXwDpGytt3sNPv5RXKPiv5blKZExQQuMNiVomwcpqORlgPVdiWSb373277PoyzfOxuF7KHF9pnbvkugaYb7ax5J+MEps5ufPAOe2D7Risk2O1PHr3L5hFzbR8E0s2P/t7WzV9hj+zaaA9uW29rFixFfQwNBSR4tYQakEpmcT6SH6Q/lXgBLSsocrVBxVSLo1peAVFeg3SqHDskqc+JwaKYbHX55VYJoabf5ZyT8mBYipvMYhh5JVyLJurDxbyrKUK8aS7lyEHSKKny6TwS6GeUNEXAIts8zaj8UWQ6o3jJpD3oKKqbLfocg8AEK+Y51vHZ7s5CwCGgXZbNuAQWfQ7IZT/cRx2cUdIeXNw2bEVtcOYhppyA4qbOuKxJBUiJbgiu3m4bK8HFaXWJjYEkR8kP/AxiQZxRITNCgKVOJW9zAUlUX6g0tc1k41LSUOBLHUZqVmF7EGD5wRFUEjLKRR1I+VZf1I5084U49yeHrvqiJMcSUhMU4n34SUcZ8AC2IZ5TIJKk8CfE4a0ffY89+ovf2y2fusFecN2LrLQSggg1GHnJ0z+lAK8JiEsakqrmFfJ4Vv8QETPKYSwj9IlSE8/Tf0UjVSsO5vTHGVcCT9SfQx3QOa5L4wXGaxHPOQ/kTrZm/VDZPSBoHQNxnC+UMvd4w0t0EHOmB+SCgLXjpTJ/wO0FBoOSCIEQFlCfYBxmMuQN404fva5EOCrmlQhNERGgGd6OE54gKYNOAAVCxSUNzIHKCakTkas+hhKhnehzFATusavO5N3JtcodzXbNl26epv8QAkhvM5OIugQEeD+2H0ebfI4cgPoIcBB3XWtH77eIot+/4YVH28wxK68eai4SvBMFSPYGUVfqHcL2x4mFqZtxoojHvhZTFowkD24PI/Y8D0UEtPZ22Nfuu9kau5rs/cTTmlte7XtHMbZrFy49zfb3tNkdWx90L3Z373yUwLGbQITF16diIalQ+f47pZ2pe3Z4T6J3St9K+hxFoiH6RES9FqCIP0lJO1GZk7qpwjEM+1qBSMAOVEn2bIWFuFjGM4o8I/ZgRyhCv5i1JVKnCwJ8FCmS2FuCj9er4QFnSdHE0JIN0saRduvCHsnVHNU89yKCTe0cKmkuIWNoS/ZM8oaH1BuX+dq3FDYhV6ppUj0bh2WYL1czTEpi88sSFistsCHsBmMF2MfuarNhbcFs8gWo3jmTQ7CRJFHw0ebkhDNwYr7jEGgKxp0gAGsFHll2tuyzC5jngwQP3tN2wA6iPtm+thdJ4ZBtOrjXVtQusFOqF9miC2thtFVaC3G0VIcIOdlKxfhdSby4RUVzbCiBl0s8aQ6iiliJ1CmGCKmpm/zAtaSy2DZ2N+Jts8CWFtZaJ8FkBduasgocrzN3nCUiUaXa2YWziwQEljxzag870NmKyi8aA4x7fdcu29a1z9Vz09T06I97D4XYn4DfoWZk9vksBI4/BGYJpOMP89kWjzEERlGHGJlTBheSbRukOnhsSzbCJp5AnS4XCZK4WDNNUgcQpzwHl3JjPR02WoMBfQUHM4eMELQIEYjqc842qleSAjjnn+NCyKjMhCUliIF46jsgtCCwHPdy+Z0WQ4nKhFjozDzcpP4Ej31CgiaSXIwXQ9wIwTqCar0iIVWOpIhIEky4W8hvSTeK5tbbte97i33///yn3fqZb9v1n/xb8oaxZsJIlfk9nqf20RtJ+8CRBoiSPGz1uwrg5J6rvFoRoqWBCZFR34ZAoKdLmhMh2nLzPZJAmtUZSJNsZXJxsw07HvujzG0SuwXGIAQvH0+IJeXDtqCs3dqwBxjOQarh/4LLYSH0EyoqE62o/1pF8v4mpFGqnJNHOZE/9ZfswFg5jvgICprZXiGOzhgIkJXipKQ5sdzglEPrMHgxmx7yMdz6vvi/fpnaXNbfA9UVafdVq9atI8NpT47dhYhDSUif3UlG8VK7DMF6Z9xXkEYhsk4YYRsjLrtLjwBsLgSXJBBCnguRtDSU1xAPrchOxs33BQvWIL2UMbnZe85/pf3N+dfZvp5W+9r9N9sTe7Ym10hyT2EvDDjp9Gtgxn3OyBjNjfYL7RJ+zZoI+wB39Ruipg+kvHm4E44OlkNyNS1mkjZc5SSTJEalkkSgstk5imIq+6Sk192on3YhhZYnUNXvaor88sGz+Hp7e/DeOGg7cDm5Z6gzSI/8MXUCP5f4ZPR5uksFRhBhJG+Xw4OyR1JlgQmWI9tV3lv9U5InwLD2pV6LhATiSSqV1afM14tOqTGru3yltTy523ob2yx/OVIWvFaKQI6xl7rNFvWoj5IuyqmLXIwLVhr9krq5tq1pj/UPDNjT+3bYwpo5EEht1tTZhrpiwqWHS2rwbNjfa1+752Z7zVmXUxlQSplq/VR/v3fvbbalba+1QBAdbGuzUxcus+JEka1v3GZtPZ32yjMvszecfaXD/Nv3/dIe3L7eBoiZ1FBVa+9+4XW2oLrWPvGLb+FpdZf19fXZX1/6ajtl7iL70t032ZaDu92RxVWnX2BXn3IeznKGrHmA2H38038ld2whZxHsoWkdDI9nP2ch8KyBQObJ/6zp2GxHZiEwMwgkt330woWhSWu8n0NUnHQx+OKoPGA7DnE0s9om5RLXE0lC3n78l7URELOCFmgnVoDdTwkcsOSmH44emRPI0xGuXqlIh0J4HI5RVyUDedYh6LE0eJpyfk1qeuY3dGgH9Y+J+nA+QEBFOWRQGu+mXx3Jh7jjEC0pRaPf1/w1br+/fbPd9o0f21Vvf7WdvGpVWr6UIj72IuJJwRSG+FEcp6kStkLyHJg7kFQLy8wpt7vYa/EXUkBc+kBcpEYWUKjJ49Z9J5C0XJAKjuX3sT6oewJwEx1innN64VuLU+3ra7yp8IN5FMdVkrsELeZiSN2L6h7oLPMvLqkQFOwsGOdUSStEDhjktUtc2cxRTl2O/lO/9HFEZMtxhAigCGHTyGXnlSdDa9awfmttZhtmahvLH96CemmqJ8jUp+G3pLCNL70k7YF3hTZn2v+0wlkuVI/XKaw6mQRnEeri6B+7lqLaj8231lc/CHI/bpMdUdaMAK/pkj/mQwi/e3GT5JKk+1LDc+JIv5nHPgIM3/b0fdbW1WnrFqy09t5O24Ar+SKQ5NVzFqF+lW93bXvU7t3+uPUNYo8Ww0m8AnpqZrSXHaIv3vBRfujddnEPczcG4SBnE3kQE3lIhly1kMci8tvHelDBLXWJhOYz2GVp3LycjFdruRq1r97RuDVB8Oi97cTz5qDikqHvpn1Ztpd9sumiSAe/O5D6b4RR0ZvPeBkrQwZ+qO1CdDjTK8vY3HGEEz8hv8ppjffxvgSCFfIsSRx5cepU/6KkPG5zGF4Cf6YgvDnyAOfqciGn7JLieImLVwMH4JGaXJLIrUAYxfwcE2HUjYSmvb/DltbNtz9u22gHelrs6T3b7bxFp9jm/bttL3ZFeq/lfrweiaJgvYd7/awTOW/RuDPT/o4W3HoP23sv/zMIwAH7l//5hp2/6nT79OveZ3dtfsR+cN/tdt1pF9ldWx+1Ozf80T7wsrfYAmya/uXWG+ybf/iFffhFb7VmJEWSfr/v6tfaqQ1L7dO3fQd71iH7zGvf66EN/vWWb/l6nFNOyAMcS2iv0vyNCS7yhAEAh8gfgzF0yCXJVMomLQ3omYOavZ6FwDMAgVkC6RkA6myVxw8CjirJ9ggEVrhUK/js0y3luMnOxai1z+rYhItG8fyDqkKEfpJtBkkHWEpOTlqp6OFiztspK1AgQ1RBSjiAAj4zXudEyQl0VQ+FMIvzr5M6/XgcL3rEPyL1qagCyRV02E70JXoy+XuiN9OjnSnQSKukAMTnzR//G/vc2z9k3/zQ5+zTP/5a2vPMCx2IaLSDJBjSvqmJBx2I0mmXw4I+5lGcef1TfyVxkcpgao91XwShOzUQkUSHhSClJqmBSeVQRt052AaMluFNq6l3Roe01+NAYMJZZ2Mgam5LQF2S2Kg9OUgIvaR++p2Pk43BnGFXjcvoyni3grQHBw6K9TJ+d/KP8EyfE6MWr17XE88myimXguMKSVOu6eqOSlXua8UmxAcZ3Ur71pNd115urWdis8SF6tTyF3mqtS0J3kzbSqs4y8XEKMNDVxVlfnPgdkTxzbIU+5PcCrMixF/ItIgCqfpK0kh3tOCnBqkD0cu4yljYTNw5AUSzq4VRXDGztK6lMrYL9aptLXvtxsfvAP45thibJHl8+8FDv/J1JpQ42OVQNe6px1pgGDWhMlYNgZz5QjwD0MqVxT/DGMQGZxCJTiwf9a5EsY9FC8ZBAmB8bfIi1uVJJZd5jQl22PCIQCIJZJpzFLicUBH90Quhr/hDAtUBHMc8TaDYTtar4N0rD5PaJ3iYD/Iei8G+UKBeiAS9i676TJ2al2htSU1vWHY/yTWfQs+oCyT1lob1RfK+J+sT7FVexJAzK3gYPR/fUDSIZFlJz4oWVIal4C+NHk4k2fGI6aP9ThLxXlTgBiC02wd7bAESI6n1bTm4B8lPm7305HOsFKJ4w8FG29V50CqJo1aKXdowzA0x4vQvNDRRf/RLcdeWQ3BVlmHfFK+3xTVz7dylp1gxtohr65fZd4d+YZ0DPfbA1qfswuVrbS6SI2lAvurMS+2Lv/qBB70WsfmCpafayXOXQMD1IGV62tYuWG63PnaPg7Knv892Ne+3JWULQ19oXMQR08R+hNRc3WP40hKYCdEODaga9DGbZiFw3CAwSyAdN1DPNvSMQIA9Mwcuq3bcXd1mTxFgdYB4NTqTetoLDQ1o24hHp3IOzhr0p+cM91kJSGMMaipT6Uzbr3jssggSD32Ug6QERFt1efIf4i5ycCN1KDswiNcldN6LaV+b9wz2bz+4ktUdqy9xraUGoubVRf25Oh+IxtRdEkoriRfqI/zptFLgWBFVU5ehQEYSoiEu7jkvv8RWnbfWHvn1vfbAbXfZuS9+YUbOzEucYUBMDIojPK1kIxBD+XBepcYoey0BuhBbl+wpOK7Ih0sZwSM1X1gZghFPQRZHyyDUOvvB5oCGz29q7vTfOajZ5CBFzAHpY5EhfQL5lNoltgY68B1h8hU0US7YLMnpRLbeRPmAIfMXAxYJpJ/KmZnkeKFfZBj1CGlUvWoRuZBLzIL0KLPUxPUhhjaesZ/gsaOIXvNA5jKT+rXtjddY6zmn+SPQWWxCZCdCz1gDmh+30TgUIDMrnuI6GxyEPCdEhIJA9gesaYrSx/+23gV3US3YsUkoAKdwfbkwDtK+yX3SusmD4NP8uuMOrl3K4sRRIBSkfrawus7OXnkKhBJqV6jUaT4j+AgmCnI6t7aWOiaWsYziT5q70BbW1dtoO4Q6KqPxORAgiSQCPbk7x+SOas/Ll3MZxsY4YthB5dKXiR6HZpRP6tAHGEltXjlkEAQNazt6R5WrfxjbnX4CPXf32AiCh2FcLx/Etmgz0rEduPMewHspSmqMO7wHozDC5BFPrrtj9EEEZj6/4wBa0kfZ/knCFyVJjxyQU74gQuA1J7xxYpJxJjiEuRfZQAVnG4xGGf0p3+GnX/s9yvZ39Fn71gNWvqjW8kvYN6IJTObyPSAXmyP2AKn2SZ1OziHax3ptFSEtavFKeN/2J9kn8nDMUGVzSrDD2/a4e6i7fNFa92rXhp1UqJa9QTZgLAj9U2O+BSXb0nsqJkMCFWYRjHIQ0ee/RaSyH0kKyvPSRIL7sD64lw/BqZoGIXAkYZNjJKyYrGuwl/c+OMzowEGI5u91Z11hqxqW2ADz4X2gvI6ZaNDqi96NJMiSvZr9moXAswsCswTSs2s+ZntzOBAAcdAGO4gN0pMthbajPY5nnRE7Y063c9H6waW7BwkGO6iDON82DGB8CpeymIOgyvqsmoOnFGSjD+S7F3S9G25mD9584HniVQ7kFwnB+f37cCuLHcqkE4/Df2jUyvZxgJdy+OEOeqQItJsDLfUgOpzhTJ1XR5zQiWxJhI5sb0TWhSTbHLmyTkU0opIiDHROidPfL24s5cKBitogRGQpnuekyhTuRaWm+pbtC8gLti5C2F/9z++yf7nyXfb/PvSvdsal57vB9HT1BPRPn5OR8dQWNXblknFwAcjO1LBILTUJR3H4iLMuT3H+FIDl4HFqTMFSUWWZdFqzuFhiIYnD3I7XuyZ5CCPxLAcExPpQvewDovXYqHnPwuPoU7MmhEakTLYk+Ejap35pjNngJcRZLsIlRdNzdUn16lvXmv+om1xmTwxEY9H8T5e2rVtma37z+KQsKtt+ygprOudUetJvHbhkllqfVPcm2g99mlT4CG6EXmZfFz52wV9jOsR4ZtJ0BNOZ5J1JHrcrUSy1ZJKNmbvK1IvnhFB4IITaiQIIJI85QzZXqYPhE0l65KEyAeMijjrouaeutTUnr3IibKL2UJckUI7sixhLwkSqarLxkcvqwVYcwR/E6H83hEMdRETFTN+i5CAO+yvY/eSh+iVCQg4b1EfNnSQh0fh0LTu8/WNtuK9HugssZK8Zg0gfhaAbwiauT2sNQipXTBJW2x8Hm9i3iLQj4gvYUAV3fVVYHIcG+fzFIY4KQOgLefdEZAhe/q7oPU5JMb3/omejTZvH6qdyC35ShYtU/lKK+c9UxwM+lyKiOEPEOJDam96L8UQHhnvoM3OuOc6WRKj0QhAOQ/xLPVJ9yGMMkorJ/m4Rdki/ufvnds3q860cm6ESPNFp/I3NTVa3FnfftKGYR1GzPopoXNkazLgnD50itgWLBH1cWtlgj+7aYldiSzS/pNK+teuPxObDfXyiwmMbaXSD9K2sqMjqyqps+dyF9vrTLyO4bKHt7NyLy/FyW9/XSHckXZf6r0M12apKAwvg4Y6THFQp8Ermmv2ahcCfEgKzBNKfEvqzbR85BNhYR5HctJaW2uN9ZdbVG7PlVQO2oqIfdY2Aagp9SuBpTK6wO1BV6OYgbsPYtL0/DmKXsE19ILUE2+wFNR1EFYUqQZ5xGw4Xrzx/GPUD0NpOOOq9fezsPJQOX0YSpz3RymHePWx7aottAAKsqhD978Mwus+ocvxSB4pwKhF68nCnv2xJPFc5YhDBI0Rb6mdxlwSl9jdIjDIJI7WhP33qQO8GESmDSJKaR2ppz5L2IUILe4ukhE1lG9YstfNf/2L7w/d+ad/+8tftTX9zPXORXSISVaX+CtENfYhQu+hp+nd4GuVNf3boKzjNIAAFUr0BXuMtiaDFnfdYRz/9SB+xDMZhmzrRm4MnqtwukBYHWOitt6kyrK0hCHChRJMSWWMgfrkYwgkBipJ+qR8inqRaEwNOWQkkyjjXGzgrRS2r/1Ft0T3PkPlBpoGRAjxR4cSkAOlpQRcI0NQlumrL7Heve6Fd9P07Q01qhLXQvXiebX3rK1wt6uBQm0sNVYtmIxshHgofzaeQqvDaTaqFhnNBoo9FUv/lVESImuw3pMh5NMmlCJng5dpXrfBiGcvQjubdiSOeBCYFyDDEv2LsBEkEEiikFUWokYrWkupezyCuH1AHE9IuwmNiBUB/gdCO6R51y9ZF3H29wcN4VMuD2RMrZ/3nI63dm2dDjajqQdTHa7jHHudJX9GCCneO/lPzxz/1J6x9vxHe9+AtYrxpEdqSJg128445gQKcXPWNPTDJxClgj44xPgUED8FdA6Hh9bMPx5FUSa2uBJVfMVK0n0drU0ObeGdSB8rM0JTPT3LEgVVx+MPXOoozf0O8X30iupJSfdUkKWIR8ZEKK4mm5rAWLPiRcaYITt2o1EFhBUKSeRVx1Inmw+LqeVZRUIJaG7Zm1F1Ee/Jct2HfLltYhhv34X5Ap/XBeUTVIoED0cM3a0lrRE2LCJJ9rpJfcxEIPI2ctQUBOwDsX3X2JfbRm75mn7/9RrzoFdvDOzfZOy69jiC/SL+oT2u4Y7DbVftee+4V9vXf32ybmhrZ13KsGY+L/+vy17EmWYViojA/cn+eK4kdsHCGI3uvB1dnojxgcLI/3rFn8MPfm+RWrZXgJx0w0XqZTbMQSIUAOEHKqZ36ZPb3LASepRDQkr2j8VHbhSXL0+0JZD9jdmpdr83FdalOBqkiafMO2z0bIL/FhYe95weAH4/8HiIwHmgvBMgw7koLIQpw01w46PEv4mzhMoqW3vhYOxKSFvT3BtjWMzdRrptwJvBwfp31YB/RULnb6ouwe5IXtqOBH/UODudYKy6ki+MjVsbfdPVF3dK4daCmJ5AKYCZVqEhiFOVPzxeuRFwp/kceSPvU+YJqnVz2pqaupjb76Plvcw7xv9z3HVs0p4EYSMXpBBcDUb06qDpQl+lMxu8RUSYHB5qvpNJiatUz/B1BKb3nuisD9hCrKqMqIWItvcwxtkipj7gYLUXaBNFgEFC5TQRBnbQAOO+hXDvr822giEM2aj6lHnmX6yZOkZBAISBalx7nCDVAEUlCzvzQTimjn7on2zIRrSJA0/qWkXe6y74hArh2zLGiwh6rKUWhaTriAgT0wu/dbYue2DFOMIrD23XSQtv0rj/Di9iw7RtqdVW6I+3PdH1NfSbIyJOZ1D5T0zDST7nHl1rpkSZNkzxOigDJB9mTalw3zBNJKCLpxhHXzbsWiJzJNQhmIozyJaEGURxEmi1JHL49XCKi51oP3jfWh4RPvaxPJ47Iy+R5pS5pQoKSta9kkYMIdz6QzO/1CkFmfxxuzrORNtDYYgiNcvY5OSDRC4drbRFMqnOq/nvjh/mhvXcYZzm+B9M3IeqS/qT2XQi0iCMRCHmornr7zO8gaq1Qe66mV5CAWSUC0IkA8tAPSXsGe0UYkKcgbqVFxcTjwTaUazGMJAnRfsaQcFyA0wOcEui9kpTPK/CPAFOHO1IgEZeSAinpido5VAoERiirvXby+zxmnVubLF6JhJ5YRUOoDcp+MU6fvS/eUmhlBIaLOhzsz2BcAb/FxXNsZf5ca21psWWVcyyBF8AYbribUSff191h85HqxLEbGskvwb32fpw6zHMpVmPbQSeiWnDm0U6crJXEUdrauseJqOISpFC8X1sO7LaGihoITPajkTxbv3ebraxfYsVIHzv6u+zeTeuJadRvaxYts0W1snfLIRjxTqtBdb0rb8B29TXZOTUrrLWzyx7DkYTciZ+1bDULPcceaNkEc6bbnfLk4Q5c8+DxngbQeMAGtIh7FTD0iiEIW3gPOjiDBfWZwPxQczLVc58d5tglhawnMSw0z3lyVa4XLiX91fwrfP2k3Jr9eQJBYJZAOoEm+/kyVB2in9iynbggcZvLIX9KTQ+kktTCxlxfuwWPR+V5xVaLBychllOlaCvUpq00ziuAsyekcPyQE1KMbndOa5/lgihDZXCohTJiCDeXY/+Eil3PQJFVlbRZCRIBBWQ90qQedw3GrKkvbrWJIbiG0hOfWW3KFo1rooSII6nCyXZh8tOJfBO/lEsuwgsdiQ+c2omn4Vc39id9qNdl1nn7f/zQfvqPX7UL3/xSe8On3wc8CjwIoZA+qf8JtZHuehvEVddwb3KOQi1qVwbnrlbkBNrM+ht6FIg26dartomSOnCJ70MMkFIQgmygdNUUnDXEmONIkqTyQl6ExOgwHZLtkdZCRhrlUO2sQhWmipElpTNqfXz9gOAQScQ55LK7Kia4YpAXBQQso7rkpdQmQejcvsf5rdmzzeCuCKKufmzzhgqg9Q5OW2LZg5vtvB//YZKjBtkl7XnJC237FWfavuF2iL0A42krOwYP3ZV80vGGCCbBpBcbwqMhjqJuFeg95U9G6wPYfHT2g2gzveKgH2kSoi+aRMyVVAIgtT7IHstHGjKIOpXeH61H2eo40cAY1S8h9mj4QhxBICvgJmtISHioU6sr/HabmMlLMjRHR+QVT0RFsGvi/aNfuh5phVBq5/cAhbHAz4GyH0NyjrgTognBaTXvTD7Psr0sqYOZ4W/BZZixCDjqruyDItU1NSHnAqP8gaGGV0z9kaqd1PEoIInRCATiY7/8gz34nV/Zo7+931uua6jne6KTgbBTC+Fu+OWXE+9juMzyKahOJNUaXU+0MPH88H6xN0EULTh5mV36jle5hkFBecLKl8yxAggmn3sa8zaFsOt8cQmT+iCJY8zOL5hnKwtrmNM+iMlmHqNCCWGUx542QKDgoQG8xUEg7ecsGgWOhcBMcNPa7lbMI/YgKekWypaINvYOtLgtZxVl3Ptdf5PV5FegOVEEs6DH9uM9r76wwmoLymkfJhCqjtv6DmADiMe8omrmZ9S2duy15r4OyhTYkqJ6q86HmURqHem2rT37vF3BUOelVO9c8RACkO0UQjiGtK/IToKBtnoQqRXzux0F3u25EEqunxDWild4hB9a64KqpGbjk5lSl858jSMilmQrl6o6OUsgpQDrBPyZzpo7AQEwO+TnHgS05Q3jHmFxxYitKA8IdzdbvwiA1qFu5/614dFI8YiKQfJdksQpy1aYNli/4gNGrnvgEodfiEIeh1Eeh5O4+1IB82IgyWNzOXhK5fUMNaXeINFpLRmz5koC0aJCVUSAUKkvjUzHoU/rQfqFDpJhyu/vTlj7QMwWlXdZGe5qfY9PZlWfo0M7vXS4yvZM4w4xSrI9zVZLGHKfEFEOV8Ua8mCmKcSBDjoZ+mbrzaXXX2u//9Ytds93b7WL33aNzVu9xHpRD3LVDpBD5yJyKKl8nLpDcNPQD9UoKZe4jHEMfOXVaeY2Ueq3jPeDOlr6yJCigaCpzTIQCtd9T8kgqRVh5DFagwAm2u4ga6AP1bgEhMBIr4hAepYy/pSicOUZB9zpLpcIyIuUrzi08+S4W9ZH4RAW+iWC3QlxpkJjnSopz4DgIMR4qkwzvJ8DV7YoH+6y1iaIeZ4Q4SnS0j9unUQcKWsuCG7NA4/ZhivWOpGSjkpOUdkxuK3xdxEwVIR1jIWj+XOnIkdZt/qvudE/wdqlBrSlSRFiHhDt7I2MYE/z6C/usW33Pml3f+fndvnbXjmeUYin0lTE0XhGfkTImfeCNaOthreD+QmLQ1KtYUnJ6B+UjffJ10Lyw9dRaoUz+D1E/Jm6VQvsjJe/0EqW4gJcS8EdFbA2cVQy0oF6VjNIdS8SmTrCG7C/qX9Hm4R06l2X1EyEjrzx5UKMqe4RpEQON4jCqKURqZixp+e4hIU9AQbVU79+wL769n+yX//613bJHZd4l4LThKPt3fEpL6neTTfdZK961avsg7/6os0//STb//hONA9yraahxhYTlLWyhIDTEMs7epE2sSAaCqo4x/Js12CbMyYahkJcu/zSevYSJFbYAOnMGCyosERhpbX27LbNXR0QXYXWECdeVk6ZJcYK7EB/qz3VucuGOE/kvENJa1yEQSNMsFL2Kqqh3YMQKgTE5UXQHtnahdS8a/c4gPy9YD02DrSGeyxNMRS62d8f6tmEtrEkfuyHEMBxJFCqI0rDUhPG7bvWrW6L+SQ2Yp3CcLA3x9ljVnHqLo0V2E7O023ElGv30/zICCV5NhxT/CrGkoOUVPGm9I6lJo1He7+kdUfyPqXWNfv7+QeBWQLp+Tenz/sRaXOdW46qECNtHAw2LkKkgmazZAUcumyLewfhkLEpSoKhmECFbucxsWGrvK7gx7mERXiIVwpKG5AWIrsrlhDl/Jkel6C+kciz4VYODtzYtlVLq48NWKcLSZ9y0RrV7TcP+QHSzKD6hnJsZ0cZnGXZU7VYCdpdqcSR+Nq5cJelciGCZ2ZtCCoiOoKR7CG7kpJBpKc4l2onPYnkEjGXvU5xh1/18XfYl9/6UfvRh79k7//xp70P6rP3AyBpPuoLCBSJqlHraDc2YiDw5IqQMdU/CKEjjYsYBM1Mk/orJFMEXHoCiaC/TZJ+gHiVEUBVqluBeGZeOdTzOpGwuRolRA3zsTEXl7wgq2eM7KefyaWRXqnfZAlaO/YdHXi2kzGykoyntSRGGIA874XZ4pp/srUYAUlx18aZ9T1D1yKKSiDgfYFO00Z+39Ru13ORoIlY0TzqHTteydcacAO3Oiatqj7ZSUhVSHuJ3m2PY8PLpnc5l7UgxwbZkiQy3/iLf7ac9gF733veayflz7EXvehF2bI+K++JSfD7e++xT13xHvu72/+fldYS8FdhaUh5hEvIK4UALcXWaT+Mi10QkbUjll8JnKSGd5TJkVHgKmcL2kG0Z0qy5CplEilgQ6UJlk2RVNBE/MQLJbnF1fX+ZvvZP37dnnzySTvlFFzMPweTVAuvu+46J/Be+8Y/s4/ef4OV1pShnDBklbj4X1pcb1v277G5qLstK5qDLWuJ7cUBg1h1K8vnohKJOncfXlnb23HN3WDr92+31bWLcMndZz9+/C571anno2aYoC7UNoFvDJXiO5/6I/AdsXVLV6I+TuBdObcQMc6a1zkixk+YWcV0wx4PdeFh5mEAYk72pXpXXDVS74r/1h12TX9v+E3hHAjfEeYqAaGUT1tDeN/TvI7y24OzqyAE74hCOkhES5LzEKlUD0rlE6JqmHdOe3AImp1jJ6O2vph4eY3sW0/jTIkoWJRS2zNL6rOIrnBuM0ocKg3nYmeK9Exq6MlBp1XmxF/andmLEx0CswTSib4CnqPjH01KacTrUtK2GyHXfiP50ZdULYPHBbEDpwzvbjKIF5I3yGHhXHoQI6keC2kPKWzi2lzl4hTmkntQCxxfEFwIqsFKDplK7JaQskBPjSdt4SIcekGCi2gr1DT+OOsPSZ06sDXa1ooeOXo1K2uaCPwH8pBxHuTDWSvG4krotqQsQvhlwJyZL7MR9SeQNJlPpr4WmSH9dKlWaAwZXWGMQvkz707Ud9qLz7dVF62zDb97xB655fe27qUXej2SyJXHS6wSFUhZ4MgRQl1uuRXimrd1qIv5SJf+uDSJOVZ/Dp1EHMu2JA8pUmrQ1ImSgkTrcBcHbg+cWWyS+JNb3SI45nLh7UNiwHHGVwEXsxV4S9UpWxrlgO8tIjRWBQbmeE8UEuBrkPujFOqVbQn1ZK5L5FgQSSCGtJOQnQm9nqKJbM0e0T1JRvPzpM41/Yo8sGyuVRzscIlRakNCdNqXNiRV61KfHJ/f0/f68PsgznbE3dZ77eiXsEaSuOruOIQ8mel/PvZV69nVYhs3bPBHb3nLWzKzPOuvX/e619nyJcvs/Wtea5/bepMVFAcGhEYvyVe8khWJau8QXu9GDuD8pQeHDnUg3CDoTvULLEe5YPVOCM6uAih7KahfqToKow2xfCDWkKQMybU+9/Zv3m2nn77uOUscpS6Kyy67zFatXm17N263eSsXs+cDDRxLjCXi9pPH7rZVNfPt2rNeaKUQTd+755ecQYP23iuYM2IXffeR22wbAWJfd/aV9sDuDVZdiMSJ8psP7rKOvlOtobrC5nBODADP4liR7WlBIoT07ZRFy62YQNa18Sr2deQ2zOFB7IvksrsCFbsC4kXpbNTeqSDm2tsVX3iMfVSaFXv727Df6rMa1O3qCkrRxERFFHvE/ajXdQ71WkOiyqryS13zYgjCZFfnATtIvKYaAgHXF9VwjsDYQ6Kzr68Flbx2bdIOkm7O525sxupHQEX1HrIWtLT0V8hZsZJ2iKBl9+Z0sp+q23qSTNOsQ6lvyqZoBGIxx6VWlIQGH4MYHcqTkw/2deB2iO0wamn2+wSFwCyBdIJO/PNl2GGbnXo0OojDPhrscGSLozupyL2kCPL0FIf0yBfnP6U65ZMbWjGdCEGKsT3EkVTx+AdTCtsOiKC4Dnfp14eC+pJ6mjDg4hnYIgkPy8dAel5Zl1UWDEIcEdeEwyI1iVCR5YruCqFWBHK5dY2IJRmXO9eM50I8UscXqlLJQ0Er5JCKYSnEotpUqfSecIOk+DtqI0A33Mv8fPU/4fb7snfaTz/+n3bqFQQ25DDXIVqKA4tw1CVrplvlOUUQSXFrGenCLklu1QMqr+8hqdshcUkdU2Zb0bVGmIDoGYEbKY9kaQdqMpP6rGO4F/seOa6IY0hW2Z9nOPVyQlm9ygVZjicgmIiz0kfMq+I+SumBGuB7DIq6H4dUzZWyL+IGxFGUAJsjmtPBR8/6WEtCJopBaEQspibVNpPxppbRb5WbapYPRRyp/PpLTrVlqNnFkRZFtlhujweX4IkXn+FE+fGUHqlPxzoJPuJeaxwOK+YrBudcKjgsPCfas61r2aBtuvNh2/LUxmPdpeNe3/ve9z679de/si33I5G57OyJ9pPLOI94Q7nz2MKKkAg0xWxoB8RMFU5GIJKkGpeLfZK7L58oeVi/RJRKUhRUEtnvsMdyl9ogtYVFqNrxvus9UndEyOYRU6q2Bk9tz5NUUVGOGiOSZGHt7FWdvYQLKBq1k+YssKaeDsadY02drfiO6bYD7c3W1t0JU27ItuJQYVFlHerldfaGUy/BlXYldkB7QPglFclD6oSNUn+v7WraZe15PdYnuAK/IuB6VvFJ1oXDhF0HD+B5rsjOrFlsCZwkdPUQYBe7oOaODuqtdyJnBAbPvs4WgtJ22LK6BWhsVNjBgS6XbO1rPWj76dviqgZbXF6HZ9gem4OK3+7mfcn7c21Jw1o7ACE0BxupltY2a+xosnkVtXbygsX2WPtW2zvS7nMrBtIAdnjG/u/vpIjkZNLc65RpYG9cjdfZxwi3oesoKSaY1k84KyfuR88lEZJXw1E8045yhuSwR/seKC1A8AAClQEbwS0qMfs9C4F0CKSfyunPZq9mIfC8gkAq0hP91rcM9xVEUKjl5G1WOBNIMJKkfjhmkmgEBJStlhO8ra/UejqrCNzX5DZIgfRSDhBoiKQYNh9y45yt3lTgluAePBHvhvgh7gnqBd0isJJJG73cUwdJQ6gpqk9KYnH3mMcdmtV9BV/tgagLynWcAxwkebjJkuQi9D2qefK34FHsRvFTSzV0zATj1+lra1i12C5668vs7v+62e76z5vsL/+/v0YeE9RrQk8n2led8uxWn1fpUp0mpEkjLgWSfdgwxOlM1bqkOpVn5bGEq7JJQjgVoaGxagRCBlpLUEuBMK1pR1WE87o7AQFT2QeyMGJ7sXUrHQRxYwbEQfc5hkAaApErpPY8CGbFKVJMEJ8EcSZnlOCWMydduOeVdFPz5Cp/TCL+BpOE+IwqIpMUcSD0WSsa85EkjWwUROj+97/RTvvJb61s0w7Gi6fB+XNt0+svtwM1IK0ZhPuRtPNsKCOpq5gLiruj91sSJFexYYrDqpjcy44DLZYoKPT4XpOfPvfunLnuDGvE62TWpO0EWMRq+OaFGG4BTgSbHTnIvgBOn1uKVBcbJYTBAlzWKqa76ZIjrSXnOrAvsfZjIPExHBZkq46cLo2drs7n0jNJSgS1sJugaoYqmSTOS+bMs82P77ZOAuNuaWmEqECHGzXdfR3NNq8KYgSpz4XVp6E+NmKf+OV37NVnXmqVZeV6TUH2Y7YPT3X/9/bv2e4miKCiEtvWtMcuXLrGamKltr1pn/3XPb9ApW8Axl6vnbF0lf3ludfYTx+6y/7n8bsJCltk77/sdXbXpkftqQPbrDJRDmHW7g4k/umV77QzK5bafz94h92+/n6kUQk7CJH0zkteaZevONO+cs9N9vstT2AzW2S72/fb2y66xl6z5oV2wx9/Zbc89jvchJfZnvaDdu26S+yqdRdYZ9dG68Lpg2DQyvi0YwkZ1TxnJt1r4IzbzvnbCoyiXArYoPM4yJzSSwXHJGFduoMSmB+jMCHHAwPTsv9mjbNrpheevZqFQBICswTS7FI4YSGgjVcOCDLdCGcDiDbh4XHiKOTI43BvKOlFNa6KzZ8YFYUdVl7aiheqoMokZFdIb7ZNP72NEOumB26fULV8jFPLUHdQEtKWQAoVpEfZa0olAHQkyPuc9vweiDqV0PZfDIHVzbWQwemSI4dgj7s3b7P7b7nThrBJaThpUcoYpI5Ef50Ay96f1PrnrliIp6UCu+nT37Q55VVWWorNQ0ptqXnHf1NtJ+6/u7F3UX/E6ZdXwKkQ1/FyqhlMYfGaFfydhCoJ0j24k/3uKWz6vsobYVcx3MwCCDX8NAwi5BpFepSAQJImfitIotRPJGEUfB25oUr1Sc5A8pBAyNha9k0z6WdqnzUnUjXJRR9fBI5qFWc5dV5T82f+VnsF9EEuqx3xl/reIeY5sw6t1Uq8V8n7o80ds/Xvfp0Ndo1Yy54hK56DSmpFL8b0uOvl37FJQR1SszLTcR6bdkMtIiLlQVoqn+KwyzVzZtIdjVZkq94aGZWXEHft+ZLGJGnOMu7x8SVBklcMClkMUwRbEV4Hw0EZXvBQxdoJwVQxZDE83sUKeYEOY2nkwYwQ3EUoyXNYIW3EiGPky3+8AxM/xqV9E7ey/rr77rutgECx55577vjzvr4++/73v29lZWX24he/2IqLpSsY0s6dO91xwtlnn23nn39+dNvasfP52c9+5nVdc801lkhM2EE+/vjjdvvtt9vatWvtiiuu8DLr16+3Bx54YLx89OONb3wjgoqkkVd0M/ktRwZyTa6kd6ADyfnC6jnYohI4F+nNEzu3uUSptqzSdrUFgkdTUltRadJIc9tG5k/3pKKoNXrrE/dZP8F1P/SKv7CltQ32yZ/fgEZCge/XP7j/Djt17mJ7zbrLrLGrxT5/x43ELcJxA85wVtcvtve/5PV2UuU8u/3J+21OabV96Jo/9636nTd80nbu34ur7wG7+ZG77X+/5A12ztwV9o2HbrVfPH6fnUQspl88dq/95cUvt6tWnWu3bLwXAqwPleke7v/OXrT2PHvDaVfYPTufsif2BCcwYoZ10V/NaxMq6628j3N403x/SVlH8KNsC2fBJvJ0kCdKWjtyYpGukB2eSoNCazUHtW15QQyeJZF6igHFX2YKnh11N7ngMzPMXp+wEJglkE7YqZ8duDZnudTVfjzl1ph8OH5wj2fUVj5m5QVDtqb+oB3oxY6or9gOEm+mPNFBML0elwqojalTktgAOZZBrJLQxniyMZVMQNgQOWPq/nmpzA9JY9KJJBGBJZwNIpKEPGfrlRDBCgwN/uOvPm5NWxqtoX6udXZ02vJEfVoDAkGp15CtlrSsXBTbe97zHvdUld9KybaOzAxZr0sZcYmTduExPNas+TJv9vT02Le/8Rk7+9rL7CqQfEnDNLtyp3yoJGb2UB7ueMUVJzlzO4I8iIi4lXIvPQq3V847UokFwS6Omovi2hxJEiSF6oQYKjPHNdWu7Jgihw/wRVEVU1wfcahnMj+htyL+ZPNQgIRPjiTkTGOAMcu+IScPz4BHOK5MWKhP0Xs3Bue4H076eAL+wZuZxj/zvo+XP8wfWsdDEKJhnicK675ad4IY+7QCkCqp8XRIpHIiJgFE8ya7EfB58W5Gy3Ga0cL+1QzxDHKe00BA2vyZ6ypJ+s6W5NIJEWk+3xlTrnsKvjrIHAXGwfTAf+ihh+zlL3+5feITnxgnkDZgKyYi5rWvfa2JUPrc5z5nd9xxhxM+X/jCF+yLX/yivf3tb7e///u/t6uuusr+4R/+wbZu3WoXXnihXX/99djv4IwDdUQRRbW1tfZv//Zv9p3vfMfe9KY32Yc+9CH7wx/+YB/5yEessbHR7rzzzvEObty40et5wxveMH4v/QcSX9aVzh+tQb1zbYQ8aCiZZ5XEctrY1mi78WR3XvlqW46Dhts3/9GeHNlsZQnsN4tKHSbOtGPPkBtviZD0vbNpr53csMhjGkkiVQ1xlYcxURP2QI2oxjV1tiFV2ucaAI0tB6wNiZMcyyyvX4iqOMQK1K/sepfgBGIM1TRpNChWkRh9W/fuspbOdvvBvXfYz+J324GuVjQouvDWGberTj3Pbrz/dntw59N23oq1ds2KdW4fdeWa8+3XTz5km/c22jnLV9vrz73SVTOj/URTrkAP65GZl44UGvwpd87h+4Qk8VBI++lfm5iOvg4pwG2dZ1oTIgpTbjvB704//CbnIFIm2bWGXSbKOTETuqNg5lIXlSr9RG0TeWZ/nbgQmCWQTty5P6FHHjbGmNt+ZG6bQuDEodLB3N0ft7YB7JM4+8uxD1LQ1oA+CXzhRI9LklQ8YnOK29DlhjM2gKc73HSXQjxxvo9v4KkAF3EluyFJeRQMNNQUnEEkQOp1XQjnL4TBTS05098ikoTNSJIU1O0UMLGU6y4IMtd9pw8RIireXSUGtTd+8N/t3p//xhGDmbb0bMwnyVsPgQtf9YHrnUgSEiabn2i80/U5E2FOzzsGMSsiiLXgxFfyKRMWxy046I6rbqWXObyraC0cqpQjkKiOJCIVSy8gzmqM3qVq6x+qpiAlkTRFRJrqjYO4YRni3t2GgJ0UWY42aVwi3hSEWPKxHhnne3s8oA1525K7bam95cmj2XFI2WAtwqiAP8FRzkEEj+DEJRi3H6pbra2t9tOf/tQR7yjvdBKJp556ym677TZbtWqVXXnlleMSB6lhSSIi6cQrXvEKmz9/flSdSzh+/OMfu73hK1/5SqupqfF8hyvFGK8w+UNjDTKJzCdcp2yUuWyI+XNgJuSyi8m3CctD3P7p350sdXLLVRszHumeJKLyNChX1ocikD7/+c/bZz7zGVuyZElaTd/85jdNUpx//dd/9fuC1de//nV797vfbf/+7/9uN954o5111ll+XV9f73MmoknPP/zhD3uZzs5OLyMiSsSVCKQVK1Y4EfbqV7/aCSR5Moy8GfYTT+uMM86wr371q9OqY0oVOME6l7c17cddoz0Qobm2ACnSAxAaGruk7rWouv1i0wOuwnbB8tMI4FrM6wJpwDsTTYneI9ETsuNyT4yU1RnmGfiW05E4zLa1C5fbKqRFcohx7RkX2Zq5y2wDDh6GWWtyxhAcNEAAc633PloNWhfDPK9Bne/ClaejSodEjQbrSoiTVFxmbz7vKnvB8lPtge0b7Ju//R/bsmKnvePCV9h1p19sZyw4yR7Zu8W+f98d9sj2jfbOS6/D5paDKLmliEV5AK2Jg8z3AvZQeVqUipwkttoFGnDW0Y8NkhTVc+mTzmLZmaLsakM8U/Bjee3bPob7JBaiHI2MYm8ErwtCivhKrFGnpNJWRrgAQoxz2EM/CG59uMEXuSrCkA1wNp3gEJhdAif4AjhRhy8iSOp12vhTk44cebnDYtb2dZUgGSphY8ZVGZ/BG1xq7ui3uOKoX0FulVF0fukgBBMOH4j9ER1gUU59qw2p+HTh6S6VOJJOtYgjvZT5SAWKqPFokyRJJRyMcnLggTFh/9bGiz1wa5G3FcZfjsejkX1d9sTdDzin9Wjb/VOXH8Lo+Pc/+KV1NsvGQip6uHlnvidQiqProbiuQkomEkg07SjWi9qbPh3q+fSlo6dau0KiUpMQS/nFywMxSO1dap7Jv4Nqn6RRAaMKuEFCKioQTW1499PaP/S4JtecfkfviXAVOT5R/BaQIDrphtZCEpF6KSlGzrGaJ69whh+CZ4L3RQ5KCrDZk2GECOsIjiIgM/eLzKpFCAlp/va3vz3+SBKJk08+2TZt2mSScixdutSampr8uQijl73sZc41F+L+mte8ZrycpBhf+9rXTAi3CKdvfetb/qwDY3qphD399NO2a9cuO/XUU62lpWVciiFJhv6+8pWv2N/93d/5GMYrzfZDA+RPJHFC6m4uVU9fV5OKRUARMtqN5HQPoQ9aUG1KcVYyqcwMbwjKIqILkVqoF1ojwWvm1BUsXrzYpTynn356WqYHH3zQzjnnnPF7chEuuDU3N9vevXtdTU4PS1GdFAEqyc9nP/tZlw5FhQRj92zIu3XzzTc7cSRJtQglEVeZSRKl8847z4nazGcT14GgkS/PavbhBpwUFOAoaAAmzpI5823b3t1WV1RlZSUlVl6F5zgkQU0dbdZQWWVjOMmQhFfqtFHSOo1xZqxuWGpb9jVaC2tE7tEPdrRaz2Cf1ZaU25zKSuxwcuzU+cvt9MWrqAfoAtwx1NH07bCmQn2L2E1NAzDyVjYs8Xe2nD6dD6G2oBalOAi8Az1t9tGff93X2fXnvsSuPfUi23Rwpx3sarN/vuUGpEzd9qa1V9irz7oMJxN7iZUE4zCjAbFztuA1dAiiqECqhwSRlbHbEAyTuYO5diHSpUvGiu2FOaV2YW6ZnZtTYqfiBvz04QJbO5Jv54wW2MIxYhTyjsqWTYSmGB0irCWpmy6JOJUET+/3KJocIwMQisMwESESAetsOoEhcHzYdCcwgGeH/sxAIOxbAeES0hI0sGfaFogASIA4xBPoTyiruro4DErYqE+uEIIo7iUcdJC3bhwuSB1iqhT1SZuqDnk/aTIy634/xFEn9jVK0aEkjlUxSLzOrDgHXbF7essofESXuHeG4BPxltofcdmE4kv9QDKPEhxDPLxpPcjbMkfWjqipZ1GhGAf3meecbXu37LSymkpHzIsYo35InfFQiK6GElAGgS06wadUAABAAElEQVT9lNScae0IfUt9IrWhhOCMaoqkTJlrSzVxdMO9BRGiD+kE1uEDTwSNuNCZ7WiNiXMaiJqZ1CvVPpARVoT86Tm2DGJRjvvdMWJ+PdXeZYl6OLOM7+gSiB1Y3TBIoBNHaomXRXFQhIkI2RKBJy542mI9ukZnVFrzqNFpTkcHA2KkAJjy4CdnIdwmTf3u6+kjjzziKl4ihgbhREdpKonEBz7wAVfpEhF0+eWX23vf+15717veZZJYKN6PkPDvfve7Xs26devsb//2b01uxb/0pS95fklMlObNm2ePPfaYSzAOR4qhfUpSOyHSWkO5IJb5MFMkXYhjEN/HGta6mDIBm3i53hLmECcOQ40YwleMWv58VO6OcKnovRSRVkAfHOQ0rrkJNmKpb1t6r6699lq/ofWUmiQxuuGGG+wlL3mJM35+8pOf2LJly1ziJiLzG9/4hr3jHe+wu+66ywnYHTt22MUXXzy+B8p2Sep10Tyo7u7ubieSJClUudTU1tbmantPPPFE6u2sv/GhZitzkMBAmkqicgAvbYL54up6tx86beEya8WL3CDBq9fULban5i5yz3F9nB/avUuLYKHxzuQBr9IEUiXOqUtPPtMe37vVPnfr95y4au3psvMWnWyF8QL7s7OvsK/de4t98KYveeiC+bX1tgT1vQSxkzjkxu2/SgqLcTiU8HdR81GewO4OZt/J9YvcycKX7viR3Vhyu3UP9Np1Z11qr1j9AjsJ1+Sf+eV3rQZnDO0DPfbGc19si/C0t27eMvvqnT+17yduJ4htl7309AshYOJ48MM+lrmKpId67w5CIO3AinOFZEPAY5Q1MIihoIhTncF6QUVX6b5YKXIbLpVnUYpiFK1k7zpArCPZNuXRhs5RLZ7MNZE5GSI09QbonR1FHdF3daRSo8zFbDqxITBLIJ3Y8/+cHb2Cvoo7FOdbqgT9qI2JeIni80SHa+oAdXSKu17IxqnYNwH11d30VAjxEEM+X8CmzFHP/isOey4qHzkQNhLmTy6TXkO2K5VBakXbkRvrCAWQgbzcgcvoVGoQJXCxn2kE0REi+lPkhBiIMP8Ud6SyqjJb55+T96QbP8FmTapJyR8eiyNVcpdtcCMQw539BHEcIshwfi8ISCfQCrMiokQxlLIlcTCLIZNycgfc7il1rQjZiMEZLxbByjqQl8MBHfCHvZ6ohzWjtRSkPpN7IoaB2labM0myO5DjDdWplSqkopP+7ePe6DAoA1oqvlSOZOknO+D1isjgR2qv8kQQAdNckLA/VVJ/BDHtH3L9q/dd3q/U534IugFssGS/lzqfmX0VzGTYL8nEpz/96fHHkkgIyYuSJBILFy50QkjqdVKt+/KXv2xr1qxxqY/yXXDBBfboo49GRUzOBCJE77e//a3bx/zoRz9ypP9tb3ub29SMZ+bHzKQYmgrtcYyZOYgB/zw8Okp9S7AIKo8QxtzPOjeaR+xW4ni6i+ECfPBgcN4w3A3CWqY5Tp3l1N5N/Vv9GRTiTB+0H3rS8pi6yLRPZCv08MMPO1FUguTj6quvdgJHhT75yU+6hO0f//EfbTVxiWSrNGfOnPH6JIFTHqnVVSJ9iZLq0RyLOBIxpfmMyklyeOmll7qUMMo/1beYJWW8yXFUSjUL9egMDBMsvK+s1j7yiustUVhoe9r2WdOu3XbOspV27rUEe0Wq293XakMEkf3ry1+LPVIR6zXG71dbIR4WhxGWvOeyV9vB9lbmM4YtbII5xb4mNmz1c+rsH65+qx1obWZt5xEzqQbPqfl2zVkXQTARsBvSogtp01te8BJgH8NFOCExOJf+90veSJDpAtvV12wvPeMCO2/ZamyROrBvqrDK8jI7MNRq773o5XbtKedZG0TQvPJqqy0ssm688L3xlIvssuVncL+dvpZYMV4yH+ne5k5pIuIoFT6P5xA0AQnycqS4+aKGkhPv6oKc87pUOakA6p2Syq5W6yDOPgopVwFh1ZWLcx+pO+MIRGmU9TRdUp39ePYbRLIlDqXgqX08anu6srPPnt8QmCWQnt/z+7wdnVxza2OLtr4SDMy1UbpERJwluGw65AMRwsZKZsWakTtlIbhxorknpNIAYii962CTE8AlrrGIr6hu3dVvSXm0UWfGKAqlDvWp3gbPcpJgTBBHcExBtmV0Guf7eBBHqT2dDuFLzfdc/S1kV3MXoB8RuhCEeHqTDCfcnzy6XBwIJOJ91osb96Z+eS7LsbKiDtd3V5DEUdaXktwTsyjS66FSeR0cxpmDJEXRU60oslIoqQZHLhFS0v2fyTxoHJJbSQWqgLWSKcFSf5Qc0U8Zdbg7/adUBuXtbzRP6qQhdTHEnRCIxcDQBvkrpAfqxDFMkmTmsPZnMv5j2GzWqtSHYea9QO6mk+sGaoH5C4jWADCaDteS3YmSkOeImIkaErGllCqRkGG/PKpdd911jlRL0iE1rx/+8IeeNyqze/du+9jHPuY2M3qwZ88e+9SnPuVBU9XOBz/4QScC6urqvNzhSDE0oU4cIYmIwSBRcFAhxn0E1HQ3yNTIzGOwr3nK8rYk14P6GieQWA4I/vC+/5+99wCs7Krv/H9q7z11jaTpxTPuNthgjLExYByWbGghIUBYCKzzBwIEyC6Q9YbFIcEQUwJkCRD4Q0iAhODFpDhOgNBMtcH2YhtwG1xmxmNPH/UuPWk/n3N1pSeNpNEYU0dnRtJ79557+j3n9/1V9slauP46flvgkdTIBX9hB4mTmE7QVVEJAgRw7+RQHOreE1//m6vjzM5tCz611MW2trZkC6SaomP9tre9bQbMKEH61re+lSR13jv77LMTkLK8K664IqnQCYIEsyYdNvzHf/zHjOrck5/85ARuv/3tb8dzn/vclEebp8svvzx9PtovY7Wl4eFXBp8BqYgzGgApk0hC7hw+GFvqS7HupM0EZh2JAuhncghwg8raztqD0UMsqrtG9AKYhYEYHCDoKiEDOgst0dbUkMI9dKOpAJaIwwR0HUWttYNAr42tqHEDQG8e3MH8EKi7pjntS9uHDqRzaVWRwLHsMZOj7IGck4LjHSMHCCzbg11sIbkML3Vim4t7hXv6D8aG4bFYW9cXm5E8nVBopS94nMO9eNfBw9HA+G9qXxtbUBNUdW3HoXvjgamutAfOHx/HQknhzdVDSJPKcdo4DiJYkEoTTe6jVaxRFkZaGwqV3EvHWZsHADb31ozEHoLWqhmhxEzmkQGy57+LM3tYGvxUdAqYKzOtFiBYucwrP2c5V34fTyOwApCOp9n+Jevr9NmceiVx4waqwXoJ6Y9qMZAzacP3usDGf6bEWUPZKUmgNArlMOjD0jjnNCVXzhC4leWnB3/sX3KoOa3gjOXtLSEtKkHs2r7cJurhr/fHbvicAh4uV7p5oR/60IfikksuSQTM0NBQXHXVVfmtmb9PeAJqHKeckvTXtdu47777ktqM15ZKM1zomUyZ9EUnBONIHT12F0oerKW6kVjXtie6hjrggK5i3YzjqMPYVqh46FDAp1GnU51PLnuenFvV1bQTyNec92bn1ToFS0qbiK5UM5Y8KAlsFm6NRKpqT9iHIOERJM0tL32d/pVJBAT8i5VVmdvPG+/cHZvu2A0BBhF45qnRdy5xViA67FI98blqsHmY0jkJwLCyF/PLecjfaWjlOD3kch7Cg3m9ztls8nM2RxJINXKyvZ/A0myuY/00XyIhkFJNSymFUgdtM9avXx8Cos2bN6filTBpo6TDAD20mQQOEve+NyYlSJ/+9Kfjda97Xfp+LFIM1ZB0BsNmiBoxEnh+RlnbEovuSa5Jg3lWseaXCgwrcKyGSK1Zw3txH05CDvD+bGAUIeKXk8y1tbQ6Tq1bH92798ehfQeic93q2H7r7fGW110aXfsOxhnP37qcoubkee973xs7duyID37wg8mxxZVXXjmzv2jjpfMGgU7u2W7btm0hyBHIXnfdddHe3j5Tnu7DBT8CRefCudFLnsDKpIqWqnVK/46WVOOcPDwQXfu7YnfXQHR0tkZnxyqOBthwAJlVMHAI8RrrawnkSqDV2390d5y0oT1WNTemeRkfH4mdAKUxgEQVz9Rps0O72gA3a4stqIjDBHLd8g67z2wurooHkDztGj6ARBTX7DB2Gpj3DUjU1wFCe7ABHCYobRm10t6JgXhk89bYWGoH8NIO3v/tA3uSA4TRsSGcFmWe6ww/0UIFm6cAFVwfGhtM3fadGh4c4qDVpg3tjqHDCVw6x2sAview590DCMoFRK4d3zOTf/zZDSA8gALAVqSRWzmrWwFJqhIa/0nVOiW8Q6zLHTB1duHhrodA7bJEq9nXqTKp6Fmmb/LcVxvaQMTIzRRc1/skyy4zLtZt0kmE9ki2beZiurPy63gagRWAdDzN9nHQ15zQ0UjdxZ02yIp+J1U5VJwkOM3rhiipm4OjBFQgRL0+/9n53yuKXeZHiHPa1Yqt0XCSLOjGO/NYV4tqnYRv3v5lFjg323QDU9vznX5ujh/728PlSjdviMShHHCN0+XiSmRoYJ4nubZ6mhIUCYae8pSnJP1/vUhpuC63XWJxsaTUT5BUaUvhwan8ZWR6DSz2rNdravDc1HQw+mqaon+oBWKyC9AA0QHBOOVBzcE6X/1IjuUYh61rqnIanFulRTrMUEXO6ZLYqsfYOHczK/ez8pnUBvIaByq5o+XCUuvQAz1ZN6WT3aeXSOR5wpXfiq0/2EGhtJVnp265OyY/++UYa22OgS3rY/Ls82MvhJRxllTDm9+2JUr/ub9lXzJHANoFZntA2hmg3JRGZxIT5UfkhKYqQ0Q+1PdzIYlE7pUuN/Q3Xo7rWlsmAdINN9wQ2tDobS2XUDio3suf8bsE+ve+9z0/prRcKYbvQYk63fN0T1+rVL0OtSyulSHQJyASx+nzCAR7ipm0mBQpr5j1U1Nkj1sNc2Av6+UwAZ4VamV4Ps81+5f6HWOdc6wvtMfJdWvji//47/HDm25OEl6lNTsBNzIgfu15vx5NLdP+92dLOOon7YuU0DleEsaXXnppUmX0QfceXXiXUGWTWNbOyL+CoJ3YInV0dMyU/5KXvCQ5ydDNt97s3vKWt6TYSD6TM2nuvvvuZNtU+dxMAfM+FBjjrdjt1OGhbgTbm6iuB0gQgI1UjZRkFXPRiMRIa5u+nsM4aWiIJqRJztUwwOAgbzlfEtMkEfsAHtdmZ11LFJC8fO4H18f+7kOpvAIS0UduOjHO3/aIqG8qxM6Rg3htq46tE3WxcaqOkA1IpUUrSKP05FaHGl97sTm+8v0bY+eBB+L3nvKcpOEgw8dNoiZpO7Cv8l5sxkFCI/urm1L2vmQAfgyX49pI1RTxWAnw99EEtllPpzKffTzda+B1Hs2YhiI590vaQVI6Poo09/s1g9FFfMAz+onHNpiRq+ZpZCz6AfOHSxMxCEhUAud76po2jbGmdDCTf08X3d8s33VsfyuS9pU1MAvMQbGoFSNNp80r6fgegWzFHd9jsNL7X9IRYD+ck9zASwARefA5oeOmLXFkXklWgUp2f86jD9sXN3clAbUcxPlxkNqVqIj5LV5mtdOPKZfSvbMqgEni4DFDn5dVKpkymdviuR9OV7oSEQZtFEwUOJDzpErMJ+Dg5kliRDe9Gp/rfcrn9PZl0hOYHOElARIHn4Fcx7EfmT0SlSJhGA1Y1WHG7PW81rl/VbdrRb2uUDeO2/fGaGwYhfsqYcehqspHRXJdKT1K7mYrrucfJQZUsZzrIlyQBKEK0TKUbOlmgYhtE9Rra2dafHbS7ZRD6ZHtcK0tlbbeuiOBo2oI4TxV8blqhP7xU0JF5qnfuz2+8ZvPjdFTN8Thyb5E5OR5f9J/l9OHH6cNerlSXVFaSUDgqGs4P2XQTei1fG5VwdX1sFKVh5JczwtJJFpbW5Pdi97pXvOa16S4OdodGeRU6ZIBSpWmXnzxxXOqFSwpMVLqart0963zBtOxSDHMr1v1FEeH/mZ7IvPPnjGBZFQ4WCphL4fkcAgiNzGR5lCcljAvMUQGjp2E0VHuxbsdoQ4KbbwjEKVzEuWMIDkZ7RmI4qqmWL+pPe6++fb4wU23RBtOVT7y/g9FN9K11agNvv8v35fsZm65aRYEzimr4kvl3uFl7YW+9KUvhZ7/DBRr3/LkuDreeh5038mTEqfFklInJUuW5/xVJj3k7d27t/LSop+V4Ez0jMa9Ox6IoYGh2LJ1MzGM7o/v3fTD2Hj6CcQ7qo89P7o/zty6PjatbmVltrCHIf1gTu5DYtKLloTqvf5TZGKv3EsNenqgpzu+TADXR285NU4ChGnz+vfXfyHu2rMzfufCp8VmxqGD/a/IviIrcAKVygYcLjx+/ZnMOw5esN3cUuyMb+AgoVdJEOWe0byJvNr7TMUu1O32jfXyfhBcmnOMpZKcJSRAwh42ytzX8l6VCBCuh7xxpD7Z2qIoGtqMNOjCCeyt2EP7WH/DgCl34cNIqh7EUUV5eorSvgfA2oGjpJZyMU4E4MrEsbOu21V4u7sIZmMf3x9g37wfoNnNfu7zOm/o40eHI67b5HVUlIZEzDbU4YBmftKtuCmBI153toeVdJyPQLYijvNBWOl+trlKhC7lfUeO/XL1q3/SY8oe95CSm/xMYrNVMC8BJPepiDpDE7KF+emh1jW/nPy7e7y7fF5uAkwedA8lpcIyYNSPMbke+AY4LPSS14/aoOoUHA9Ll0wZmKgmpwJLZdy69eFzpauakIEYVW2RQ7xQ+u53v5ukR3oBM+kd7Oqrr06fVUP63Oc+N4eTnm4s8EupgBzJ+Uk1uyOvzs/Fu5EuAWKwSWoq9SU7jSoIA6O0z08auOfSo/n3/C6h4HqT0KhM2r0Ze6dJ4+SKk9lcSr8Er8tpq2XKZV5O2nbLvahOzW2Hz+VPC5yqmKfHfeWL0VxbD6irP6Ldy6nnmPLQnKTeotF1UoOteF+PqaClM+fcZpkjw0hItH2ohnLSTbXEl2pl2jEO8A4N807pIaySuF669Ll33TPdVwX3luFPDmj0SCfg135J4luvahr8y4yQAaDqXf5MPUSzSZW6E044IU477bT0o9TJd8l0LFIM849DdNpfKkmEpOOg45ARfrS5knj17WnGq5n71BH2HBYyL9lehEEElEVyu68YEwOsqIplprR08EBvDF1/f6y7qxxD39gZE4cG47vXfSeu/cqX451v+bMYHBqM//HWy+IL3/xKPP6iJ8ZXvvgVYsvNegacV+VRvwpmbNdCqRIcLXR/oWvzwdFCeZa6pjTrum98Oz7x1x8HGN8XPThD2bu6GOXHrI+D9ZMwSvBcd9rGaGlrjD1IM+7CtujG8mBcO9UXd+DIIHnJFMizL1SOrXV6sjTXN8TTzr4gnnHBk+JlFz87fu/Jz4l7sAsaHhiMjXXtcdv+/fE3t1wXV22/JQ4ABprbtkTtRC0A70B8b/udceuu7Wm8xLWNGJN1ImfasfP+aMEm8dT6jYAlQDPtGgEAKV0cxNPeCGBdl/0TgBDBEQKhFF9Je888KR3z/VaBvRWAtg5B2CmoA55SronHTRTiDOIdGb8oT3VFVNDrCzHEWiog6dPWLZP+wAQEjLlvtvDePqKqPp4y1RxPmGqKLZOFBP6Uxet9doL3eFKbujHfa95zz5uFl0JWLe1TXbQOO6alsuVtXPn7yzsCC1Mmv7z9XelZxQhouGr8DJMH35e//OXk6rRS7zrPLkdTY1S5ZD8PaRRgI9jJDNWXuY3RR48Uju7UBZ8SPsipqkdylLk4nu1dzq3yAMqeVObOFx+s2MRnnzjWT5alhINeyNaaLtuil18Fwe3oxZBE3PRzPmsy1tIoB7G2TU3JBVkGyvKm53Xo6HsQUFWphpaVMPf3w+1K94UvfOHcCuZ9+7M/+7N47WtfewSnVm78K17xiqTa8sxnPnPeU0d+VZpmjJBRiJB8bBIRB2dcKcJi0p4jS2Ll4HihGk4lssaZsmbysb5UbxsDAOX1zNxbxgdI8KQW0gBIGtC4Oq1VV0VmU7cclqYzLKGfzfTSlRYwrj5aO73fiNvpxq6+GFvVAIjWW6T9O9qTS9e92N1EgLtmAUdNMCysbziB/HzVLvbksV0XoAoClJumxNwpjZkqK1HSVjBTsUu1QoglD29wrJfTbz2l+ZOnpSQSJ598cnKwYFwe993cMYNOGPxZKKmKJ6jSDbjjpZQkT8cixfCZZI/BX7GDYGl0FDsMJRL8uPyGkRzhZg0vZiWkphCq2HykfQKil6rTgymvheWJ60oXJtfznuzG1u8QK7vAPlsE7FKsnPqhfT1xxppNcdFjz48vXfv1+MePfSo+8u73J1uVR59/blzyV38UTz79vDiptC7GcQk9iGvtfycGkZKzX5Ykof4bz/2NOP+pF2FDMxyHu/pjgkje/RDo46zBA+wj49GDCp72SOwCHFu+dQlAcGYocZZR47UjEnMwhi3ZILZBGTMAUMIeqIbEp753bXz7vltjW8fG+O6Pfkhw1+3xlqf/f3HTfbfHn3/p/xDvaFP81/OfltaE9ku68/7AtZ9Na+3MTSdFNzZKrjvfnH0w5ToIjl6mrUP9MHH0XkiD9C43zhqZTNKjrHUZ0FdCg2QHVU7t3ZR261FvEiQ2xfo7A+jk6XwnUjJV7CxML3x9nPeDSItaUa2bQO3aUAmp/+R1GaqmWQVzYz2N2lhoiC7asJu940H26j7sk8p11ANAmmLMfHaxlPYf1q5qhAxcNuCLZV65/ks/AisA6Zd+ihfvoOoY6mbv27dvJpNBDpdKcjR/5okd8cCQXsYmADZyuJD6JFepS7dMQjPjZXmk8I0/qjbpsUfPZJ405jEJjiSihvEJvZ9AiPuGiKHDAzVIETrrBzCGzXOm7Ev+SkpuVjl9lCXCgm+JIKbd1ZPad9g2PeoZ1FQil9wcDllrFik+tVGtAZVh8tJn82bEnPYwuOBlw1fNoLc8BBGuISt3+ZEAHQI4qF+ux7Ul65stes6nH8eV7pyCKr7o4UtbJD17zU8veMELkm3GZZddluwLvvrVr87PMue7/TQIoya4lbMm4aAUSfuLI0dvThHpfppCPnmIcuQmO6Y540WGauZTTrvjWVlXZWl5OZXX/JzNYabmVYSYEfTmKanNLfZgnskyyCMgdO4Xqz/Pvu+k9bHzlu0QUhPxRFwAL5WUJOlaX0lS17iRRn4ySVuAEjZaAiT7wNvhi+CgP+wVVg7nJMScRJbMAjcJgUoNDlxcO3ka6u2Pm797U/71Yf3b2Ymv7GNM2uz9OMk+2mfVslz/KWCvhCZjXQVH3zTFOh5jT9IDms5kZEoJpFRDnDF2Rw0qKyM9kj3HGNaxOU+tg4O/GxXXfZNx8v6747Sb7or6fgzwV7fEN3FV/Z7rvxOfueofY/e9O6OIhODZv/WcuOx9fxYTqwjFgA3OnXfdiQ1gW5x+xulxHQy6X4bkuN19z93x6HPPQUpRiB2D+2PH1EGk+EjrAA5K1wXvQ9N7iHR6gkHMUzXEe3JBzdzNrsy5o+KSVW3yq3fdFNsOrQfkjsW37r41LsQGaXVzazyaYLJPOvlMPN21xf/dcVd8/LovkGckrfWzN58c73j+q2JL89r4yLf+JXk0fM+1n47hkbG47Bm/G921I7G990FeEU/HqejnbCmzV7l+PIcG+oZwOc/+h3reEQ2kXZOAtrTP8bmMpEmQmBiRlOB1VV1Ph5mnCvptSspYb9rGDQJyvj3WHxuQDm1BBbChkAHDtCsIKKkvgRvKgBqI1XhT7ITlqXTqhprh2M+1ySJr20bxf7Hk+y4zbSWtjIAjsAKQjuN1oE62Nhx5sLu3vOUtM+oblcPipqEhq8EKVbP7WSc3xfu7tkLcjmGsCVgBKHU04J4X7r6HQ/Les0gjVScpw5nKiEd/Z/+USBnvyECfbuEHR6piz2AxDgxCqGLMKuVZXzcWa+CE1inaT/yzRSqpuMzeHYMc9ANjGKtCaExBqHu4jJYJgldG0QBwFJOCl0yVyr/NuFNeV09d9eVogHvrUWCf5yQueFXtbRW2Ft/z0SkHBFhGL2obXeUBPs3PnV1RNSw7pubUdNQvD9WV7lIF64lL4+pKg2djwajjb5R67ZZ+7/d+LxlcS3BUeiRaqFxBSwNAWpsjiUKT67rOeBlIkQQgiyWdIyhpkjBx5NL8oV5CuPd5IInyyFeHBGiYWRkBeApd58+eq28MzmsRD4aW6NxiXsB6CNQ8MxW5EsC9zHpWlUaQIOhZTspBhe08Ys3MK+AaNLbe94Uvs9ZKcdtv/ca8uxH39ffHAODplE2bog/Cqh7Oa/NUPUbRI0k6OX8VHVHAMV8AyLJWCX/Je+LD2VsqwX60vhxzVfMeSNxoiE49ZAmWEtKsyCN4WLV+DZ7VlgaSFY/83H/cvefBaDh3vS9CaqvEdx3S5jTuDLhqhlqpuJ8qiVbePsHfSSRtk9rDQOzq7dE1V8XC1WV7ZfKVqmthr1wzHuf/6/+NM1Hdqp4Gug09g/H5O+6K991yK5K7cjzh6b8Sr3rVq+P6a78VPQ8ejLPbHx233nxjfOHfPhcyRDpXr441qB4aUPdoDJHKNvw8fvYcPfPMM6IBJwYOh6yxtAMzD4YlUKLijTKu0qcYa+cnqZbBOJg7wgv3zrzO3Z7DB2IC1bIS9jYvPe9pcfGpj4q2xpbY23sw/vY7/xGHBvticHQkDvV3p4JUP2urb0rMnQeJbYSoJb63887oHxmOP3rmf42mxob4Yc/uTOJOQzxTDmAf9O06digiITQPVsU6gArHctTKuaTdvrcCoJzR4HeTf1VHdk8dZ49J9m3pjpLMiTiNdVioa4pbJwdjmPO6hn2hDFNyJ2fY7tqxWMd2uI09EjcXSZ3O8nOA5BrVwUg1KtAtjOfjJkrxTdrZm9Zn3oLpylb+rIzAEiOwApCWGJzj4dbFF18c/ri5GDHcaO0Gzft5T5ME8hzF0HN4rDG6sBK9v2csWktj0dkwFKsb8QYkK/2IxEGPioicutk0S3xpu6ENyBBA4cGhutjXX+SwwC4EYLS5ZTS2tCqD0CXz0SUO1j6Kteie/qZ4kJ9JQJBtkpzgw2z1fKJaz0M4V2UIZNRJ4NbeP8SGjkRnS9MkHoc0HZdIzri6liCRPgj5rdrYbA/mFMsTECg826h6HeXrvEGevM8vlLLyF7u70BPZtYfiSnfx0rI7euUycGNl0qOdan7aWTQ3Nyf7JD14HQ0cWYa90qW6UHEYd90ews6CHHFBjc4TEpFi5unkiNdzMCc37BWj5mE+DnjR+LmB8S0yvnNGjUO/gcNbb3XDHOiq8FXOkapzA8ybLnp1261bEOsexzPAEMC8s37aJo47gik9yNmGY0kSWuWkCrfwU3u374oPvOLPaNtUXPqc/wwXmBUmMCDlfXnN9TfETQcPxV++5z3Rsh+J2eYMzuX3Fy752K/m86AqaIrvxHuStcQ7P6XES+h7KCFWPW0Eodqr3HwBkx4L67CFKEPtvepVr0qBXX9KLfuJVKN76q9/4+vx6v/+zhlnFFaUgZzsTXDPyZPzMcI7I4PJtew/6HD2LcaI6zWs3SrGrnKdp2eZwjWj3fGI7XfMSAq8LlB6zw9ui1bUBX/9A/8znvWC34yzi1tiaHA4rvnMP8WX/uXf43BPL678fy22bjshmgATH7vy4/HeK94dz3zWM+Pss86eCd46Q3xTZp7ya37PCWc/59cXuub9hZJ58+cq7y9URuU18+bPed3QBDJ+tF/627/72/ju9d/FrgZJKetOMOn5k3WBfvBZT6z4q66scsnP9l5mj9LehkJ9vOIpvxmP23pG1Mt1GyfiH1Kl7v6e+Mi3/y3O2Xhy/MGTnx+7uvbGB7/2TzyZjZ3zl4JXc/a4R57QuTGecNrZcfUt34jT122N0zs2EGtpFMaN6rmZV879ah6w59W0omnB0Xji8FRskmmFSpsOEwoAKJ1SpI5Sk2tsEumRaUJJU2VK+WEcIZU8GSllA+vrxskBgr8KphgjtUUoai+ypf2c5O3ssydwZm9mvNwh7YXvq+Ou6nyZvreyLs8moMKNgVOQ6X5WVpk++yDlr6SVEagcgRWAVDkax/FnNxS9IS2V1JPXcFhj+Z9lch/buGoXxF2Bfb8E570AWCrEwYHm6B4xcvjhWF0/AoF45I6XHwMLtd97o3CaGthYz+0Yj/429JdHa6MFV6It6uRDMIwBdCBlF9tmZ4rtn6iOXT3N0TvUxEYt+IEgV6eaVKsdCyVUTX8fGidgKKpZnS37o6PpcCI65MyauiaqMODN1LYk5iWUM+cCgr1KoJeyz/yytQaebYD4trGSOi2oRym5UH1DgJUnpRMlJCyN0y7H8+vL/ftQXOkerew77rhjJq5LnldjdAH84x//+ASKXIf/8A//kN9e1l8JCCKJEPe0GvCiZy5AKcDJAKFKkST/HDuBlEESc7u0bDayKnxX6jmOJ5CkDKIGN8FcacNWKeXReNiVIuAeTqB6voE5xAUARg9PRdZckeedr8PDmSvf9tI40i0cQdQ20FpbtPwkZ9c1N56orSOf7dl7KD74wjfFUO9AvOjd/z2qX/LM+LR5+X/693bE6d/ZHsX+wXjRf3pifPvT/xzv+puPxpsee2F01cPr7oA4goEwH0wuv3Xzc2bOKXR37wg6zr62la2uHPv5T/8kvudErY0QJMk4mFLtlVfmf331w3HFRb8Xm7dsjt9+/m+jIqXE5RcnDWDLc/3114fv7B9c9c5oWb1qTuMTge+A23fWcGVS0pPue90NBaJXor4adaimOoMe43wB5s4ckERZG+/eAwBnLfN8ZfrOrz8du6bauPbJj439Yz1xN5Lapz73aXjxOy8OHTgQHUjr2omFhOA9fv13nheFxlK87uNvjz3fvyfu+Ob34v79e/BGhn1lG4FOVU0jEGnP4R7WPvGA2ttiFAmM7+VgTz/2WjDO2ldFI7ZUSlgGB4bjQHcXoLcUHava0rs/AgOmxH3DAozzWXfXbNbYBmVlTiAV2TvejRv0UqwnrtBY/1D09vRFfUMpVmE/NglB/62vfSM2bz0hSYda2lqjugHmB+NSxt6vb3gw/vdHPxQXPvnCWNPaEa1rO6OaOu6LQ6gAI8mmoyMwvTJGVuVILe9zHfPhTxn32cnJCBK+ka49MTrUw9rFZreeMSFcwTBSI9Xr9/Ufjm/c+/3Y14O0iPPH2U7zq4SduVLdbVNbZ1zyuGfAuBmJj37z6vjjZ/1unNq4Nm7vfxAdCiWIwCRE30qD8C4TA4ChH8Lo20OQ2S1gH3iKSIjwhsi46hHRsUjrinWhp7sJJJHaHqV3nAYUmEdBYxmp0gjSr9XcOIdz/gZi0o265mwkyT3OdAgbo4PsR/vY188hHpNnt2XVID1yDJRyUmhsYW31orh7G3t25dlnZhleSvFq2G/Tuk4lr/xaGQHpgJW0MgLTI6BnMN0q33jjjTMGwN5ShUnufT8qN3/6p38aquL9rNPJKSjdIJsaxC4eZw40V8f+oc7oGe6InYdbo7R2goPMjfsYWkpmjqckVZBMboYoaml081ZlgXL4kTD03xwiYF4V1ikzfkPTQGxt6YeIkPDTbe44xKUesaZVU8jTNdSO/ndD1BeGoq2hh/ZmG//MX8pOhx3PmQxoa5KANzaOdiELddFrqszpwcfDRJewGtI2QrAXqV9j67wvqjUVKEfp0nLSw+FKt7Iejc3nJwHSQkmA9IY3vCGtT6VIDyVJCqRxo7sGG9QsuAUPbapZ5g4WKgn2hepIjj0YtwEmegTQafDYWgDO/LmQGEgH7wKFONOuo2HmaAyCpA6QpiH8gYGGaCn2wg12nT2U5EwuPJeCog8Ajrr3HIxnXvpf44mAo5Soi2GJ+x53agw/8QICLhfiNGp/ythoXPuPn4t//7uPxLNe/YqYasHtb2WygUpZfEEow2LSWyJCO0py/dUzZvXYCdjahfq61Ht2lOIfltuJmJP5zRrxf1N7S1z6xQ/EN//6X+PvX/SZqIPATynr+LLrHOzui4HDvdG4iqCeHa0LP1e5eVk+372UV2XbZsCzgzc99qkw806XmuXP5uP73/m/cdHznxb/64sfio2PODHt7akcxUEmHnK/T+qk7Kt5yqRocOZhLIhgIfmTgwClt74LjUpSeR+UMLmeK1PGcqi8kn1ej1TIlLWzKnaOHiRg6RDqdK1RxCbuIGDr9oG7kuSguRHmDoT7oaq+qHn06njKeS9A/bge9bzxODDciwrzcLQXGpNjD9UhCaHKJlmO1XXNvJe4m6aNeiNcN4QaGQoGfdTa08Iuipe0AewydaPfgSe09TCjGoXqOAiZIv8g++T9BHLuYe8+AIjrnsgcY7TUNMTqEnHRWL8yVlTr2lhuBgyU4xm/+YxoPw23+BP9sWOAwKz0Y339qvg1pDrDxDr6UflwbO87OG1vFEkSnQJayzDLJy0boqP+TnObnoHRwBzUMjfFQilOwQHG6lJjNDCvQ7QtgS484XU2r46XXPCr8cnvfDG+8qObY8Oqzti6mnhnMIrWNHfEias3RDtMwHpseLRXGhpbnUDDyy96drzrP/4+brp/ezz+1LPivtoDtBupDufKJEC0SmkRDKeaSaTpLJtDMFN6UFzoANVsYXtvHRshbhTx1AAuMo84DlOMrRlwRE8FR3Wo8tudTJUT+zeydgIe22AU7k9C9LkDlAOlB9AKUAx3zkQ9feaso23uSzYmvUYs2zOqGrCZmoodsKzyZEB5XZGbdRJgp70TS2UlrYxAGgHUu9PyWRmOlRFIKk3qdxvAUJsjJUZnnXVWbN++PQ7A0Xv6058e70Hd5metgueSve76r8/MmJhiDP3kB1tr4/bBzRwIcAXr++PUzi7sb46NyCwgSWlKkpSKXZI9mSo4IjWcRUFPDttRkvk9ByrIFMrIvGMJToYhiLuGVsXBvrUc4GUOqt3RWPLw9cnlJVUwWgA8SW+dR+YeHbNlZG2QqJlNGsHCK4VokKOWPXvtp66J//91b6cNi5U0+/wvwqcX/M4L48KXPCPOevy5CzZX8DjAXHhImpwfx8I0d7Sya/N/yzUdZD0oyZPIN7bRkSOXSYp0u54lc7i25pKN1qd77+rJZuzfCrGuYQzu9zRndfrJ5f5x/gaJRD88DYLz58YxtH7/C94Y995wWzzxxc+IF73ndfmtmb9KwTpqm6MdTrMLuB81p5dd+JvRte9g/I+//mic/MwTeQ/mSZDokq58JUxT4rnkCY13b6kkiGvChbDuzY8ct+xJx9Yxlknws0j2yX9KHRZLjnfyQrl4ljmP7r7tnvjzp/+3qG9tijd//aPR3DkbgyfPaL0p9hLjqqcyU7KNoi01gLLcWD+pJaJmNMV+IkjVWYIccVUD4R1B8NWgpZWpcY3BkR/HVbZeL2UGuAZTOZSf98++JNsi70GwCp5sS1lvdnzWTXP+bvA1Ebt1SD7W1jVEo+B+fDjZOjqftkOaf9X+7njWX14zR8XO/phnoLkx/umNzwMsZGtlRoGPm15JdaVbzAJ7o9KhbEYYH8CI6n1Vipj4r73N6DBm/fRnU0cn71AL0vfROESbfMeViJQGJqNtDGYakoRCWwNe0ZDQsv7WVwEqpgCriWdM5TYu1QtwmxqMWycORz+jlvfddpqJLqa1uaa6JR7TdGIM475c6dW91Qfi/hGeGc3ee+dQ+7YHb7gvim310bSuNQGkYrEYLQA943FpHzmIbaOAK1VNDYsl77v/F1gLozhYKDMGzdgabS61x9klzm+kIbD1Yoo2jAz2pPkTzNYWm6KuYQ114b2T8WhU8qYEvIQL/9SliRju62Ich1GZW4VEKKIXYKX2Q2ttU1pn3TDpbum/d1aDgUGYwBEExyMgFbV34hmpuutuKhiqRo1uw0htnFEtqMzsLlNsJNeoHaQzBs6tK2WxiSYBLKPMpeDJpMOim3C0sLPA9yUGRhf1mwmSew7nfz29T2XzfF0BIAxocr2OUOe3qgaT7VQ2ycwf86Jdne2fEqSRl8dTesWmpwKeV+QI2Wgcf79XZv74m/MFezw0NBTXXnttUr0wNsdnP/vZZAQvYFKN5E1velMKWnjiiScu+PxP+6KBHCtTYbQqth7UTmBf3FS9CfDRHPf3j8bJbQPsevMyVz4477NqT26Uqpt5xHgAeihiMZK4icn977xnFvrq5uyzlTu6JLFEYR2G7rv6G6N7oB1uFRzNhi5UP44NHFmyh75e6dzAtaNJ7sJTq/Ot31xZ+7NP2W/VYhqQEOigYLwGCQj2MJ47G07eEr/6jF+rzPoL/bl/cIBYLKoYOvJHnqyqLBY5DAc5iL27cK6lh0Ay4GjJuovMUTb7We5JCA454vnzrrVkf4Me16qi6ngPHRCoQJm5bJ/tswTzx1/9jgSOzv61x8d/edcfLNhsn+2BS+5oGP+kGfWlSz94RfzRb708PvGnb4m3/srHgsUz91m+qjqTAWt6C33h94WSY5H9g3gHdBhccqkRTOuaNT3y0wZINMoxKwM8DDbJ9CyakpRp4e4e8YwA5ROv/XMI1ol48XtfvyA4qnxIfon2TynxOXPtzAjyDrt2dLnuGOXDPQHRq2uQZGdJHoNej9IP5cNl6h7lZwLJCgOf1FQFEzNzZZ953voSic5n7ytREiRp9G69qb/TjdRlc5X7D5KlOhqh1NMJdex0x1yNHV73+lVx5xPPjNOvw0lDosK573qhTV87/1dibA92dhss393RgeTHP3PS7LV8BWnbUmb9OEdWOoW6VonYNevaViGxaSEW3CgSH+1RKY6BnByZiG7cXh9iP2hrbokT8OKmpHSAMWxHPauesbJa21VZ/4nVAAMopVuQ/AwiLTZP3k7VtZqmcD8N8X+I4KkNa+rjMBB0GOAGyQ8DK2N8FFEx0wtLYQOqYgi+JxnXaoBJE+BVcCTzTU+BCVRO9zvbG+zt3CQwKgGMdB4zCjAZGwG8ogo4SR/GYcSM9DxAzB/mhXemDhsm16+O+ZVujSMFG8I5QxkbXlUmx2hDMzZRYxMGo2WNYFfZu+8B4huNRnHgYOxurInbp3odQs4oYUdVin+kl86ZxJxX41nuRDwfnlXGyQPvyn60FA4xrodZjcOouO0GNB0ijtOJqEFuY5xVc855gdIXtQDFFKCZcRvD1bxgx92xzPgNAJ7H1XCgTNthSvNEvYk5kV1Ka+8BtEaiajTOIV5T/fTeks5hfjmvJa5pj/Qd+mR4LlehUjDXXtn3AjCH7yQkYbMgabr4lT/H4QisAKTjcNIX6rIGpG42z3/+89MBaODCPuKf3HnnnaEh/Nvf/vb453/+5/j4xz8ev//7v79QET/Ta/lmuxFOZ19nf9ze3RoH+1ujg0ju7XiE00PdcpK5cpCk+o8HgrrWBl9dUDe8slh37/x7vpNXVKpd0QgqHDt6muJwf1siauprUa1rzrwIVWRd9kd5cNqEjPJTDRdRVblMZU6D6SOT/VE1T3cFDkmJk38CnXW5lic84pT4k89/MTlBOOWUU458+Bfoyj33YKdwx+3xwhPXoVahs9iFKVzHzzsLjdWS3eVdGYGsyUBOIs8WKcM5QYURQtGUkzuqtAxUE54XtUfVa+qJ8ZFscCi3Ca+MEqjH3CYrYB4lkDOnE17I0lVv+qu49fPXxYnnPSJe+uE3JaIgVZCv1zwjlaqKNIJqXal2MNaVVsW5F18YT3/JC+MLf39lfPbyD8dvvevVee65fyFYko0BRM1iSflDUeKOURcU0twE9BdztKGqVxEJiTZi9umnlSTwJf7TyliGuuBy23XNOz4ee+/aGRe+6GkhUF00MYRprdB/hpVxZQXz2cVaCVAkGSVWa2ECuQ+MKRE1m+6geSYDywaBZhdjrU0m9V6IZgn0aXAk+LGvSukSAJKDTv9rABxKaLyuZGoOOKJRcvrHhkdxCKCNJPPJTwpyzJyODA2julSO1hbU6Hj25l8/Pw5tXh2nfkc338PRtbkjfviUs+JgdXtM7cPVPjaaxbX0DeL0WFINEi1TGQmAKlodTa04OWlG0j8RhwBHGuknqRjS03HsaFxvjdgdbW7GHon9XXA0DIOoGqaVwzuTJL4dlzRuk7ERCdMBgNB9vPOZZ8osJ68rUhhWM2tESUs3AKOEJE3mgtId33P7rwrfFG6mx9d0xu7D+/D6hn1isRm1uNo4tHNfjDch5WjMnLLIwKoDcMj4sk2GIUgMDxqv3Y4aDilMAwC2fgQVXTwhjKX3g3cE1bLR0QGkNu4etj+TnqQdyrHwpQfwTiKpGuMdr0eCZvsmkdSaZ3SwO/W5SP312BSdwpkyDJK4n3O0F8lLWpW0r/INdw/dSH8fgySsmnlowRV3J+p+xhMbYFy72M324Npuf/U48Y1G4wFA3WnlYmxgB2jEzblnkhKrAZ49RB97WcdDPNuHSt04DMRRpjg/e623lb1yNZoT9YCZ/ajWHeBstrcmx2V3LTPEuD1mTEmSoE/F+dkWt5P5NNQQf1CjxZeJCzxn7KOpYqaKLr2w2JmRHln5dVyMwApAOi6m+eidXLUqM9bNo7Vv27YtuVK+5ZZbEkCyhAsvvDD0LvbzmhLXs60UJ7bJBR+JB/ob4p7Dq+IR6w4BCtzGl5fcSlPsIA4mN+/pY6ViiyWDmThwin0Y2Q+wzfJ9jENuisPGeibYaKfgmiUuGJu+B9UgXK29tKkbxw1kS17rOloOwXnFE90xSLkofk6yKSZ7OAyHcwxOZCOHyFz7JFuFzUctdkuQ4umg5IoxkVTTMeZOfXNDvPEzfxE6Q/j+978/M++W/YuUjJ9kvK7X/fXbooTtwlLOLByTfPyW08csL4c2M6sKWz6Oen7CryJSvMxZQ359fpn5deP9NOoCAoJHlQ7ImFSWB7zfJYgyicz8Epb+7hoQdGWzneX9/F98Kr75iX+LdaduiVf//VujgC2AKlkSdxIGM+pwfFetBVorPS9hNsh7VGLN/M6lr4tbv/md+Oon/zXOftqFccqvnDOnjqwci1t6NIV+k9iNoF+UQJISizL1OAtKRxZKFgm99FNNCehB9DoWR+vTchv2o+t/ENd+5J+jY8u6eN5bX7XkY9ZZB8GvalAi8Bm3hZL3xmBwjEJISrrb7hrGsbLNfgbvIF1g3MlfxDGA4CiVC0dfqYXXVZ8TcAh0OvHMuAV7jv0Q/DtQLnPDyiVNTsUUBY4RwHUSIrWAhECpBttdnMyqXoU9ynZUy/ohbGsYQx2QDDPnux69Lf1U9qPOiYUgnjhArKS68SgYDopnfCnT+odQTSsq/ap8cvazbbZt9SXcZvPsg8TLEUzL9PHhCcCRUgnXmiqHm9o6sFUqYM8JIc6PUsxGAIyrz745HqoUjuDMYBxVL8FpE0DijLpV0Ue5e8b6UkbLakO1sAlHKrUiuwyrUQbAhDLERkkiRDMmVJflvMAhaozdeTAaT+mMAirh/ewhBw52ESdqPFadhLp1I/szAKiRd85yhgATE+wtMrMyu0fHGqYLwGUDWhNrJ0txO/l2RGYbOE6fawFsRRau7rNVlywDiuenWqSBDZwR9QQZrsbeyvd3EqnRBP0u4EGuBuAm4LT9pxCmYhOgZzsTvBcX245RZfK7GpLp/cVWSKYRAplUZhNjiwuNOAEmxwB75h3skfeUhuNGJF2diJpOxZnDGu7vob13AsD6Ceg6xXhr6yZQTO89FeTTr8reauxFz2H3wAIN5lchruPmPtRw8zxKMR9EGlSL85uzxgF6jFWasOk/xJONkzgDe7mqPVLlm+W7Yhwk52olrYzACkBaWQNpBDZu3JhcJ1999dUJCMlhlFA2RtIll1yS8tx+++1x3nnn/XyMmCcGKd/G0tfOhphc04xiw1Q8spMDGg90vSOl5E3utA48+bCF5vkX6oSSIrlGlfkkOOek6U222DsRpR68j8HB07uVu3NDn6pRcLs4rLvX1BA7Bq9kQ9W0oQkvQM0c2nDOazkYAEXdg+3R3NAbTaV+CIGFCcNU2DH+snm2eRDbIg/sWZDEoQqxpVe2nEjPioZg4toYdlATEConX3xOvPwjl8VLXv2yuOf7d8amEzYv2oJp0mVeeUdmz0Zw3jiSzeezf7PPmMv2zW3j7P2jfbr79u2x5fQT44/++X1x7kUXpOx5O4/27GL3HVOBrpx0gYuRp+TaSzzkCTIfKSOxuLiuhC4DPPndhf8qEZhRA6F8JSp6zqthMavKo9qNdS83aRMlT7RSenT9p/8j/v3P/y5a13XEa698ezSgMkdViQDRbkjC2G6ogpQMpiuoBedgWJsIiLvGprp45VtRsXvpy+KTr3t3vPvb/xDlFiQ7cOBToqHLHWfXZ3KVDzEi/zjzhAaBZsP4kXdb2e+0RrwwO9xZnT/B3xJKqt5MATyW26+lmjOMV8C/+29/nrJc8v5Lo9QE536JlBHDAiSdC6hy5PgunHIgUCmFE1xI5CVwBOgdxX22RH8RhoEevlgqAIZMamSpSkCUOEmAdiItOQfJTgeEYgO6zH1w6A8BwkAKEJ1IPiB2G1BX62WL6eaZWqVVjhd1FmjoVjj3/Vjz7CKodmYT5TsDke78zeuE665uDY2BkJ84RP1w/+vaWItcmjhEGymvsBrQV+TBec9WjoZtl2mhK3Iz5lkzSaCgnOvsyxsBRy04SzDAqd48bZTvoM5+TDZxBGmGKueOTwaOiI4HqHQtVLPfOxkN2Pt0FFvxUomMwhfIB6drdcxNuSc130vLsk+Na1rjgmdelPbnHbt2xsH7D0TzyasJqYa0iDIEmkpvxsg8wrunHZrF2Y4SQLMg4KCtJ2Jr0277qOcEwNl+do+k9kYfXbcyXrRVUz3SMpSkcSuVY/t8TocE2plNjREbD9ukiZEh9gAkhwC/QgKdmTc/AU+BcT2Js7SrHk97CQimDtvNtMY8+bwisBE8G+/Pdnsty4nKLu/1eYxXO+fgndVDcbg4ETfwtwmRZz+ARuZiLcy6mcSDDm0Z4KaTjVpAG8MT+wCD+5mDDXxpYCzOn6yP61hhhznD8qSn/p0wHltRMTyFBrtuBYU2yrEwDPUGYhDuBCDRrCNSzgw44sbKheNqBFYA0nE13Ut3Vu9gl19+eRgj45prrolnPxvPNe96V6wlQN+ePXvipptuiiuuuGLpQn5KdycbWLrpYMq2X3xxx2QnhuVcG4djVuC0Obm9P27d3xaHBloQ5Y/FRjxwyX1zx55+KrXWz0NT6G5DiBgrRxU1JSsLpULfRNQLjIj1wHmZOHtH4Buq6OovxZ2Da+DicQBxeBUERs37k6e6Edx69w03xaoGKICfUMpBkgeKuuoSPgUOH8+Cyr5bvcelbr4PEERWz3eP+Y0nxzn8jA0MAf4g2nlONbHK5yTgdGGd1KS4kyQDkLgeUckzENeSyg4EkJzFXuxaVGWpTB7SzRyYnXUtMxIU79v2gxN92BDM85hW+TCfcyCbtWu2dfUtHMX0VwlPAxIdCX1ok+nWiRu1PjpyHCqLF0pnevDo6QN6co60ZflvlgSrfEp1R4gRDu8Sh7nxkY5WT95qudh6zhNaJWKysthlfrZdRrO3TMf2h1/6bnz60veF4/EHgKP2jWuykrxJjkS8okbl4Gh34uuUJ7MIALVx0Z5FomnrGY+I//K6V8Sn3/vh+OT/eG9c+vF34qmrL3lEzJ9b7l9nZATuvYRULYSczk+SuiJ1Sgj6HqZmUqBjrRt8YepiKW96/sxi+Y7lukTSwvN8LKVkea+67EPR9cCB+NXX/HacfMFZixZgfTIytEuRqBPouGUlTvqiTx15QyLYZyWOVZPzHaxBKiFBnEaU4azF9kPpnUFfkwqfxC13dZohcPX5duZhGw4I6vHk1o4a1TpsbRpHeR9wHd0zXoid2KNNsda13iGEW0wOGD8HoJvL8QAAQABJREFUqToxo2pLzBfregKC2Xg3vteuIxkDql9ZWRph6q0FJE3B7Z/YjYrTQdawDUFyUQXxPIFNSfV68ipZOkqaM19kF/SPI4Xx3Vjf2h7rmpqRsgMYWe++4zI+GgF8WX/ZvwBqhwAMu9mvWtn3Nje3J4dF7id7iMdziOvazq0ucKbwfquClyQ8tLfG9cLceS5ku5NEOe8zkhzto3zfVEWscx7w/GYLimtbog6pUR1S3cO33h+Tg6Nx0lmnJZfmOwEr7j0CHXuucyDilMe2sVpArO9nxrhpZ0fbiv1RP3Yz7cwdyhK+0jRBtUengPFlDnLg5i0XlaB4EjU7VdBq7Aee5qxIz4w+YxpjPJwMBEPRxLy3Y7u2F/SRuphy8Ij3AR9lnitRzxhuvY0TV8c7m5djuWlOeeYkAFLHVDOOLFD9LGU31tCePvauw+wDaX+lAuuYoH3DuFO37SXUNetYj8Pku5vzunOqgX0CwMi7ci4ONq7Dw+EAwNJ59Vl7gGwPF+OZvZW7tucW2fnEXHDeV1EW2zV5+cf8cHklrYzAzAgsTAXO3F75cDyNwGWXXRbDcM9++MMfpm5feumlKWr5O9/5zvT9sY99bFx88cU/+yFhE5vchu46O64/bmoeunIjMYFNnoDcIjl3YmMr+tM97fx04LihMTobB6O9AXUyuOLsuUkNI3mVg1hzbxyCc6+xbGttYyL+U2e5UccJ0bgfz0eo01VTD//Tz0KDobel7tFGApJC7iJeasSWY337AxgQowbA4TCOut36ll64WxDUGoOm7dwt/eFNHv5KkgRJuvfWnfVCtTgODmMKEDjdBMeiCJfb/BztqMnAebag6eRB04yr20pefyJO0ino+Eh82ALGjkOqE+C1bwIDYVT5KpOa7wMcpmuImq79VHa0cbBNNRFzpAfHGHqBsjWzSTsW86oa6MFp0MJRDjpr83A0+XsYzncG2VSZ5BPEhm0U7AlgUG6j/Vlen8kS7aYP2nSNshb8nJU424rUzzz7vL+21JYMQtwYVNR6PHw9gr3ns7MlZg97TTUkwZF1pfLNnFecZVvyt++Bnsly6dGO790ZH3vlFUlt6lWfvDw2nLFt7vOpMbRL9ZuKPlZmMoutUTKh2ovr+vmvfXnc/PVvxzf/9Uvx+Kt+JR7zvIuZo1nvXpXPH+0z8osYpP5qQJhEusk6h2akn7MgyTvObuWgzLTPNjrKrEnHXonK/DG27Icl5XOSVb6sIm/9/Lfjhqu+HBuZg1//o0sWfUYivMQ7lq2ZrAIJ3fSJepVEuGnNIXQXKo28ycEE4EdgonMG10c1BKyEuaq/qQwKVtWzRikZICVPaaVCfeuy2zfk5KrGOC3aZhgs/aO8x7jVrqc5JwNqhtjDtG8XOFWjulmLBKSmjhmgTuc4SVppt2CFbTbZGZWNnaNUA0Ah8KnBjik2YkfZBnTuY5+h7JrVvL+9AIwe1O8alSxNtztv6FH++h4lcMK4dbasii0tbRTLfsG7qVc2YcfqqqbYghJYHUT9KLGBDhOr6Oaxg9HHu7uljTOmgTGc6I3q4Yl4EAbSiPsM5Q0BJpIqY74eaEsyWWO/d2yltXVQkQhvxran3J/GWihWSxn9hKkorCNGHkS+QFyVx85HbYmJrmHaVBebYKwNc+bsRgIy6dhRzzh7UjfvygHqap7QBQSJemp5/iyAay1nSzVqd9moe3M2zV8zrikZWM6xZYyjTqiUqxb1OtehSa9/eqfz/W9sqGcBog43OBH7VFdXp64iDQmwmMIabYoAVdq0aRflurJ9zrPS90nuKWFq4Pq5AMxkMJcaw/lDy3fAMLmDU3yAvVf326OocXquCzTTIFCngHQvK2s/I7AlyYKCMauJxyCjugWPgyOqFzov7PfNPKs9nsA0W4ezjZZh6PY3qcc82lAGvBtY3fFYSSsj4AisAKSVdTAzAnqTUWKUQAdX29ra4rrrrkt2R8ZBuuCCCxK3d+aBn+UHNsC0kbuZu7vxXaUkwU4lcbSlZSAGRgvRjcSmb6SBwK8N8UDvaLQ2DOEKfBA9f5SSCDaXiFL6495oMFGJ8DwpuW/ZNxx1/WzubPZWt1hyXx5lk+9T9YJD1qzWtRpOWTVcM05DuKuotWGwWk3cjRJ5JMQ9eDk+Fiv2IV23bkEDDZmONTNLBFUWaJsFMUpb9IqXj4V5sjJQXaF9TRLK0w8yDBUjlF3M1o2EOpIiBqk+AR4PbFQaACXratvQFYe4gqDOk+UPAIImOdHW1BG/Kj3jxlQd7YAmgxAy/DNJ4k0JXzJg5qrtacK9tvFIlBgJlvIkmayNQZ6sy7YkY3a4poUUoNWeJ/Kam9hzsIbkUCo5yZPPHWuyngS2qcexklBSSiSwLFRIRxzFEodyiVbYF8cwEfkQEcdSrxIZJTCuoAP37I4PvfiPk+3Fyz/25jjl8Wcv3HwqkDiTuz0/ecX3Sw9pArfRRElAnKC2+r8+8o54xZOeFx/4n1fE2y44OUrrWuY/vrzv1s8/x6qyr9YtkKZq1oMgKZtzVQ+zGc+Lh3BiXFVDy99YQfAwhKSSvAQo8qwP4W9azzQm0Yvpl8CD9YghvF8TZ9/xk3p14Hm95hOifQe7keL9JYRjbVzyV3+EKlWFCtG8NtlvgbzqYEojaiEq9X6oJGAM72ujSRLEWlX9ad6zlV/LEPoJGEj8MmZKinzANqfnbC9fsveVJwEo89vNTW44NybzQgDjpUy7GyUFE+wFVRDUBtDuhFivGmOyaPcoxGmR2EK11bw/lFFmbcksSdIfbEFqIFaVsGbqqYIw8tHMMmBANbbCKu6v8hlrRUWsxFs8zF/U72r5zJa57CQAcG03IjVa09QCwMMhAi6xVV1tR41wGwT1ahwvVDOfBokdwG7qByMHo4t9YdOqNVGH57ld4/1xeLCfd4vAzQA/XWILFNwPGwGazlH2/vgGsvchJdfmUZf/9dxzTYwDmnomh7CDgkEDMHAOykrUHGN+kg0V16rr66J/4HDs7RuOtRs3RDNOG6prZPLkKZvAXThxWc2OvZb+JMagG8x0yuYr/zb7N1e3zK8kCR5j46POUfLWCDhSOpYWChkFT6q8FZDAFBuKyeasjnXAAwAk5jwvjE+p76k7s621f9WuQcYhvS/kS+eRgJh1ZOWuQcE8Q8psTyIdq4r7AJ9dOHNQ+pTUgGlSDWNTh20V2yfPAHzJew/n9lqkfyXXMv+28HkVZ+wg7ehjbnQ00+CA0GT3ObVHbLMuyPegMrqDOiZUD6U8NSw89ys6NdO7lQ/H7wisAKTjd+4X7XnlYSn36HGPe9yieX92NzLi1/0vqc3xdxTiOPd2k7eL/S+2tvfG8D70utE5No2XidfRh0rDYHPUoyff2kjAxuIAetsc1uygGfHN5sw/x6Kpm6jq0+AoL3f+X0k8XTqgjBSHkRz1c3gJJ6ohGNpLqOTBLcsJ/QYOCNttZba9nnuqc41ySsweOvNreGjfPY7Vk9drnYfYYsl8jRgbz8brqcyJlyGIziLAz7GxFI+aOW3louS5oEBiwnsKx3RZIDDwGaU+6+oASUdIknAdOzkSezHuXsN9iQtMqikHIgTJ1fxk2Zbnj8mxpyrGuA7e4yxA8t6cNnqBlD2fqcMZoFVVpkw6xhwkkGGJP36yDEGvqjAJwPBX9/F52f51bHIQkPVHkOZTx9AG1g4rP4G6vv2HU6yjwe7+eNzznxodm9bE/d//0eKdodIUXyerfF4+1iZE4WCpDacOeOk6hJe0OwD866rjOa98cfyf930sPvC7fxwvwGV43qd5BfxYX1VzVfJ5tLK151m3bWPiwhvTppExNXDvoCMp5fUQk5xuCcekogTA8buSLlVxEoHHujFJfCbnFqzC+Wpgn3rDX6SAsM9588tj05knLtkSiUUVJF37U4AIg35Osf6V/OpYxfer7PpkLgQaiyWDn9YIxGhf5V4+A4imH0xvMMVU5vGz3HbjpFXR1zwZY6lKdTz6XgI41Da2xUj1IPZpvNdkq2NvUM3KXbCGPc+9U+AwAXeJ4pJEQYcOYxDXCWM4dNPjl95I+i6gUJIqk2tMopl/NbpfXsM87mb/7gZ84dlMOnZZiXaV6gkcCvAaZFTHBULsKSdWNcdJ0ZrsV1QxHAQYqTlxe7kndpOzobEpJpGQHCBobe9gbwJxRcpx/n2ZlcThsyCFv5CBMInKmY5xDo2iFswzrrktTbgemG7oAA4JdJ6gVEUw7zzwP1vXDI5u0k1eVyWss41YRYxlLZI9zwfXRJ4cNpx0xx68/q1iXdQzH4ul2R0aSRDrxnVqrcnejPcjzTuPCx6M01RXAY6sUnBS1NkQ55oxp8Z5fgeMkgn66xxWvpjaP+0BcKxCimW5VYzVfvLtAahsofw1qNsVXFu8RzJezGMRjtU4DjR0uteHjdwD44Oxd2ooSaMKJRhhDaxl2iU40jZLm0eXpSttP+/3AVw1bLJP/FheM2sINiT2Rb47xJbStT1zXicQcj5Yi/gyjFtxCNFHWTIiqgF7eRwwHl1JKyMwMwIrAGlmKFY+/CKNgB6blES4KVYeEZWf7Y9nQjMctzPXHkoc0FEO6CHOuVEOiF7iEA2MtMTQKAcSOvY6TWjFaUJzvYcHBzQESqmXgJ2HOaKWOIisZ4KD7tbqtXGQaN3jHAplCAYPgUItQUTRP6kk02xzniQClFb4M7/teZ6H+tfyBDRKXCrrXLA8MtfDgUsgA5Aze7hmuSXZtRnRUNYkd9A+5WQaXU2qJ4Ijk/1SvW+Uo6yRg81/XksgSUkSsekHVP9LZXjAwZnmsOyHY9uMwbJwEkfBPD93frOy/T0/4T2JMbSO+W2fnzP/bt3Z+EPgyBmdftLrD3fyANeupKRayUxSMiKEzMC4lx1nuerH0gafcf0M4QjgL5//xpgaxHvTOY+KGz/7lWgbXlxiMdOMNAqz3yo/OZaJoOGvBJw0oknm+JMuelKSVNz8gX/nbkageK+y7ZXrrvK6+ZaTEhG3REbByt49e9Pcv+rDfwJQ2kRuW/NQaptbkepn1RCpEoqTSXUKwgxCa8auYjp7Ghfy2NZKT3zX/cMX4rYv3xAnnf/I+E+//7y5hS/xLW+5AVAnIOB90/Rs2IzHtAEIcHcT96Ylx8YXkmTbFk1kOWKcyO+7oFqX0qIpvM+l/tEKwYXeDyUm2/DqNgrwKE8QKFkVJd5dr5dhcgwM9ccg++kohG4ZmxWboHc049yk95OyHUPfetWfaou4ri42RgOEalLDSk3O2k2xUdeChKIdyV0Xe0QDIAO16enuLdo1bzg+VdTvvjBCu91flNS2a+MGwS7YHAQY6ZTh3vGBuG8KZwVIKmqwn4KlFkNcFxgU+C64MdByXfLwVhfNtfXJZlApyySArh/Cvh/pe6qDfjhftlG11wHUEVOsJgbCPaAo+NTpBIeTvWQqk/3rKGto2ymbYk0fI0O5JyC94WPcj72Nq4CPKfn3ftxbryVgz0bKFERlozWdIf0hvyp+eKjTpXeBPd3wFbaDIzAlgREzQB7OKff1vALuau80zpzpxc/sAuTdSNYeYFxqOeN4ZCb5UfB4H/c2APGUKj7A+/IDAFM/QO4+OriOHf1U7KTW0ifVNpWU9jG2B/GSeZh2daPyjpJHDHNtYpgSKU8NjDpjL1GZfUzePbXnoj7r9NN91SNIkZoo3Uak/36izXwhk7G7ynhqFKBWA9jcbVuYm4188k1yBhI4OnIAUzkWUzku2cWV38fLCKwApONlphfo59ve9rb43Oc+t8CdxS+9/OUvD39+lsk9SzUakxvl0ZLERBNRuOXFmeRC6fGoh+Cs+3rWJIA0NlGMQ31rowfvcj24IV3bNBgdbPCNGAyrA51UEhariAYpKWpEHeK+aiKkuxmTt5ZDbBVlFdX7X2wDZgeWwyXpsJy+LNaExa5r8K0SWXYUL5Yru67MS/fgei5bqC0SGqqPqM4mQOIo44nMCYLdU91JiYiHkYSXxzbHMQczudIhbisydbtTajuIswL8IX8JYqkE0VAP97EoQYSNlizKg0iE7oBogbRasD2VvZGIlDhZ3oqofDL7bGt/nGT/JfkWG2fHtoRkzHWRLwW5oKrczV6x9ZTCNQnO5bTI+lTJk9D7q//yptj3o13xsY99LF72spf9ON35hXv2b//2b+Nl5z0vPvyDa6J9w+pMCrP4S7es/mVqOUgIWJ/pBZaol+qtSAmAQMylOaW+pMoE4Xlo1974xzd/OHmN02vdsXKoVZ2SIKyBkeOzyd4FIrUJgncU4lMG0U8i2Y99qIPdg9rnVgKkDqLGdAhX3z0Q2H0QyHofNI7Vlprm2Aqh3JScLUOEKvVBioJzT1Yw9h4Q+0otxpAaqYWg6laVEib65biy8MnIuPK5AbuVBoCHRPMQanpz2Um+ExDHHQCRAfaWw7ATMH6aw2dYYiDS+5FNTnqfkOUkKVETe80ExP8ABPreqpG4j3h0k0g36pC8TSAlKeOlb3wINWi2otEh4imNTwKUCJ2A9Kye/jTzLpfZC8e5PjBOXCcAkv019lFbqYn9zHcdRzEAyDH2UyUlBYCTcY8KjoVthsng3xSjir/pGhdvvWtXbACUnbh5bTwWgNDCne20ESuhtL+Yb5C9eAfOK1axu6vg6lLP12bagzizqvBSh/s/gAHOJHASVEB1bRwtCUEfCzWtVffn5DvHrOzTNkLQN9g/wlyOIhGbjG5ce3eDqg6hFl4WZKQ9i0orkudBP/v5Luo6sbE9uhnntQDtdbSrf3woDhIkdh9rpAOV2SbWtOupl+/lIq1FsqOUyJ2wzvayTsZwVpHWiZ2lDGNL2Tin0pFVyuq3fZTTTR/WMm5jgCf7ld413lNBlZLQSV2H0w/B4SgFFOjD2WhVIIiNHcAkyzReVZIEz9kz0khydyUdryOwApCO15mn32Poqg8OGvxt+Umu0s9DksN1LMl9LyezIT3gc6FbXY/oveYBvNx1RhfSpEl0wvxR9a57uDFaOIC24LB2XXUfhIDG5PkhRs0Q8IImQyyMsHd3N0O0FPqieLiVa4VY09iD17wBpEeLE7puv4IJ1dc8Bx7uJGHRwEHu3+Vs9R5QBiHsxtp2ofxe015KdT3LFLh4bM0mrx6ZVNnxugdRnoj4ERvrGmeuZfNDHhvhVf5vIMigLtPvrhpOjjMWKjsrTyAmR1EQ/NNNAhqBjrYiSjPksgskK9vhqPjdvJVjkK55IRHd2R2JHMd3uQSwBLreAT/xB++K/Xfuire+9a3HHThyxl/60pfGrl274ur3fCIuee8bAMsZd9h7y0pORuXk5A8xH6okOc4LrW6vJ5Dk4+j+aPxvzk+89s8TYf3iv3hDdJ6wPi9t2X9913TyUaBupbbWUc33EgyMWgj4ITYePU4+3MlhUMXzrsneuJu9z6DDY4AkpS3GZNLYfoz670DGsh+i/eS65liPRKYWXTulDcW6Mmq643g3RGrC3qbqVltrC1J5nN7wbo8R98b1qutymQACigZAh9IAYyUlzv+8TtF16HyYL6sh7h/EYUMXRO4aLrpX8CcR0vOeWeyrc7gLhwn78FQnMBmFiaWNkDZWqmCVaI/SLRzFRR02T2MEvNVZQakRMIgqp3uZ3/uxCasDZAl+Dk8wTgAPHQk0FouAJ+cI6RsNn6BP49hRVnF41AOQZIikcWFdOdYsGJhO7l7Z6XSQva59bXOM9gCsAJdK0x8JMd8C0+gHRBLqRWXRZeqe8yCzswrV5JPZMQqUo7RRr4UGizU2VQNSuQQ8YGjVFnCo08g11tJw78EYGTgEiJ0F2Qk06XiB/0O9gzikGI7vIxEaYD7TCYYepaDdchcbb73ZDeL+fF3bSXEizC2Tjh+GAFpdOE/YPrQ37hs5gFqcugEw1FChA5Jl42Dm6aRtX7EJlU3swsaGR6KBcdfL6hDuvutRPb2wGgdItHM367KfFVN0gaT3VAkmbDtFZNwvM49FrguSxtXLI5/tGQUA1iEdPZdxdQ0JkgTuQHpFZ5mdWd6Ylb/H9QisAKTjePqVIPnzi5jcYDN+Ejvhgskc81OW1zu69hxj05yEm9VST/RwDpjugQ72UAgiCBEPrh4I9B7scrajr96CNKkBUb2ez0w1SIvKBQ5QfsocIlNwpdxfCwW8/nDYbmvrg7iRM5WyL/jL1sg3058ax9qCeX6ci8ISPfUsK9FOSTsdGCyV5BTmpGKK7WG/p5OfFpLhpGcqp4mxtRaPevMvmnhmPXMwxCF3Py5ctS+bTdlnn9e7k44VFrM3seqs+mzF2IOHIzl3DYxvcVoyZLESV8YecSzz5Kfsx9+zA6HcUNsr58g1IFNdaaUqdzkhlZex0F/7ISf103/8wbj5mm/G6rVr4sUvfvFCWY+La4Kkf3rebyQHDSkmzDJ67YyMTygRRcqBWlitHllIzpL38iQ5m0ALXGgWbsqQ8pDJuCppVtk3XINf+eA/xn033R5n/ecL4sIXPS0v4pj/TkBUlynYoJuZm3M/8J0VokMVsFgCSZXtPOZKFnwAwp73aYK1qFMK12QBNdnkHIJ3MSXqPoQcvgdXzevxoLaN97SRW4dRm71lsguCGO+TfC8CGLT9GRwgJhId0fub3uJ8lQsYFDUWSonRNASQqHxnZpplRupkS81U7ZDqlLuRNhnglr1b5xBVrUi1OnhiLrdmpojKD7YeyJOkF1OACSULSrtKSLHWtTThuKcx7TN7UA8cRtVaWy6dCOiKXmaWDMWxkVFUw/C0yXvPy4vtFW3j+XpUDuu51syZoXrkoIFm+wED1NNK2RsKTcnF+CE8w43TX9WfVTFMwIY9Q/s1NSOat66ObYP0jVhMYzAktXdbR/930o5et3NRBYM7yQK4BXvOw0O1cQLu0BuYE6enhPpjsZFQB4DZWtyRF+vb0r5k3011xDyqQ8o12Ls3JkcMlKpaLyrUg1hwOiZIYoo8O4UkJwWNBfjpjEL1UdVty9RL9gQ4UoEVv2SwyT4z+VsX79oDbimtjs38bB98MO4YehD1asNqCIspa3pfn9mXmXKZTUrsxrUhol1daIAMsYbWAvSaG2qQGGXBZ4d5RzJfl64T/rP/zry5lKstW5HxK9MH1Tw92l18BtFVq/AxPO3fHezDqmOWcd5QDciyeytpZQRWANLKGvjFGwE2uZ6R2mgpwtXMdrzpPmREjKdEUovjqsBHsINqPJt1DTrOHEIcJsOcamNISsbQ456YwEsSG67gqDJl/H42WYT6ByeJbJ5cm7rDmlBsENPwk8sFtFuqxQXqCW29SI4SMyrlnPvL5/N6UB2hra119UnVY9aGZmaLn/voMX7z4NNouCjnklYummiSYKVnEo9N6OJLqOQtrHzGlstlzforyEkKGpTNic3NdNj5YSZlpajqMD+leZl/cYHvWi6dwNgPwTXch5tda8mIVYde73oY+PLjgXZkLdk121ePrkwNBMkIdmsZCFwo9wINWOKS7aih3JkjmSKN/aHN1zBtmk2ZquEY0jdtvDJlkmyOtfcwbozX9LKliqLAKScaZsuY/8kBn4qr3/fJ+NrHro41J22K9rZVPz9eJuc396fwXVUuU/4eLafKBJlZn72DSH6RCDSXeiB0h1krSAG5XrmaJaS1wZmm5yieu8xXUm1i7t2KHrxzR3zu3X8fTR2t8eL3vn45TVg0jxKWCdoheBMw5yvcNimhMCCxKnjZ+vdtX0aa7pBrVxsPv05fmnnY4KzjgAAlIDVIMOToV9pWOQCZCihEOut9N5KNwzUjvGPuIQPRhS1OYs4gTaiCOB0BFBlftYyL6EkACZtIFEvFaCzVJ3scvYrNb0NqjP1HHSzZK9F9ifPadkbBecCbYjX2SLaxvL8uRiHsC2vZG5YBkmh0TCKdmABk2c62hsbYhEvvFsCc37sBcGoo2CoBTHpfaaAjXK2nPdaZTjkmAAxF1QMBj0XXAf3qRHrUji3n3uG+6EcSM0FbC/S1vdSI+jISJuCDIHo/hL/eO2tw5616l2eWkg6PIIMndHUPxuE9++LETR3RCFAQhJfJI1hWomPr0v6DauL9SK+GkHycirc/FLzRiqAcwYDADRW9tD7njDH7Yes65gbmU8+D2Pz0JkmX0i77pZ3dulIJQEOgcyRH7mfGJtNd9zDj3I06oe+CIKYyOV6ZfZFxCAEkACCZaPZ3nM9KC89o2hRb61dzLmGfRP8HUL/r5W8/aop6Ie2aGEigKl+VdbQhOdIYxGII0H4Yid8dxEo6hUC5VYCceufM956mqMY5VZhtE10mTa8sxu5B7pVodwtcB8yEE3D1/XnUFBALt/T36l0V1dIyuDeBpOlHK/u48vn4GoEVgHR8zfcvRW/dt+46tCZWN/bHhubBpMZW5mSZ1KiZv6MEGBzjZ4SNcJBghmVA0ChgSMcMqtClo8WTiP+c6XDuJC24KoVj4VxPRtDpKl+57q3spn9N6UL2cfq3B1ZrYTy2tWgXUgBYHWnLkx1r1EteN3TdqNZCZOhlR/3+cYjoZCRN+YuQDXPqXOqLvdJttwChg2CsklgLJXvSNzmIC9z+VKf9WCypFCHBIIhKhsgVpWqTJMGSJz+lgJc8U9kXP+uegWM2/UtcRqpsgrqZfTorJZXBxy2A1F44/PL2RjjIRzgkBToCCVu7WIutS06t9j+WJYd3AmJDCcNiz2Q1z/423/x2ec3xVNWl8p6qGnocGwcsV9bheA2hWsTyS14LK+fC5+2X3ru8XlkeXxdM5rn2M5+Pf7rir6NlTXv8wf95R1z56vcsmPd4uug4LyZJXHgc4FRD3DfjnOUANogDQ5uivjSESlgf6lIGBc2AruvI90KVMWgt5imT8vnZSfO73rg+9br3Yq8yATh6QzSvXrVwlcdw1b1A9o0BMa2qMgnNa1jPgu4sVMC0FMbFMT+zD8JNT5x/2lsPIagHNt2hZzaDsyULCtwex7C9qcOwXulJZdJWQzUubT2UtgtchlG7Ux1rlJ9qxV4Sz1DzyRMg46EUxoWtlKTYUIoGpBx6l/PZjOSfu+4d6zHGcwSpgVl0VV6lJAOQ0bxZNTUAgxI2yh57EAnBYVzRO05rqedoIIlnDSsgQ2It8ZHWNzcnKYNbl+X24grcvTOx2xwIxzN9hyGClKHWfgGCBEr17C0ZeKVa5mgz8KYJJynduOoWyOkWvIAkRm9zFmP5rQSKHapT9U67pUwdV299AhnffwFJ56q2OLDnIPdpB00wl0Fo16OOqDOHHkCFwNJW6jq+CwL/HvaWkxHcTQ7gkRXQ1la/jr0oYxqQsSLxHP9LDcApbHsGe/dF1eBB2pl5atQlfbGuFCejHdBQsmZUz3lgAODYNToYo9g70lXswPAw6fRNJ8fhR8N7Uj9PLW0ArFE7GfTIJ/PC1jJwaQ8W2KyVyTjtpFQnELr2/0bvHbFz2EhP04mHZELVNyHZU/LI2rwdRlnv8GScBEjuoLwGAKTvpSmBwelHs7Yx7uTRBnaCubgJpw4trKH1rNG14wBctEgMonsC9MJB5qCbdWx9U8bl4pxZScf3CMzd+Y7vsVjp/S/ICLgnb24aiz0DzdEz1AAHkBghAKCRCQwvkejIF0xAyMON5Eap+lI1uuYlPNrJZKoBFDUViVchwYP6HKcZoApShGdgxkE0qPqguhTX+O7mnlRO2FgnPTDIZ+naIbkpN+CtrrN+jMjrYxDj6DxrI4BRc6VamPk9/Gr9kbjhR7LHspXMFDjwiehD+6kLDqaqYxJIEmcZgZa1g9sLptSe6TvZ54yo6+VA0Ti4DSmMB91CSahimu7V9N8sp9dsp+6oWwuNKiUkAkrFsFmyTflR1hfrNtlXAYm9nJumcNE6EHfDLUyQhwPMo/yCWhQnslNtTvY0PpSt+2+YkXBu4ZjClc5aNSfrEV9sux7eULTgk4BGtbhiUvHIRqLy99zH8/yqqkyqcjRv7LK+z+9bXkcBo2Udys6Ot5/lpOquNpfDVdaYzVnllcU/3/qV78Rf//d3hC6uX3vlFdGBQfdyUldXV/zLv/xLvOxlL5uT/Rvf+Ebccccd8cxnPjO2bNmS7n3+85+PAwcqiBWubty4MX71V3813Tf/F7/4xTjllFPiWc961kx52il6/b777ounP/3p6X5+8wc/+EF8+ctfjkc96lHx1Kc+Nb8cN998c9x2220z3zds2DBzv7+/P7W5paUlnvGMZ6DGejQKeKaYZX9oAAy1Nx3CFnF1DAwTS2WkMdqwI2xvhnCEQ+8mogqOa9kZlRj2nTKGSlpYXL3ybR9LEqSLXvT0OP8ZTwK08Fa5YH+MJHFnbK4a9iO58u4A1u9aMbm+C+wddcT1kREwhNMB7YYyUjvL42+BitIY/yr1KEAMKq0swzTSc9ycRAWqVI1zX+9t9sH1arI9qt0leyuu691TyYntUQISSB70GpaA0bSDhjR2tgjitrmpCa91SF2SPU7Wi9nfs++KUhW9xiUPgmSogVhnq6Vd2b7iO23bqwEGhY3kpf4yDhx840pIkhYFScyjNkQNtHN9Q3N0NBCslfaL39zHB2FiFNi7H1XbGYemcOCAVF3PpwxxGlPf+bRvAw7do4c4N4xlJ1hczR7WAtE9MTSIW2tiLvH8IGdLM7aWSvxUAz4I+BrC/kr7XzBBGjf77/7vUhK06Wmvtak+zjvnkdix9dBnpFC08azaVeAJAnajDrYLodMPIfZxH8GkZDvhQR0eoOVw8lgxNjWsiaaWDiQ4ajLgfRSQWwkeqJIE86iAfVPnlphgHEYG9pOZEaQvhcZVsRl1tr7x/bF/YjBJxJXyjBFbqEz7a6dtjLJyst+uAmN1fb9/Z+zC1uishhPihEIHqn8AYa5Psj60Y3IFC4gES66tScorU24N591JxKVCOR0LN/UT8pSdsbWAKtdfmbnfqWo7Y/9IQnbUMZ8CICYhf2D2L/WMcV/7t5No80He5fuZk32ctY3M6bpxzifuP4DK36BnrWCO90hGl0FvV9LxPQIrAOn4nv9fyN67Fz66c5jDbTRu3tsaD/a2szXr7pSDioNUtaxabIEa/CzHsjBK0NHE0AQgAYo4RDzoauHyp0ODvZrdlZ8cjMCF49AR3AgolCbJZdX5TxnOoQfzFKIADcFH2YBVk+toJGo3G65Hnnu/cXX09jZgwEsvU461lpAY+S8jc7yaJSUzuoT1eYtRsoQCDXUI1iAG+JHMz4mZ/Pns6SwoayJqJORpqweuBsVFytGTXT1/U0PyCrMH02/HsxXwNMLhIWGSOMO0VQLKf6pW1AGODOKaEUoW4ojPLWzWcUYGzBIY5In5+Xx2mDYe0k4hlRQYfFfHAICyjV4vBOIGmFvHlaYkz1m9Om5A2paRZqmYRX8J42YSnS2gstRa08Q4OabOoeTVbCvTWoJIacIgXne+HMHEd8LQeLwvSa2yOvnNgVxR8kwVLKoU1V5AZxuNceU/n3OOHMO5Izf76HI+3XPzHfEXL31TUnt61Scvj02POGk5j0VPT08873nPgziZnAOQLrroomjEZuFJT3pSAiVXXXVVPPrRj45bbrkl7r777pmyBT0CIQHSF77whXjlK1+Zfi699NK4/vrr4+1vf3vK+5SnPCVOPfXU9GPez372s3HeeefF+9///vjUpz6V7KQuu+yy9Myf/MmfpGfe+c53huBt06ZN6ftZZ52V2tLb2xunn356vOIVrwg/v/GNb0xALnmqmmnZj/lBypTUgtSoVIfnLlz/96FyNzxWj70M8sCSqp2zydzOnzYUEsmTbAz33PDD+PyHPhPtm9bGcy5/Jaqcs+Td7JMP7ZPvswGQpyDqXHHWLy3o2+h6sjG+e9UQ9sZP0jZlwThJrEMJdfcgpajGKJJgVQoq+E+jQFmCGwtVrU5p0SQcI7FPGeCrTYj1VSNlSGqgdDNTtcrGMNmpAL4mCWxTxmkDjUTNK7MSaYcIb0FyNABnvvK9pVtZ3TPDQ3uQHul1TI9mBpA1wKqpDsmXkveyolh2Cv/XqPoMSDIpSSL0dwaSqHtewbRdUMBui4Sgh4oHxvoT80zwadypIfp4SnVLnMr+cCruo+8E8Gyf6Eq+zpR+lQDFOgwQrfUj3hlzDfC+N9Ge9ajXTQLqRulfH8T+AcBVucSeD6Et6Bgmr1LlEcCRc6pTA5O2Xe4Z7hHQ/UilmBP6W+bnjrsfjI2dzdHZ2RprUNOrJh6QqmZrYOYVsZUZl9vnWoBxV0f7u9nD76jnzGsm/hNtrAN8OF++8waC973xzBNoOBb+kwFUaFqNhI713r+XtVOMuua16fzaTJ939f4oukfx9sa6cj3o0U/AmgqeHmDXpfu2q1Nw0QOY+tah2+Iugn+f1bg5NhU7GTukgNRtcu3YhinaN9q7G5A0ks5jFP/iSSgiPohq6S6cMPQwju7OWWKN8rzgrKoo0OG8glF2LmqKevpjSboY88zpr3HuVItFsx6QVB2n07cu7OYG+T7A/N9dABAyJ77DdC8FJp8CeClFc1ymmzunzJUvx88IrACk42euf8l6qp70JHGLxqMLlzYN2A2sahqItUW8JrG51RBXoYSUKPeglnXezZlD37OBT1NwZf08m7LN2+9us0qdUuJvA2QENPN0YidlE02F5JfYoCXgZxOHEw/UsdFPsAF7UnuAjPK5bh73zU04HSyzD5PTwgBL3KtNqmcYC3uVgzXFs+Cv5QrhLG9tsQ3OI6pdEP0SSIkYT6R4fmAIMOY0sKI2DlgIp/UFAoJyVQK+koDJM9qmrF1emVcW7VTlbtwDmafTXX7Zt3k508UiSCcDCtld+3SQo3AVAGl+MiaLkUDypJe3Fg7zQxJgSyRbIbhpINgmzZhNlCd5lcaVcayD6NFo2JYKX3Sl3MIzSswyCDTFAQzxA7f60Bj6+oy55Sk98O8R/fMedfh8EUA9Sr905e7cCVadkYWe4fJR09577493vvANeHcajf/20bfGWU88N6lJzenfAqUIdp797GfHGWeckbjXeRYlNw888ECS9nht27Zt8frXvz6+9rWvhSAmTzfccENce+21IZAx/eEf/mFceeWV8YQnPCFe85rXxNatW0OgtG/fvujo6Ii/+Zu/SfkOHjyY8j32sY+Nr3zlKwkgCZ7OP//8BNZygHTrrbfGNddck8BQenD612c+85kE3C6//PJ0xXK++tWvzkixKvM+1M++Q74azmehdiQ6m1W568P9f2Naq9nbNHfGJHDT28BLrwOCv3v9e1P1L/7ffwj3HccDD3mGj+yFZWlXpa2aSYBQAuRr8ziKLYcSjrLAiL96xEybhs2dsyj4wppM65kFKH9eW6M6JBaCpCRq4JEkIYKgLKvbRRnWLdNEA/cx+unfWm2LAB8Co+SKnL0jZy1JHOuwYAxJTCoT7nyxsYg6dFOsRlpxiKCsMiRk2FBDSnrHg6ZP9i20ijbYNt5LPaYlycdsviKgQZDhPprPCFOxAEg6Ut0uHw5dcOtKwDhtPThMUEqVlUWoBnaMVlxsuw8o2TgddoyKv7dVEdvJMXOhADxUb5NpZZKRVo9HtEzdDqYN43w/Xtv6GOV6vPypHun7Pw5IEYxOquZAmiKfbUqBW/lsK5LDFvI7D5nHuNrox5NeR/VqJh67HrzmjeH8oQA4amS9jgP2qhj/kyi5HVB6Wy0OJLDTub57e+ys2w842RKra4APrA16Sn2eU5l6pHUrydEJhKqLBb3e1W5N7ZcxNwGQW0fMuguaT4nrJ+9MoCeTHiL18bBz0ChENbpGVPV8T5RWyTSYICj7KNKgB0Z64zABdE9qXBdnNmyKTsbDh9Jc0M8y9kxT7L21jKnr0yKbWKWnM0NbGfl9rOe72f33c46mylIO6mTdVgHE98BUq8HO9qzRUlLpK7JHW06ektMGDI6qaK+Sw1aA5DaA2p0wQlIjzCvgxaNS8nzpuufSw/n+5m1Z+fuLNwIzJN8vXtNXWnw8j4D76SDqb+NseLpQ3dTWEye2cMARm4Ntnx+5ZEgvyOem+1BS5XPp85wLs5vwYmWrk60NzsA0YWM+iQ05cdnunD1psTlnuLKK7O7sZp1x5zjM2NAl6iSX5Ayq6lNMx3jGIYbHxp1si1/uRp+3YX6d+fej/wUQAEbKgNIRCAtHZwyiQGLkiBlgUpBLJcJMkGdeCaPDqHJM1RItcF4aZbyMVjEz4nxoA7JOEIC312fm5fereeGDAo6AtnxZKE8aGw5IJUoCIvO01jZC0GSOFLw/M37kg9TB/S9cTQ5k8wqU/MkgDxcWSBJLyqCU5GmPIImat8U2+j1Xb1zg8TmXeg4cjit++3XRd7gnfvftr48n/OZT4ZZDuMKZzsuc80DFFwmuf/u3f4s9e/bEu9/97pk7N954YzzucY+b+f6IRzwiSWhmLvBhFIP2Sy65JD760Y8m8KMr4XvvvTce//jHp2xtbW1x0kknpecETFdffXW6vnv37hRn7c1vfnMiugRAJj2BKUkS7JgGsJmwXdu3b49PfOIT8dznPjdJnLxne97xjnck9Tuf27lzZ2zbts1b/4+984DT9Krr/X967zvbe02ySZb0kEASQghNpEkRL03AgmJBPkpRiYgoXj9iuei9ohQVEeXShEgvCTEhhWz6ZnezNdtnd3pv9/s9zzy778zOzO6GcCXsnGTnfd/nOc/pzzn/+vs/aUkCWwnyOAtFza+zUgGjVFmGL0pigp2pk5NknlqFz7/v/8Sxxw/HDW/9mdjwzE1ePTnzk3AlX4vJtIv5TAAfMDPGH0o+PlbLQtAcz7xT2+FtiWPNPNVq+ikiWdLG8R7KgKWgmpp/Ua7MTmklYh40D9oolaAJki7mcmLSahAkaK6nAEBfmpS4V1adgTMUUUYV/iHzQEybh0+LcNbtEPe+62UweYO0wfejmj3SN26QBkqYczGZ4YkGmTqUFjemcwi+BCrQjCuLeZZV6V/nsBhNUtlxTZIaeUyWC8ztZHrUCDeWwAaxh3YX92E+1g75PZiY42L6OcR87inqjUZ8r8rYW2ValpeBPke/tgoqTZuz+rgHg0mzU3urYfLUCMloFFFOL8KbtM8zvoZDkLHw/e9P0NXUh61gMWOXMUcCbuBDRX317EWKZdJcMRibLlhHTKDu6O4FbY5OlsCAjMGkukpbyDlA/UvQXK1jDPWXG4BJ6q8AAAGG4jHM3NqBM99UtxJTt1Zyo/VjTH2fHfdcozQAkl2JDBKauuyafUE7xu42hMZwcXFdrKtYGHcNbINByxhTGeWK3IGItqill1EqB8wBo8Tk19NfVIfwBuuOkiPxcA/hNIa64qqGc/CjAlWP/1yjJQoaWQuFe6A+qZalUfQqhEzNaOe+C4ppJ7kKk+tWX6vdAu+gcbyAts0XEpy1apmmcsbZ00aGTubWdb0GyHRBMg6VY4rK++56ds1pWscgzaW5ETg+AnMM0vGhmPvyVBoBD9dHjpVG11B5NHEgrK4rgzmCCJ04wH5c+pK8jTAVyNvl5j/MoZBpkThg03krmawkbhp/gCkdmTieuTqhBeFg5iTmMBNrT1ln9t+Ux/6//PTQrQERSFMgJab6FxHJAuKHbYaGe+h7vIp9B1nPb6/Yo0xy2IY5Wh9SWSWx9sIk2dWGlDCTfqZL6Y+mQkkyyq9OGJZcBuxNSyvnYK2B6XFcs5K8M0PyYKeNFZhEVhOBcqYxdH6SKaI+UEifleqL71GN9NiezJRSD6kD0ul4W8wv06T0XvQmGZjZUn93b3zgVb8Zh3fvj5f8+uviBb/wqpS9DIJKol5zwdnSxRdfnG7LiBTW9eIXvzje/e53x86dO5Pv0Uc/+tHkd9SPI3ZVVeZBrRZH/5/nPS+DrJbxqcOxvdDMrampKWmP8jb4jGZx+ifp15QnmSE1SJrT6fdk0i9Jnwy1SJrYvfa1r403vOENyZxOJuy6665LGifzaGK3du3avLgn5TOf7zEIUudF87G0ipiSbF4nz00Z2rv5u/DN4vLXtj4Wt//r12LxOSvjRb/zBvJnTzwpDZuhEFsjg+CMjxNnTXNaqG+IXxYj1bMdZIu+sCl+Zw1KZA/JeKD98X0dkbnSVGsAJkeNrEVwT5Q50deKjVWghIG8JWiCSvgtMVyLL6JagxT3i/Jsk1WoOVUzUsmzVexNzUBe1yOxN8MxzKGGWOtsgfjmcIG1b1sV9lRLnPKcgi9LErRAUz/zelEtU7lEfCJoiTcGk5SxL+afSOSVLi5b4kOMURvmdjB+FQv5DRpbA75ALRD7VJNSPYySNP7hQTxe2JMdD6vfBRJfE34zS0HPdCUoANmAFkaN8BAEuTR0EYzKMXRKh9iZAFSLBjQm7gW+W1XkEdmuCLsu+6B23P1lkLHuh0GUySiCYRLkYcw+2Tf6X0wB9eyfMkiuxFG0cI5ne89gPLJtR6xasQzh2BhaqUDDCcgBz5bi67SCGFSVtKkdOOxayl0Og7aDRgrq0MV439GzLdqquuO8qiVJAFROHb7fCjpkimREZYb99F0oIoKqPkuiFw5iWicSXwVWGgMEjx0DFEOpYwanTaVp1tP0prHTvNGArTX6zBV3Ehy2CguPFdFcfZhAw91xz+DuuBJGezGmd2p0oor4g8TMKmIO3AJl9Hu6AF5CC2tAYuSfCKaKYiXQcg8W02Z+n3jHsnYIF3+EM/aOvu5Y04UfMGZ01TBJ7q2loPxZjtrOxHZyvQIG6RxmtXO0A8YXczrNNT0oUl/SAvTHXJobgfT+zw3D3Ag8pUbAjfSRDqRAPRLA47GgDr8iDoOcCTmTzmSyOndHSWz/O5PkVj37M5afzComSraWXpxshcTV+l92wWvZ0XQmdWd5ba8ExgCHqdLLrD9nXs6T9UQCm2Bb0cxPMIr8MLOdSmrbiaiuBFgzGdud37f+PtimDuzKDcAoTDuuXnGYA+wQRF1O1OTttDyflampxYm5mzG1PDVxMp8CMTgWs89OXornI74OrKFZ85PduVILmCXQ+GAEiwkoXAHxZHsyEisjGAr7Zn5rM0mf6d+lj5pSZ7Hr9IWaKUm4/tnr3xm7Htga17zy+fGa33vr8azOuH3tS6L345dP+8uiRYvipptuSkyIBOLrXve6UCOUM0cW9JGPfCSZ0eWFptg2SJALk8yLTFSeXvWqV8VLX/rSZKb3spe9LJnFea8WJ32ZNJkjfZ/27NkTV111VbS1tR1/XgAH2/E7v/M7ofbp6NGj6RmJOs0EV65cGW9605vyqn64Tyclnxi+CKfMBCeCarqC135/a1z++TvSJPZCCP78v30OYrIk3vA370y+NtM986O65jpKZB/0nQAJAhbI+6RV6k1T6pvkNl+4Bt2aNGVJcwEBPwyxboBX0eBSDC58c2oqq6OqGsAb9xX9hWC+9AVyfegPVIeWoIE1p2mfRL/vRFYdWinKKeHdtYxKxkXtSQd70xCE+zGZA8Y2MehQugm5jSZqetaLECQvxfEfRaOX9nMJW95LgU00hc1MV9VWAKVP/ZmZceop5aJV1z8GMI2yJVl/R9vRJHG9tJU5VTmdCOGJ/NQok1SMfV8bvkgyMg6Ygp1H0CxVY/Ar8ILX1EafUwTqG3vTOH0ZoU/9XNtc0hl9jD8eNjAW7g0i/OE75bjzz+Vkf0Xc6x0gBhSMqDfcQnyvZabUpg2zjwzgvzSK6fAI8yiogT5YPtva2hwLWueh5SmKHzyIwVl3V5y7elE0wEQ0Y0UBLwmjOR4H2jpiL//mn7ciaV/6GVMhsJm+eHTwECZ/g3Fx1YpoxcytAuZPMBXntBLAigSRnw1Z+i5zIey375ydKAb1Tx+3PJXBdDAZWSeZfb/B+hJGYxh0uJLYOMp40M/24o64c6QGM7vmmNfAOJDr3v5dMFirYj5Mp0NeUjmf8cAkE78lWVvX5Fg3UPH1gFvA0PSTZxV75TH62AHDZ2UDfM9mi3bRh3IAHPoBX7gXgIwjBJRdM4iAjPZWDPBe1NeldzQ/RAQWWYEgrBuT8m0AaSRhA2tErepcmhuBwhEo2C4KL899nxuBH98RcBvb0V6btuUKUOmW1nLoZKJITyM2OqSk2C4Xqu2n640EtMRlI+Yf+p0oRTud5HHgs5UcbKd6xpxlaAoKt17NNHrQQHQDwe2nQA5Gl59qNnI6bcnzWKaamf/uJIMh7HAdpm01HEKCT2QJ+FxszTswiRO4QGZmanLGthX1xQ6YpMcwEdnBgbePvP43HQORWEuIK/0o6qmvivqstw7NkQzIrMxOqjw78H2+BqmjUt7ZkuWpEZPYy5kfrwnfrQ+TPg1CdWv6lMm3JR1PTmqiqjA9dGxcH2rDpsvnkxJIH/7V98UDt9wVT7v+yvjlv3rPpAKV1tvuWvqd9WbS7dP68da3vjWZzGni9prXvCZWrlx5/Lnt27cn8zYZnjwtWLAg+ghiqclbng4cOJCe2717d9xxBwwESen0W97ylrj11ltT/i984Qt59rj22muTv9H3vve95AOlyV6eNNfTd0lToFtuuSWV0dDQEAsXLkzaJX2Qnrx0YuR9l5Pp0wzbwMLtB+LKz/5XlCD5LsFXwX+r62rjTy+5KC5lD/nvSq7FKgjWOtpQB6FoUFfXgtJ4tUpqBvQpMl/SDEB0+t21JVOiYEUghUqQ05qIpdUIo+u9fmIhjWCKpM+Mv01+CkDRjta2G8k/PBBrD0YfBn2gZyD6kf4LdlAGEap5olpWg592kncIf6mkgZCL435arxSb2mr5/LO9QzIS+N1oDmX4A4lxg32SIQlWBHgxAGj2fqdSUtvGCHbn88Y3MjRD+VKELUuos5+wD7vK4vCBfuChCS7As3myjDoC3bYaUBWmy1Y5Op2l7EE48PfhyyoTYdI8bUQfG/o0yhh4r5d6WmBH6oCJLqb9jvUwfkJVAAfYYhkmx2GAceyFeJfpsbikgaEZgh70sM67QHHrGuiNzcf2xuaO/XGwvyeBOgzRV0VJ7idaH5y3fmWs37Aapqc4Drd1Ui6ocpTf3tkXy5cujmc+/bJobmmKo1v3x/57d+I3htaHMSkHkdXzZvfoMVBAgcauBv21AUNlPmWObLdxi5wGtXVqh/1uovgk7NL3zckSMMMAuo6KWTRz84amvgsZi4vhRJtpXzP72jmYEZ5bcwhBFmaFjJWje6i/Pb7Z8WA8PnxM2zyYOMyw0TRaRhIcYaIpjHwPZoW9A6LL6uNVFJdiPv8svEFvHK+PjUUKR23BiVQGgEVFXXUcqC+Oe6uH4wBatD7Gu7d/gIYeZ7/TAwJjbKC8hZgn2j/nSfALxyp16kSxc9/O4hGY4Sg4i0dkrutPiRFIBzwtba4iSjkbvhuceDc9ENTdYxze2CUrCZw4hqfpE4Q8hLHIOm7M6SzgsMo8e6bJPnHJLVkCt4ZNPTE+HGCzJQ/qjBw5OZeHs/Va5uSt/uS8p7rioTv1wDjVMz/K+ye3xZnItGkzzYkMz0EkuYfxAWgTihWUuy6cnXuYS2fm+HMOGv8yHZRjB0HGYVwD6pwmOKY0n+nb9H9sXzqMmX+hyDUDPNUzMrD9SMxtZ2FyFpU+94N010tbuyBEuiEguyAK0ZVR04kkCaZfVlYfhzY3S/lz8nhlz/zT7/9V3PbZr8eai86Nt3/sj5PZy4nSJr6lMijBws4waVqnyZpEo5qhD33oQ/GKV7zieCn33HNPXHTRRUnKnF+UoHrRi14UH/7wh9Olr3zlK4nIWrVqVWJqXvKSl4TQ3KZ//dd/jQsvvDARYgIt5H5IDz30UGzZsiXd6+rqiuc+97kJpU4CXF8ny1eyrcboa1/7WipLkyDR87z3ZCWJI9ePBFOp6Gb0baa38bzvPjBpYdVgivetFzw33rxhfWz8Dvf+WxJvBnM3CKS2zvxH0S509nSjZUAf2wvxjEZHCrAaQlXmKdcU8BA0I+8U4y1TWAuh3FLXQLDUqqw8iF/p2nQAAEAASURBVPzkkM+eKDNQ+G6o/e1CSq8mWAJ/AAK0t7M7gTjI1EhgwwGk0fCvMMsDaEuGYLiGYQSKYXis173WFStkejXvoZop1QWDEvXUUYo5H82k/caCMiAuRDNajT7apj+Te342IbyB1JEJxCwX7cyERqxsHnvDCjQp1TB8R8Zj92NdcfgIbcWskK05JcupgeCeyiQ9PtoNQ0Gsoiwb46AgjtITIwFgC2eNTMMinlXAorBikH5qVlcNQZ8g4MmvL2Z3LwFQ0YqpiStFcFABE1CGBkilzBB90qfHsVDYck/P/vh678741uC+uGXkYHxvtC3uQqO1E38iY+UZOLaPpuw42BkdvTBOQLw/vPNwbN1zMDFlCxGWzF+1KOoXofGqLIm+x4/FQTSf/Ud7QHzFH2j7o3HwmIEWBuLhxx6N7Y9tZ0yOxIMPPchcYq7M2JrcTzL/NCzhWOsCSLgQjLuUgrP63tBoIS3cehYioLp0vCqaJ94hh/coZe0v7sIkEGaIAe9GgKSmpnuoL24h5tH+waOsQ/ZUmMM0c5RTi/ayqraStcKeypipIVN4wRTCzKp5h7kZq4yl1Heci0ujJ3OHCR3M/mBteWxpGItHaoriAGu1F+1cElfZKOp3TVewnywGq0G0xSEZTeHp7aATMZfmRoARmF1kOjdEcyPwYzoCpWgZZAmW1AqOPUwMAyVs6iCy/U0nT2V4GQtycickijTT8FBVMteFZkMnZTf6YiSqskzupSlN7JnmNQBorb5O5Btks3fTPU645/kLPi3DdkgApw36RKncyRizJ2M/9jCbrR0FTfpv+aoZRD0MTFfyF3KWTk62f5TD0vhBxnTR7MRZ0NxDEzaHTprIEVerNMB8F8xSKtDxnik5zprglUOMCc2eeVNkoz+1nOnKSGhN9AEX98Qo+Yxtzj59YvJMGtNE9/O8TRJ5lfhtZJ4NeQ1ogFhPSmXVeqqdytvyHx/+ZHzpbz8VC1cvi3d96s+jsibzCcqfPPlzcv0n3z/5yqpVq+KNb3xjYoKUJotyp59Pnh555JE4//zz85/HP0Wzk1HR/E6i+2Mf+1jSTuhf9I53vCMBOHjd8j75yU+m54T51mzupptuSiZ8XtdHyfT2t789mdpp9qN/k9Dgpje/+c2pPM3wZLquu+66hH6Xbj4JfzQrM77R6aT6tu4pM5w95dN1RzOG8HTKMc/3/unLsfn/Envqjs1R11gfNWiifpiUa3hOlEG/Jrrlh/tD9u7kq5GL+VcyZFknHshXIPfztZgz32o+9E1acck58exfe2U0LWzJtCJcL63MyAkhxrOSJHlhTGBoZI6srpKAn6LTDfRiQjVSRrDSMrT3E7AEtoNnZdjKKzE1g0AeI65TZS2EPuWXCLrDf33sC+7BK4HjboPIPwzjILS2vIsVK8AqhwnT3FehRnk1e+9K3lrQ2kcOg3y2Bw1VV3G0LCBgbW1mtme5NfgSQu1TXlf2LsLs7SjujQXlIPBhYjZKkFSs1pIZ4TgM0SDoaPNhThoxVxOuekC/Hj5dU2rlBMvgMfyOOCdsE9oNTSEdS/uj8MxTTMS+pLngen5OqFHq0ZyM+H6J+aMcIcDno+1agR9VK/5gV11+YdLS+vxVl16YmBaZvkMEkR3GbLBmaQsCFQRHy5ujvKU2xmEaDvZ3xEG0vFeg8VvNGPf39MWi+QuiFpj/LY92RGdXJ/5nxFqi/cdjJzGmFfgtVTPmx2w7jKt+ao5ZtscRIJ197gI1+KlPDBL37MsRNY3sa+W0xziCCYmRhegcdRNz6aHOHfjRNUc1aHaCK8hwuU5kAjmOMU1kr85kmOk6t0iAYfD3PKDOu/nWzZwpJFCTlp6mAHXzqjcPAZrXBR/VC3riql6e8yWg75ok+kIIzVOEibTgQjKDibm3irk0NwKMAIIcV8xcmhuBp84IeOj+++Et2MdzqFVw6rHZIcicOJSzflRxgAnZOtvidgN3QxxFKtePlElpaCkSvirM7ZShCfvpPmoy/GI7mgFN4ST0G5DSScSfTvIV6x7vSxJQN3DP8WQCyOHt2+ehoD+KxPvpJRs1cRikB9SgFCd7+qzDhffMkBFLHmj/nclxODTSxTgSe8Q2pcb4NyMMdFROfjkcwtm9rLUSFE0QBl517mWJnYcz7Y9lyqxWq8GhrjN93tbYBqHUO5EsJ3AFfg+gNbJdeTIPsnoctRM4fLpsfVUwZrJM0yXbZhkZhPFwfOvfvhx/9UvvjQb8D97/nx+JBSuXTPNYvg6yW+97wS/HzZ/5QixbtmyavLNf0odIM5tC36PZn8juagrX2goE8ZQkwaIJnszO1GQ8I03mpibXh+ANwoRPTfpCSLCJsjVTEq78xpe+MN72pT+bKctJ160zJ/5PujnlwvX/ABjDo/uZ3cnJWTiwfnF88803Tr4xw6+7/v2b8bG3fTCBUkzHfM7w2I/FZcdK88r/9eH/Fe9657vij+/7VApWzCAmLZwEeQN+NPrVuJv1w7h0sA5GWFtllRlK2jBrbaCrDx8k0CMb6qNWNLeJUe2GkO3jGTVRg30DUV2DKVhtHYR4lsN3pAcmZCGaissJ5joCsXt37/7YPd4DE8I+yBqpUkMDgd8DAa72SqRB/+OVTIT0SAe78JHyqKKM+kbMc1sAlKjippoK/usc643DwwA3qCnisWVFNXHhaH3UaX7FvjNKneVVNdEPo6d5bAl9G8AcbFBGiPb1IeTYOt4Zu9jnikEBNJhz0lBSdjUEv1on9x5j6w3QT82HBSww9tMQWkDXpEmC3fb4VwQ8ATYETNCEcT7M3KrS+ljAHgOYZ3qmxPFFM7Ub8IhHxjoYR/zBaH/S2NE9jjM6CFOAKebGyqWxtpRgsnwfQ3OSABNoUxcayAMHHo/Vq9ZFHaaWPQgl+mkTOq64rWtr7Bk5ClNLf5KZJtoenm9A87cJjc48GMJkqke9an88T+/v64lHCZ5eBuCL62GY9quJc3XYv1HbQ3+WgBq4BmazifHUeE8NYz/+ZPB+UUOsp+OgEFxX45cBXQD8UV0ae2FU2zkVOjXNRIBpSu9o+kO//eTyfHyjVgM2UcuYC55HdxF4jsdtJTBxgHi4Pks1F5x4znJ+YekNp33Om38u/WSNwPSn9U9WH+d68xM2Au5fCyogwAgA28thxR5XuKclpsdo5NkxM3PnPcyMCq7mSQ5LLYemAzr+y8B4Hnp4dSGR03fGa6Y2JKK9SPcaOZxq2dSVhs2WskPOV03kNpkjfVbQ7aeUtd+v1dhDn06yXx4SMm3JTIZS1UJUoVXz4E3wvzJ3/KfWwwPWA0m9mCOVXcnGTILH//5/JM0kGmBc+/DXsQ3VHKwyK6nNzIOaounmLBHOMCRKKy1jECLliSTLdj57GfsapkNm6UyT4245AlBAJiSiZRSQCLWJJkcyMWEw2Zae8pKvir4a2HNS//iR/c7KTPNFCfd++47kdyRh9e5Pf2hG5shnM3Y7m9Ft9z+cTNy4fMZJf6EnkqZjjixH4mc65sh70zFHXnctTsccee9MGTefOa2U5uD0mKSHrr0gFuPbMXkSqYVJf+jak7Vs09W/f8uuuPlP/jExj2rsnopJoI13/s47o6uzKz7/u/8nXvbHvwzDgN+fWhsIZ41QBbvQ1KwP06UU/wutk8E3TYIT6M8j2qXaD16YjIjl3rgaFghs43xVwIAYWFbmyJSTvlW8ewtgEMBvieLeIWCgS+MgTBYKBWC8KxI4hL4ng5jZSbAnxFClUBTgHlPeDJ9TCzMDo9TTXYtJH0HFG2HWmjEjqwDOH2HMMEiV7TBdBhrdPdIZ88uJjVbZlDQQZewBRTCCoqsJHz0gM0CbRok/dHC4L7aNdhIkFnADqmxkH1hU0YKWDIEdTJt7wJHRnhTSoBiGogbt5RBoNPVlnCVoTbprMZMc7k5j2AAk+dLSlmQCfIxnHoc5cTyHYQT2gS53GDO1+SPVaSw0OezoHoy+AbRRaIqKIfTLYECzxFzIEJhY731D/XHX0LbYVX4oNpQtjsXAcRtDTwZNs8fbHrkXTVJXXH4ZMP5oi7rYm3cMHYlOgrNWVLDrTcyHc21/NqBBa3YvpHjPz2LGzD1bH8JhTOSyXTEzJUzBgxmXUcziPZMUlAnvvh0tzj7Os6UwSqtpDRE7AIUA0XRizVie/zjuQV3kHOZThLql7KsLKKMPTds9mHruLGG9QRAUMdYKP9V0SR84FweA9e5hvJcPVcRyQEKKYGhHELIKqJH8D+0X+ebS3AjkI5DtWPmvuc+5EXiKjMCAPh9s3IX7mfugkKlVMDgatfl71uTGSAYPj0RiEkdDRiMdyBy6MiCHETd2QdCbChmJflDTBjCDSCAPxO6pxgQsi6Fycq0yYprn5clyTrQ7+9YHk+a3qtNkkixzAELfT5Nt7Uu+OpnmK68vq4u/FO73xChBJKTrXBOaoBH4W0fs5JZTcLpoyyaIeAuaPufky2Y7KRHLhBoXV2L6QQsEF7AdmsH0YlYjItZsSWmtLZcVmbatsz08cc/nBLMwWGUyc6G8M0kalshkaQqXs8W2ydGxL45yKWuwcP15Lxu9gppoiHNkDJlUFuPqmDx63yPxwdf/dsr4jk/8Say6cEPBQ/lX2sCYATCc/ECEC68UVQwzJgnCszXpo6Tm6oyTi+I0lsGhtYvi9pdfHVd8/vYTC5Dn7nzJlXFw3eLpq00LNf1JlWy//YF408//fPLJmv6Bp87VP/zDP4x/WrcaIhSYaqTvyewqaUX0F2T/5R1xnUJRM76Ogb4fkOAwLhK7/ETAoCAnM4nSbFnNwdCEU30dZl+VaAx9s3xbNM/ynVWD3zSqeRiACxDjw7XkgcnQyd5knf0EgM19aWRioOWzlDUjIeiVzAdWu4W38FhJ9LYjOOnGvLMJjVJjWYIET6EKxtAC8V9FTRPaFUxkYQAa0IqOEAB1CEFZKUxTd3dH0ih1oIW6v+1A9OA/qaazAqbqafPWRHM/72ZnBpZQBgO2pn4h/eqI3QNHknBuEfvh+pIFMdTWG9VNrbGj4iimaZ2xpmphlB8mpEA7Mf5WLUxM25ESfJnwJauCuB8AFfDAQF8cwIwt8xKD2EfuVkr/q1DcCtOdFrbDZ7/9wz7jfqWg5xB9ONQH84eoZx31N2Nwpnfk0ovXoQGsx3enPfaOtceBoWP4WGImB8LhCGAU+W6mILGCswTAfxheGCDGXOhyg/uOoP3TLy5D/HR/ZN75PYA2SoAH/ZlcEmp33DctVSPMbUUDaMAGY9MITAyIgUw6++2JlNYNP2VQBRZJbBYax9I+ykYtNC4HxVzLfOea4bQ/c62UBdYLz7iFsCBHYaBquNbGntlJ30pZU6IlzqW5ESgcgTkGqXA05r4/JUbAvV60MD/z5Bmgb4l20poxnUSQ5hkLP3lIswUPduN9SKDq7O+GqqQxMSFql9IWXvjgiStCdg9gMiJAQCNBRkVS8ywubJtPpnqmue69LGFSQF3H/W3yy9N8pgOF06UYs60xGMX8/Ms1XN73vzylA40GZWMCcV/QODDlgM+FAMCu/aQxm3hGeG7RqGRkqmAE/ae2LRVTUJbgBeLNCVjgPKgzmZo8tAycmrfGOr1Wg+RQ6GFN57LRO9F+yxBQQRM8Z2kc6aNaoCeemF8liwVjdKZlFbaucNwcDhkfx0LCyuQ6ktiScdI/waSUXXQvI8/n43ho1774w1f+GmhgffFr//sP4sJrTwRwzVeUxJ/PDqCFlNg0aepneuFbXh1///d/PykQbLpxlvy5+T9vjoXnrTyj3rKszig9dvm62HMBUMm7szhIR1bOx99jBu0bE+vaUJMiYaeUWu1Ja/O8M6rzxzWzPmYVAGmkvsG4JIQ2zKJq0DJUl/M+Y+7UCRHfh6lbtsgLesI7r8aplH1iXlljAr1J70T/ocT0lKJxKkMrZNJMbBhnnl7iKC2qrI/1IJnV9PMOwGhV4tBPWNQEWZ38Ssiv1mcYZlnGzT0lA41IRZ34w9wIEd5d2hcti4jpBFPU24Z53WG0XsTSaWotiXnV9WiUDEY+BEJgTXzin/8h+ju64xff8vNoR8tAsSuPjiOH40N/+qG45NLL44qfuiZWtixmh2I/xa9KMIPFaI8+B1DJw/c9lCDuBbRYf86GeAGmoDW1S1PQaQOnjrUPxbe/+o246tnPjNYlaHRgIBrR7GzecmfsenR73NjyglgEOt2CkgZM8zDjqwTEZrgjOgZ6QMfG6Jh1JXOQ4lShORK1EA4RRsIuM4DsG/yf9oxx+m1e16UClccQAu4uOhCrqhfEwtp50V9XEg8f2BePVXWiiWKeOBPd8wdBFh3BV6hIH04EWprCCUTh/MghDcAU9VFvBf5RIh9WcKbWGEtKCHeY1HwRFMMoNQBs0Yj5oQh/R7jvKeaJIoui2K8D9eByYku5ttL+yPU8mbMCQJUizlwWWQzizybqXxtau9FK1xXepWjQ3Go1Z1R77/kxxF7bT7u8fqiMNuF3NMz7Pz7EiS8SxFyaG4EpIzDHIE0ZkLmfT40RkFjPk4xNhaYVact2G566peY5T/7UkVfH4Jxc1r+kF0mTG79b5qnk8T4nASxyWT8anCZiTMwzvkNB+7yvxC5rWUYs+8tzpTDZbhmEMjZ4jQ+mT9mTtliggSx2Q1aSbZkt5bkm56HtOELXlmPLPkHQ5/fNPwA5vn+onXoyOZ4sSj2MYANQ2oINyAhI2PSB4NYH0yKTp9SwqbQu5pee7GfS29UTP/juHfGpP/9I3PCqyWhk9sx6NBE05b2hm8kOPDdR89CUEZPAeSLJ9aIE01G2zjNJ1p00SBPjYQFqgYYhEI63l29qEz2cjd2y+sJz4rzLN6WxcvxybZ80g8/4r6utPT7wil+PziPH4nXv+7V4xs88d6JZ2WrO+ywwRR77Ja8vrRvW3vPe/rPxtnNfHDfccENChTuTfj3V8/7jP/5j/MpbfyV+75a/P8Ou5KN4+o/JEO0/Z+msD6RS+VNEpMtiAlEqLdeASW3GE9JyzVrbf99N+yKogihsg/jhLK+aT0DSFVGJyWYnfpd7ig7b6+QLlLbAieFOKGhscQ2Yli0taY52GI/FwE63FXXwDyIXoY2CExHuluID1IOmpGmsJjZEYzQD7jBcDNOCqZ9SfzX5SVvEMwqiBiCCi9F2yJDOltwvh9BaH0ZL1FJVGy3LYew6Aew5gqnczkHu9kVjazk+dg34pZZHH8iA99x9Tzzr2mviwisuitL6SuD374idjz4Wa9auTSh484sb4rGt26IXIcfqdWuifmFFdB3rik0XPy2eT6DlQwcPxsc+8tF4OgzV0qVLoqQdwr59VyxbujCuePqlsah1PrtSeXRvPxSPde4DmvwgTIwCJwLDjtXF9kcfjR40Z4uXL41585bEI3EguspgDBh/zRXdC0TT86xJsNU9+ANxTw1OOpKcBP7xl8QIkFWTuVKY0YMwix3jB9Fulca+h3fE0vLVUTu/MZ0KPtGLIHAIzVU5yHiqafppl+bFPcRi0r+ygbhFmjWOmQftjmWvYH3so55u6i+D6dVfaeUgyH8EeG+EwSnCauPB0sHYzvmRnTBZy2xTGUwQnU8AFtlVqqXtpTCtJfoiTmh8RCw8AhPeT8iPYuiA3I/I2FmNMOD1aLqaOM9rgB9/pKwX80aEa54dMFel9GUUhjKdtxNr05GZS3Mj4AjMMUhz6+ApPQISoFUT2op82z/TDuVSfbdokYc0v8ok/Pr4nCB8ZyvXw1bpfjJ749AoTB5OHlgmtSsyYYV7cXaMZ5I6tSTJmzjlLvzj88rYTrBBSvZO/CrMeybfkcChgehD+tbIAeIRW5gcU//L65EhOgbQQjdmh7UccMNoQWSKBLTIkjmLElqd/kX1SArzMrswFXnpqqvjZa94eYzjO7CsqLGwqvzxk69NvVI4eFPv/ah/z1j35HHLm9EHuMB/fOBj8d1lrfFbH/7DZBbXj/ZHjRLnMwczks3egfjAq38Touzx+Km3vib9y57PVrSaQQPSum6yVZAxVXkdfnq9tKk63vv1v4vfes874wN/9icQkARIhNhJhGlh5h/ye266khfjkGTEF+3yBws6rZrphyR/7En5/M7XvxlrzlkX937/nnj/Pf8czUvmZ4MxQSQ+KZVYSN6XGebfd9i3xKTwImk8OV5LINplIJL2CBa5nP3qJyk5zO6f+gy57TVX1sU3H7ozCawuW3de0urXoU3qwRxNYU6ZQCUIY1woI3CNFfw+3N0e//CdL8QrLr+BcDjCOGOeBkNSwgvSCnO0Gow0qGI0Bggd2B9FijMZf6eXd8lYQWzbvE9ooGEGfEvSnj7DXKWH03xmM6awzUCxQ8Q+amkCNKK+KrbcsjNGDnRE74OD0bFqaay5emFiyFauXhGbH3wwNmy6kNkdjkce2BILFs7H7K4e87bR+MIXvhiPo30RpOLWb90Sr/8fr0VYwpkC09CJz1ZPZwfgB3VRA/jErbd+L26++T9jCczO1VdeEd/l92tf+3Oxm+DJX/nK19E0NsWOnTtj1Zq1UcbY3vzZL8a27Y8lxkewhle/7jWxYHFDCjxewhiXVmYgCcYjGoVJ9NRJsY3Iq4DlRGKHZmxE1CuBkamuIn4QYAvGmnLIZE4WXbQKwAcAGEAO1Iyug/1nVChsTN7GKvTdRVCERqkPBmgbFdUTU0hmtpz1PkyZY/pl8bupsiZWon3bSvylZgSYmzA7bKEeQTv6YbjGukdiA75EgzApu/D7ypk7Yhinc0M0wqRfog/2R7AGTQftTTHrQD+nfoA92kShE2SBcbBvFcREWosQbxUarDrWJxgMMY7wsqVyWdzXj3YMTWU+IiL2nUiOgEkLjfx7dmXu79k3AoUr4+zr/VyPn9IjkGCXUf2ftkndLL1VI6G5nMS9AT8lYgu1VLM8evyWhFEtPkSWkZG22S2JYAkojQIHJkwD863XT6VXxlXy8M8IreNFFnzRbjyiE5uAkREOtXIgZTmgnozk0dOFBK5WB1zafqpk/yTW20dyaGOvTH5OP59jQ0C3cvipNenr7o1fvOplITy0UM9nU/qD997EoV0UzfgRPPvXXwWBo8dAsp7HIX08/tcb3hM7Nm+Jq19+Y7z2D97G0GRHtyhXxlZyrAu1TTONnWUuuGBVvPWzH4yD2/dEX0dPIs6Vqj8ZSZ1qFWtUn6ecuLBc574ELQmKRpi98ahtxsSoDhhf4lhpCilT/aNKC55/QcxfvSTeuGYpzCCE1nAF762BRQfQ4GWeGU9G3el9hsicqpXwurpIfcAUWPguaSYrqem7lJ5LDTBfZiZ6Ou0xQK5xqa644orj2Q3Ca7Ddyy67LMGoH7/Bly996UthoF/jSRUi44ky+LnPfS75PL34xS+eFjhDqPaf+qmfikWLFqUijx49muJVqR16+ctfHo2N0wgyJiq3zy3FNSGIgFJ9/Uu2HXgc5LHKWL9qZTL/lOitAazAAM6LSlowncvWzJA+I9hnDQIaoJZDc6+VdUtiWc18iHf2Qsy75gGCU8baGi0BHpxrY+xTo2iMkv8gxLjw08ayK8JJ3+eFyxYxzjlIyYXq1lTAIDgnSZ4jY+U8qXkiTwcAC1yIZrTf48BhX3/15Ukz9p27HojOdlBIMWM777zzYs+uPQRpPRydbUeBE0fDtWJZ6C9lTLF9+/bFK3/ulbFq3er4xpe/hoaKd5dxvOf7d8W+Pbvj8T0H4pz1a9M8GDz2okueFq/8mZ9B49Qf3/zOLfgz9cRt37stnnP9s9AEPzu++tWvxf79B+LAvgOx+d7744YX3hDLV62Kj/6fv4+d23fE/Nb1rHP2V2HOYTirGKMqGMdBmL1BmKSoYExAedO3KxsHtduMG9qZGswjZSRkBHphYEW9cwDcq0paa6O+K5IvUBWvbxtMRht8aY/MFozJOIIXh1Vd0h506IvRIjUzBzKGBmwthWEsqmiIcjSEFzC+8wePRHMPvlqOOQ+KFlvLvZFKzCGJUXTOQClmg5i+ATREEZjYaZ45Ek30R22iIsVi5neEvbMXk7pKGKHRUgIQw3T2YtY5QLwj40tRLOuhMlbBsG0c45yk24ruiirRhFXMR5NUHOvLFmAVcQyLBxltF0i2Hq3XbwKMMASgkFak316dS2fnCMwxSGfnvD/le+0mbsBNie8TRMgT6FbaQNlgYVxGJYAoTSInM4k7/fI8LHRwrdIuekpKCnwOsQQjTns9lvONWZ+aeggHD60TV/1miZNT0jhwa09nTTIjWNAA9PEEHTA555n+QvIKIS6DWA+Ck9JGiV7HIRET0xSXte7kNp7ICuFDmQJctJTUxW1f/iYH/nPOOuYoHw9hqteetyEue8Nzo3oi5o1at0/8xp/GA9++M8695uJ4w1/9Dkyv4A8Qe9xTMydzZJptpPM6sk/mDsJy0Tkr0no6s2cnlzT1lyRRDfD2ajmnvnNpGY4WR89BADBA3q9vLYq1oIL1IxboZA08UXPIqW2Y/NtR8V0xAZs8WhbtvQCAQGRVgAaWBi2/nWV6Yn9TGewLSM2LIXY1yZ2cJDo1efUdzkQMMrQScwISJAjliXYY2wef+FnT3XffnQLkfuADHzjOIP3lX/5lCsz7pje9Kb1Dz8Nc693vfncq561vfWtijgyqa5Df3/3d342f+7mfi127dqXYUm9729vCMv/8z/88vv/97ycAgbwB//Zv/xa/8Au/EHfeeWdikIRgv/zyy1OMK2HTrdd7Bu2dLmkyuLwMnyr8TfqKhhKzIcGeYKDZR/rVfOJjshridFnJvHhg97a4d8/WpBG9bMW5cfXqCyCKocAZP9e9pmTf235vNIIy8Mw1m2BKBuILW+6IR9sejxUNC+Na8rdWAAuAAMtUAYO2EA3FIVaaWirXAZdSEsBBX0PlA/IHMk+aPvs9XzclFbCyUsM853/uV2pWSonXdOe9d2E2yJ64uAXzMfxqmPslS5dEH6aEjz70MOZu2+K8CzcSaPWxpHVpO3I0avCJ0n9qiCJvZI5kDA1ufOUzrornPefGxFz87d/+73j8cQ3PxqOpIdPyjvGu+1tIbbUzDTCl+vmIBFlefiyOHjsSR9va4sufuznqeGZ4YBgG2jmhM/xvF4zn14e2uQoGsQZTNgElxmCyK7GwqJBxcW2S0d66ShVcdDJmHfwzvMBEUcwdFgBtnTH+wNGIi89Dg8OSVQuDH5hjl5hLM5MsTT+eu4swR+T9XwPgxKraFZjHscjNQmVV1HlOw6oYKDlA/KnDlIGmKD2O2Z3tQlNVSdvPh0nuZf/roa4O1syd1Hz+UGUsYL8ph6Eb46wsQaDUB9resQE8Yyn3CAKYLoAv+tAelbMGqxDeLMFq4VyYozLmeoS1WF5F2ICKpjSu6L5ifll9LC5rju2jh1IfnG8RVdX6ii6raaJM4wnw+ZRt7s9ZOAJzDNJZOOk/CV0W8vl0oLxn7aubPdtuL4S8fi8eHKYMbtv4NhkQxFRiMMs1+a/P1hL/Q33Wyfk1uZGVG01maTqLZmUDKQvBKXGVHTeWmT1tuzK9U2E942iOhmNBw5HY174oDnXiVNtI9HQOlUkpL2yiQ3m/spLzX5OeoDaD5fbRByRztEGNmqh4atMK/akmP3WqX0jNOXRMu7Zsj8svuvhUD/zE3pfAXL9hfXTuPxrVG7KgoJ9//z/EnZ/5Ziy7YG285aO/j5Qc4gB/MGMmScg4/x7UZ8qs54M4/Uznd8/sM2mJoDz1rTp5fWsOQ8LMBTqYlTMWR2CU9EmrnVeO7X8lawlvtoyyOrOKJ3LbF4UJaix8WRwX69FnTTbe+yM4dQ+jbShBsqw0OCPCnlB12UPpPaK3FJSCeUpcU3AJBFxGVGcEooSmoDHDvIdl7EsSnzQvI0b5ojO8xLUNGkOjMFv6i7/4i/izP/uzWLVq1aRsf/3Xfx3/irP/pZdeGjJECxcuDJmlLuCYJcAfeOCBBAJwzTXXpN8+/OUvfzne9a53hQySacWKFYlRevrTn55+ywD90R/90aS4WTJRapNsh8lgwAbtfe1rX5t+T/0zhOainTY0o3Ho6j1M/JsTUnnzulZEaWwub4yHdj0WX9j8vbho2brkJ/SJ274UDRDS8+oEiS7Bp2WQ+7ckBuoNV7wgjdXffO8LCR1t05K18e3tP4gDPe3x+ouuw2yKyWHudcifB+R3NfvWIPOjFsk3R58knfcFahDxzPUxNamFck1506nmceLyAJcNEEHLJWi/9rYTnJUYPSuWRHU97yx1ClV+ydMvj89/+nNJ8/Xil78saXg0GZvX0gyyHL6Y7d0x0tIft37/7li/em0ycytWu4YmpKy6hnVRkkzDXBNDmsLBZBrPyc9qgkFr8nYUDVV7R1eKCzaExqy+vimWLFkcz3rhc2PDOetTvKLGhibM0o6iUXNt8Y//hyljCAaihqiyNWpU2H8zU97M7NOzppfzpxM/nF78XQV8yPcYTyHHzqIa8e9qqUdTx9jZbk3rki6GtZ/M9chD1pQc2360Vz2VWBXgQ1ZZ1BorEbSV+C7AfFi+JVfULSYnfe87wi9HHPKTPKAk4OxKwFoYvg20/74iBCp05mjJUNxOG88dr8ZvCeQ+2qJ28BCn00PELTw2DDNJG6owJa6pAqAJFrAZf6PzYI4qKcd2ltbMiwpQA4cUTFCqtRpweGV5S+wZOormcCyF6xDGvYdx6RjohUGCcZtgmMg+l87iEZhjkM7iyX+qdt0NWVjtdLLlnXDnm+4UzO9P8+km3cemOYzEaOqjwndXIHnTZ0hpvhJwCaHpks8aa6MOjdZ0yYjpgj5kdaD5YhMvQ9Llbp0dHj6VkZ0yJ/oEDbNJ1xNnaeIMmig2O+TmcRCNNRyO/R3zo62rNVrrj1DOBJPkOJCUlI3jIF6CNJCeJHt+mSCJ7QwEIasvy+1ftEjUe3CUKPJ86iNj/uzO1NFJl2f9I5FYRxyPjNkkoC9akx9ZLJtZW/LjdVPfANO3PvK5+PqH/y3mLV8Uv/kvH8yIRAi2ZGQpUUMeR31onDUIozqYmIupc2ZJ/z8S2hEIG5EaFc5PLLFpKy7B6bpuoa0vjr4j9BWtQsM8NL2Y07QNddGnM19LPqEUPDdjcxS85loWzS8Bg7DeR6WWMKEp5V1Q//lDJTqpYECtQ9I8UJi+GRKMOXOUl297RHlM2j7mSlGIWhSZOR3KayF42QLS+1SBtHy2tHLlyrj//vvjt37rt45na0NzsH///ti0aVO6plZh6dKlSWu0devWZG63ZcuWuOOOO+IlL3nJcc3Sr/zKr6T8Eopf+cpXMEfqjPXr1x+/9sY3vjE+9KEPHWegvPHQQw/Fq1/96pTHP1dffXViqmZikJyHoz2dsbC1ygE7aXFo3inBPQShu6p1Sbz5mhenPa8LQvTWrZtjz7FD0VRNRCFgmT9/7y2YeQ3FW57503H1yvPjzp0PxtYDu+N/XP6ckEGy/P985M5o6+9ODvxD/QSbhfjWl6lEc2M0USUJnAFfzz6EXjAKRfi1lBs6gbmzrYVJ/zx9WrK3SkGEeyjlsfd1lg2ihV2SNEAlrCvzVNciksN87fwLzo9v4CO0ev6KBKpQV0kQa5iINZjOLcQ/6as3fwXtTjkxlnpi1dLloNXVxKMwsJ3HgO8+fCRBjC9ZviQO8V31zDgcjM/LHBkj7BlXXxVf/8a3Yg8mlY88ujXWrtsQK1euiJWrVsY3Mbl74Af3RQ9M6fNe8sIYWUL8IjRlIzAwqR/OAd/60LQwKEkzkq3PUeI6AagjA0X/hEw3X4oVZK8ZnGEYrbIy57Ak1gNfvn5jS4wPoxUE4a2qwlhNddHWgwbVzDyb7VDZd/8Ko60g5J6+ndFQUYtmD9NMs6WU5a+oW4CGrSErQ+EZ5+AI/l/dw7uQr/THaubqAO/yfsz2SjGdHEIgeB8Mazvn4fnD+LxCsT5YNhBdMDb6pFUDLlFfybhxpuovtRY01Dra1y+Tg+aovLoVBlsm9MRZlkB1EFQY/0g/2RbM9SrR1vUMINQBRMjgvlW0f0PNUnYx97K5dLaOwByDdLbO/FO835M2Lja6JN/igCtXwnwaSSdeEdoGOLhnSpq91WDyIWnTw8ZvhPTpCDy3fn2IUPJzHvhrcvKKmqVKpFLW5+90XHuqpJQ9IxPWA3OiVFyZpwSaPg+FJVp/JVK3+dUwUaNHcXBupSyklw1tbPhZ7UpPPTCto2o0c77VzA9qwIrRvGHHDSEn41dYtgxgNwFxPUps2nR9zdo7+1/bLnPXQqT3H9oEcvaqnmJ3HdGiuOfz34nP/N7fRl1LQ7zrM38RSxYtSXMlNVE4H34Xdr4MCXlJWqtZ3KvCPA5ANldKwzX1QsMD8SARNDXfExks2+scao/vGjqdMosgzOoWmhOtAGjYRZpeNfv7+II/7ab4RAXCkBTbLL0LWQtSaRBC+h8WY44zBnE2Quwy6cNifI98Lst52lVNyuhMWJZSfcsR0rpEB4cZUmHPBHjJUQ3dp4wNUz2hFVTMMluSwTElKf1Exnnz5iW/o49+9KPxi7/4i/Hd7343ZIw0odPnRYbqN3/zNxMzc9VVV8Uf//EfJxO7icfj9a9/fXzqU5+K3/7t3z4eiFdNkb5K119/fZ4tfVpmYbDepqam2Lx586Q8k3+wQmTsk4ZEzefEXb64d0mEsuWQcPQHivn/3v0tCNH+qKvCb6m3k9HICO723p547Mjjce7i1cA/Y0IM03Cg82i0EWPok9//evxHxW341BCnCBO2MZjUHQQEPTKGCRgxCwRqOIz2e0gNJsGV1YKM9BOUe0KLAAfBi4RALWtI1hraJmCGAqoB9ktXi4S/mpJizLms6/B4R7SONkBwV7K2RuNFL30Jgp6aqMXE7c1vfQvMEv2tq4yrbrg2+TAVgWr3ste9Mh6+/6Hoxjdm/cZzYt6CeXFd5Q2xby9hUGHYLuL5VWtXRV1jQ1xQcZELLIaqYWTKGuKnX/PyqF7QGJesXR7N81vQwh6Ja6+/LhrrG5iTxvjZ17467r7vgTgMtPjqtSujGtO/XQOPJw1b4XrxPVML0idaG32qYk/Acysx+kuKEFTBjB1jvIiohMaMd5o58yzgchrPJhiG1Zih9XV1xA/u3hJXXrQu6mswgwM4oxxNjeALibGibIUU2XuGSI4yimBS2oAev7NrW1zbdB7m42jM0oj7J8tZWs4c8lzyGYMB02ewpml5DPXsiwoAF87lhGpnz+innjLqHOV93o3pYw++RkVo2tSAscVEKUGE62nrCkzqlsMYNcEUlrHgimC6qtBKjgLw0Q3inykFMWadeo4/1LcvtjBult1UUcHexnphrRxBYzfAHDUBWHFp3apYV8O+TB/n0tk7AnMM0tk790/pnrvVunUpmeX4i8MDIxysknP5NsyXmVJ6hkCzMCP59j5zVswfYFSU4Geln5xTIkgCbrbk4Yv3BlIvDmRMSbKj4sQTsio9MC0ySVkfsnqTSdFJuTMmaQl+FqPj2Kf3gA+EWVFDTQedx8yEg8SzLteCjSMFVyOlTXsRGgmD6Rbh96T5XO7jYksksGshxr1mjJ5Tjc2J1mffbLdlNCJpbMLvyO9nWsbf/M3fJIKuBqfnPE3nnP7www8n34g8T/6p74VBGmdyNPdQ1gHe53VaVxJvuvnmm+PwYaj5grRkyZJEdOqnMTUpWdexXP+MqSlvw9Trmrrs3/xY/OM7PxRqEt79r38Ry0HFci3MOk5p7QB2AaGt2aPaCsc6T66/aoiCMrSezrvgIuMEXDTfD5sScwTzL9TGrG2cUpHrHF97zH9Y7x0wCHWYveEbBWU0JeeJn9PdUVekH4lO99PdTxqK1DKJQo8ztawQvG4MUn5PMPm+2gdjpDnYM7370xVfWKsMwCDvH81PWtwcwn6652a7JriJDM773ve+BBQglPuCBQtix44doYZJJkYiUBO797///ZMYJCHQ//RP/zSe//znJ3M6mah/+Zd/idtuu+2kKgWGGAJdLE9+r6+vz39O+6kWR2f/BO2cNDJMM+9ZNRqAtaUL2dPGYxk+IH/7wLcSYf22Z78yGqtr4/e6/w5CF/EOa6IKc7BfvuHlcd+ebfHl+/4rFuJUX4/p1PJ5C+PNV78oLly0iv2KoMqs6THm5Z6BnbG/BjM6bACG+llbCAVcIMM9AO2wzzkWYzC0SeuHpkiksmwONSkjq3mo2/ktYm9Ma5t+yFCM4N8j2IT+c4ejA61FHYT7sWha1kh947Eb06yqhbXAXg/HdmC7DaBaTFu2DT6WzLU0z2uk/zth8O478Hg0oCGrumBhNFJmA8T30ZH+2NF3jKC0tUnLuGvk8SSAqFhRGw8OHiKo7L5oXUWYhHXN+NPUJc3I6HB3HCgiMDnlrCxeBDDBYDzauxNTuX67ndqdOHq+pt+sOZVICgF5dbk1FmsIP3F+keFgi2OAOEAyGkPElBtgDEpgDIvK2a85O6p42ysUNsD8NTVURw9+WKBRxFFCWThOVexd9ZiTayreTTuyJFvKXKIBHIfT2tXbhgXBrrisfk3SPPs62j5HWo2sfnmZNh0tFnNTRnwrtb6Do3tiAXDly2FKt40TXJf8MmP+ay9BECKThDCkiLkVdW8TACGrYaiKua4GcAwNcgW+amNc7+vC1BHmODHBzOtRgFse7NsbR8Y7qZP4W2j+6hFamjoAyejq6wOgA2CUupWxtmpROr/Szbk/Z+0IzDFIZ+3UP7U7LhB3BcS+ZPyeHqRkHFI1HM6z0F/HOyzZrtRRxqeQmDmeYeKLDqRkhZHKtC0zE0lp909l+W2m5PMGUGXnTfb2Wb7s0NBfQ81RXocHEUcIWcg/bRKkojSW1RFFHQShtp4F2HtjllfRQfBGzJGsBwLx+H90Rcma/ZXolFyQsBni0MrrLEdSb3yghDtHZHq1TLZjtj7lTbNcpflNOEw3ldRO1HM6T+YlREK402dCR/OcQZrJOV3/ie985zvHHxbB6zGcpV/zmtckU6KZHM2f8YxnxOrVq+Piiy+O5zznOclH43Wve13ce++9sW3btuPlffWrX02+GCKGFdYjrKy+IN43Fd4rbMPxggq+GEjzX373rxOh8I6P/0msuejcNLaOnf4QJh2tp0vZnCG5VUM6hfFxlJXWq9/wu0Sn5mhKkU+1xqerK7+mf4bxTdTKnt4qyJ/MPnk0yutxfH8cpu4IhGkL0nLeuenScYZEInVSymr2b75O89teSwSXn0iufQ9ceGqQnqxku36Y5NPOiTDtaq0HgcM+FUjDdPW5Dm+99VYQvHrTu3HhhRfGmjVrYu/evXHRRcTkgSEweV1mSZOi22+/PfkdKQTQZ+lnQEtzvR46dCgeeeQR4uhkAWv7IAyvvfba+PjHP46fy5I4cODA8Sb4feXKlcd/n/SFDpZBvFbyT79QmVlRx/YeOxx3PvpIYoQUStQvIh4NZku7jx6Me3Zvifa+7th2cHdcvfZ8ioTohnFYN39ZXLLs3Pjrb3w6vr1tc1yzfhPmiTXxpUfviHaI830AFchwXsV1iWT355I6xE4Q+3IDlWiJajCBE8VNmOgOAB58raopW948JeZTv59+3iGZbmPJDXKPbTBjhsk0jFZD5lgTrwSUMtyJmSt+O7RBLaprIn8FFSQ9tqMnBmu7o3p+SXRU9ER/977ox/9piKCwMmhHBrswI6yJBVGDrxExtEZ6QI1DexNtqUmu4wr28hL2XMuzj4/jpyN2xfmV82JNaWMMIxw5BDO4re8ggXc5K9BouX+XCdSA1mR0kDcBBmGcsXaf8Z8mhMb4gd2LVgRiq4nRBCtB6WJqsFvzXicm0Zdm4pgZ1oIBZsmQF5Zx2YVr6Ut/PNjdFe0VrF1NRmEq3GN6QB90u3LOLUJNoowLEkAYlLF4sHN30hKtq1oY82AyuZsEJFnQWPLTfuNYKdAaJKBwIJwror/RDdIf49QG2MpRGbz0BnG+cDaNg9cts+dzpgZnhEaknYDPIpBYx+jlAO+Z607mSOCKR/sOxLahAzFG3COh5mvQHnl+6hdZCfpeRfdgbBypiCXVLTDnC9M8pwrm/pzVIzDHIJ3V0//U7LwExyAHRDFMwPZOYirwezWxGU6HOXKvdfM/2e/IUtnASX4TyrgWIlPTBQ/J2ZLbs+0xFsepkkSSh2xhcpMeZBOfTAAiEffAS60pzF34HcYQYmRFQ1fsw9a+CClqIo45wCRYPAgtQ6JU2/MKDpAq+mQPbbOofXmfPbwq0qHjNfvvIViSUJ3MPVty1PCqinkQQHWYNdjmrJTZnjpxTymf8MSOdXn5ZE3cTM7pN954Y/jPNDAwkBge4Yp9Xsfz6RzNJSglMD/5yU+m5yQs3/GOd4QM0nve8550zT8ifX3rW99KDJsQxxKOeRKiXA1RXnf+ObUNef7Cz75OCCmIpl/98Htj0/VXpluOnbFgKmFO1Yb0EQAzN88qfNbv2bhK/J+Yt/y6knX94LIV7HywxpjrbkE2zmg2LFEe3gj0MkeTIb2zu6fzl3eiuz86tuyN9sfaUqR68Egg/qZhXph3HelrVsyLqvXzke5O0Rb5YkMP2bfCdeXy1U9OCONxXr4RARooP2OQ8pE4nbb+6POkuaOd38b37Jp3bjzjCmXsP/jBDyZG5hvf+EaCAF+1alVilly7Cgdc35rSqd2UMM81pf/0T/8UoigKES6TpCbqve997/E2bNy4Ma1xmTCJyr/7u79L8N6+K5/97Gfjn//5n4/nnfpFxr6ptgFADv0WNXUcj43LVqcYN/fu2cKcwYBQpkzUCzZdmXzGvvHwXbG0ZX48Y8NFsaixNeqrq+Pi1RtCX541C5bEK694duw4ciA9++Zrfjo+d++t8Zk7vhFNdY1x4/lXJJMrzfQERrCf5VWVSP6rYAJghCDW22GMDne1Y/ZWHLVoosu5dnzd8KWnrzdpOSowG5PtTn5ME9rGxGDAIIAenhSQ7otqZNthatT+NZfWRiUmYWpLXI1FTezbmvMdrkzANmMtMDj4Q2nuXF1VFbWVtdEKkyfjZlwn93qKT+2xbDW0jqH7pzGESmDyBfsYKx8JjOHQYhXHVgLuqhmRsVCX2ys4wYDMCsIstnPLKcJPaARzw1HnAO2MTEuRTDPPDONvUw8zAPuRKVV9b3x5UOv4NuajI5hIOnFgKgz8mwLMwvAc4T2+5cGHouEy/KnQJlN4HMMPbAhNG5wqmjpEap4dvHICM4xwFhfhzyRi4+ajj8WjZXtjWWUrfk2LYgGmhImRpg79+SrYr/WhSom2ihSp/pIQwLEWVMpOxnJEO82JlAQpSWDDBcroZo6b/Up/LKWE5xNjRP9dG54pD/fvjUeHDuL7BGS8DBzFeabv7euMZcRJWovfUzEmsH1MehkgOeXFil31PYQpmxA8TFQ/93GWjcAcg3SWTfhPSnc9rPZ2chgOlsXlC416nm/zs/Qw7bM6drsBpv2cv9nm68HgkWc5bsIyCx48HqCnSuZQ7peXNVt+a7PcwuRh638Se4VJ0xSvTGanCnP4Ha0U5iLLG7qTg6zaH7UGnZoWTNSTJJ72hEPWmm2Drc3N+bwmcloJ/7LR4AJJCaOwqWqSZkqOkD4irRWNyEdhKCeVMNNTk68r7X7zm98cr3rVqybFaZnNOV3zojz9/u//flx55ZXJZM5rszmaF/pTaLo32XYf5hkNkT4bEomFvhiWqxO82iN9PqamqW2Yet/fmvO86FdeE9e86vnptrOh5LgKPzfn33gxmrdIuDiHJyfXgzM0ef045mqLxrW/z+9RVinzrQ+TQCOTnzi55OmvFK6G6XNMd5WqiYc0HEc374z6Y+Nxw/XXY34FMUqXbMdJpbLOhTG+61Ec2SHmmjctZ4Fm/Tev75baVZm1wpT6PfGOqAsWDEUEuxLNrU6R8vE4qS2neO6Hub3v4R3RdYRgUU8gaWL367/+6wluW38omXw/jV0k4tx1110X+gu5nkWvM/3qr/5qeq8Ed5BoFJFOX6XZktrbL37xiwnMQcm+iHki582UjE3U1FiHFr89ekEia8Mk7cpzNsUzzr2EeWYeGOB8/1Hd8Oqrn4vEn4swA+pQzMJrES+65JqEevhw195Yt2JlbFy5lv3Mfbo0XnvN8/nLTsPCaseh/8HuPWiHui04gTIkjQTluJ/tx6/pEP9K0RAswjSwhj6oB0+aWdaHPia9fUB3479Sp0aCMjQ/JuQoGpPM7KsMgIUSTMrSWUDH8zXbgwbJwNiVvK8KNQRz0KeluBU0PbQ/I21lMB6DUdbMkynGEEwP9XdC8reDRKdAylhFaunnJ7h86uG/RITBoMmUGHxb5DfHrph3V39STRBlXhR+pZhQ9MH5xDAtRvgukp+EfBFw1451CQh2aeAdewa3CoFZC76ow5hLJtAKuKpUrmZ1aGnK0LzJH2ry5n5eirqtCBO7ETVBlDQwD7CdFS1JiCGK3KDMMBYPhhMooS8J5W5inPiAWeJZkSTR6onYN0Q9W4f3xR5QDpcCnKBvz/LqebQfIUpfR+zYs49xK4oVSxfFw488FAcPHYiLCFOwBHPP/VhD7E0sU+Gbms2IGsAu5qPY0BqMreM4BKDDWNc+gBYAmOARGbcyyqktq00IhAMwbe4T4zBSS2F0L4QpquZ7Pz0vZc6rqitipGc/mjzoAcxCDUprbXPp7ByBOQbp7Jz3p3av2fh2dmDL3VsZG1u7kiPwGMS9B9qpkjbZmYRe8iojvrSlloisggCr0yHeTTVt36cqLbtvSVnwz4L8FG753pvk6EkThQlWiqYWS5JWIlZtVTeHbdaqrBwZpmHaZmR5y5o5UR5tV2JmLKPcTCt/hvMgaSg81PNr6fSYKNBRE/ghk4lOrsXDfIA2ZEfl5Hs+V4OD7LyKeowapgeoOP7E8YqPXzn+Ra3Pz/7szx7/nX+ZzTldXwtTe3t7ig8jzHGedu2a2dHcMTJpmnTTTTeFGqrC9OlPfzr5XBhnZmp6//vfn4hOkaYK03RtKLyff69taohnvuL5aZwlfgxwqUTYlM27a4EtGaKmZxrNj0OoBlLGyvyOv9f8rXljRsrxMZG8lyTF+YUz+HS+1YqWoZm07Fmmb5pSMWMinkt0DMYNz3peCmw5TaZJl4aGVkcpxMl/3HdrjF+4bNI9++Cbok7Udzx/z5V3Z2aoEkIjIAGiqcK8Th8kiaOpSVPBRI4ycJrpDFOqtHopgSo3/NcjsWjrPkySSmP3ppXx2MVrKSvXZE1T2NTCT/HbEu6/+bZT5Dpx++Mf//iJH3y7DgZI5r6jo+OkwK2+OwoXjh07dtxszodFu3M99/T0JARJGarpkgKFPEloq4US8a4azY5M0mxJpmRr3/6ELiZTu4c4N5rDSeSbNLdrMsgrJpBHMTUTpCbFSJoYWzWKak9XVi5IfpxqUTd373Rmoh9/lmHAEtz/SvHfMfVhijUqVDqMgIzRENpjhQPtAHUcxQ+la5Dg1DAni4DAbkUj5alwGJM0BWDugz0g3w3jyyT8dSX/JObHQG4TOXQApkMY7zL2I1HlfL/cu8d552RYXHdqyURB47iwCemaTEnZAu+jHWozTAJMS0tiD2lP5iNk3Sy+FPOutQRTN+ul/WMUpCBslKCoxlcqwQSsBnM8zcBMyXyNLcu6RUIVKsU9wDqHCDRbxL8GQBxqyD9GJQNoXAxo65hQBUqmslgIYE4DFmyDaBGL6Fs5DFLmkwVTqS8Q77m7ogycAVidnwrmoWwccY2MH3W1nLskeo51R38P40ecJ314ZPYWw4gsKW+KfYPtCaVyiDF0XCx/FOYl9ZuyffM8z3b0H4nHx7ristHFUb2vB46mB6CRg1GLJrG1rigWNKIVK25NjGspa+RcREZJq8V3V1QHc9eNAMS5EWn1CF5WA6yfKu770pfR9qHBjhgA3KNkuZs7AABAAElEQVQYc72q+uZYQft6YVDbWQfGmzLkxjo0jpvGOLVorAANjnAVjJTjNUa5I9RThCayCu1k6hA55tLZNwKeqnNpbgSeUiPgdra/sylWNB8j1gPOlcBZGz27cjYmiYcyoi/THimJ17cog7O2RJklYkfgpKk0PxFh2WWeU98yczLvMAeKElEJAR/zEO0cw6mVzbepFDOPAum3ki/NJwaJ8+CB67MyTII4GE8lZ5Js4xCHjOYXHgizJduQCEDiTxjbweCcOZVob5JZA585Ia40shozOuMxqTkqpX0T3S2oJiPCE5IebSxsgwdqDcxka3l9al/e5oKHs68U6nOZ5uOku6e8MJNzev6g5kPPetazkl9Rfu1UjuYShJrg/d7v/V4KyJk/56dmejk8cuH13OfpE5/4ROHl9H26NpyUaeKC82DwSBlw52XqmDuP3lHyKRJd4Zhr8uiYc3wnJt9PGQHXR1VCmcsYprzuVLYUytRK8gyn+NQcSFOUaoiPjFwsbM0pHuZ2McR2ORC8ajV09tfMS4JbAtbYLsLvmgSfEBa5AnQrfT8K22uNElYCirBSk/Rdcy3bo5YN4S8J4hGmqIQ4UhIzjklhcm36/s0DVdF3RP/DhKJF/8bxrbj+L78QVV34l0xorRZuOxArHtgT33/j8yEOYaTI90TXb94O+3HPl76XXoYvfelL8fa3vz2/dUafmnxOl2T8c5+iqfdriWlzpmmqEGCm59VQyERUwFgMDCH0wfwraT+YIxmcZTi7LylFEo82c3FFczzQu5e9qRc0MkuUpRjFBA2UtqLqeHTfnli7aGn0EAfn2BhMHetnHOIdkY8htpLWQwYqEazM1RDa3jHN4ShpCFAS57QagnZJUzPMEXsu5XfRhs6h3mTKJUJdP88wmWi9s/dPFriRfbCb332YVhXTD5kP+ySYjWVnkNi2N01fWp/Z+zCxVMnkM6ULsnNi+DCanc4xmCS0PhD9YwgZUk4+3PP72ZuHYXJkTBLICI+NDdIPCXWs1oYh5GWMsrfOndaneYcg2mVovOI+IfiOiHtqqZwHzdP0qymHyRqASXKvcQzn4atbyr0KTP2qhJynraYSzP5gkRKQge9SKXtIeTUxqXiulDxV+OOIn3mBAofBg/H9rXfH4UNtsfCS1WmchP2/tHYVWqF5cQGM747eA7Gl6/E4PArjw3oshdkyWZvtdd5QcrGvIXzpPxrl7Adbdx6M667cSFthbPo7iGdUGQ0g/e18/DBQ6wOxAqQ+ol4xTrSXebt/AA0iPmcCQVhuO+dXH+9zYhwn+lVOv/p6MQEc2Q99MBiLAaJQN38/PlMMYVxYXgMcOMwRdWq94GPuMUK4u1cl9EVMCdUuzqWzewTmGKSze/6fkr1321rd3BbzazCeSNI9JIsQUCMcciK36XjqwVaYfAZDncSMeFcEO004ssMmy+kBq6FdJjHPSpAsM1+2zReWeOK7OUeRBMqU1FG/TqEd2KzLfFivTM8CAiUKGZ4zEu69hpWV2EMml6SaxkfiDEiMW166Elr9iDI0u/zqdJ+ZxJLhSGV4IEnUWb+bv+YgmnPlyeNFBiln3Mw3XfLIl4gpvC9Zf7rMkWOjGUoX8OFPJM3knJ6X9fGPfzz+4A/+IP+ZPmdzNNe/6KUvfWnSHL385S+f9Nz27dvjQeKYKI2fmmSCXvayl51kdme+6dow9fn8t3DvZRAszpasuoRYTmzleTygJd+0xfeexJJmNs6n/hKa1qh9yk12MlJqgljLCyGvKft7/OIZfkEizbqR4TAAajntOtHawhUxS7E83Icvyx3fvx3QgDtj5aqVcfXTr4yHceDfvmNXMhVa0DovfoY5OVUCEDgxhsU46KuBy0bEN8Y0wWxO02FbrfDEddwDUeqo2HrfqfP/8wdRDXNUPMEcWVIJRNOiR/fFms27Yt+l6yHoINInQF0yUtVcZ5YO79wX+7fsjCXnrSawaueZPfxjmnvPnj1J41IHAzaAVieZJQMGML+8IRqr6uLwYGcSoDy46zF8ivbHcy+4EiQ3AojCKKhRcA+UuK0iSOdRNFb//v1vxGue8dwYa5QxUpsBYV9ZmvZqNYhp6hwLnksae+Y61/R4uQbNyPLGZtDJanhvsn2wfZjwDJiuqdFI2iM0UuUwFTVoK3NkxGRRQGOq0a74TqqpMO6XvjwKzXLmWOJ5BE1PMUx8pWZqEysw7em2xXdTJglEu9HDrDf+jRzDLG4RBRK7TnWK51Q/WiVQyhPTmN4r6jIwaVUNgg5MyjRjc23L8BgfKvV3wmzUdatmk9vkoZ2Yx5WRX2FKH3MgsIP7fA3aEM8W39n6EcpHcFdRDcvI7zypRfXM8wW3b2UVMJWVdVaQ3g/ZG+vgSlyJiVrT06ri1m33JkGF+9Am0N4WVTYnLVE5saLW0dGljU3x3c4tsXfkGGXQWqqTeRcACDcpZz2Z8C0ZKo95S2tjfnNDqlsEOt9g2yHTog/X1u17Y+G8BjQ7zEZq5ngs5AzdBcPWx1imuWKdpH2Qsn2WP0kjpH9TJYKXYnLx2sdC1kDVED5d+Bu10hbn3jhK+i4pk1Fg6LCmJgvqgRAr9Lfywlw6a0fAJTGX5kbgqTUC7FlL6ojyzacbeJ40kxMqWxCGqcl8bthud5JIEj1TF38hwWU+c8tIZehyXJglaRLSBtrR3qFjcXgIFX9ijrJShM0e5QDzV2GyTWoFajW0wozEGmVaZJTyJPnn81Ofze9nn9koyEx1waR1EeNCyeSJZzAN4aDIZK0nnpRM9GDw33QplTpx6OT3LbMKCNZTao4mHuiHOTo4ABaRZjFPIOmcbtwXUe0KndMtSq2EpnXCFhcmGSA1Pd3d3XEQGF4dzQVTMNimfhhCHE9ljnz+nnvuSYhgajimJu9Nrcc8M7Vh6vP5b8E4useZI4IidqNh7MeWP2ea8zyuajVM1RBNBtvV7FPnaAke14jz4j+ZKxmp6Wcvy2PZJ9bBiRpO/1vms9fDuhJSuJf2yqhINlpDtvJmL+0Q8Ombid/y7Ouvo/lFceddd8czrnpmvPiFL4p1K1cmxCml1qcqLe+HhGl6p9QmnEaSONOUSkIqG5UTDy14YPsk5ii/I/Tzgvu3M3YiAgrYQjwxmCzH/4mkzV9Ge0S66ueeF5vv+UECXHgi5fy4PCOwyjOf+cx44UtfHOurlkbjeHXMgzF6+oJzYkPFEmLTzIuLa1YDalAXG4ltdP05l0RTVX2srV4Yl9asi/PKF8fG8qVAKq+L5eX4o7C2NQHMduiJtct0VaApEOBAhiUx56wf/1P7UQncdGVtVVQR+6iRuEIrYbTnoSXxffDd6EV71IWZ1DCMTi+mdX1oLFxj1SCdVal1YSoFr+lhPbeWNcVVdefEZTVr8A+qx/JrEJ8q/YayNZZCJeC7NAw4hGS3mhrrOL5mXVpktW3l9WhKVuPbs1JNEJfxlVXkkSrkGU2ge3j/O9CSdQM9XVRfEs34+TQ3su8QkHUQ4l+QoDo0qrW8/+UI3RyBMvp8wieG95qyKmGEbIdr2z2/Bt+hFkzHmjlTqjlbmsZA9hsCBAiNSjfIeubpAi784HgvfkScWpjE2fQixr+0HE0jZclkyGzkDIef9vm8+mXxiqddH839pbFivDnOrV6czMNHYDrd3xXCVbJPXdS4GhM9TPMYf5PCnUEYw17ORNt5AbYS82FC0lgx57fd+XAMovHS78tTS/+qZUvnx9WXncuvYkzpaSdIfsU1aCPnr4sbFl4U59ctow2VcTnsWxP9TImync9RtWfMj1ppuK2ExjfAdcWTLc4bAqfj5qbUn3y8KMBxTG2qXRiVNXUwn2oTs6Ln/p6dI3BCpHx29n+u10/REWC/Oym5l0k4uSlKTLrZTU1e8boRtPXvEexBgiv/LznHkykdGulTYlWJnv95BmYE5zTVp6pyZqawbg/sQsldypj/oSCJTW3Rs9YSP4YDUcsowSQymX1m6pE/Mt2nx5wHkExSVs7kXI6XbRP+e6a2T37CcXIcsn5n9zxkBGTQrO4UPkfpWRBbQQUaAqVoJiZsap1Tf8/knG4+Ybk1K5oKpjCTo7noXUeOHEkmeXk9MkOafpmEPjZ45nTJuEm/8Ru/cdKtmdpwUsaJC663E6ZzEA6aD6H2E6ghnxfXTgoQm4jCbC0mfwkIgRF8LQYoI4EyTJqbqTVmq2D21Tr1mel/5+vJN2UEJ3SDaDqf5TAMmiHpHZAxaXnOyeUkyTqEST3S5erKQzCth0MTrq6uLvxmjsbTr7xy5vdjclHHf01f0/Hbk75k79D0TxRqjgofMnfJhAmg85IT5xKPTyRtxv/Icbjkp6+NS/n3N696T9z70P2xfuWaaG4Wh+upkXbs2BHzWlvjvQCjPOdX/0ccWFUZ//XwffHscy9jNY7FbdsfiO8+em8ivK/ZeGm8YP0VsfPosdi8/7F40QVXMY7j8dl7vxmPHd6XiOpngmT3/I1XxmBxHwMwMUd8aHYpIeto+y5UQ6m4E41AeOeBsL2ZQAgw5VqI9qMJE7F8lmVrOoDrHoSRG8FkbRDENX1mytD81GPGpbbLALHlmCRfWDYfgr0BZoy9EWaqrHcsDg0foeLMnsCYPUMwF4PEW6qqrYxamJLC/WwMcIeiZMaVEeryVL7DuL7EOMT66BEaj3lfSZXEOPszL4uMTinaoroaUPFgFgwm3IOZ2uMEWVXQtwT/mXr2BYn2BGdOvwVHGKUfng0uQwMXV1COAj/NtOsS6EB9rIDZU3gICHdiUoqHezC7HiEwb0cMlY7HtrJeguwOYhbXEIsIsOool2n2q0mcAz5NSqcA95oJ4bCiCzge4psNNQ6gZMmYDZrPfKmFKY4FY/UE2K2NHQjqShhDmQznw7Fdhva3Fa3YuPZytH0YX8WjR9uJtQTjCUOzG4CJYswN65mf1noYtpKW+MGtd8bG8+pj3doVyQyuhgKbERr193Nmcr6YZOJkjsYYb7tQDHCR9SYmj89yNEr6UtlBmUGTv4bJPygioL+5UFLViCliI9/Ruol4N5fO6hGYY5DO6ul/6nbeA6iQdM97kl/1XiGT4nUJSzdqN0alwUqZqthYlerrZ6CZXDI5yPZRDh4ONUi/BqBdk1M3efT70CRDjVFh8pHsWJy+VUruJj9x4mldiIdpR1ZGVooMXCUIO0owtSU/VdKXaTZNl60SranSk5Pvp5skBCpgqpKZH6Mxr6IB+V9mXnKqMjzc6zn8BcGoFmnoNJLQwoXpuutmdk4XnvjAgQOF2dP3mRzNDZbpv5nSTTfdNNOtFFh2upsztWG6vF5z9LN5ztaJnmuDEA1KXqdL+Uz56VoshZEqw9xmEEZJEAXnZaakg7omNgOsoXxtzZT3dK/n752MuO/MAE7cErBqAPTvkRmRmTDlbW9saoxlK5bGv3/m35PGbcOGc0ATGwz9upQcr1279nSrf9LzHV27NMo2b40jxALaUAC+MYrm4si5K3hn9fnQXFUkvak62NNrTseBttj1gy2x5vKNUd8K1Uz6tS/8z9hyy71x531b0Q5ODsSav6ECdjimhfuYY6qgQyZbJC4d2Vsh7nfv3xfHujvjwuXrCExaGx19PfHQvh3RgiS8uaYhfrD7UZjTSuIMncMeNxr379+BSVplrJm/NHa2gdoF+MEFS9bE4+2H0WoOx6UrNsROzOL2th+K8wjSeqC9DQKd9xjC+N7ex+OFfwRC3stfGw/t3RF379oS585fQcDqzvjetvvidZc+lwCiffHpH3wrNjQtpl0dsfXArhg55/K4a88j0YOJ2asvvzF2HdsfX9p8S6xpWRwNmMUl+pX+CXutCVe+gtw3NYeUSdKMTP8aF1dijujDIsMLqIHnmibGzpf5OqhH4ce4MNJclzlqBdluQVUtlgH6tQ3HGhiRVjRfau31i+tF69w6Sswgru8oIf4R2oxBiPdhiWiWdR3aJzW7KWAt71WCxiZPMvuUGbCiPPFelzTA1B3FR7UNIn0B/eI1F22uvAaNGe+mApN20P+GeJ97RwaT35Y7Q19Jf9RieqhgTRAHYxyNYiaWfPGce/7Tn6+UM8x9QIZvYykMD21X+4kdYIrvozYlCajY95vQJO0hQO2B6tHAQycehmkrL2pCIIf5IZr+vuEONCxN7O6znzcXb7oArW9/3HH7HbFk8eJYs25tHG1rx2cJRDjm8cGHH4pS7pc3MWBOHnyG63YFe9cG0Pvg0TLNFf1xYm54xsX8ZT5glrZXD0d7pTEOBzCFG4tnNq2J59743LQ2PBsMp9DSMg/zS8JJVDfFQFe2/xcyRw6/woipScAQx1MQijz1E3ahj+DCtTC+xZ65NQthdtFkMadqsqaGncifm/s8O0Zg9jfh7BiDuV4+xUbArc9gdT3JPGly4zM2w+24IPFTAzM1Rvm2meeQiK9O0nulkxykHEYyJZIl+gapUfIZN9ZKDmmOWeJc4MOEJF3/DE8AD0V9eTzU9TfKjgM+JpJE1lF8kiQihcL2UMjrhzXjgMt8lfL8flpm8jehzoyULrx74rv3ZNY0BbTMvH8ncmTXNMTKTITymgtzzPSdNlDivLI62qJJCab0aI7Uop1OUnqnOd4C/Ag2f/v2GFx6JH7pl37pdB49Kc9MzuknZSy4cLqO5gWP/Ei/JsdrB3Eiud76hAVmBnV4zjSV+d3pPx155zLNAzGTPMRnTjpFlyWTuNnW0MzPz37Hnri2ZcD0ftbcz38iHyZNqu8T66cJzdGNz7kx5jXPiy1bHolNF5wP+uDRpAHciMZOImRkQlsze41P/t2HXnBV3PQ//3c8eKw9Dv7sK5IkfwwCqr+lIbZesYF3HBhn+uBafmLsUYTaI9PTXviM4x2owhH9In77rzBZl8Sd9WkWWMvepL9EYfJd70VyLiyzhP16TJ3uvO+++CLxgo7UVUYf49kzXBVXXP6ceM1lz4mjME5ND38/rsPM7Qb+ffqub0TlgZ3xikufFRcuWQsjtSs+c/c346Il66IRjcatOx+Iy9bCzB3YG+ejLXzFJc+KL1D2ACZT16y/KP7zgdsxZ1scT1+7CbOqojjWcywxQXs6D8HsLInLV4E9hjZmAX5IrfUtcQgtYYKhpm8vPP+qWNe2Lx4nrwFPuzFZ6ySmTgOMh8l9T/8y9QAyBgx6Gg/XWZoDmB0/E9KavkTAeY9CSHeinahkmARmGIE5OojDf1dPFyAO7NEs1HK0Pk219bGopp53Dl80zHOXF9fF0rQjG2QYpgG0vxGYCPfTPvxchoCE7kOjM2YQVv6rgMFqgmmpQF0i42SbBH7QX8pn1AKxWFJ99sXmlxDAvLQZMcjR0hjaS7ub0Ag1KUhgPdFmEfkIX0SbMk2Iz3Erjc1QGciqnBeWr+apfbAnjg11Zu8Wa6SCtlif2uQ68rWiDROnRPNHKPz0b4R+Ol4m4cD7QI0bKKXlnGGHMfW9izOsiL1dQ9+iroNx6dia2IjJpH68Jp9NPkEwrdm6ZGyI+1TK+bsY5qi5uQUNDMzWlodjjHo3bjyP/ONRRwyjZmLiHaVkOaQWhH2ixlVRrK1x7+gHovz+R3bHutUL0PCUxSGY0H4gOYqr2T8Yyr309cGe3fH0hnOSmevhI4fjv26/PS679LKYP38BzGY9pnLHMmAQypI5zpNtzoEc8mvpkzzybGlyyOO6LClHWwRyYGXjUsqsSeiASUPPfZnQ6ZitSWXO/fiJHYE5Bukndmp/sjumqdcgHqn6+gyP4AzLrqc022itdeVDOKkq+c02effNQQ5FN8aCPfT4AOXEo5JwpeJqiWQ3NGkoTHm+nKkSnlbtiEFVveaBaST0/EDKn/VAGMIZ+dBQF8xGLRJ3ZfvZoWW7tMuerl0+n9eZlzX5M7vbiyROpi3r7eQclqtDdA0+FGqiZi8vfzY7wnxWsxMZyOxIn2gPt+nuRA/yZ6Z8ksfxwOgvSbsvet4z45zyhVMynV0/u7tB5gI62bXiAdzPmlAToHQ8Yzod8WxdzDoyrBdN89QazpY82EUPs3wl3pb+o0ia/Djb+vUpghjEnEfGQlNXIXMlViRuduKsf855GzBjvCAOHtgfra0t8bRNT0tNcl1qgnN66/PMeiHxKjOqxD7fE/ISPvWpL8a9bUcJYnoe6oFqiMeSOLBpXTz6vMtjoCyDOvddlXB/omnzzd9Ljz7t+VfPWoTMUQXvaBlMdALHoN3uWSe91zQla82JNqmhXtm8MK4/77JY2NCSgpTOhzFtQFvyeDfmYkySY2Dg4E60OxL5op91A54yjkhf4lINxqbW9XHn3i1xy9bNAAeUxIWL1qA1qWV/1XTX+rI6ZSj+H3vvAebnVd/5/qb33tSbVSwXuRewsWUwEEogQAhLlhIIsNmQ3ST7JKSSS7LPTXKz2STLXjabu08IhEAaBEhgIRBiwLhi425LlqxeZjSj6b3ez+e882r+MxpZNmWfx2iONP/2nvf095zf91ensaOZZQ0L4Lw+mSQCEOgAiwli5Fy2ZlsiMB8p3nem319H/e7Le++JjhraiIdDKy4kQO2rTgimKINlg9QIFg15JviS7FwgwjXAV3LifSPs0UMAtwb2tyL2Y+2GTg6cTu61ky4a5ak61lRbFx3VdeSfjlP0eSuSk0uiPqpxXmCaQHqUgfS56MYL20ncVg8DSFyTdtm+N3N/M3ZBSYmLnwVTybEPY+F4zNBuY+nkY5QK5tkob4eJVst4nSqOmS4YbIOoqDbxG5KcbDjJ5LDmjz79GgcAdwMQGiHYde4z7HecXihxMhXDbKvSZoexAY9EHzvCceyKLsI1dzpd+NHiRnj2izmTKinfVWy8n3GkJnN4TNDLZB8e4UpQD3RPquUcU73bz4KsBDJYV75XEMdsBlW9Ypgfe55+KgHPa665lu+6K5+JW266GWkdwXSR8GzcsIGzrjceO/lUzCG1rFa6BYCr5f1MYqy6Tw/gsGSYPWqNHYqDeK4YZA2WALplOLquDo53x45KgBhgqxEJ7+0vu50i5uLwkcMJ3LTUsIYAzUU6twAMqqqeEtLVOdUek8bEmVqTxE9wlJ/ROsWoqmuO6gbAURlzi1rmmcC1C7etfLpAR2AFIF2gE/9C73YipdjoZthMDw7UxMhEJbrlY7iMHYfzijodHG12WLjygCf+GeAvO9rP3XMPFI8ViROOu3Nn5IoHphIeVceyoyjLLhgRip1dF4d8Akn9Ucc9xmKwPvOdnTcr69lfs1rlJg/pXheD1frKwUW3WK4E4XcNjuDOqk5nOYmAt8G0OnmU4qCWQNErW/rZS0uSqovaRXn/zhddEb/xyvfEr37gVxYMZJfk/2H+escdd8CNHouLNm2GAMSlMG6JZyBUnX3XiwSmhtnLpcy7onOZrTudJDjv/n6+taMEUPUbuernmqfl6nxOv80XqPrpDEEhtUEpmycQJb4mtHd4Zn80NjfFhnXr4x1ve8cZ/f+1a9fFunXrUo8kSnoAKYdOHMLTVjV5WGXP/vg9p+blmXz2hyBgdbbgXw6Sjjy5Pz79X/48GlB7e/0n/0t8BY9ZyVaQde06V/Y2jSRBT5nfbRruHYx99zwW6y/fGi0bzs0gSM8SxKxOCZKhuVQv1c5RfzbzWQvcl5RwzymJlN7M54APLXUNsXP95qisxyscgVSfnDgejahc6W4722WQSlFHS3V97DlxOI71nIr1De1xqq83SSx0kd1KTB3L+fqDD8Wu9RfF9lUbaQNzW7B48s+OSjFMKkFwKeNai3rVgdPHASBDSS7z9T0PxeU4aJAZ4H5pu7+298G4et2OeN1lNxObZjweOQp4ouzkQMMus1a1a5MhU4UdiVJv14N5jBsnODJOnW3K1JJZdXDHpuhXNXLVk6gKjiCZygx1GCII4EbiQbUCFNU46AVolAKKVmFzU8oY2i3BjaBBpGG5J8Z7kWwBjmhvmgMy1TI27cYngpAvcr1zj9eVmkwhQREkpFhNFrh0ubB+yms4LzZyXhEbbOY0IKmTJ7MK1bxGCPoqx8fnh1u91w/0HVlPUiesRFozAXCYch4ZfJeG7Wkuq44Z1oBSLNXHD88OheFXW9iVTa7zEiRnp1jHDYDXSu4b5WxM7sUJAluBml85amXGDqpG0n9d7ZbYUtHKXezxAlKkh86bMa1mdc4y3IWkpS2uvGwXUiTjUZGPNimZmiL+1BwxjopoSyeMmztHDsXhpw7Elqu2xVra33vyVDStbUWVDQBmbxm7ZqS0L1vVih1VVRzEJqqHPleizu4gOATmExg+2n8oLi1aDeOTOUM6qtTHgN6PPf4YwOzGqGpqTc/t9NgAKncEnXVu+Of+qDe8bFDTkKSXDByxd7K2ymqaAEhrkKjBRAJgCQy1o1pJKyPgCKwApJV18IIcATdACTL21FhXNxIzNePoscvNTOdcMnRVhUFVD0lD1TWWnlvLddw8qgc915Qda1luN/TMxMft/eza/EVieBjito6MEgFn51v+3qyG/DWrVXW+cQ4uqIDo629hLFDVKuegmq/b9uj23HgPhe3MS1n+3SORMxuDZ92Qn0k0S+JMF+baOnn4aB+ROLlnMi3+IOc+T9uuuSx+4pfeEztRwfjiP30htm3bll/6oX6fgjD52Mc+Fu973/vij7/48eTOV7mAkk85+o623wXxyyXP9zTuzLOEYbJbEMBDYCysMGc3m7ezyoC6LMV4uwSpjtLRhXuynH53xT3vNH+ThOGM4ltSBS6HJcCtpxyd/sltTXHH/ffH0RPH4rJLLosN69enIJilqq2Qf5wgl8Mjw/HM/n3xyJOPxxD+nzfdvB37iO9/cgyNPVMOcewYTqF69f++/3eS1ODd/88H4CAjJYG4M0BP8nIFEaYtlaP6nJ+dfCALBvnRL9+duNaF6nVLe2f2CtqUgCzUr4GZ3bOsfZJ5LoFo97Oy7VEYPzIerCqp3kFMen+2NrAlwdPgseG+OALnXZhRVbMm5cvjanUTrHXL6nXxVOeR+OLjd8c+1N32dx0lSGdjbF+7IWYhoDe1rY42VNE6apujsb4Orv5YUmkrghklWNGWQzuhrA3UzpzrYe3ydajrdR6MT3/n6zGENOHo6VNxccd61jwOCVy73LOtY13cd3AP3uVG4wR2TUd6O1n9jDQbt4R2Ce/ui86RoFFs6vjLsirWT7SVMh5ecPdsYH/rQHLUgbOBFsBgMwT7FNCiG5W14orSaALwrcN1tXtuD2ttivJWVVRFI/CXrlIW9kEQxj6nfh1EwtY52Td/XmRzb7tW1zclAt22KGEBEeEtDek4hPrc/Pr3nWak+aCoLFkoiWlMc1jSzDzWI/HH0/s08ZJmTsBgqp2IUoES95o9gUBASVp7bACjgAc9xSVpFtcZymgErDUCFhwtAXwPUrFegOHeuYFYg6qddkU1PPcVjHkdYLDLcwLPfAOlyJA4NMtQY7OMBj3lMYYXV6yJNXiKswUCB1qXVM0ECxWM98RIF/3EKQNMM+2xBBnO2TTjNj7EeI2dwiEFY868DUwMRQkgffN122MbTh02TBXHISRLYzzvKQ4T7S4B3B3muW9fvTY2r90eG6jvON7+ZgGmA0gFB/hOBam8w5PdBKOti9IJbDVpmWkbdovuJzpTOHjkYHS0r2Jv4Qwk5tX0yOk0jp7/gr/5Kchu9JW2FwHairAzKyHQ7RTreobnSnsyAZIAbAUkLQzXhfxpBSBdyLP/Au670htdY0+x8ddVSPip7pCBI7vFEeYviWvoZ/+y4yf7lL5+3188tD22nz0JMIahxapQaXDzTpxK39NfxuXVQ9i5kvkkosY5OCUgSiF+51ClOtW/KlY1nYArmKkGzilJg4CVeE4G9Knrz95/r1bPgyPrSYkPEpgjqE1JsOUlqO6h+3DirZ99CKUb85xZMT/+q++JCtSYfvQtb4y9Dz0eq9aiWkGWwlypTl/mfyy8lpUy/2oeJzz/Ssb0jcN84df8KsXxowRHKk8C51wFe3NBuQslzH8SgZ/r3iWZB/sHYmR4JG5+1UvjEw99KdZs3pAaOYLdkYRYngQ7crerURMCyuQ/Z+803OYINnWykVedv1sgjNzkpUrCUkJ6aQMltVSvlGCYHyXyAW4hZoBp/GSnn0dK2fNxhrDFHa5uyBsxnFZi24sEAV9cUbe5PSqbauPI3q7Yd+9XovHeqti+cXNs3XIRfSLOyb59sf+IgUOnon3X2ujY0RGT5ZSLRGl+pp5Ho549qyPjM6Utnc3/hz/6izj02NNx05teEdf+yE1wnSUMpclwuXy8O1Y/ui+KMc7v3NgSz1y9JWbp47OmgjFxraXCeDujXvfqm5e93dlStVfpobOTwJEEHJ/dF4y/5Ehr25U7k7GgdH1+q7G6K3GqMNYxHnVV1dGLS3ZjublUIeNjbUtbVJddFQ3EKzoy2oW6VFm88brd8eAzT8XRns64AZuhay66JGZQKXxmtDPWta2Kd9/y+qhBPWpgJgt2fcWGHQm8dNQ3x4u37yJmUFVSL17T1Ba3XnxFtDa2xqrGtviJG18R//rY/VyvjPfe9mOpLOP63F5VFi2oub39ulcAvu6Lw6cJELrtauq+JDa2dKAKWBOv3vWiWN3QGr1FI2l9TCCV1BtZUt9jr3HiHIsUiwiwpOrZldEUbYIdxsAgqq0glI7iGoDAbFTX18QqwNEGAin0Asi6xvtRa0N6BICo5HlImyeTPokjgyRVYLyOz/SmtStxnlANI61UrZlxzXd218kcAHtqjP2XZ9J7Xa9KWry2kLjGpOpMItXFBb9rPzXbBABH721ugHv7UF87zhnWAgBp4HqqwJ66JnmiKX9G9TE2AusqxxaqDucUCUDy3X1YKZ3/npkdiANIknTOgjuEZKtbBwCYZGxO4vhhgLOirLIi2rHHWoXqpMC8AfW1VuyxlGz7l8aCtmbjAmNhdBDGAja0PN9KjWQumGeWGFMTQydjAJBbieS4HGakz/UYrtfbaohzhPvyneM4i6Dda1ov5t6ZeOTp47Fm3bbYtJl9AM90So4F2C30Z3f9DsDqgehBErS3dCqOwzBhd0qBgp+Z6op6wFkRIMn90PrLiJMlIDt69LgLPTZv2QxjZhUMGwLCIq0XxCplNOit08JHX5N0rJSy8BseAzjlKAMQJRfqzIvAaAIwp3fTFG/KW1bSBTsCPHvZsrlgR2Cl4y+4EfDguGPgqcRFH0IPPvPktehkmu+TOTNigqMKUsF4Dm6W2b/zdzztqPPZlit/aQkeVtMpFtHSK8/le9Za9m3aJ3jSAHs5wGU+nUeMAJDsuwfG6ZGWGBxphIhB1cNIjCQtW4wc6Pca3Ke2ooIoYXCunkgAKDnSAcCZRNkS56MJHJ0tgbC0GlQklhL2bitDAAFttM5Vn6MrHJC7LMEuCFO1w7kyeZ9EfAltrkInXSIxu8IF9M6LTyJrGEGVUs5yFWqGBFrsqzBI7yjlZBxhy8lT3VhxrO9HelFfFbOrDIi4uGUaQxcNjEbpSSLBL0mSQHP1GISvrk8c2IWGLMl4rq803J4RSYX2jbBGRilxoX7XZRMxY4wbs/Crx7leFgGnEL3LJYno4TTOED4Q/3pmhD9LGRlUyu9JxDYzOQ531nqVLKpONAxQy9ddnvd8746TdgklEBQ6ZKhn/htKMnDkvQL3UzODSDvgWkMcSmjofne0cyBGn+6Kya6hZBtQuhaPiNjNVBSjerMJFgfBNCcBS4tbfr7WPJfrEFOMjaqmvh94dE/8+iveHXUtjfFfv/XXUdtQB0CSkoUz/bUHY/tX7mVsaLf9pI8jjTXx5Z97TUzU5PzrJXWy1l3vM1OUQSrGPbDc9fHh0fjAJW+O5vUd8aG7Prrkpuyrc6HkyHWuaq/ums/Mfzqa+Xbmh+WK0G1ybayHE14BV/zUONKjsdMJaLl66uDUb6hqQx0Lz3YY6B8EILkPXoxa0eaq9iTdGUZ96+RYb5Kc2I8WvOI1ltVg2zMWR0e7E3PFMpJ6osCBvilVOo1zhVr2i7ZKXLYjuTkxOhONSCs21rF/MBTd2Fz2YrdiWIBaCOD6oirKrmVvY+3RT9fRGGD44HgnEp4pVKRrWKGTcXiyJ7ogkidRC3VclLRKeJumMcaf4a8cIrwaSdANKJStms4I8wlAhB7uvlOE/VAtwIbysHSKrdOAuZHxuH8SD321JXFj1epYzS5XRDvKq5pwzsAZguQACBJ3jzydpG8pEC3t0w33FpyLSJyb3I+nIPT3dp/EaQLgEcCQBXSFsYQUsrQKIn5+X3FNJZUtmi5IzLynZZM5AygYmaiJ0QlgDM92VT/xkEZRIWzhmaljt8F+poR9TZufOcZhbGiU9UXYWtrU1FAfFzW1IPnBhow104PkaFCwwlgm6Q7PZmoDdQrWdWOtqlkpUr6SyvJook9rAUc13F87C2DEeUK9rsGZR9tMj5I0dXQUr3FDp9hPRqIaiVN5Je6vq9bEwOAQ4Ij9a4r4duMjMUp8KKaJmEyVMYTU7mQdqnIA5M2ofldj2yVQcfZs0/Ge0ehBE/yGG25INnCdXV3Jtqga1Vol0SP9x2K871hMs8a+XTYex4nZ5L3TlLOV2EuXVq8H1KHdUFWVQIxzohTaTP4moBzqOxgnRnqijzU1XVGC9zxCUwjeaMcMdmPObTFSrMqGTYyZ+xV7IgBPD4UsNdQHR3C9znVs5GpU+V1yTljnSrowRuA8bLELYxBWevnCHAEPTwOrZt7s3EZNaSvm1W1eIAHRDWiR8JBTL0FXweGkKlAhIZbdlR1eErImXzV+zvKmn87zAjedco01ZAyj55sklky2RfU5uV/VbOxCg8JkPiVCJUStd3PXHqWtphsPVP0YGxPXh79xiILRKYgAbqytGoaoH0j5MElNXHR2/bPorgqIANXq8pHM61ThRy5l1rr81+xdVSD7Wkd7ztzHh+xzNo6L71j4Znnm0E2tMiqTvy3UkwFB2LX8uERKBbd2Zg366hAVRRyCnLaJw91KgXUErdTNsEFNxyEcoCmyQ87KLBxpQCKA+bgopYoXas+vJXBUiwSmhcMSomOeFZlfPv879SvNHIMEG0NNxfkq7KUFSLQOzowkAr5Og3Mb6v80kKxkPHXxkv0+X2MCT9wpKE+fGadJCD0lEhpb+57NA+X4rLCSVHeaAMAoOfIJ8Rk5u8fzFTzLm+NXBnBtKatHzSnzQGYbTDotgaSMHtR9VA9KwBPCunY9RN2GFogrekulBmuc7oO7fYKxgStdXJGpkj1Ltd/VJcFiOX03KLPqVB9BtW4GgP3v/ujXoq4pc7GtilrD4c7Y/s/3pvGQa28qgWCs6RuJ6z97b3zrbbvPjGdhQ8xqee4VSqByeurxf7kfwm7qLE91i+6lRNf/OPNhyudiDulJVh5zLijJLxTenD7jjWx6IDqRVvo02eqFVVKUnoMnpo7M51Q9DJUrpH0jU0NxkmJLIB5HGXuZIKsqm9JcDRNU9Kn+zhhDZVfboGkmq6tvKKqVRGBD0os7a1XktG2q4v5pwFYHQGMd9i77cS/+5Og+wCWgQ9DJHB82phDtN+82PO5trWhHHWs62fn0jA3Gw4OHUKsci2aJfsoYBxAIdDT4T6DAcvJEBx0PpTK22dhBEzjnmVHtCwJ4DLu3GYj0NiQADCGlTrEfAlCob2tpfUyxNpvwqCbRW1qOVEiGAnUW4cihE6DWg+2WoMaBrKhCGoX0qIY92KTaXytqfKPUtb6oLqm4nUCdzHFQerSU1+y6txzHUG96JdMMOKAnqUOynzZUDmBzA7gZq4+xZu3jYPj0Ug9EfHFbxoBIKqwAMpeA/VE9rgFgqDOPCcodk9hnLFweM6iwzYzbdsfdMwJwydgZcqgYtdZSwFE10qNWQKypebYs2merkQ4hLVItjueEzZQrtJc6J3FSMT7cg40OjhAoK9iXXJOud+2TSnCjrkqkEkk1FQ5R0HgDzCzqamVfaMKeaXYM9bvRPtaD4G42Nq1pi03b0BygjmG8Bt5zz91x2+7bmANU93iG3FfckcrIe9Es9lMlrAPmWZvGJ4dPMp8zcWPzJVFbBxjlWdO2sg7J5JGjhwFK2NA11cGUm4hHSkbjNIwjh6KLc/L62dqoJW6Sc5TUQwGTc6ib4sIu9sycYt4BReOMEXNUwTqvH6uMmvHauLx6S3qeHK+VdOGNwGLK68Lr/0qPX+AjICfczTZTWZLky6Q4giG9ai3II9jjySmggKcFSAIocchINHn8ytFUKqOcSZUlpRk517KB2A3m4+fzJjmMVRAgcqKU7mRHl4e5JLA1LU/p+KsEpvnzeiYheDUCrqSPtrVQmmQeAZ4AUa64Eh6UxFGfgKurswaImqm57GAvK87AWinfIQsSt1RCKRH7qTYOJL4brz2ve6GjjojtPleCgOKQmkQlQihnsgwtAYwXlfU2I52zsUhZzrwYx8WDc/kasrtLIayUUOUEeLqZS8ariAbqtEJPbQkSkt4Fqzhw9RDXj7qJOvHTYihHjN9nG+a5vN5TkKwtqbf4Yf6SMzJbg6emttooqmGtzddRcNtz+IhaCqOo4xCJdaV4Eo/OdA5P/CQIPUUskkEObQFOpoLp2h5L0hjBd74ObKLEip7sfHds/c2GZ1JFOpAo9YU+Wpcb/qyc5ySRymtPNz7nF4nTJDmEYBLMLZqX+VJsewsE6ezUIADaJ47ezhO6EqdpiOEYM/UsVZ47JJ+u6O9/ylRWDRzt8/K3OGU48tQzsfvfvCaueeXNi6pb9ci+5PxAyVFhKqGRGx4/DJHHrzRx8dXsNyUEeHRIY55znM+nXpfXsdz4OYdzEKk8pKxJ5ymb3fyewvcEGKSCZ+zh4tYV3udnr2tjqbCrrqg+xuH+nz59OhHEAtZmHDhcWrsO6QxqwOM95DOGGW3gfQx10RKkAtO06QR0+AHKKENKY7y2xw7sRw2tNtagLnd6WFUtAKn7F32YnoAohcAdxUvZYyOHY+/A0Zgg5s0U4Eb1OdW2SrSnoeljSkuw6zEwq17lFo+N44tUGQmdIMP9ZRinDGNTqiAidUeC0cc+VIP63zTqxb1TSGbMByAv5VlfjVSsAlDkTlok44l82tRA3yOB76ddx3B4Qxw22mEQ1mYI70YkIapzO6oNM6xp/hpp4wbi5fRhc/N1JBujuNvPQOziOSoGpMyCaiTKJfzTnEqk4zhC201thypKx6MVG6QxGFpTALuiAcbEwLI809FGXqT/blNFzE0R6nF6HqwDzHk2nQaYKXmzwQIwpSNKhbWhKUOa4liBGuZ/k6FWihc+4ziVRT/Mo1JcwRfjFxwIldb1DBJGn0Ptqsa0Beo9yfkCsGMsUh9o0wjzkk5ZDziSZZYygMcBzZP48K5jPNuwZVpbrHQSiXs1UZUAz9MArWkkis75A3ffhW1cfVx88Y649Zabox47N9X2khSXOXXOLb2ddlFKHOPElvFQBpA9hHXSelBkG8w/gefcfP/7uw/FoaOdceNVO+n2ZNSzzw+jZqkb9V76dP/sYFyscI6CK5GkqRY8gZSpFG+LlUXYPKHK2jOLFz5A5iRxkRw6z8idqzcloGlfV9KFNwIrAOnCm/Mfmh57aElgsfUngODW6qHpBuu/nDgoPLbyz0o9DHwo6DCvh8zCa36nZ0x+x3MfNjXi5aBJ0GZJNampGED1SxuDHCjl5KB1INPiQOEQ4N4JCHvzZ3BtLtn+zECEGDxWEmhxyqVJ1XATjc2kzUKWp4zgg6bcC5eEAegocbupEIKE0hIRDXjg0DwLhHgvfwKYcycOfqozh/3wIPXIlXD3Xlviu8SBB05GwmXtq+BwVWI1AREwllS/yLgkCVjkhGalLLno1yXErD+l2adS+9M6VhqNeI0arUQSMCugArwibcolBOY/k2iWsTOylZOtoDkkR4Ij/MYvW9eZe8/zwTEwOd7lANUkwaI+10geU8tRceyGAS+qvknS2//cacgEhK3jqr1KUj0idxYcOBvPVMH8y2yi5vNaC66QVbfJtkMC4+w7C/IWfDRf4drTDa+qdQvPT0Hm+Y8yL5QwdU/pnvhsqdmZO4wcKYGfXC4v0+YzGZ//BwGpDAQZHPsfejI+9+FPRPPqtvip3/3FsworwaZkKTjKMxWzzuqYN6LipLVcOHCue0FjUVk2rt6jZ7MnkCA1rW2LjVduz4t5Tu96ZfOBkoGhWpblny8pRVD9ioVF1nOPIVOeHD30IGFtQkLwrw/dF1997F4kJU0IVlGmAlRc0rEx/u3VL41tjauIAYQDHErUBXgxgYbKAR51zKvupzto5AAqZcNIex46tDfWNbXHTR1t0U4w6fIi9iMcJQwCOARZqrApvRQFWcck5SVJIm2VANeeZBJivEgbF+1tqLNU182KTlx52Vv6XALwEJDMAk4GCPA7BcOhBocDgo619gEpy96pvgSikDMA1BwR1jpEts8Nix/pEQwPniPBwAhlPDl0JI4CCI0PVAbx3ADR3kYcp0ruMZWyV9azB5cwgMVIp5TwjSKd1rNeEUR2KbF0eFipyLHn3WmYnxOliPZRpoh7qYAin9J8b64uQ4WO+Z6mnBlAy0wXjDskY6Vt9B3w4TjosroG6ZGe9LoBZ6fZJwRKrpcx1OHcYwWOZXi4K0GqPj6U2XLZfpdFEwBDWx/jQI0yHzJkpgAEueqfQXUFpWpd6JWynLVnWAIlLqo0Dw+iUlfSmBgdM6M9/K6TpNLYL6iqKmE/qACENjMHOD4YyzyYlgMwq6rqkRAh2SFI7WAvNkhrVsUw13VR3tjYjMTO+gCG4wTmHelmCJ19wDd/F+GdtYtzzNOwFNDj0zCEOugw/XUu/CeY3La+OTa01wKyxuPhxw/Exq1rkfgjgUrzp5QV0MeeeAUSMtV9S5m3cvpazrprYc7LkV7PuT4BVXMAzGz+XHQr6UIeAVbCSloZgRfuCCh70A4pcye9QEosfFq+b55fpqWyi/Pdl92Vv3oYevjm5112t7YAxg4qLMvvNcRZGJkbBSjBoWJz18mEEgFjDQmMkmE17x5QI3DNelH3EMjZVo215bDVIc3K227dJuv34JBrryqhRHP2e0FOMiWDb6QrFRzWBmOUSDaH9WfSo6w/6eb8hTyqUqmqkQO7/FL+rlwKfjHXvT+T4C3YUiR+YwwC3rysvUWS8FCnKjfCMmkK+HaJKMrLzN+LOUSN5ZNaVtCd/Pr53m1TFbR5Nf5wZ9Gjn8I+4tzFQGSiApNU9lBVERzNcOgWoWqzHBA7X935ddue03fpM0RaFWsktYMfZgEbuu7Oxs+1lLXQtak0M/9ueQIonWUITEyWtzQ5U0rPyqlj8RFPDQx28pHGOjn3OCwuUaBWU4znL+xZvEdYJVc9c/G+XAsW7lcSFoCkHiRJgv7s/uy68y5xI4j5QSSLZ5XTVlSwIAQ/8v7fThKNn/mTX8eAH9C7JPVtWhXrHtiT1OoKL1nOSBv2fUg5SiG0nKn8iS/M5/O09smjcfm/Php3P/gEUpLxeOUrbirM8tw+MxxKcywvVbV8dYvLIi+PaZJYnA8kZXOA5Jc1YmyhGy66NN75ktck995PHTsUf3PfV+Nf9j8Um258FdKiyjjej00Pakcdzash0AEHPI8DEJlzSCGwyGNvGGYPgcEDIb26vDGqENdW4UhgCkL/waEDKcCp3vF8CmYVXZGvHCJ+thRiHAlTOYChGtChO2uB5lRt9jykdtIv71x4NvicFg5jBHE7wDSOI7lzqCy3GoDUzv55lH2lmjEUd2vXKLGtOpj3Gu+mCM+fo0ixxsZGo3t8MA5jt6XKnup2tTizaEYyVg2hbLEyEmxEKQDUOZHRM4pt1ch45m3Qe0qwWbFsQV+xQJl/Ss9SH3ifTF7oYEThvEB1vJRSP8jBf4ESowMApcHtPKPMpa7AZzqRCK2i7QAe94Ia6uplDQ7CCBMYJek9wN56bWQpQbnLABLa7CSJknVQfg3AqA1Q61djRwmYZMjpmZCfYhRJ00Ry6501zTPCIKnlgE2B5RxjO6s0SmVQ8k3iBKHMfZHCxfNAydhQ1hFtRY1p3Y8xtnOcMdolZfPFiLAPFOPSfFW1fdaTJO73BwaZFxg9AK4pVPEycMR1ks9ZByCxmcZ28ky4NuwjuyL57O98Puqfc7+jzXOAzF5syjaOTsZVeGb8Tjm2cvPXBnDm9Ajgew1ro5nzoFY1QdrwGIp7/YIlYiqVeBbWaxEraGf+08KyNSvpQhyBFYB0Ic76D0uf2dk9OCUkBQh58lM6oLi2KPHV40Du/ZnkSQEH6fkm63WLNiCmBKMkniChASJSMGTKD/XsMwcsh0Ijuut1eAPyWpIQpBal7Om39Dv5GrCjmcWrVBcuZ/ODQI6f9VWh1rRccgysA40TPi1J/GAwWa1PsFBNal7mr0DdQCmO47Vc8ledNsiIG/Vg5bu/JY75/A3anHig2HaJjGT0On/NN3/34JNwH0XCNw0nrwY9eAlsfxMcCsI0Us9a4R26dIVjSp4s9GFGRAsQOA/T4ZnN2vnnzime5YCfa6BEubeJ05410PpNSbWOd3X8Z5o4KCV2kBoV4X3rewFHqXA7tUwz00+uPRrokkz0Urph4SUbj4XvfnKuHKFnS0qdJlBtq5pfi3leYF+mlpfKyX9deJ+E2Dr88N649+++Gpe//Ia0RpVc6uAgkzAu5D1fGxZyCoB1UT1B3QJhZ5Bh5W1miHEeZ922ySVfrreFpTz75ypAz6ardhDfBfUikqW5XlyTf//7/yuOPX0oXva218U1Lwe0MNiJ8E05s5fOa3bG1jseimoCWBbDEPijx59MnPbfuOqKePINt9DgDKxLIOfrpuD22H7Pnrjuc/cl5oe2cJsgtD8wUxEzAKYnbrucrLQo+/+ss1foYjgjLud3mPMNj8T7cwRJebtddxKBQ9gUTeJas6OOmFXERtIRwbGh/vjG3u/EvYceT3ZKawio+aardsf65o742P1fjLsPPx5bWtfFtXjQU8qgnVsnUob/ecdn42U7r4ldm3akfdm9QkDNACYJimOftl0IUBSwiN9WHR04DZBpoFpxVyAVYvyT7Q/Ph9IO162pcNULfMeZ6pPsGy2IsasgkAVJHQRL3Y47uNFSJBPjMhnmYMzQPv580GZwTDBOgNJx7FBO4kzkCdT+elHFraqpidrqKhxbVGBX524OWGOvGKBN9TTYWbAXemObnEDqDZgpAhiVE08oqWNzIHjNOoqRBKX6INjdU1j4oBzOAACc451cSqv6Nw9AUsGph7ywzsqa6Wk5krfjqAgeY39cPY0tUAUjg9QHzYdZbKrsl04rZvlznShhqQB4eiJO6GFP5gNjVMHvq6prAaClqOsCbsjbMAsTj71fNcBpJXacLe6BPtOj3FcMoK0nnwvWuZoTgNkvpIHl3DNBl5JXPeZ2DUCyfpI9gr45f2MCR/pgGfbL/qrqJhhValSN+p8lF3MODA+cxEkF8eBgGjJgZLcNWZoGEWqL1MF8ncL5zizA3PKyfceZmE98nJngXOGK83Dz9ZckT3Slg2Oxs7woHkVCfRrQqgrmGIFxn0BSVo6ErAWPh1WMSRciRm3R7J9rtZL9Tin9cvoaeZUr7xfGCKwApAtjnn/4ejm/iw4ikemBm5cnt1glKe6kEuoSSEprpjFInWajdZP1Ty6oW3FZ2QQbfqaKlpex9D0j6NicU8o2ZrlbieDjQMiPbQ/U0hkOfQ6KjJjMt/r5W1NONmPyqd6mvvhyhJa5vYbGPKoqqKAhPcqOZt12w+kiVosqQ8slHUQIgs6u2RGBq8lNOoAwQ2NFIyBF3uqzJ86NBJKMz+HhZDn2ISsxb9lCjY4Ux2lBMo//sjwS7/3MWSUcYEGi5UjsLCS+89sm3ApsxgXtDMSPZ7V3J84qn3o5DoeoBa+vqU/5HCyUsfBplg7MoQIiQJINmPCbLAAAQABJREFUa8s9TLVGG+Rgdo3UI5kTTBjzBEMMaBRyWaFg6ntMqrSl8Upl5uVl78YMcj4SgfVd1qM0SRmbY54RD1nTJyHWylEZycaY3xhEed6LYygtVNp7/FT80at/IW686cVxzz/8c+xq2UJ5RRBlrJk0agt5v/tP2fjbzkQ/sSAdljj+3ZfonXLl9x99OP7h1/803v3R34yOretTgY7y0/c/Fv/0kU9F69qOeM///YuZDRiEl0RhPl5mlvt87394c+z83Ddi1cP74wtHjsaDp3vjxX/wn2Js24YkwZUBoT2T6o6FqQxPANf+4/1ZYEou3NTRHo+98XUpy+w/PxT7rtwSE3jD07mKBKf2js8lKYWgkWekEue9h8FcAEnnzZ0y9KOu1Ie741a49U91PhPHBrvj5q27YgBvXo7QO294DRKVOkDRP8e3Dj0WrwJIDOC9bFPr2vipm1+TGBwHT52MY/2n4vADndhtbIxdG7bFIeLXqFbsHKRnDiJWoj25xvY35kxwtAYVrBrAi/Y0pwBqQ6quwdFnG8WeiL0UohW8lMrJe2R5qVxeTmJDsh4VqQa5OPzqXrKlqDYGudY3i00RGgZQ4wmcjWJDoxrdDIP0DO17fPw4Kr5438MZQwdSozrUxCapW0GOQELJtzLDVXjgSwpejK9qeTO0VRBUVY0kCjGVNkBuUkpFVCcsh6GQ7HMErEgluDnFN7L9yfEC+SdGKUeQCKgpQp1tUaL+slp+W8fzehzgcYJ1087nOuA+Y5jUKWE2zSqZ4sYS1ALLUXdUXW2K9ilRktivoH1r6xujGdU8tzKffRlSF+H5EKeR3M/6YuyrcGOujeRxHMXsGelF02Em2pGybSmuj3X0qRiVUetZ2MX5TPMEVW2AobGBnuhFpa+sZjX52O2cIJLtKeF8HUWNUYBUAUhx5ffiJGR6oDNmRgbwFIhdKGe26n3aiuU2X9rgebquZvD2qQpppNu8YAufT7bB8RvBLf8TTx+JK3ZsRHJVAUiajMrh2VjH/JwqBlrC7CpFUlmDhFJHHKdpfxFroYS5BfOldabUXXtczx/kgnkVK+8X6AisAKQLdOJf6N2GN5g8FHWz0Qoy3I8FJbqizQGSXryGkLgMTeL+doD4CIAXqbIKjIUrq0bhFA6jZrCY0Fk6LhJQekqa5sRMbm7JINGghzS5Zdk5kL2mjZ8YMDMQT7pszsj/BIe4KyfFlLIIjODY8c82L5s4C+SbWpfHUp4k5vWCVoNnnoVf86sQRxwWpdhc5HYr+ZXCd+/LiGSPu4zQKLy+3GdbYX9sS96T5fLZn6SSBwGRtY/2kFF7FFXDvNffHau8Z75nnHI+zP9aTR86OLgkopXw5eci3srT/fW0RrcQ/ahn9DNOA+SBbLCAhWRFEE2TuJ0dIgZiaZGqafaZCO3oqg/BuRSgmEb4rqREFcYa1Io8ML/nRNvtr+sTsqmgODtlQGJjS+mtMJecFWR5lo82zT7YF+1rjO+jyqTrRbfqlpvNURpZcmWj6rdkKM7VbOYXKjl9tCs+eN3b49Of/nS86U1vWrjwAvv02c9+Nt548xvjt+/9WLRtWhNKxD76H38/EeXv//AHo66hgTFQDZQx0k5LtFKQpnDl/ei/fWU8+pOviPUNxfHtP/l4fP34ybj28m1pEOfgRGezV3ATH1uP9Cz+oeCbrsI7Dp+KUy3bkqTFWGI0Ic1LQbazP5IpzSD5iwAv2qA8pyTByIMzp3Hgsq0tLAUO+5Gn42TfqRQLpgoHALu3Xhm3b7062bvMQeA+dGJ/dEPIHu47GY0Q0qrF1VbWxLr6VdHW1BSdA73JJfg39nwnNrWvibde/8romu6Pw3gdm6HNSTIBwtHeRWmFQ65Uo4Q/HQ6ojDyAhEFwNIrL6lL7yj6iy3ft9cp5hpXkuPeZEsikEJ8pYYVnwT48JjYiFWlSpZM+l2HPVo+abBmux8fTIPKM43Z9BgbTWNFo7C8aisNEa1VCvKamIVpxXlCLFGEcwvlYf2+0InHRJbbSRyUgRkGyVYIf3WkzGbG6ug57RuxcAGCnkEAZCHVamx4kWWVIKJwvpaLlqKJN6yWGdumoZALPm0kFTt00ytf5QK51xw8LictlSKeKN/BMH0V9+hS76xj7CPaUiLgT6Eq7qdPM38QYHjsBRu6l2jxVzqsKtqCx4POOqRRnI8FzYaI1Y08l6nSF+XqyeCIOlY7ECWzTxpDWTCMFOlFRjP3PYOxACnoZYKlKoEo5xqHKUraI7YVe6AwUOwvjq7gcxUtAhvZWQwDvcbzDCRxtpHZoro1v9D2B5Jjg7oxzGZIymUgz2KB1jM3GetpmcHOy88f4sQZL7Re2WHO0fWlyfsqQxJ3C06L2VI6/zn8CwDhCWzuBuPjtRtonY5Q1w3pSDZFuU8X8mckESC9oa1jM+q5mnHYmSLy0tpXvF9IIrACkC2m2f0j66nmnF66ROYxKE0jxmGSTZuMTHHk9HZIQjsGheXqoHXBEzIfqIWIdDMJdwj0pHoHcHnMj2XTLOV4EMyOqhkGoaDOkfccCODr7JoMrDsN5FFCpbqfqiHVpg6ELW1WfijjAVxEfREIga29BOfwgMdBrPJ/UP0+KhST3uozflRYtvTeBLg4n1eyeLSU4kag0yz5P5vmCslznyUtx2hUZQHYhJ2oLjNsMV3QkYZ8bOHAFXB7QJg/pPHlotSM5q2WM8t8XruatVTUPdX111CGxjgJ0ibDDnQWJmyYaSqKrBmkfcLoYt7SOj9I5iQj/WZfJetKaSkCJuCAApWrakAFYcnlPQdHn/EimrGRBkepdegyDhGPtZImr5JG4M46V9maL2nzOgrMLcjYFRemPMZVo85918mtanxJ1uv62XHmhWbszQihrx9k13vWxL8QH/6/fekGDI0foDW94Q/zOf/6duPsTX4rXffCn459+7y+i65lj8dKfen1ccdv1yah+EoIr2YdA8EmASWDxn1QwLvxw+UtviH8AID38tXvj6lfcjCQgA1aO76LEACOczhfmokt+cXbKjLuCJEFgljEnzsp21g/OW5pdiDelAc8nyVF3nbP8SNkKWP7+ubhuy6Xx1htfHo0ED9XDVzNSlFr2rK8feDw++8i3Yh3BWy9dtQkm02nGaZ5wpTDdMg8j7RnXJgWbpEYAg05HjvSejPZ2YlsBOmRQmVQ30/mBUgEJ1FJAgeOh+qyum4dgQsngWFXVHJdUrgUQzsae4RPJ+Y7SwRKk5kkCQl/qUYErnzMg8Rj7RAU2JdXRrycy9vRaiFoVhmUEjIwQxwfAkhLPoIkdNZ6cHkRgCYOsgUCyeO1rwj7H6bP8U8ND0Y90rMn4N/N7hPuULvIdzgkIfaUuqolVIZVZzbwoZfo6MZF0VmGqYeyaAJCj7vfkVX1LCY/gigeSvmV/2leeSU5Rwdczv5O3FOcYRYCk6R7sUwc404Y813jiq5Hs1MJEc2zwYJfmGVBWYfwe1ExraV8bqsyqirnDaf5lX9bj2htznNRfq0TeFHsIMHsab6dKxrRt8neBrQyqAzAUG9lztrpnU4Zr3bFQi0FWTK/nIjfUASiL8SJYAjCZxC5MWyVVDieQ/piSownGq25WN+Vl0V0+HiOUXQSzMSXK7UQSOIMzne3aAlG/vZoArOHvPQH+Oeyi3DsLk20Fj8ba1sbYuKqFtVYSnUjOT9HIPqRO3fS5XK0SM84n22+QXFW465ifxmlVubFXJW8D2h3a1ZYCIM1XeF9+/8r7hTECKwDpwpjnH7peujEbMG6GHXyMTd19LHtZ6KoEwvgULpOrBqOjSUNiD0sJVDlJGahayP3sn9xbBThyNU0Fe236vvjFA1pvZON4vcIbGbEVbJ9ErK8S6Q1IK1RvS+1efHP6NsSh6/0SSGcnjfDxZqbqxllJfftyVPEck7NLT8Qah0IjXpyyODln5zmryOf5g4ew3o0Ekgutz4KTqlqodyQlYIXty1vhu8RKJYdjOpyepW7z+ufotnNqD0CEwcPM6uTCOICpi4N/FBVFgYQpSZm8ibR0bP3uJb3IjTL2lRAE9XCkBSMJeHLdd21Qlt6bCuRmudmCwykIPIk06AnymiyZ8nn7bsCRZdgOA7JKWAq0hTymfBytQUo/SfFoY3411cslW6P0ZGFOvCFLRx/aF7/1hz+ff31Bv7/2Na+Nz/7yl2L/fY/HHf/rs9GyYVX82G+9JwFgpW0OjIQb05PAUVLRYe1ojyFYcrxM26+5LCohNB/9xv0xBRE6BWWbzWi6nE2po8+Ydq1pjhlj3Ghrskzq27Y2zZMOAxakpctkLPjJthTrNCT9tjBrfkpzXZB3uY9KL+awv5jT/fg57rCcKl1Z42L62Gwf7q4HiRNUEjsqV8eBnhMQlqXx0h3XRD2c/nsPPp7WdFYXd1os4yadXwNR/oarb402bJg+/+Cd8a5bXhMX1a5CXetEknibtQTitgqwk3lwZD9AUjvmc+KE8LBvq1oVl1RtAKDVMEGzsaa4KbrmBrET6o0TRQOo5cLYoh9V7CFKZ9bN1cbOOYIr84zK4JiiEgUrPgM6CTBwbNZva+e55sl7bKY/uiHKW+saYjWA0GCrPj8+FUNIQE4ND7JvURq3ZDafs0l6pJrfLHu/qlkGEK3Qkx2/GXS0BAK+hWC1XbSukgC2mxpakGiUxsHhftaZ6wFX2ahvlmj/OD+bU0g0JnEmkLzQWQb7Sqo0a6rNzZIgDUlgMbY05WuQNq2mbXC/Jk/Tnh48ctLFkkYYQ7hldxwFbbWs2Ur0E+tY6661Ec4ChDQw1YoJKlyFlI0d2scAQDkNGIJ/FNcWN8ejjPWRFPw2AyCq8kkguos/XjwW9QCXDkCRYM9ujGEHdRQPOI+jviYI24RNzwaAWnNlLcFf1zL+mWqdY5av+WFAq+pvl9VtivtGn0nS89RRBnyOcZhFEvQUjM8aAPAmzzf62odTiinOjCLAu8PD9MzPWDZYutjvPNkTp04PxuU7NqSxVr9iHNCsGnaxz7zrIntJa6WD03cXM9tIn8BkLD/GmOJcCVbCsCXHFKnC1MCVlwtxBFz/K2llBF6QIyCRmhwWsJmNcVLIg5TszrZNiVHseJAWlVUosfG7V7Kr302Hz3dnXm++EWekjfISVOkU67NRJ691HFDGYVqa0v30ZQTu4JFhvnHIVgLq8h7l+cmSpFlyPN3UFyeJeNyWUpeArjDZHu1smnG5CplNLkv6/ifrMRivhvmFyTYZ5FBvfYUAQ+KmsI+SFBMSFmf1rbC0xZ+r6Moq7MwOE5PE8bfM3unh5Fgim4fF+Z/tm21zZEYTUJIoE7JBiEB4OYd1enSDiMv7kBHV1AqRN82k6MzCxtv8rAuqB/EHRa7EyHlRGnmu7nln8mqYpG4Q5lAEFdTbUlYHYCPaO/UAP1nzlDPPGbd9WbLlWc1Km/yW5pm1LwG1dM6tSzfq9Y0NyWvVfCEv6DfnQzuUT/z8H6Y94O1/8ktRUk1AVOZFhoqEouA7qeNIl6ZxYmRUSeM7t6ZUio3cZS+5Nh748p1x7OChaNu2jsuupgyaCrZVmUqG+Tyrd7/55rjlk99I9xaz92CaQd6Ie9/04hhAXakIUCvR+XzSmTXGTX7O7DPgzovuCpMTbbLCgqTkZk5Xbmep29FrxqkKQlq1Itdk92R/dE0MRC9rrQIGSntbW9xz+In4k29+mrhIlXG4+yS2SVckOl5QVQoDYRYp6xx7SgXOaar4u3n7VXH3gcfi7n2PxmuvvhnnCw1xbLx3HljROPZBx08VKM3qB5iTcuZDMFeL3U6NnH77wvcqHCBcVLIqNhB2+KnxE/Hw9EE8rbEfompVjxvxrXjMa4DAF2T4j5/TrTM8L9q+5B7RZCV08yzvQaVuqGwm1uJaWsmRbA+fw3GkrYMQ8af01odErJJ6i3n2xrk2CigSaKBZmYZWVbIyCHcladOo2hkXaBIg1g7DZ6SO8Mh1jAPXO7HfkpnmGaTESSlYmsv5+VGiWNKI6iDurmdQA3MujM1j/mzOGSWBmt8ZC1UsBX7eLliqWM1eU8W9nYx/H4CHmEl0iXmj7WSaRNLVjfruGG1oZDe5pqg52tk7dOXu4neISwAcSfkX0VIram3Xl7XGHGflMfaKCeJLzU5SPwBbmxysuOIJWE41xXj3Y2G7rg44pqMEt8U76CiV9gG4DrNXrho5FjvwmLemuoUjrDRJ8pQi2Rf/phjr7ahnnpjtj4Njp9J+NkV9k9jxyZCY5J7vFA3jTZKxBCA9UcY4V6NKjM1XKWOrNE9puc9wGg/GpREHLfuPdifAV45dVxtMgQ7sV4+jovkI7R7Azsw+mxzFzayfVYAwbuUpZt1Q2JInKuVdebmwR2AFIF3Y8/+C773kSjUHtfSCthcelpnBv+ow2mNIpAsZfrDJjbqWA0hPQbk6VUZQZ2pPcvUz4sqcpuyQ8lP6hQYq8+keL4mDA+VwVotjbTNuT7OrZluUEunrCbHMdcekSq4qhE9u32LtDQRKbEQCkVxr/yBHhA4JSPOe2nAPWVUNM6nZ4tnI8mXHU3aXntaQxajfUVjIohE4+0sDdaiWMe5BzL/no75mvZIwJoFElrLvSerk7zRH1TXLLWee20sbUkyYOcY5zRPzMQ5Ak5c7htpIRurYDlxzywXl93zWz+pWwQ+C6K0Vq/CyVIsTCmwBICToUjSX1BF8NTP0J6RhdE70oVaEEbwXU8oKcf03MdcNrMcJ2np6eiDVv5z9US3r5OKKtYk4nS/kh+Kt70R3dB86Ebt/+vWx/cW7Up8c+3HmZZqAqsbMKULckIEYpdEQrID6fH7S88lwXnJbBpCe/OaD8ZqdW9JTrIRBNVdjxcxIiPNP6dPRXZviS811sfPOx6OhC2K8tT6eeskl0bOxPc1RpjD0/IfXWVV9WKaD0helh0tTFiyYx4W5X5pUbUqxzPJlQgaBvHlfeul1aW1RQUyPACUg1oeRpOwfOxaXtWyO9+5+UxwEGNXgZU4PbzWotzXVNMZLL7s52fYYpLUa5wavvfJmwBbhCuDm//vbfiy6Bwd4RpDeI1WoB0wZ52xSqSdt8LkQxKh+Z5MmVQfkwjFcr2woaYHAJ0fCA+7bMHtgKG2t6IiD/ScBcMSSK5+LS8vboq0cgh41u2mCms7gbCWfu1mBKPNi6gck7Mc+6DjOGiaRAK6rb8V2yBh1xXh0mySWEMb/gIjxcWLI4d3MBrXU1OJpU0YT8eyI9dUG201ve3qcy1gltBk32iPDyKSoqxzQ0VBXF2uRpiQ5DmXoIMWyBD4ZgJMhMn+3neai81JBINVp7GtmtM1iTnRUUMJ46MLcsA7+JkBiaLk/m1tvd7/S010RoqFp3IFPn0SahFOC6SaAjR4mTOw75u1m5znKHLgnqLScvM8x/qltlG9yRdXh+no3ErwHynvi8d4TKR6VDiRUu9TuC8fdgCQcKVDPIGrkh7DplFWjP9K0b1NUD89FN1L7vuH98TJsnxpwqV5XV5vmV5Ck+/o6xqqcMi+tXMfYzMRJQPnoGBHGGAfzKGUcp6sPEuyiFIA2CCD0Pue3npnYBLiRxZYne1uFRO7ma7Zj4wdjDtD84CP7YweOWtai9jcI4+wRbFXlj5oXh/14OszG0rlhIPKiVt5XRmDRCKwApEXDsfLlhTgCbs6qbE2jSqD+t8dHP954dKSQH5o/yH65vZYhEWqD66rJcWGdXvMIyn/L3wvbI+E9hLDn8FB5HB40SrrgqBtCgU3dXb0gCYw8pjPX2gkmFVzNPyrpgCMLcJRQ92BtKUdqBKc3a48t+sElS7fOvO+qMFWdUSk8u27PJ3iD3KXkJTvExtAh93gvof9n35GynfWirG1qHixYu/YQWVvOynrWD6obtpZCOEG0DKFeN6j9Fy0oHP3sM16sONT1YNhcCgA5ORAHDxxC7QSjcIJVrt60DjWb9nhmojMBo8TNVcrAAS3e05mCa0CCUALFCiRYHKO8vdo/1Y+UxlMPPhAbN2+IbahndRFEsZ4xLBuciiMHD8ZFl2+PQewLRuBiW46gTgAkFaAd3trZhhinbVW1gFI45vumT6Z8jksyRoZAlFiog+tfOQinfABO8HNI/+N//I945zvfiY0DalDz6Rvf+EY8+eST8ZrXvCY2bNiQ/xz9/f3xmc98JhHn2ga1traeufboo4/GV7/61bjiiivi9ttvP/O70phvfvObqbzXv/71sW7dujPXNPjWCUN9fX28+tWvhqPss758GuzuS04afuw3fnpRBunBiXl1uUQxMQ8yDwyUnKVstU3zu3HDLrr1yvTz43c8EK98348zhq5K8ngfRJtPdmLKQNSaete1xF1vvTV9LnwpXEeFvz+Xz86vnvMk6pVo5I5F8ntdSzpTMFYNOC2tqfxaes9/y7qW1vQYm84TQ5Os4TYkInPRP3gqTuPQQlv6Wew2j4+VRH/3cGyoW0tg3fWJ6TPMeIyhnnaa4LHlgJSAGdA9eZr1Vhrr8QIHNooTkyfYDMuioaU+jk/3Rh+x3FR7S+q8tMMln9lhsf7nmyrIFGj0TPWjJjuCmhhASzWwNL7mQjIC8b6OGDtDJSPpOc0CcTPmZThTYL1PEvR2dhqve6yfKQhtHescJD7TIZw3DHAu+OxV11ZHE04mjIc0xjPZg0MIVZkdvykAkupySsoaUBHrw1mBrs431TbHeiQRZUjg0vDRgQSO8Pwn46MMaVN9bV10lrNb8EApBatCGrOaZ/WZ0oHYN4n0jElJ4AbglwCP6C8VZs+cO2xa8WinsqGIvRggVk6bUgBX7+GZnpoEiiAZEVSdSbSprIb8G3E73gVY7y0LPWaX6CKceEMOtuNtXftmsL+dRgVuhnPSvtL2OuysEoTiegkeHIqQYNVS/sbZOtTc1FIAsDEGjl2pZfH9IPvQ4Age6NhrKgEflYBmARyXGHsWj4ZOlHWcoLD3z+1BZXIdMehgGrKwbHst4FNp4fDIcNRjF3xTxdY4ATC+t3QieooARKxz43OVcp6O0XadouSw1PFdw5poKzwTaZee7+559JloI1aZc9lQg40VdlA9vf1R3dFCgHDWGuqAc6irzlJ3PSqkLl/7MMtzYOBhJXwraWUElo7ACkBaOiIr378vIyAxc88995xV1m233XZGlUfd5G9/+9tx4MCBuPzyy2PXrozTe9ZNz+EHzwE5jRITvXiSy2P2PIdbv+cs7LUYespHw11pIjsXivTauRJnH5zoiGPDqCsMVMXgBEQB7a+rGkCnfzgdjPm99k+OZiXEQCNcOfX33eCVEBgYNnHC8sy8W6+En6pg1YBGLZ7mSbuCXD+4jxLi/uN4pxUcYrTGz8snXaqqNKZbgyyPLnb9nEt1lr9v4VfvGiC/6jQZCbFwsC7kWv6T7auDsKlLngGNg5HNw2k8Mi1tc1pntKoWcDKBF6Y7vvKvcffd34pdEPonTpxM3NF3/My7Y2vT6mSvoKrcJAExxyAmJyAE6yCcJHB14lGbAKtutOGsAorriN+il6VK7BvGCaD4xGNPojJTEes3bcV1vERyWfQMdsaRwwdjy86tsaqyPpr19AdRpY3M6dnh0KujEqSBvr748mf+MbZcuj12vfrGKB6FicCaacPD1OrSRjw1sUbojHYhw7r1JQjk+dLv//7vx6/92q/Fm9/85jMA6ZZbbkmfX/KSlySg83d/93dx5ZVXxsDAQFx33XUhyKnCoN3n+/HHH4+Wlpb48Ic/HH/1V38Vb3vb2+I3fuM3GL+747d+67dS9TfffHNs2bIlrr766nj5y1+e6nvHO96Ryrv44ovjfe97X/r8q7/6qwlELSIYCzrgPvD2D/9SlOPm+ExikUib+hzlyXXjOs1StvqUEuop0mDHbZtWRys2TE/f/UgM4aZYG48q5sFYKeaegVuvNzwJRCWEPpNL10xe1/fybpnjEPDJPoaC8hanMiEABX7FtDc9bXbKHAWZHI+8Xf7s5xOjc/HYiO2FQ1/UlGyRGqp605M6MV0bPdMEiT2NnQxjUY4TlOaqkWio8pnADTfrF6ETjA+eW4jZYdTXapQgQeAOIl3JQFwGKiYAP2OoxlUn1TXUypCSpJTaaVN55pBMjUOM9yDtaS9pTBK+LBOvDK4BUdeXNccEjJP1lW14GcvBMT1GglOBvdLsdDWE+Hh08vfgbC8uq4doKzF9qKcEcFGHS3HV34yvI9iz5z77Si2msZdxjFpr6rB14Zkc5nmF+TCOR7cSiPT0LzHfWD0UWF9fPu90gZ0NQFXHM9yES+wqnkef+dlSABsOInqQ0I4hAVHDcYJx0auiAVZ1WGG/Z5FCJvUzqf80YUjkqGcVfaxAitQ3ORwDaR+an04XWkrZ5LLcEvCoUOWuDmnSCYJ64xK8qHkySurpoRQeWZXgPTbTDYjBZmsKZg7PZDGqbOPYaglYVCO2j7ZihvEwgGySfAF6nC0lY4NK2VCFK2KxCUAqGc/UB9owY2DaJPECdGCHJxB8oH9v7C0+HJfVrImNlauInoAOIG0xQO84e6dg1udXlblibODKprMxnRkEtKJqJwPEOTHZribauAmwxRJL9aqCqJRtDPClQEip8ENPHogbr9wWV+3YGMO0d4zxLiZ47uipgZikn7VrGuIkJ83TzNGqQU4L9mRjeJUByqvZa0sAp6oPrqSVEXAEVgDSyjr4gYzAI488Er/7u7+7iGtsRS960YsSQJK7LOEjV1mC6C//8i/jR3/0R+Pnfu7nvuv2eHQYJVz1kfy4KSwsI4RyMsHc2eZbmOf5frYEpUcNqGI834QmQDzVXx4H+iHi4GqVQmxVlY9Gc10PBAuHGxSsJIYctAVgpA2P3H/VguA0UrdEmce9QEmblKyH2pbgmYfDFnI/5X++7fte8ttyGHNJLc2RPt9o2ye5+B7kJp0JKP9T9/+5JIHRIOpohdk1rGYYnzWZ3zFUkpKNtpId1BGJEzINMTYwRfT4+UJto+qcTaW10YSqYtEkfURydMMN18fP/Lt/H4888Xj85V98LE4dOhm76i6L7zz2UOx54smorauP62+4LlqaMVp//AkCPlbHFVu2xYljR6O/rx8pyuVx8ODB+PY9d0FYzsU1V10drcQucdCe3vNUnDzeGY2N9XHr7t1wq9GdX90RtXjeGh4Yie/ce390d5+KHYCHi67cmbik46iWJq44DAhVq6SpVD1pR0K2aqo69tz/RBx8+ploxdPYi256MWOMZHGeEFlusGRkvPKVr0xlFkptvvOd78SxY8cSg8P7Nm/eHL/4i78Yd9xxR/zpn/5pvOxlL4s//MM/TEWuXbs23BNkkPzLv/xLAkjbt29n7G6IH//xH08ASaCk57FPfvKT6Z6rrroqfumXfintE3/7t38bgrDf/u3fTteuvfba+NrXvpZAVPphycvaS7fERddftujX/Lko/NE591maQMowC+GbnqXEcFiQHu5Eze7Oj38hnsHpw5W3XM94uRIkohzY/AhVemlMK2wppFq/z0mGgQShT3dajj5Q1s/vxtWRIPWKBKPXk92KaDBP6SZfsnx68SzDtXM5thl6DWMX43kdY7/ABqcUg3y8fer5qwiC38CqFeSvJPCqRPMIhO181QA2JBsQrIIQA7pqyeHac3xkFo0AjMZQ2avEM15ykOGNtNB9zbVpe0uwLalknyrlYe9FZXSSfRDByJmkOp5/SqEurVpPbCR9jRX0jfpcvgIlpe9d2Fz1lUHW08xiVJW1LylHMlTPn9KjYdo/QXn+7tjJ6NCWrAp1sprKihRMdQophvZOdJD+URdjWYaGwMlTPdFz+nSmWpl1BRVD4gVt2owkrjy+edddSRVv12WXAbba41qA5wwDdGCsK54ePkp/AVwS4uwbialF0Sm4K27lXDZKaS5r3BrNo0o5ymOouiEenTmSHL8IYhxb9yMlzo6jJ53PruwgHu+YJbjR1Elsi4YIRs5eOtcA2EFcoorcBPP0CE4q1vC8X0Zfapw4StADoYDNIqf4PJI8/8GcAigwvWldT+J8Qe+rU0hiYhxQiCe8Kfynz7IHzo4iIXKOSlDCY41IVRbzLvAylML9AweiE+nQVVVbYzXn3DSARpVQnd24Lx2d7UnqjtqMqWI4x8FoHh1d6I3RZEu3Icmrc00zBtqYjaESOYbdUgXr58rtG2nnbNxy3SVRo9oi7ZlAXfSuB/fEmm0bcGJBWw73RFUTkm/iLj1Ku06zDrZgo1TBurU8QVs9Eq5K1gADupJWRmAFIK2sgR/MCOzbty8uvfTS+MhHPrJsBZ/4xCdi9erV8Wd/9mfp+r333hu//Mu/nLjTHR0dy97zXH6UD6ZL6WQgW3CDB6ogw/PZg9GzLQUt5F1gIeFxvuSeuVyuTHqUeUM6Xxn5dZqAbjQqKUOo9nBolMHSr0Vy1NLQneI0eQrmbVaPO8Xm8YDknwSdKW+LqlmCICxjOATVqSe4IRxSr+sOV2IlO1DTbf9HXpLUCLuOSQ7VrKW25llOHU5n25pLkcZBNgfnRqKFMmog0HSZrhH2ciVY8ggnqDryhSknojxiJR6zWS/MYXlwFZEG6XS88LrqTNr8ZN4IxyAQy5I0TvU37avypK3D8WMn4u4H7os9T+5Nh+vq9jbAwEPxt3/9d3H1tVcChI7HX3HtLW/+ifjWN+6JltVtsWHjttjz9NNxkN87YBJ85m8+TdDJKjjTjfGZv/9MvOr2l2PAPRGHT52KS3fVx1133gXYm4s169bG//78l2PTus2hatu+fftj29Yt8YXPfiFuh7u79Zar4vBodxooW5kDH4nLRiRIR57cF9/82tdj546L47GHHo3ezm5Axivy7iz7LiH7nve8J97ylrckCVme6f7774/rr78+/5qed1XtTIIk7zGukoTMu971LmLfGKMm4h//8R/Tu2BISZJgx/TiF784Hn744fTZl8OHDyeC0M/uJb/3e7+XpFDed+jQodi8ebOXlk2lSMZSml92cvUN3JmIMJ4UAXienHedFEyoIrRM0g5JgLT3Gw/FDbtvoqTCtbRQTiL4GOeiJMlZ+H2ZIp/XTzZVCYrv2cqjxVCuEqVJZQtCNtlTQexDJSbCVFfaC6s0q86dw30lXxO15UgNi7pjdJJgzDx7NeWD7EOqQsHwAYA38yfIGUaSktkw2e/sL+9AcjwCmFC6KVMqf9ZnaJ8BX8eRLGion6RHPOMLEjDj6bA3QESXsP95n1LUgcmRODXVl9SDXbMmVd+sXzUonUoojV4uCeR1LT0yOUad2M3gnkx1siKkAjqVqIUBAw5iTxLIOZiAAzzQZS6yMerHqx2dxzU37YK7o2S2GdW+CsZMSYc78tOca48+9jjvzyCl7Y9NWzbFJtRK29tWwag4GieOH4sBXIW3trTF1m1b4/i370vU/cYdG6O4EYYPZ1MN+00RAKkXFcBu7AOnkcY4WzKUVDVugaFy5z/9bzpeHC9+7e64uH49UhmAFf0fc4ek/ZXsi94wjHRPxxbaRLrPz1UAmKoBNsQTmsaQ5yh7wSyut9fWN8PcwUU2qnf9s6PxEHaN6wBQauMVMW7ljFMpEpsT40Oxd6YPj4zsx0hJjR00DsDNEpmH8Vc3iJStlmeF+j3HKqsFuHXU1wAYBkRhyzYD0J4FJM2VAjJxU34C1by+04/GxorWaMLNdyMS+1qcBRH0Kh4mzlbXOB7/sMOaQUWvhDqLUb8bQpVTZxkCN6XiKPbFPvpY5nmgSI790PVZQjtVzUtBnJXWAbJc+7XYJV2/a2uM4iClin63EwC8SNBFmw2u8DSe+ZTgXZzAOwATwMiltN4Eh6ni+Z6vvF2YI5Czvy7M3q/0+gc2AgKkHTt2nLP8W2+9NdkR5BmaCDho6kM16HsBSG5wmaGyW6Tf+M5fikmEusNCWiCH1SWf4KDRqYNA6cyd3O43j0ZBl/kyhYOsFPPJTa5P0qMzdy1U8SyfrKdnFHfNuIctK5vC8Lkvmmp7INPZ3CFW5Kg2YuOiKp2Evq1daPGSglM7bSuEBK969NNGZpjjVFssbVJqOJBqIGKSBzm5cOT7gSaGQ7W5aaQ6mRrU+esT5OVSJDmXR1DlOQpHHnICVTK4tDgtMHLU0pLEKxzpjJyc64XkoVoJt1QAa5f7IL6EwnkSHEloqFqXrZLFJUugtRLwt4o81fMgynHLAaqEpnYKzzxzMO684xvRfao7mhoakwrR03v2xfYd2+PtP/XuOMj1v/7kX8UTTz2RAmQ6HtCFiViS6D1xnHgvgIj3/sefRa2kIg7vPxCzQ3Az8Sz34lteFNdfe31UoVff3d0T6zdCaEHwdXedikcefSSuvuba2AiB1nW6L558/MnYccvVifObKaVkvTrTX7ixGzZtjNtfdTvBKseis7uLv9OJyMgCOeY5F78rNXrrW9+6+Ee+qT7367/+60n6pe3RRz/60TgFoBMQHT9+PP7gD/4gARu53qrmKXFqb29P5Qxj4K4Eqbe3NwG9vPBsrUQcPXo0PvShD8V//+//PV1S8rx79+4kcdJrmCp2W7duzW8757vPjOt/Y1kbXrxUhMI1MbYxnRDhi2d7SRFe9JEmbb/pimQP8uTXH4jSDwGy0q9LX3j6IFyVIp3zOeUWi3TdmSTU/OgeI6F3ruT4pcT+o8RlBsLQ+5LxPqpjrsMZ7G6yiFrUTv45vZ7NPwzWJ8iYQTpQBJGttzQXYHnZBLaJxLip7AGAQKKjKghtCpAgDhJ7pbdPSITStKxKe0bd882xTTZtgnaV0n6fX3s2gQRgCBseJROuVcGJUnBDD4wB9JTa6F7aNSdR7k3jEOvjPMjaAB4Y64728gaktBDQ1sFmkJ4ZiOBkl2QlS5IASunDCLHORohjZGygCoL+ascjgV2Nulrm6KKYNcC+RH3anxgPy/HSAUUTKmOTZJY4dk7aVEmdc/9lfpjXGaQOt938onj5y26Pz33un2Bw7Imf/DdviXVrVjOe7OV4rmtsaUIihJtt7HOOHDkaX/zCl2KEZ+1t7/y3ccPFl8X+Z/bEU099BwDVFDuvujxaqmrj+FRPklzaJfcF53MCKQ7Tgcv16ijvG4vHHt0LmJuIS3ZdGps2bo2nn9oTNXhuu3jt5ug+0Ym778loa22PA4cAbqOj0XWyMzZtWh83btmGBAw32AC3p/c8Fg3Y71185WVxrGI4Hho+HjVIWTbP1kQbPtKPDOOcAUXloUrUzpL6b8Eg067pEWZxBJuv1sko6wCY0Ngq9tYGGB/aio5PEM9qDDu5IVbOdA17GEy7McYYVc45jGxH8CD4cOlhhkpNifJorm2KvQcPxD8+cmeMMm9p8aTlxXygytoBqDvai2c6ALhT/le+cL0Ju7Of33lz7GrroJ1qXlAff3pjzFXNfZqUKE3WGiMPdT6ANYZqMXKgO2q3tKYxLkaV8iiAcgdMr2YYKrkdkmsz2YWKWFfSBT0CKwDpgp7+H1znBUhyjCVk9uzZEzt37kzqc6ramHJ7I/Wv5Rp//OMfT79JNC1Nf/7nfx579+4983NrW2tsfvetZ74XfnBLE+ikg3z+AhAEgLPYeULhPXKedFlr1HYlL6qpSQRP4f2md6whWtBDr6vOSJgBjPczz3hZCXVsrtr3FNZXWPa5PnsQ1kCgNBHor7ICtTp0/+UAVuJ5LJMYLajSnbPsdJhAkMBVHEVSMzI9ju0EBAj/sq0dwoiDXTWHYf5UBdRxg3+6+/5Bb/8ClNp5u56cKDzXeKTfaVCFUiRAlQedBJonovzLPvp0FJWgzXjFquYwputn0hAqOYPz5OGZHylLcKnBt7Zh3lCC0UTXpJZK2d32XxVELALO/Hbm/vkPqt9VeLiS8vvmLyXCSnWMW299Sfy7n/sPcfjAgfgUQOiuu+5OBGANqnRKxIoQfdUQ1d7YLBJrWWJE+KyEagriRmIDa2MOcg5sgcOJrkQYShBmrYXQkxAwMTYTcHV7MUJ+ApW9Tgikcrill11xSSKEs0ypy8wx9l2A+1pAfCnqMHufejq++qV/jksuvSSplag+JDEgofh8kxJgQczu3bsTwaHKbGNjY7I5kmDVBkmnDiYlSJ/61KfiF37hF9L3WsbjxIkTCRxpx3TkyJEzjJEnnngiXvva18YHP/jBeN3rXpfy+/k0qk3eIwDz902bNsVP//RPp+vLvRjDR1WeOhgNtVh8H4bzX9PcEK3bW+MUnPvc2+Sie9NgZyOe/Q6IZh4vuvbS2HffYzFwqjca2psX3eIXgYIE2bJlct1pV0XKuZCpklw4M7NyyBn9xNRItoQWVpgo2NYkiREgyLxKhwQeSqxSwWawApPv6Yb5d74n1TzAwxREdynrBBZ9mq+U2SJodynrVFCg1Z8eF4f5c+1IrFunjhQsV5WnnEFgdSbBwyTSFoGFQGwQr3KTSCVUsSrHtqiM37UJVbqgIf80aloGTTUgKcz7lARTU0iqSgFTh+e6Y01FM7ZteCtLtjAZeNS7Ww6gs7sWXgVbrosUxJU9RDsZ212GdMb9vQb7J9XXhpSs0w/3WnMkOxjK7ahrTN7aZJRlEvlinEIQzJb67bc3TcNgmZwYwmaGkbIMxx/APQsTp/d0T3zqr/+G5xDVV+z59qPCevW118QEKmAT44TCxZ33Iw88EP+MY5L2jra49657WM+9cdMrbgU4VKeQBKnF8/Po3qBa4jiMhM//w2eTjczg0HA88tDDSTL75S98OTbvuCh+pG0Nvz0WfTA7rrv+2vj4n388WjvaE0Plzju+GT/3s/8e8DGOc5PPxar2jrjvW/fFyWMn40U/ehuxpcrjKI4xepAo1aPO1wcAg0OV6rK/djsl2zTBS08N9jzoKXSwp3C218N4aOYsUZgzpOTIuEq45C5rxVECDLl0G8/d0BAnFHa2cxOsfZzPzKDCOVrNWTV1Kr6299vRN+Tubm6YRux32oi9ZudV8Z4bfzQ++KX/FU92HkTKqUZE1qKu0cF4oO9oXA5AqsSeS6Bo0F0dffCS9rIB1vRjWHd2Y/85jbSujOeFzTgGj/REzXqsmSrKUXXGux5rFDkV85mB+7QpM7kGGDZeU6oya1pq38rLhTUCPuEraWUEvq8joIOGzs7O6OnpSYSMqjYnT56M97///Rwew4vqUt1G4keiSBWe5Q5AnT18/vOfP/P3tX/52qIyCr8IbYwbc2ZzZ+Mt4wB8LnucEoNaYtzUl9RiU4TpqG6WAUidgy0cpKicAF5aiUVjWZZYzSHw3dgeZe0twqPSVGxq6oo2VOu0bemoaIw15U3E+OAgovzCXhT2MX2e7+AIUqLjeEo6BeE/guG0RMHSvkroSAypWnIaBxadk30JVGW/n1Xy9/UHCZHnU4/qM/4rnD/VA43Vg5+B6AI85aQ8Z2L0Fk/HAYg7fUAt7bdKJ4IjD9ZkhwAZmHuKs5O2qxRi9Xwp3V/QosL8Ep8jGO9393RG16muGAPwNzY1xBrshI4fOhq9J09F59HOGEDCc9HWLYmAOt1zOvq6uqILKQvUJaCiGXoEbub+w3H68Mn4p89/Lg4dOZxsGRbGgU/Zf85w1P8am+LiHVuT/dO73vWOeM3rXh1bt+9gFCgSItWkXcUoRFV532xsHCcwMB7wjh44HG2osL4CFb41a9ckXX2JMQNffjfpZ3/2Z5GgPZMYGD/5kz8ZmzZtSsWsX7/+jOqcP8gQefDBB5NBus9ynpQk63zhW9/6VvrpvvvuS3ZF2i65b+RJz3bvfe97o6GhIVatWhVvf/vbkw1Sfn3puxLjK8o38LcxtmMgPguB+vAjj2IvdUgts7OTAy1RyJ9E9jQ2FwLHPF1623Xp46Nfvz//afE7g3iulW51OpBRtUr3+6WokhVBVUJPJq63kg2lmAa+LnxW5pKEg12AdigJ0VZHiYvvSWXWfU4JCP/SfYlgB9A4oYgf/N0+ZWAk648upV0XZxJZdVE+5718Vg6lww8lMFOo/ap6OAaBrX2GqlaTqLDZnoXEPsX3UQjKvqHB6Mc72XQqn/0GtbCpkbE4jb1pb19vjA4OxdggDCZURwVHgi//TaPmNj48mtw8yydQKrt/9GTIjBLA+IyZ99mkR6NIb6Zom3Cuhr0bpBYTI9gWMZcG1LbJJ3EJfnh8MLos1zFjbBwfVQB1ZW0eNK6QSqBuRxntMBUqkSwoqTNlkh3Ul/F+Nz9c6fdSVKAfePARbJN64+qrrokfecUr4wQSnLUwEK657ioYCLfGJTtZ46jJtsDce9HNL4krr70q9u3dx5jAHMOesQ1pWVtxA1LO+nlbLYq2bbT91pfdEtffdENccfWu5HzFZzqp+Tp+NC2NIg2SKdGME5TX/cQb473/4Wdi1brVcXqgP/71q19jT2qKG3CAcgPl7N+/P8aHRpNqI1AS7EMMKBhonp16mxsntlP+NzGGqtw4z0O3oBPQtnaOcwvHMUhx1uLG22dpkD1P270Rxj+5ctdJA+OYBqmatduCvexG1DA3j0cFkqdKztfSQZgM/XjAQ3KZnaYUBKhpwYX8L+x+c7znutfGpW2b4+dvenO8/yU/njyEuu+57gWm6TnluRmvr4pxJKLadOkgRBVama6nB5GQA4ZnYZApYeJnnGlURNsNm4kjBZMgjZ2SQUAzoD01Nw0mDjpYN8Os2zH6vpIu7BE4P3VwYY/PSu+/ixGQO/z3f//30dzcfMYV7yWXXJLcA2tYrWpOnvSIpQvgO++8M37zN38zqez8yI/8SH45vevsQe5gnozkfU8cy7+eefcYc5OXE+vnLKFyhmpHFqjVzXjhSp5j6bvnIccx6g/T0VhxOoYgLntGK6KhcQbwwoaMTrfERzPG+svF9Vla3rm+VyHhWAOxo8xHGxdVVDKyxu36/IlY8bjZHUoSLQ/J8yVzmE81oF68I63moHgu952v3O/n9eV67qGYqxmiDMQBi1SAX5QanWT0nI1zcXoSkTjfQMGXh6j2aWkdMCAeqN9tKkFnvQp31/fhKOEj/+3D6WDesmkLBM3uGBociSexMfrwf/1vcDkr42oIpcuv3IVK5VR85m//Lv6/P/ufEJszcRmSnE0XbYpLuPapv/gkKjB1sWH9hth47YY4BoCqrUVvHuK4HicNqh9qEN6+ZlW0r10dL7n1lvjsZz4X34YzXV9XEy999SujsXVNIv5Ui6u2bXffGweR5pZhoH71ritwCLErPvnXn4o/ob2S1Rs3rKdcYKSqTs8zHTx4MDldeJp+ylH+4z/+42RDaDFvetObksRIl+DahujuWwmT+XS0ILGpFEjGiBJmAZTSIR216Alv9+7di1pj3q985SvpuuV96UtfSiBpUaaCLzyisfer90Ngz9Lnq6Kx3CCZQGaIpWUTayFXuUqODtwEdI01n3buvjo+9/sfjYfvuDde8hOL9yezkJvVlQGXXM3H313Prl2N5LU0cT0qZVKyJZGXAsqSSaJPoDSNatykAJdrM3LEvZ92p/f5tlu+QMd2WoMSJe02tENJcm5/tkEkJT/aA6W6JCIhGM9IIrMs5GUXYGtMQkSfB/XpoHz1qEhVqS00MIF5wdUs+TPpCW2krdNISXR9rRexcohnn1Y9oQlOhidH86ak2tJ+Q1m2xwtTxNRJam6UW4q0ZwYpEh3Cs2dPHCo5GTuq1ib1Zjn901LoqfTFUFTJlTZHAjKbW4PEVy9sAiAldoKAPqTrMois3zhSAqQp2icqKmJMiGiUAMMU/XFu1uJRsp5xt9w8CUB0YmAZrl/rsj1FjH8fXhu7cODwpf/9ZVxZ40gFVVLPwSmAIEKRBKoGBvvi0NEj0duD62/u3nrRZsYLCReSojX4aJsBtFTjJKAIIJ1AKCpgjuu3vnE34HQyautxjJCAZRq6VHvWBl/5o7/lPF+2zWCszpH2OEMAnlOo/w7iyt9r63jmK3keQCgsLkBHWmZZSZbh1FheWtO0YXaANTPC+behKFY3oeHAfuEYjHKu9tMu16OBvYsZzyLA1CSScBl1As5xHF1k5bEq2C/xKh/TjXjtHKBtfQAlXMq7/qxPu8ANDR3xzqtfhT1YE/fNxe3bro3NrWvjHx7+egyOwlwlr9lVkN2LBmYxantXkw8FD6Tq0wB5nGvQZwVGFUiJBLwuXZ+/ke7BJKUsR/UyTz7hvXgYceW4fkeG8bDH2rVPU/TJobB1K+nCHIEVgHRhzvsPtNduwnJ5C5Oe6tqIzK4kaWmSg6d3qy9+8YvJuHspQMrtFvL70rZ1+myA5CY7qTcqMhZuahIkxrbRxbLqLYuv5qUufk9nBD/Vw0HsKFcFJivVg8F4OZafq2ksvvP5fatAzUEtk+xIyWs9TxlkE1T1Tg/D4eWwoSXZcZbdb1l5H21nXqpkRZ5jDLWQUdRJjNuR5T9Pnf+HLqe2nGm0vdJFuCOdEatKgo6hK5ERKBzDHGQLZOyzN1KCQRCaJ+9V6laHlZPWWfk45dfP+U77VMMsriqNl7365XEtXFm56LW4lK5tacT5Bhxm7BDe9bPvRv2tC5sEgmu2t0TX7FjsuOHy+E/bNycOZTNcXWirmK0ti1f82Kvi6uuvSpO1ft26RMi/vP2VqN3hfQoa7doX46qbFlaiKvSWNW+NUoDTpTdejZrN9jiNHU8TNg0lDZWxb5gAj5BflY018RPvfivqLbqLzzjwdcRr0UbqP160JkYGhqOpFbs/COEGiLKmlrPVxs7Z//kLmzdvTqpzepurJqaKarSq1JpUqVMapB2igOalL33pGYmQbr5/5Vd+JT70oQ8ldbxPfvKTxHraFh/4wAews+pOe8F8FdhyEMsL5ojSJD3a6chBCfXu3buT97s839J3vQM+g5qToOfYkeNxw43XRQVj92xJSUExoIhlQSpcDUWxYdf2qG2qDyVIEm6uv6UpBTh1Naa9IrtqLpk2En9JW4t1ovTE4pPnMAjUbC1DYDIX/nkxARHyaifBI5CeA9c5OSD4LIsyeLccJYZzOGeQlk/AZWGJZ9QhOED3xSVIsbQ/yiUiWQuzV38rsVy9vgmC8j5Yh0Q038WLtjW1l/7MAEgmBDiAfm3n2hvq8QJXFScH+yHoIVIB3RUCMvImqRKAy/lI/6jDtuuxLI0lIMfepWp5cc/eP9IVG6vbolavdTy72jANIAUSiNZCpCsNTskhm08UGbXYDdUh3ShHHawGxoAePtUqcC8x+ep3wR0FJ8J9ENXk5PWNa8bnaZhCLQ91v2Sv5U0k213OGkrMBMfBDpgoZ+2aDryxbow3/tgbYhN2fr29PTghWsV8oMIFYS9Y6OhYHZu3bY3bX/4KQJDtwCsmDBEldv1ImP/+L/+GtX9LbNu+I0539cTlO7EVOnoCyVR3vOkNxOCqxuPp04eSWlhVbVUMI5Eb6u2LPsDPJEDEpLQtTwLZcs6v1YC1Vtryqle9KspQsZzGPrWK53XmJIAFcFYEutCL2yzAIh2eFsB6SGtlCsnaEHHZUKvbuLo62bG6b/YjnTFob1JhnS6JjdOc+RPVBIotjmcAuS4bFAsBKO7hjhwpgW6UOEUvhET7/9l7DzDNrupMd1XOubq6q3OrlVqhlSWEhBACEWXAiGAuxgYTZgwD84w99uNrDxfNDIzDeGzfAY+NyYwxmGQscrAMCJRBuVstIalzrK6c/wr3ffepU/VXdXV3CcvMRV27u/5w/nP22ensvb691vpWaRPnPTYZZ3SsB4xgmscGUEdTWxwcOorJOVtgIMuu4d74yb4dcVrbGooG4OWcPkw4+6rR/NTi/8vRUsa+7IBjgLVx7s0t6XfM+WBoLFAQ41idDj347Y8+GSMrq9g0YFqV8ScliC7UkgKSalOf2q+OEH7n+3I6tVtAaXE5LbfA09oCO3fujPe+973xvve9LzS1MQmMFH5yHyR9Ea666qrZHWfP0fzOIJA/a9JJX5akhdOa3xVSXGCdhJeWEDhYgNTvdXsAAEAASURBVJNWh7lSN2OT06pAI/ucT7Lp68/0MrN0PLVrub2+Re5oqoXSxl6hwd1j80uvrBK+u5gpXGg24lmWXHBlbfJd4Kd285/n2S6tmEi6B+zimmqk6WEm7FiXrCeWUCa6SiG1mKTBtpLQQn+LlrRTvLT+dAFVC3ew0J/YuUpWKnhPRw/9cXD0MLupLPz8k4q7em0TIBaTobHDyRFdJsWGVmKltFRGN+BWOtpxbOoVEqsQQOyXJyeOJi2oArR9PDY2mWLvpFq6uw8rVAHNoX1bV4/vHP4TvSzyAyP9IfvfKMLCT8ePIOAh/LTPtVI3Ee4fH+4GsDGq6yoAcv00IK062sN1mbbiZC0pg1xx8jmXgEFTKOMd5akCwUzfQc8XULibnidjHf3oRz9K8Yw0mcuTpA7+LZYkcTE/wZIbKuZ/omR5ziOWkiZoD953f+zbtZfxXowcjr06Cf8A0kQtTJnz0ZXGGALjuc+9NO788i2x66HHYqOBeo/2xg+/8K34p09+OboAws9+2XVJsHd8LkwCfJ9DhgkpA/754J05xGF30bOn2N+SloWz1Xo5nrKnNxM357RQ2Z2U5fJyZkeKXhMWyepjEZaaUhPw4rv5jw2Pxooz18WFL39ONBOAswBAss0aa+ujE0KRNt7dKDjMUNI8sBR2M4ObKiyjVEitktrYMvC7Yz9lzvMxyVa/mwXZcy4mKyfmEZtd1N15ytL77DgnH2VjaIBrm/D/tGW856zZH4VtqqqP0+o6MbHqTf6o44KxrOFnqy5os31lNiwFJPmcjaNKqcME8rTyFgDYBFo5dU+pVdN1lkOfQ80dpQRvwt/OIKNjsK1dcvGFaEIfi89/4fO0CdYHWE+87rWvQUO7BtPwm2Pb5tPj+S98PtrRLyQyk0kAzbOffWVc8JzLYWcbj5Vtmo52xBe/dDMAIqGnOO+8c6KRDZcf3nFbfOYznwYYlWYm6pT7Iu73la98Lfbv3IU5+yHIWi5MmwmNmPcm4E2JW5oaUhyw57/0hfG5z/59fPJTn8SccTwuwbzvXO47fHg8hnoHo2oVz1MDdO7DgKZR5lbRHHWcpm7TI5iGNhI8dg2x92gr+6ybjTXBkcDz9LFK/vBxZH52ZDZjYbGKLb9u9KV7MIcexu9TAoh++vgoWzfpybAz+Uvgnz5/y6U3xJaOdXHL4/fF1x7+UXzotpvj/S9+W2IT/K+3fCp6AZjvfPar0jrXCYD679/7u+iGeIFmAOgKuo0xx9qPeWDWp4wV4iiVEHTY7ltDf7Ri0vr8886KJ2qmYxvxsSbcEKB+DsURfFiZTaMF5FRLzKQR/KamKHNx36cBsPxyyrXAMkA65br8X7/CGzduTJP1X//1X6ddX+3XddZWyDE2iklw5M6xASHXsmP+zW9+M5nb/Jf/8l9+9gIyY7IvuOj1LnMKKL47P588sfvGgpxpZ5Z6zclzfbrOqMYkr6OyObHVCYSsF2LITPaK/vNT9ntWezVW2mUbHX3heekqD2YXzM/k6fg2c0NL6MfkS3FMvnOlsoSTSFiaE8oimNdVhrwsrsrSC4oXRXIWL174XFD70ezUs6hrjJPS3O1TKRPg5FM2fubuN86us/FzQF0p5b9kogK7rDB5ER1mtik9rrnnCEJKnvJr9EEaSY7I2aKdipCAlmMPIcz7zKTZa8wPoGTymHXJR/gwoE9n+3lJKZeEx0h6V3DN0/e++u3Y99Z3zPMbyn872fuJzPPqMPM7XioGR8c7Z+HxYhC28Lfi7zrt3/6DWzFvrIl2NNer1nRGD74wVP6kSSE+IYKiMx2t516bAaT7brkjVqzvjLee9eJ42799e/zZ+/8ksfEtRjBTlMUv/EfH15133xX/z4v/Xbzz7/5brDtjU9IadaI5qkI7NQxgOopPzTDzvcngq0kbBUgVgFRg/mWAUZnPjDmlf5N5Om/N8KCAomhp2t8YZtJMF88P9oGbQSthuJPi3HNH8Qcyb/98CGQia4Qm+wLMn8cGfxo7x4hZxLyRdXw2/tPDYgG5tcFSZfZLoR94BteXtceqsg7mfTVVPD9FD4mmdOXED8J4Ky69/DKCQ2+FjQ1T3+7DgKnKeMOv3AiL3D58WIZi48b1+PWVxFYY46oBOfVoilYCgN787rfF3if3RHNDQ6zesDZ6SvGJoowtmD++/g2viSd+ugft8jDU/RuJeQbgpB3e8W9+Ix7buZsYPgaxLY0WgFkHQLUZrdXY4Gg0t0KMQmyfBgDqK9vboqyBINaYIb/4VTdAwQ3RBWDh19/11uTjqMmgcYEe3PNYDO7eHqumquPAk70xff5ZUVHHHFjFLEUzTcNuKICpaae9W2FBRSMjeB2gzw6NDaZV1vkMI3qAKoACDdQ0QIRJMhro73Y0cGuh8TbeVDNtqFnjQ6WjsYs52NHhvG5v6LN0sP9IvPKcq9PG3d6+IwBOyDYYF1/fcUc8enhPvOS8K9OmyEWdm+nn6dhz9HCUt0GGgaZelaPhLbQPrQSMi5oq3VhinFCaBMiIi0v8qu7Yc/BoXHz+5ujDvHD3tACLLQcK4caZG0yrUetpdK42dBJN5Zj1WU6ndAvkEtUp3QjLlX/6W8CAkYId/YtMmth98IMfTKY4ften4MEHH4w3velNyWTBXWGv0dRuKUmzKzUhc4kJl0lREzptzU2ubUkeYhIU6Ej5nL7PXXTcT9q1Q1665POPm9G/0g/WQ5DkgiSld7ZrffzaZb/46h9COO2U/KcUUFypWPzSb3xPTuGawlT9CxcIslZzp5CT9QV+BByRKl2w44JbpdDBvyQIcb5CkP/y5KcR6jd3JPvFPCTJ0Bl/KcnayTJWnLfX+V3Ww6RFQrtoOyb/BPL3uIBGZis1dG04JsuMp1Bnfr4oJBwvZWBl/q/ZBv6x12RHsl+9oviM7HPxkSzPY45zwHZOx23zebe2BbNWTOZe1pyTPUvNxGUvuDqZwM675Bf0i+BIYHYD/kxroTrWj2MCBsFtDz48v2GfYv3OeC4mkKR7//n2eOz2B9J89Wd/9mdPMZdf7NOdn6+84llx7bXXxkfv/3J0YrI5ignl/sGjcZT4PwIWpxTTBIBpAg2tUmg5O/P6P9WgVa1l7lGXoJ+MPiLF2zQ1sN5VMycIkhowo8u0Zll+vqbYTzzHYzCu6Zfjzapm/Oc0f/MepWgBfZJaCPa8rwRzP531CfiqwK+/VpbYTOBzCcdcN2qYS88jCO1Z5VBHo20oBSyUIoBPoK2aopzWoYznvwySHn26qqhHBQBuZHggBgdgtxvZGzXQhHe2AqAwXe0bORgPHOmKnlqYQzua4yjarIe7DsfaptZYe/HGGMEscdcE2mYII2Qf9T7T+ISeecZGQB4AEuCglrhAXCJYseOCszfF4yWDcWh6OB4b2RVjAyNxxprVsaq6NW367EWjs4r2am1tg7CnNx6F5KIME7RJ4h0N9I5kMdzOgWyIdn9gal88vOvROH/Nurjs7K1xMyQOvWWwtm0EBKHxcd6Q8bSWNdk1ppF83cBxrlRgVBuaLBj43g1L3GlojVwvBTWltNE0Wh03tWoxn6yhnvaxVDlbJ6sgOiqP7QQD7kWjxDBIm06GX3Defdaac2Lb/ifjnr2PpC7aQ3vVMCfvPHIgvrv9rvjgK/4DdO34ADMv10dNmodlNkx6Pu7vSlBe44hBY6XpJ2Z407CCDgLU18E8eRgzRlROcT7ml2og+9C2m6yxMZHqKNB64l4J6mVg3EvZT09nLL+cqi3geF9Oyy3wtLeAzFTS+spkpznMwt1inbUFUJrV9ff3J4rfxFK0hJI4gRvbZgQhtoA5kQKtk+IIavG+0UYmZ2mTjdMAOQN2yBLTylZWvBt5stvoG5Rrj2bPnVn4uRWJl1wScJHnswtE2sVngc7Omb1y7kPKI1tsXHDyZPlN+WsJC8zcr/lZ89/9PQNJLAKAiBMny2Y5s3uw58fKAGAwE2zPS1k48G6NEsy5SvAfmGZVm1qLrxVRyWfreeIbHPOri3EPZBCjmJIJXCXK0NcB+WI2SZigJkig4+FxzW1YvLJ2mD3tmO+eO4wflYDLODeZSDR3/sJP4r96APIwQs0w/mh5S3ue/dYH1e00u9ruaI4ivqkd0r4+11jZP1iMYLsuVHJv2d1vaMJZlh1XRVVaeOuf23f7ltZbUJa5ceROuu2lqWnxrrp123DVufHWt701tj287edW3n+tGxmEeu36tdAjfzFpFDZj3nTJJRdFS2sLJonH12idrDyNnW3RedaG2HHHA3HRZRfHqQaO8vaRefBNb/2NuPvWu2L8hufgYzMM26e7+QjIPAtJA8fJjjzBhwxjNfi51eMPVM2zbjJujoKpsZeKByz7PTxd+fOUPVX61fiMajaZWO34PDKjpXIdkXTCDTbvrclceob5fWN5W4wSouGhgd088zy8+MdkAICbeC7aH28ug+DFNRtjc+2qRCs+gbmpa1YJjKZlBczO1FIxLzlvjQx1U02uhUhBoFSGn1Jj+7oY6i+LgeGjsQeTtSOw/3Wx7gxU8bShnZ7q6QdQlUdHYxNgYTj20V5P9nYnK4sayq+fTgWAa4owE3v3HYq+3r6oR8PUCV23POiDA1BTO88h7HcDePb3dyUSiqZRN/xGEgvbFOvVeP9g3PXwA7FxyxmAreA+xBBiUrBd1LaUTAAQuJdzcOVK/Onu2RE7H38C0zd8UUfXxngPwA+KbrVqmtMZwFfQoF+cPkcC2nJY5yrwNxrVZwkUOsBcMsFGFfFZ7e3UtzRKmjedP513pwkY7HxThoZnM+VsoSseLoFlDi2XY8WNrgEAXh1sgBIj5KkCbde5qzbHr1/2kvgPN/9PADjU/PVTmVnz7CKSjTcJICbHHS/8UccJgTpzdEkdMaDoj3PRXD77knMT02J0D8UWfDTvS5ECLbWm1lNxzxSmdwWIk8jLsAiuAdkIzEu0/H6qtcAyQDrVevznXN/2drwxT5D0TSj2TzjBqfN+0p+A/byYwDxijJ0gJ/HRidLoHmwIfNXZndI8optroBZlkq9FiD42aZLHgpBP7DPvLijSSqfJcWaG9K1EwZ2J2cleQFHKrqQMTKVQAidgwcScJmiC0001Ugh2M7lq5rbZ8qGAOsIOmPFxRli0BVTa1Wu+leIxpc8IDyzmCv1qVzJBQzH22ORvCuz+NlPUY0/iF9YI6J4BI9iYs86mHbLS6RHuwFUwYpXg6JotLryRWRJyDmGZvQYhQkHi+Jkvcr/skHWqY0d4gMCNmpvJINdSjfMtx4vTGBo/hRrr4PK4WD2Lz88/WySFfRfEagk4strkPx/zrhkQInIiWPCe+X1sw1G0RJq4zVU0a++5sSEggzVwsp8ewawGWlzHXAMLaSO+EHhHkF8m2GWjytsjSDGWfi6JxnAsC49sl+yugnbDf0C3jICnZtXxNve7JfP7dFzz1lfEl/7rh+M/vec/xX++6T8jaCo8/mIlzazUWP/oth/Ft++9FWrvCfwJxmLlmpVRh6lR07qVMVkGacNkX2qrpdUuay371t7dgpndgR27or31xPPa0vL+xT3r3LO3xB1HMNMahl4bFjvHWwmCpWZobOpjtsZT4q4+x2oERnxPPo+MPyPajDH3qUXm47zknn4+PscQyI+iQal0U0KGC37x1flZRkIpx3smhiAGGEyMom1QZVe6HmDiJoteKWxlcBfynHIRFyqwlzBfK0wruatBba9ojEtrT4v1VZimMX/4v1IaaC+grJrOlfM3BjHA6ACAQ1Y+5uiSujY0VzDOUZYyzPl6AEOP9g3FIaLqTDIXGH2tCSAyRhkFb6tq6jCjywKqDqLhNGZPBZqWMYTw9sqGqK1qin/+7m1x6w9+SJ4YwaLxvOqqK+P5z3tuNDRSNmwQNwDKSiaqo4C2h0Ut1lWtJBYRQU6Z3DXFG4DY4dZbfhBNmNlt2NgeLWh29uNfqLbOuFKugY7iowCBinXl0cO8PtwLzfjKpijBHXHycGUUaujLOnxymCvqQasSLfRgqtsHyLFjzpmui05IMJ5gM60H1dYgi8kwcws7L7ZY0gr5nNgurkwlzI+yIcqvKDmDrJJ1nH5ZeV3sJe8vcM5H7rw5Dg4cjXdffWMK6NtQTZgLrn/+2RfH/7rty/HHt3w61rV1xLbuPfHZf/pO/GTXjrjqvAsoj4y1k7Gfsq6k4yrsL67TBoDpPJFRTDP2xvA7GqJwdfzJZXHrT3bE1ZecE5saq+IRzI1lSLSvh6njnWyeXVIC5TqxtA7iw5TNllRsOZ2SLbAMkE7Jbn9mVNp1rwzwU8f0y4wcnVXT0bZ2GG0EX5nwemGuGSTYayW7Vhxyfp9JmQibBHMWqQomyExj5M8KtbI2sYgKiIg0XjLMEqOWBa1KCcKAeTEHs9gCkrJLfE0LRHolJsd0PyYga9itrs4EzSkWZBe+7smhGMCs4ngTrwtYEsqpjwQRCuC+q2FJZAUcPzZ5zL+5Gi48p2IEp+Zu6lJ0ipQFWeLalG3+PnN0mPOPwlS0CkEgO2Fhtsf/nu7jgoUDL4EQC0kjwx0RUMoRUIrrn25NTl6Sfz5+xvN/8Xz7UcrjOnaCT6xJYrcSE7lmqGG7xvtTGYqaY+bexy+BAGQA2/Ss7FmLZA7jowgqNUkANOq7AskkZVJr2ULMD53Lj5/r/Pr8TN+ohJoj9Wk50Ez5cFxwNMSiXww8FyuLjFV/+MBn4+abPhKb2YF2FDa3NC+5OA5LWyQfJ3m7zt6LA/6m6UpKIjc+FgO6fEzk7ZuDU9vdf+l6LyJlR7Lx4r3uvfOe6Fy7Opo62+O/3/e5eKy6N5oNIImQuG3yIAQDxMNBUBUo9gPWBYonS95JUyO1n2ow3NY453mXxC0f+uKJHrWTZfuM+F1fEBnpFIRLARDwJtJYUNJLbAAIratQwGaDB5Oq1GO0n4BICvM8oG7WBfzqB34zFlPS2jJJuV8zXBiMu/seY/d/bbQBQmrQpjgHmqOakZ3DXfFIAZY3nO6bMe3a2rghNk6v4CkoxG60JbsH+tJvmsimMvAi45+bT64XArbzyHtdDo5meyYbxWmEULb0zjgoYRyoEeM/G2XkCfNEGVqOQXwFt40fjCNoRaoxCVOf7UWSC6ghW1vXBGW4GietGtjIYyPGWE/m6/qxivh3B3buj3/6znfjpS99cVxzzdVJk/vpz342MUNu2rQxpNI/eEiSo9VxyfrNCXSOHR2MHY8+lEDoli3n0H5o0/i35/GdUbX3QHSuWRUXr99IUNSKGDjQHbuh+2/AP+usMzclhj7YFKKwimecgkwQ0mJiALPH/WzMbaAvWEv7fFYw/zMZwLudmlUyz27CDG0VMQKPsCZ20Q9SydN9zHmsx2UAQpgMjd+EbWKadyoAQyUA2SlArutgSrTF5km0SaxrI4WRuGPPw/HK3qvjurMuj6s2X5A2Dc/v2By/d90bYnfvkTh71fq4+aEfxeNH9lJPyjfJWGGzb5hy/7iM4L1k20afroI2vIENy35A4yBzMLaLacz0UU63NFpbG+PyrWfQ99OxeawMQFsSR6oykzrJOtQK3j9tMOCK6EWTaB8tp1O3BZYB0qnb98+YmmeTmIs1eIQJL623HHRBq2IiNOWvviskqTFIO+r8Mo7N+QhaqBq1UgZydFHnxNIu4kZ0Y5rAZJ52Ic3Im6R3XnJhLztS9EoZAFPDBFacmnEcVUBlXwtfFwVssuHf8ZICoZVAN5K0HZ7qgqopmloQA9rOXm9mM7VbPD9O4OaVQ4Ad3pUN5tLxy+A5/lrah4kIdvShRmypKd0S1kBElcToRpvVICAMEXAyWzJToZea25LOU9yw3ZzQTpS7O5ONLH9T0Lz2FoYoj3vWTy3Ntj2X2UaaYnTJCEfy3nOtyhjjt9byhmQSWnxdOvlpenFcqZVUmzZ37yxzyzO/TMe/aUN7c7zhg/+RHfiRGDzah6A7b7Acc6EARvDXBDCt9rlB3LMPFJS6x3iuMMdZx3Yx8lP0dmG6ODQZqzZURSO7ujWa1fAs7BvHdwX/C5NlLy5/XnZL4fH8u+95yfzsbzegKWpc1QZ7VTUBhSdimIDIRyYEwfm57mgLsjw/h158OU7yOuuj+WYlwrHfrc85V16cTMYMqHmqpxR7qbaO2DMNaF9bmT8xfS4fQXE+SLuhRXGuZB5LTI1p48DNKHxyFJ7pBeeCIWiZpahWwC6voI8QUMeTqavbDEGct/74/uhDUYkGpYHNjRY0Js1oXAYAT4/27cNHcDzF/ull4+nOGVKGceaZQwUIOQBram/UZFmGpD21PAzIcnyP7FStAWYg0Gx3algriHOzRRCVM95pyiehQ4XaVZ63yfERgs4OxLaR/XGUctZhWqY1gCCsh02yQUzpmhuIlUcZBEcyuVX6zlj1O7sFqR0qAVn3bduGD2AHtPhbuO8U8dG2xBt/9Y0w23XG17/xrRQrTDKUL9/81XjLm98U1R0r4m8/8Sn8nqqjFxP17Q9ti6vROPVA+X/3HXcnv96jBK5+17v+HevcdHweFrvamtrYt39/CktwxYueA7iBbW7m2SvD96hiNVq9XVUxfrgQVat5VmijcYk2UlkFHWyyAY4m+KtggeykpKvHARUzz5Vt7L6Hsaf0DdLULm0P0paSJjgWSnxuBIf8jfFZjZLtWot2bWfvweggUGxdVW186eEfJGKHi9acHls7NsWTRw/EQ/t/muXhQzxYFYU+NIs6aNHmg4yZ7tKxeFzCHfLU/G+EiaiRuacF071RrkFph7YTJsaW+nh8Xxf+TaVxNnGd+gBvhTRWAPrYUY9jGTLCZghZLKdTvAWWAdIpPgB+Uauf+VCoQZo/jSnImNzZlGQh2893LdT8KPO/0KzBZdF5NhdaNQMY4q+aSb0ZW/CSgdEZcESOLvSevMQkHetkHYspzD/e2YVeR2GZfHIh7WRZWauaBIYyEzvPV1OiaUYVQptmgzrLKuAfH3RQdv5XI5jWsDs4HxydrAQzv7PilcGUNAlAWlITcD8FjCHqK/Na3sY1tOt0JaBPwgV2gp/OZFsZRNUW4fYnTY6Z1tIGTGQwM0FAkIhhoZB00kyKTsjapfh17kcdio9M9CUw3lxWl8Dtv+RecznPfUpPgGP0aUpVsF75d7KkSeiK8qZoRktmn+fJT2ymE8OkPNraEIg4UFkJaOmH3aqTXkIYcWDW4CjRillsTGZ0zfn1T9/7wjZZ+P34d/LMRJ8/O7/AjoXg11RLIN9zT08ay+NdrZ/MD37wg9iG0GtQbFk6FyZpzmX3zFk9i3//8Ic/HDfccANxdDrTYeNI3XLLLfHQQw/Fi170ojj33HNnT/ce3/rWt1IcKa8pTl/96ldjx44d6Zrzzjuv+Kf0ebEyGLjX/PQhvf7665MvzjEXzhxQsJ3GtLUGMpcNjUPRitbIuXVQgZoHcRzBWBrmUUgyFKLrcLAXOOW9MEI7TfDbFCa++ik5yQr2NcdKQrY7OmgCxgFB5iEo2oV/pJk7b6dNLLVUmvGhtZAYYN94F8FAC2APBH6ATLqXc5I+M7QjMjqJGRNyAToYLcEAjG/E4MEHaHbzi6vc2OifHEGILidOWkYIgFSPZoQ8ydsyTONfWYLZ7SisbrWsNTUAHc2mewVHQ5AueBpmZfoYFQDt+omODI+neri55holbHfzTYpqzVpLASEFNJxlWA6cf975qR6bT9sU6zesT6Z///tTn47D0Hpvp99bV7TFL7/qVVGKqdw9t98N4BiPRhgFXw6b3mmbN8X//NP/N7qJB3bXHXdAF95C/KUXxaM7HokH7r0vthJDraLV59AWsoHAk42UZhXk3QfwbYIQ4gLGwrqHd/tr7NqyNh685rxoQpM3DvmCYYS4JM240p5rS1FAQ1TnPKwJY1FSM8hKDbDyCu6RdUI6o4LfnLe3H9wZ/+mrH0l+Wgau7oc63fhIf337lyD2qIwjA/0QX/Sx3rM2mxsW8yV9eGZpYo3fFMPQ7kzaucOMIpGabHarCBvSlDYpiUcFMC1nDDj/HO7qY60viS2tTbGCuFf7GQPT5F1G+UvQnpXQlgzf5XSKt4Ajdzktt8AvVAs4YesDMoiTfoqOrtreg/y5aPruWxUTnr4ppjEEdoMM5sKwk+zC5LF+zN9GsbkuPTqUNEdpNl544nG+y7w0yU7ccDsxZoiNM6GVAQWRTEAzJwHayZP720z2/KtiV75YmLZ81kvt1wCLdz/EAoO8y2Ln8fmJI/yvGZyMxkMIDG7rF6Xc0qHo0KIf3TEtw6HVxfykKbsl2oyM/nruChYcFsJqgJHRyjWjmUvzyzV3fO6T+UhL7k5wvvfvVf4pxNainaoDDituLDVZnQZ2o1dVtCaGJxfpLMel5rC08yyRdvLd7DR3TfQmauPjXkmF0vg97gnH+YE2cDNgRhw8zklP/2F70Y2Ghe1mSzYhwFTpo2A8ERqhnGDLUkRMoFnVT0AGQ83WjEO19F57+utwohwxtk1jqvgZVHv7orfceEIAaZynj3zkIwkACTI+9alPzbvNoUOHkq+UQGRh+tznPhdvf/vbY+/evbM/+f2P//iPE5W4LHK33XZb+u0b3/hGGFR7GE3F7/zO78Tv//7vz17zjne8I/78z/88aVBe85rXxKc//enZ3/ywWBksjyBLcGHMKa87cUIbi6S8sX4i1uDnYVDtakCC2pdBTLP6oGvuByyM4g9UQZ5VSfPNaGHIqD0YHoVmB3BkSlTdACad9Ae8bnQYIgZ+d9s/+R8BstHEKPRmhC/MBQjmFcwnms3WMwc0Mr80oH2oRtOS+TtxLwDaGGbRBTZ5pMQuDEGvQjyn0UHoyHsGY2cP2p+B3jQW87o6xzSiFe1A81uJliVpngBMyZyQZy1PzmPNrDFX4gt0ffWauGy6NdpHIQsYzqjHjWckU94g1x4C9HTTT10E0R1Gi+H863NhiOpGXquhlp7AX0nTRQkgpqnzkzufiJ6enti5a1d8+xvfjDtvvyP6CZI8wVx+GIa3BoT/UczDalobAMHXx8oVKyF+qEnaI59NWf0EXl3E63rkwW3x93/76bjnzrsxnW1NzH/F49o6ufJUruC5rR+KV3zia3He9x+K1kO90cbfBbdui1f+1dcxWRzFJA1gXI0HML5C8IgD0PDrxPzOB1n/LdfBPKXZAVAyhjkeWDExDKZFkRPso0tXbIw2gsI2U+66qsoUBPYQjIiikyNDPYDNgdiLiV2BeaKe+1VjLthS2xzrNrVFeSfWGKOMt/2ArxHuxH+BthtgrhWr8d1aWQ/REMXR721Aiw/6ww2MMzeuIkbjSvq3JNayIUoIrJTUlmkGrNmolOrL6dRuAbcQltNyC/zCtYCCmVSj04AD6HZmBJk0R1IXfmUF0nHeBWgQMgJjwrhozE3dM1VecEBtzFF2qtTcV7LDxIbektIU505gYzLUqlNodp9pJvkhdxgBNCcS3i2ClAwKX5p1JDCQ9tWOf+skmM7sxM2vQrbs+Vo9PBUNM+DIBdmUFizmfWNDsOGbYMHsD+lD0YvX1DFFQHm76HaamXkO7765+6uWa4w6z9yOo6bsm3GX9BPKvytwFG0mctwMTXNXK1gZj0oDLus0oUMyF2kmKRuT/auPVn5ldv3SXs3PNu8oa0qmVL2TaJPwJ/hZ8jrZHb1XH2BW4bEdwUvKeZdfh5c6Rt91Lk46RoQkd9DViXndyZKtJXGEWjTLP9d6J7ty7nevOfmd5s5Pn+wHd+MXuRIZKlqq9PdB2GQIKcxOY6I2icZIXzyvGUNskbXwRM/Ggjv+3L7a7m5oqKl2jBS3Teem9XGgevuiZbkN8GJw3ByQXHTRRSkW3K/92q/Nnv+Wt7wlaXxmD8x8EBS9//3vnw2u7WG1Rt/5zndiF0KywMVYS3/4h39IkNCvxG//9m8TQPQzKabcO9/5zti4cWMCSjKHCp4MoyABzjXXXJO+F99vsTIIsAR2arXe/e53x2/+5m8mhtHjBe/m8U00zPrdFBgLfYCiYcbfeDKbw3xK20rGsv07iVA/WCJxjhoTNDQI7pOAI83RBEkKpuUI1xk5COOD/Aw2K3uc75p7VgAiKon340jV7M2g3zJTVigUcw/BSB0gqRXty2EYz4YBJlI2TwDQFIrV/lQQ6DWBOEag5mOH0O7uH++OlVOYZzLP5Mn+V4DX8V+ApO/QlGN4kT2uOq6boD7TAK9NY/j7lNTG40jcJQAkzdQm0IT5fJbCspZvgGjqm4R4fOTqAUNnnrY57rzt9ti3bx9xjtpi954n43//7d8BgF8Yt/3o9njZS6+Piy66LI529WBSWB5rOlfH3q5DMXV0NHqGD8fd2x+NDuJ9pWR5+edTZtt0oGnq3Lg6rn/RC1MsqimAWCWbXpPjPbSaNZ1LbmRdtP3BaEADVqYmcCaV0Y713YOx+Xv3xYPXX57avRUzWdGHNPoF8tQvTDPCRtpilpyGPDQPL3EthbGvlHMnGMcCV/v2xjPPjy3tqwBeY3GYdeMQM8oYc3wCpdxbs8J6zO9sP+f8IcZXPZrIdmIqlkKdN1E1jMYL7eFe1qhmzCLBbJNoB1tqCbzbLDiihlaDsVqAya4CwD2BD1i1BBX4Kql1XEP+T9Bf3Xzu2XWUwLiAzBY2BRdowvK2WH4/dVpgGSCdOn39jKupQp1C+SC7WqZsos8m/PQb2qMxgFHP2EASdObOSadnzrYsqk6es4lMhjAH2rUK4XscFjayrsSAuQZNPr79SaAvPt3rFAEmYIboW0mAOZ4oF0FLYbwZTTVOJACal4tZA0xoAogsLVy2Zg6f8C2rt21QAKSoWSsgWNSgxcJiICsT2U9Q3aNNLGQwFVm/xmHqaR2p3+x+mZlQFkHfVBPmJamGMzf3N5JR1FPNFSC4UuFeYVcyhoVJdjk1R7aD98iy5xsfvFoDt0Sjy2KayR/4ErGIakooyFX4SdfwnmAF9SAG42yaKdLs96f8gbwaEWo0WzwK9avaSdOx/Za18VPOv+iCIanJEQjdoZaJ0fZCVEx9plCoyaTt4u9t5Y1pt3xJd6UOlRCLCE2Lz09+FBxbDMTkxVIv5665gOCptGXqO8bY9MwGRZ6f727Wiq3H+b3AWNIBOuuy7A6+pnhMSC/5L8XX/5/+bJkUyBDnUuvkmkvLdSJt6rOf/ey47777ZosvsCk2Kfqrv/qrWL9+fQrIq+YnT57z5je/OWl93vWud+WHU/Bs8xQcmQyw/Xu/93toGybi8ccfjyuvvDIdbyZ46ObNm5NZ3/bt29PxRx55JO7AvOqVr3zlPO3SYmUw1ILmdZrWGeBbk7wPfehDKe/jvVhmfd8YNknzo4+h7HQFTJkm0Bj4ezJJ08yMkyYwzdKczuOaNE8goApg9Dty6jOwLEGIkqO8Qm0u2AY+JCX4HY0jkFdAAlBV5nwP6GDuVqskO1sV8wvK+3RMU66jthf5p4eJsVcFHXdLfUO04zPlfH0UE64RHPwFcfswszudnoaseraq9r8bcG74VALoKrieWT7GIQaY5lieHAv2xSCgeGwMU0CuGWJDTI4f6+7s1aJ5sZdgDjZSQtkBTB2ldXEuYVZXTzO/joxAnLA5Lrzg4vjGN78Rd991F3TfB+O8refii3R+7HhkR3z3n74fP7r9rnjo4e1xzjnnMA6ujr/7+8/EP/7Dl6MXyvBNm06L1Z2r0CoR8hqBX/PChjqMA9GoXXf98+MLn/9c/MNnP482bzzO2nJWXPD8K5IW65jnnQMbtu+eB47yugqSNmzfE/dcd27cy8HLytujRv9dYlJ1o+HZBjtkYbQXevWm2ABpTWNqTxhCmR8Og1/WMAbqaK9sHrA9GDqA3IbOlay5U5g9A8IAQEwZ/Ma8QL9pddBMSI8NAMlpwM0ONrH6AVLpHF7KmWRK13LNYbRI3fQthB2VBMotrSiNA2gv6QaSxEtQkjPfNkPaVAsIPALY23WwJ66+9Ey0j+XRid/lUcaVZpjdTxyKtq3ro/+nh2IaXywmgOV0irbAMkA6RTv+mVTtfJJXYFMQFCCYhtitGsKRlvV4blIuqjhrWVqojb6+8IQCk3qhlh3wWtZsrq8eA0wMlkQTgELzdYXYPEkTOtaIgydgRLP5DAIYKZ5gdfwrWhLyS9K7C0UxOJrLcu7TvAvmfZl/jqJtWtARuAVHtsMou2nDIImW/tJoouze71AzO70N7tpj5gLiG6B+5SxytYDA+hGc0lm/jXNRwg7b1AoygLLc3do8mQtGiDAYsRhy3HzqEVBkq1ssaWNeC1BVz3NMSo2oFoh+47O7eVOJOYg2ZlVSuPDOc3ef//mY/P4FBxw7amx0yjcwrTvRGfucNczum0wbMcEUlB8zYNJZJ3+x/ewfCQTMw/tmd/DarI+sr9omU3tFE61w8hXaKxXi3ekupF17LkYYqUBSqzdmGEJbolVOd0xZpxfbubEczib83bro09y3b+6M43+ynGPEuBL0STfsmCtOxhluQPDRbSSxf1FRTYis59PVk7aMLZi34/wSFJfmqX/22S0g1CYtZhrfxeWe67WFOedgZs+ePXHTTTfFBz7wgXSKgOVv/uZvQt+fP/mTP5l3mTGVBCXXXXfdvOMCrLa2ttljra0EvDx8OHbv3g0jWcMscPKEFnbVDx48mLQQDzyQBbIVUAmw1Dq94Q1vSM7+i5VB7ZXBdV+FT4tmfJ/85CeT79TnP//52Xsv/JD6H0GWGQe/GUg4MIkrIIAbIDaBSMbfJOQ3anhT0g+I+SlpjARGCLhqgTVlcnzIcCamkWqlMI0TflmzIjXgC55SGMeaa9Dsl3QxZzunCsoAWeRfyfW1aiX41wNz3MHkrwIdN3lL6V1DvToBCysw0ZLlUcFZCnG16jUAHwi8o2usH1NbucuyspqXhDjoHAA73o+nsLoxVWMM6vGEeKwfZRgcGkaLgs8l42UHZC1wJqZYQqWaaHEOyhJIIihvLfVEGN8wVAW46IBVjfmVNJlYFafida9+eTy+88LYuXNPXP2ca+K0TbDN4Qv4xje8Lh586JFUn1e++pejvqk+WtpWxK++7dfjYY6XoiU659yzoxqzsBuaf4l4X+0Ai7J47Y2vjCZAoeNkxTv/bdy/bXsq1yZYKg9VDsYg/TUvzTw8xx/ZVIc5vwxgehBt4L2jXXHGRE0cYkPpEcyHB9DC1OCNtS16Yy9OiGfj5ynt+yFCbjhjdtKaapJRE7JO6neGGTnlbERLNAo5wgD5YIFL2/JC39EFae5bC6jZ7PHRSchXIh4AJE+nDTd6yTEEri1bQ38eZv3oq09xq/ogSOqvYjHTwStlyeYT47J+ujHWsR5VgaZbG2FX5dgQY/iJu3bEwLq6aNrYAf+GmkfKxxp4orZIGS+/PKNbYHGp5hld5eXKPRNbwIlMDYZ+SdqGOy1Oa+LBhxNOcszcGtPoa5OfOHv+zLXmNVwNpSgWBb2w9jQPollS80JMBS+axLRulCALxaBJiDZGeTKR1/PmJ+8hOKpnp03Nkfc4eXLZNkdLnF2hf4u7s9KTCgytuXmnOnDKJAvEkeZJQBGgA2rUEcyeZtaM7BzOFQz21mdaJcFSHcJIYy0xRGoxh0sCbXHJshJYN+9tafoRdiS3UAOTielz5+twe2JTsawe5mM7qCOyRzya/TKX17/+J/oUoaiT6PSa7i0EJpPsYlrHblmPZkD4z1oma2rK3xfmYwvoJK5uRxY82bGyVll45tx3275MrVQSR7LjCqqJHBlBZYzdfokzciAjOGpAKGwjf53pBbN5n87leuJPPnNq3ASTAtriZN1q2LrVxGh6jPryX9aqpysJCA0yqRgjGUbeJwvbyZb2XMdTXvellMHyCyqNf+VzJIukeS0FRKqN0Z/nPe95T7z85S9PxAFvetObklamlphMxUkwY1BtgdPCpImRwnee/KzZXDXsZZIRFCd/0xxODY1mdmqyZHHTxO5973tfvPa1r43jlcFrumFA+6M/+qMEkMxbkghB3rp164pvM+9zouXmiL5CxoTTVE5QorlbOaZgxhBSEzABcBpH0yAdvxojE0MzM2PC8X+ipJ6xiZZoAmA0hSZe3x+oyJxtqstHY21DdzRXDaaYOxPMUfns0FfAUNOxy3n6GvWODMYYmihN2AQoVTXV0YkfysqqGsrIWMX/Z02BcU88n0MEEj86o6kYgP3MuEqqrWwzn5t8/vG5yu6HyR0gyfE1NtIfE5BsDAEyxqmb/JyPTg3FLuIgWe/qOgLMMq8KsoeYK8oRyOswMRufHk0zi09Knr9+MQV8riYmxmP96hWxbjUBbtEqFQAgI8QcqqqFmvryi1K8v92QyhwmrtyOnh1JK9904TpqPh2Pjh+CTbI+WqHtNihsOWXqbGvOtFvd+6OJe2+45AziuA3HgyO7o1tQZrXshJmUgCdzwJ5z1sW3734wYDGPX964Pv+Z+pTGXn4zkKwsjk8Cig7D3jdAYHY1Zg3EemqrA0TS326ebS+hLXxiMCFUC+Q6AGJKY8JFqIwy+SS08LceLDMyNhVPArxkoKtg3Ej2sI55ZRMU41QE7SSU6TDo7WHzqot5rMB48rmurMEEj74uXcmGBqBoshtQe5g/Yzo1wEaHCUWBZ6NAX+9hTq2DQ75GUF1THo/vORQ1DbXRu64xqjrriJ+EqaBjGU1nZUdDBtRmW2D5w6nWAssA6VTr8WdIfTWpSHbq7jYxB2uu5OKbEwAIVvxpKYk1kZSBJBdGBS4XQS/P33PwMwoT28FW7NmbMHkerog2ItANoeZPpnUzsp9v7qxblrnlx3tkyWMKvnUuGjOCr7vUyg0KZItdk1+rADuOZsoFKPlgzZUwXbfYta6DrCswNyHksUgJqIoFRa/J6ydY6qmDcQwWo44JYhhBFJHSTFsKwbxa4TH7Z8shBGDmWGArr06K17TbngkABUxuDN5ofZeSslZfyplP/znKCprZWC/LUdxG3s2xIWObC333WB/mMtku9NNfkixH7y99sQEtFX4kzbUMx0u2sGN34Rl2nf4UtQidxgSzZgoWCivmaf/pD6FfFGLZ8bI/znHo7NFO6ZTfjKBbJPalcuiLYN8XMJ8pRfU6OY5f1VIfzOPc0cP2T0YZjTkN9yjHv8lnR41PiotFnUwZ2Qn6S+qa6P15dgQ4M8M5nXOyF/3GJhjfo45h7jWEkHuiOtx5552JhEHN0Y033piyV3t0//33x3XXXZe+56BHTdCWLVtCs7g8qLamd8997nPjE5/4BHFv1iQfpLyM+/fvj02bNsXKlSsTOYP+Tmp+TAcOHIiNGzcmfyV9nxT0TVu3bk1gSca745UhN6e79NJL0zUVEC7o73TvvfeeECClk3mpgCnMgKmT7L4ntjh6n6ZCrgWQj2JGihpRc7o07HyhKSurK/A3WRG9Y6tx4p8BjYz1SjQ2dWgjKnGSrIVdrLVmCIFWc0RAEJs8ao1SBzKOpOzuFUygCdCsL/n2cONSylNLu6xqgKUMLVEdmxsVqIw2I2w38Nx63iZYFA8gDO/l+wTjV0Y0CRDUCglMc02gdczGC+sLk/Qk2q1RMOvQIEFhqd8YGwCPlY1EL5to62rbwTvlyQysn76ZRo06RX1KmRPLKa++piM8C6MCRZ8DyjGlQK6aCfVZD74/klPIlNfc2BxVmMhVsE70Ach2Frrj0cEuCCzIF1WLgIaM0YZURVtDMyZtmJFBRFSrVgWV1TgkPpPkra9Vf1933Asd+V6C6lqXGgBcFZtgyXqC74kkg2ukWv/4UG/8zfd/GFtbW2YB0iTlGW6qi4eu25ppbSh3BT5jA5jEVWDSV42f6jrIE0qY//UTGqIcPmWa/Dqj1k/h16OFhVo5AN80jIRUIPFvGGNQM8VVkCXsNHg5GjF5OVrpq7OmWCMBNraVmkaMjmM9OR8a6sNcsBA1AOB66j/GOa5McO5EWSNazH7mcIDSFLZ9E7X4vtE3FQDi/aXj0cMK2IK5x4Fde6INkonGDu7R3pi0fPan4KgcWvlJaMRnOp4WWk6nYgssA6RTsdd/wevM3ImTaMaEoKDkP4WwelTnCjMpEKuLT7aqLam2rjXqZepx8DUgoYuPviE6HStA5ikHEqzT0UOQhWkWDYXN3LTOWxbcqQcYWM6FyWN5WSsBR4ri3s/9NQU86cD1Wzo2ZQK7wqime4rBef5zn469yiMGLG0nkKJkBzpI97LT2csCtVjzmKd1tA6HjSVS2RzsV9MWsE5xX/29LIM+Q3P3V3TRZp/FmO2/GrdHyd1jahgq+KtmQfWspzVZgac5S8vneDpu4qf68bKo6iqLw/WaYFrPf72kkNGDxmoAsz9N5QSsxhxy5CxMltqx5S+L1cBjiUGOq/PfHeOOt1ryrOP5UQObCDAWZn6C7wIOtUj5OC5uP8eA/8DICThPFiSeyNOxdch/Ofm7443nBaFW+m3v4WaDvheVaRyiKRUA8lt6PslQdisuSTFOknB58pukM/JSujngs3EicCSA+aVf+qWQje7aa6+dvcP5558fIwjyebrpppsSwMlN7d773vfmPyUab8HRZZddhn9Jb0jAILgRsOgfJHOdZAbe5y//8i/jd3/3d+Ob3/xmOrZp06akYfqDP/iD5KOkX1JO5HDBBRecsAwveMELEuOe99O/SQ3UFVdcMVuu432wPQQngqNJBN0JgmvTOUnoVggWBKR/mtPRB8ZPKoexrAzgMjzaDAulbHiDmIhBqw2I1ixzZTUApzybd/shfTiK8F4GCBbIZ+QBzNbmxYaO5B/GJRL0aFZXAbipra+NDijZ2xGeG9Ayrq/qjFaE4YnKYTQPiMiYyVUwdjYAklZiwlUC4CgFeIwTaLTA59patOJo6XKQpFZhDI3RCBooNWVTXFfGnDo23R+70XBNQh6xoRqyF8BRH2uGjHWeX8MzNYUGQ81tagfKPwVAmuAcQUkaT4IlW4iB5rMhOGpoaMWUbgWEDJAFMIb7SoZj7wispY4hQFqqJ/N5A0Cnva4lmgjS6yZhNRmwf5f8pjxnEm3JGJoWQQtW4qkN7a8CCM+6qX1J5o3kKUh7/K5H4mP/8c/T8d965+ujf0hQGPHkqo2x/aXnxCQkF9JpVwASV9c3R2UjGyxIkdNofhoBP+Wsy83UopmYRH3jw2iHCOCOFmw15nY1BIx1E62sBECP79EkIEpt4iTAxZhVTYCSGrRRoyym9bAhnj8Ju58+a+lfwtRpHqkhxtrkGCAGINWM+aBxyjRwTImyag1S2co5AKVJgNJUD/3bzZpew6ZlDcyIALVuzPKqL14fQ4DtPu5fmrSSrMbUrRKtetlofZSP6pOWP/1Z9suvp1YLLAOkU6u/n3G1lS5YoVD4oCDUgelE1VCBwHH8Mbqf0vSWdgcRujB1kBGshh11zTTcHU/C0YLWc3IfY0dKJ2EXNv+SNkUAweeF9/a7ZVQQTcEnWREFdXxLS4ACHl4wOLWySLiAphy5aCaZ94SCwDE552cs/p4AmaZ8CsYUop3Faoq26ZsJErj4VZpJwPI03htDlFEfltw8Kwk7XCS4c0fU+mSO0gruxIACEHl+0vBxntqlCUCapAvu5KdCeNOFDeSxpSQbmuTCmfdLMu/iuMdOpGXJrnwKr+levCB0JMmAPp8exKF7cCLaoAJ013IYimPb9V8zaT4mVXg/HmBNCBorMIuzH1JK9Wa3ntIIeFKRT1CYhb9LFDGBcFMHXXIrfmldmM0sHHsnyC79JJnBEOYrNTw3x+YvfT5thMlMDi4EajUINjUAs3HGmRdVJKCjFlXzzUw4Pt59rbltMoRpFDQkkFrUIVDzHCH8yeQ3xvMvgPI8y+OfpBASUeRaZg49pbSULv6Lv/iLOHLkSDJTyzNX0C4GR/nxpbxLvvCnf/qn8axnPStpjU4//fTwHibN4QRJxk0SMH384x9PWiNN4zznWgCafkm2yde+9rWT3k7yBs3wpPhWG/Wxj30s3fOEF9oodJVaF02epgAyqX0VVL0QsywFcedRfU40zxK4VvHeiFB/Wh1agDI2Yhg/BvYcYu6Vur+Ka3jU8IsbiyNqTPjSDP31CsZLC0L2EIDlSc3iBETkW0BYtpcb6upjZUNjMmerxXTNDYUNVashSmhKQKASTUcZZnIjg0divP8AZYT0wYcXE6yhgd1sbFG+KjQcPBOWvxJAUEADMzzMvfBpzVPSWkJ13Y/TZhVU5434qzgJCHqGuHaMc22LcdlTMRl02uPX1ChqwMYBkgaLlRabBgGgOS55RvirrqonnlEHZnmZubH3rAQEpvYFxOjX08CYasfUsom6GBBdlla1K62cV8NtHO9q19RGqsVP4RrQCpYL7gBk+hIZG2qSoKg8NmikoNV+Yn/89ZtuAlRNxts+8Z4YfuGz4h9phAnOGXsU2wPKLGRwHVoLGDyvtDMe3/bT2HLm6XG0Wk+uyegoNMUTDz8aFxDotlKtDevAJCyCabMCzdFX/+FrsZKAzhdvPQ/tFfO3wNH6Y91wuJTA7Jhky3N6Pv5nq2DARCWc/U5bObNJPHRgbBhTx0q0Zo2AaTxYec4bqUQz5u+jgM+DrDfGXtJErwT3vWnY7aYHWJcgcZgcrIsLN69Ac0Sf8PuDY3vj8DA077RJcH3pAGQco5QA+8PyNvzY8h1RyrScTr0WWAZIp16fP3Nq7CrApAnJaDKrqeuZjKrukVjBBuZgK5OiKv10zlKrDCMPC7LCoYt3OexJmqS5c2/coWOFRlnquCf21N5GgSz5KyDgzQqvHHehNQlU3Kk3PpPnVzKJa66VXZ1OYUIO7LK5K4KFMWImyD+rQgYEBVZqkOZyza470auaHbUC+qd4LxerVljzhllIUhyp416sD4aC+VzA1xyc+W5dmthFlWrXumXl5A4CPXZSk0aJ+9oumj1NIDhUUH59OSy/eSz08zmmKCnTLOf8N7GKnlf6nShF1dI/9rML9zCmjXo9qZ17Km2U5z3v3dsiLJT1stOpiRBR1yXkKBuk/fmtHrv5SjRJA0gk/fhwjbBTrF3//NLOyzF9sd6OCcfTyc7Nr/Z821hGQMdkymHmYkSt9Aw4FnNQkF+3lPcc3JmnbH7j7OL3orV6KknBzkDIk8mhPR/xWQ5qFfcNVkQzDFSVnGf9WwB5zYD2tYWWODQ9gBw0EWsRityt7ofp67GxA4yZbDNAQdnnIk8C87TjTj6OX80iV1U0RutYZWrTnqqJ2F0wlopjkQt5N2XmqY6evNWLMk1n/Mtf1AjlWqET5aYG6XhJ/6XiJEX461//+kQfLmDKkxolA8EKyFbkFM8zP3r+6173uuRXlJvu5dfl7wvLIPj6yU9+kvyXJIPItSf5+Yu+2zf4nOjrU4FWSM1EATDh2NbMrQo/k3JBM8+F7a62wmCibQj4zWjOuZTuAeSgkZDswRhIjnSP+fyqgVazIFXJGoBG8ygAgmexC6F9P3TQo+WqS/B/RGAuw7drHaZmLVXOB2jmYYrbULkS4JD7fAGQEYQFc44zn5V8lhjh2TnEvFo7jpA+goYJkBTT0AoU6pIGRhM855pSzMlKmFskQxnDBHASwb6Eyg0z9kfJ1DmpF5CnH5SgTlIIwb7PrsPOsTwuGJLKGsAxLWikTWRdU0ivhsK6tALyDebPlGiH5NeFf45mdfp2NTdgOohfVQVgYoT20Zytknu34QhkwNo0uhn3iTQDX6EMnBCjimC4tZyTiFJotkmeOcEsRYxBAsp+6Df+cwz19Mdr3//OOB9wlN0fjAuddkktpmfsOE6zFthoap31Ffrc334mXviSF8fma7ZGLeaAD9/9QHz5774QN73nDwhk2047YO2AKaVjoIQNsgcfeBBSiw1x8QXnA1AALGjGwcJsPqE14/cLp1rY6KiIjklMItEgqmwyMC3VjDIIcvp6jkRb82pIN+pgaNVEEIgLOOxgFmiOlYeUAABAAElEQVSEkGgArdUu25b+kQFvkn5lGEELSvN30H4TbAJh9vj1L305Lrjkkjh/04a4uwtm1wFA+CAzK8C9opkGaWLOz5aprB2WX0/JFph5Ck/Jui9X+he5BVgF1BoZlHQUp1TWu6jC/KESGlbZ5KawAyhmXzteVTOfDYBAyiE7y/k07WAjdSv4KdDXQ7vsDnkOVzzThYjlD7Mz98/dOWUyJiXhNb0zIbOaJMGWhc18Mmd7zmEBkyXJ3xaKyeZrMERJHMZg7NFcTyHYnBIYoLKjLFCpBGk15GOeLPyClOpTVD9/FkQI/NRKZCvIgouKvirQFifbrAVg1MyuvT4ell+BqDix7FMHwSC7hLSLvi3j1gMBAiOuxAxWo7kF5x03kaU7/ho5KsyYMq1Ulqd3VGsgnYKf1fPZLrbWFHWrBoz9TGmmKpJ8lHYhMPVgSa+QDTCalksYYUWJ3dOMJdUOS2ADLIA9LMJHmxB6FrRFXgbHhSQPDZRN8gpNQbMAwtZtfhvn1/juL46jGjQsauG8s/VUG4c4SnEyIczzjpeLoGoaIC8ZQ3HKyiRMz/pBS37PlaxC1r7j51iciyPRPkHEpa9t9+I2SL54Po8IVpPsCDue6jBr2rftiejq6YrLn3c1pmQ9sf12HMPZUT/3qotSEGTZ8dgwRgDMBEwJHyTycAzIeug4tFs07ZscKcQt37oVgRzTnBdfmdpYR3D7yLGjVtPGSTFZKJ/a2qTpZDym8qWaZn1qzRzRed1tU/PJ0+En9sXNX/iH/OvP5V2foGJwVHzTheAo/02AczxwlJ+z2PtSrjGY5qymdqZx9GfRr6UMYDSFCZRkDVJxN9A/+pTQdWyqlEcrmpFKjju3Chiq+LFjBL8jfHCmx6DaZxxNwmpWQ53XodXsQFJtBDyMD2PiSz8PFzBdA1isZIz2I7BPYN5VVYNJHeZojQAY+7iU3bHVVR2wlqlhAMSIxEj6ukgDLmX0tOZbAHqkbMyJx+Jh/P3OQSPRTLyiwnA3hDyDbJIBrnhmphDCneNq6tujvrkzSiGweWT8aOwBUDmD+zwO+2xZJ8CKpoZqNjQ9VFukhm8ETcrA4EBUc5qhDSY4V41Mlth4oV3K8TWc1GRwZsTZtEPDCO+jhWjCfG0SrUw7MX5qARcSSwwzp7pJsBpGvDpmQses7SwwGYV23bFdRyDWfkJXuCVVzZzrmjXBs+FWi897YWg8Pvq290fXzv1x3dtfFde+5RVZkWZek7YMLczYLubYHUcASWjS1o3EBWdsivMuvih+/OO74/xnXxSNEDR8/kd3Jp+3Bvyndvz0p3HXXXcnX6Err7gclsatGYEHIGSaft25e2fcdvudCbBedc3VcdppG+LW7/9zMtH87q7dsWrl6lizYXU89OBDtP90XI8J6Mq1Z8Vw19H48bdvB/z3xoWYrl522eVxCI3nvY8/Fs+67FmxGUD3g+//IJ77nOfGAw/dS5v3EVdqP0CxLF718hso7/3xtZu/TgDePfHmt/5GdFa2sAFKH7XTek30M23lmJnpgnltsfzl1GqBZYB0avX3M6a2CsHG4Mjj7rgoFGrZWe/DRIM1r3m4NIaY1NUsHC+54HVin97KVtjDmC7NJQATqv8RFgL9d1wgktYDwVahUT8nRa9syZWQIRMk8+/mo/BWwyJQi3Aw4c7jzI8WRwFRcLRQezR3/+yT98WVlsW1NPkmKdyabz1lLkVTMkIZLYdB92aFOQQB/5l8914NFey2sTBm4mL6KQk3Cup9+I64iC41ZeCoIdpYyM29OM+FeeS/CQrr2bkctR4s6BJSyHqWA5uF1819R/AQXAGAFyZrmGlTEArYZc2AQhYk1doImp8KOcT8/Okl/CjKjgxickHfejMHGP1YMgIi8nNRmqTNS9klra7HPKQUoYV7LzbsHEMy0jWgOUl9C7gbJPaG2hp9afL2Kso6fUzAWM0jwqX5JjCOcDQGQMpN0eaXyMs8MzsqoYljUQCvrkmhKD+jgrpkpm0AD2z/Fdoc3XWAWwGV4GupSSArgUgxMBXMFOifKhzhayoQbkcQSgE8bik8sv0RBJedcdFll8bt37st7iHOy6/+xq8xXmtjy8QaTJ7wEwEwlRDXxECjbBVT+QI71TwTCMgDg4NpN7wO+mYd3fv6+qOaYJBNAHeMrGJiSFoFniH8UQr8PowvSwFzSJumWkZHhPAnJrviIPTmAtek2bWbEXBtA199F0jZYnn/nHbpOXH6ljOX2izPyPOe2L0rajbnmpmZKipUksoBNlOiYZ8X2tNRWI8GoYnj1YxFhc+CIMXz+WvoZzQMF6KOcXIm88IIAH1ivDKBnRbm5mmAk4QHEjSUwG5mEOIyQFAVYHuK+WSKvnOrRs3UEEDnEKEdzqlay2YZQwZTy0rGi4UwmKn3dC42llHa0KJj9S/ajVnmEYDWXuapJrQ4GreNoakaK/RYxDRfaotWwHdzcnoo9jFvPl7oSsJ9ayU6f54XdDaMf9YNtGjJjI3Kq60aI/8SAtAJEqvqIcJmnqifbgIMMZtSZ8FbmXHw0FpNaqaI1idPxmkaB1h53vrKNpj88DWiDcfYrHPtE4SxFQQ4bI8q2nSKekzSJiNQj8vaVwngE1y72SCobKONjqANG0DL5Xg237/9rf8RT9yzLS54yVXxqve+PT0fqdOy7kzfK5qMHbQ/WrsH4sy1a+LOf94eu9tPi2ddc2V84I9ui/6jhC2gn5587Ml4ybteDInFcHz6M5/Db+4MTBOH4q8+9OF4//v+Kw2J6Rrl7zpyMD7y4Y/G1gu3Rl9/b3zyY5+Id//7d8fnP/ePsWHd2thyztnxmc9+NlrRmL7gRS+MW39wa2JBfN3rfyU++sEPxYrVHbF+3fr41Cf/NyaJ1dGDBuwrX/tKXLj1Qtbbkrj5SzfHxRCVfOvb342eoz0wOT4nbvnOd6Me07qOzjVRTTws/6adu9tYVwkGWMJ8N2knidpNtA1NlA3gdGD55VRrgWWAdKr1+DOgvs5ZA5iHKbwwhaXkMSc75zQntTo8UqWsnmLSWzxlMGKERWbDVD1R3omFgGmPe3dmMYGQ1I+ts4upu3+atlUoaAJOKlhcWZbT4uSCm+33KVBlyb14Gb1a+BOgGUHexSjt0bNAVCM8CI+WkrxO4c0d/tEyTeXc8cbMBL8f3zWTQy4l2RYAORZAI9urgVLDINOXu4YCm+KWsNz6PunArICuIJl+zxt0kcJp2NWM5khwZCvlAuMipx5zSEFJsFfJrrLlVOgvLs8xF/CjQvQYYOP4RaLNEV4V+TVt0cckP9fd7ayHj8n55AcQxsuODAG2adtk/1F0iRWZScmcjrEx3VwT480VUcA0rRIP4AlMPBYDFu70dhH/aBytoPTaAqYmbEhqEPr62L2WPnxhm9ovlfShZAPF7eVYOzGwzcpZzXWCo9TeHNJHKDNdQ3dJXZJWM/UFudN+M4MJgRBtJf3l82S5l5IU1pIzeqaMyi7hHsh4MUpgxq7HHkFwI0huycZYcVo9u8nlMY4wePsPb4u72Xl+7a/+SpyN70LP0aPxw+9+L+6/74FYgzD2whdcHwP9ffHN736XnfnJuOryK8izwO7zHUm4vQSAJftaFQJglRrF4cm4864748d33UPrlcU1z3kOzyG+CV2H41lXX52EqXu3PRynnXtmNG2oTzGnBOyOzJSYR7KUPdNqQAXcasfsn/aNq+On2x+Nm266Kf3NnHzKvElL/tWvfzV+8wt/uHid0zhyPDF3qjln/DaiMa3kWZIlbgJtwP6BHsyh0MjTLy1QbJ453cB4Q/BPFzEuPNdBDgiaZlNiEqdJWcwq0RBVoMUdh+1tXFIIxlqloAkQ0EN+vTO021NoUEYgZCipBuxgzidANgm4LZ5jOvPDmYoeNpi6ADdSue8GnikfryVP9ZajaoK4bprv42jGxgH54yNPEnyczQQm/gsbToszK4mdwzgfxpLg8ZFD8UDfY2ltSDfkZgXyqEeIrwWsSJawkpq2A4jSRoJrAcCooiqLaVUGKJuQZY/x6PzF1cmsbpr5rZ1guWtqW9Go9vIMMzZpEzcfarm2rboFljzaDP/Bvt4j7O8UEqFFHXU3WHora1dVZT3zJEF0AVcui/IS3PzfPh4//sfvx4YLz4w3feB3Z/Z+nFddr3wOKAPnlkJdPjHdHZs3bkpam0f2PRm7ew/E89ZfEitgVHycYLaqiJtammL1xjUxxX1fdMOLYmJwBFM5SCYIRDwswQRZ6ht02x334B81ChjaECtXr4kH7n8wjhw6nBgZX/KKl8XF510YP33kp9G5fnX80ktfhnaqIW697Yfx8LaHYmBoIP7tG98Va1esjVFM4378458QfHlDogZPRaZN3EBxjdNk7rqXvCBueP6L0/p86MA+/PZeGd/+7nfiqmufE5PNzL1Dh1KsPs9nSqb9GR9spoyzGWrfL6dTtwWWAdKp2/e/0DVXUHH6zpOfC1CUTrkbxyJcjYNnLU6XA+wYz9ciZWJzLVe3IjiuZ5GpZ2LfivlCH4tQN0CpWHR3sdRcAm+gKCFPWZTccdd0pEyhiu8Kk2kVoQyCNjUjjbDhZaQI7JBynyxl97asS554OdFzNber428KoDbOAjrEDqbOtxk4msmdRVpQ1sqf1+T3sa0Wu59UsHWs8uP8TVLvPIm3EjFUUQO7WDayqLeWSQ5wYs1Rns/s+8zN1fLYAv5Lh4rynz03/0Bd0oLFucVAOP/Zd0UXgXJezyy7rOYylmWtXXzFEj4rDaglIqaKu53HJG4yTZ9P45Q93YBWTu0GAht7x/QHO5FcU8OOLp6+CYhkvZDlYi/oi9WFWaOan3b8ZgQuwl+BbF4Ry+1xNUaJ6dBV+ykk2yGZdQLeMjNG2ztrF8GympLF2sYnSpCZnZmNORnz1KjkmqoTFcMRJDmHYFVQnyUAEv4YQ3v2xXqCya49f308sGNbjHeuS7vr991zfzz50yfj+pe+MM69eGscGeiOR35yf/zk7h/HK3/lxrjjh3fEnXfcjukcAT37BhP9tY74/3TLP8XGzZtjVWdnHNy/DxObQ2xgsDHAc3n/j++NB+99KC678irAUHfcd/990d7SGgePHI6WRx+NHkxz9u07EGqCFJQFiRlgt+am/D3rEs3xythIKKNeyewQAe9Pd3wp/uJlv5Wc+K+5+jmJ8Sy79pn7qq/TNujI/+Nv/3b81j/+WTTjbH9MSk3HS3pnLuU5prlgRyxAVY05F75Dxg7qHulDAM3mg0HO6UWb14EAv7ISAhJAUDtjtBRwNIpGxXlg2vnWjSrZ79jlNwLOmBoqTDfVxDhGBzC9G0HTpFnbEOAoKmCBk+iAByJty7Db5YaX1B36EJUBlqYAJAY9HWH+85kYY7H4KdYEu6Bydw9rAtKSBtjvmhH4nWsGE9DCdwl0sbZqBdYKzBHk1czcqF+dZm3bjamQDyEeCrVJaiENgFuG8L6K50A4XsYmVwXARtO6/HzrKKgUqUjGUEb9cO9KMa/08apFW1oJi9sEJr1uSJQ6R1S0UATnDzZ2Khuh0Z6KGqYw212zV4P4rgREVWCqOILmSIuJw6whf//pz8W3PvDZaFu3Kt76kfeAbwBYaM4rMFO1PJaYQ3x20gPIbumM27/zUDz0yLYYWom2HHO/ITaFLrn84rjnzp/gfzbM54uiDgKHg10H40uf/WJsOnNzolvXCsJA4CbZ9dzw6O3rjR9BiS9guggTvOaWZuoD+NUigj4vB+TUEr/Kza40BphfBwgCLK29fq5j/GtobMCnCX9J8nbe81w14TN3shmpw9xc5HHXcjdaJgBBA8aDYkSoZc/XfTc/sdTHBHNuTbTcy+nUa4F85Jx6NV+u8TOrBZj5phBUC3V4a/TK9IMWabwUliEXvrnUyCK1Cfv0TnbHWxWL0o8ZqLlguj5+WNJfjDnShcXCpMxDE+wmmxSGndwNVqnmpvg+CoqCKK8tvt7rssnbT4ukeT/KuuUi55Q9l8bIu3uMHVRNN/i3WFLMnZdV8Un8IGtS2f5+fFG1bUfASMtDdoVAU8KBgTo0VFW0H6uMzGkGFPV+J8i5+C7zPgsgDkobzmKreWEVbWNMnlo+K8wfmwC5ar40ywNYCQazJXCxM4uPZe2hBm3JZc0bikW5BHv80qNoj9jlXti0Ov5OE1xwqhXTolq8B9jRnqI+YwhT+lflPSH5RiVmXpov5uaXllDIpiBeA7BulEp2pt4avumLpEbIZbqO8dQ0YxapYAX5cAJfef7FtV3ss/WWHU5w5T3z6uXnHn/MzMPbqf4Qw1NwwAkmOifWWJl7FhPpyERf0jIKrhRs1BIQKgzzIQAGQpQ+HwpABYQ14/icfvbp8cQTO6P3SHcChY8BmA4d6oqH798WXewq12LyVIYAsxm2rHNw7nZTonX7Q/HkkzujHOf8Cy+9JFZ1dOCr8CBgvxC7d+/lb0/UQgE8jBmegTy3nL0laYUffXhbEmjXrOmM6vaG2D/RdUz75O1U/K6jey0bHZqLCpJKmhriHX///rjjs9+OT//O56KxVXJj+9jsM3CePyfHa2/z9xzbtfj59rjJ/vZaQUaeB81G4irmoeRsz0kZAUJ2QX6m18yl7JlVK+Bf+mXmJT/LcmR5c8+5E+ay4NOdX/9eXP/2G+M93/9wdJ61Yd5v+ZdJwLBzpP1lWcbQmOzH5Ey/H2nAC7C7yZLmLWynFJSVObSAdmYfDn0HmX/L2UDQV6kdGAGESTv5BQTgafJs4VlYhTlbGd8FNTIjSovtvephuZuCLGUMreT+iuE4A2AhoConr8JYfxRGuqkb5cK0eIqxV85m2oTaKABXCTtCpWys+c+yGdzYJMBqr2/AbBMmT+ZKom0xnjEZhMDn4voNmKv1x70DO+PC+k3RzPioIgit4MfyOPaN6aNvltfYz/oRNgNmKgRHtYAjymLD2+aCvAQE+O67ScA0iRbEdwGDm3FlaJLsR5M+UqWQGjgmTAKMGnyOqgFSk4WR6OnanwCCoESc46bYCggxHvnRvfGh3/0fsOU1xm9/6v1R2874JQvrnsAGBZoAPErJrmbIGFb1K5ti+vyL0A4NxZqz2ITjMd47fCQuuOLS+PqXvx7dR7vj9b/xRggupmL3k09gAjsUz8NvqLu/J35wyw+yZ4NX2f1OP/202L5jR7z8l18ezR2tcWjvAcpCcEHumylwU0lSf9gTQh7rvGnjafH14W/HvieehE6czZD7HwhjfrWwATIMmO5G+3ywrycGBzCPtj2Smj/ry9RKZitQ48f+vr44t2xrjFYR0mK0m/wdkxkwnGSNn2liLlhOp2oLLAOkU7Xnn4H1dgEYQWVeie9BimuR1gxnxPQhCZ8XTdXGRoTyGcOJWcFEEWIVglsLs/5BBHKpZrOUXVvcXC5+JifsMRd9Ioa7YOpvlJ3NDh+L3YTBDlnij82hOLeiz5zort0kgGgMwXgYW3GB1jhCxqxgk+5rjVzIs3IU5bC0j142gOkadNXm4VfWOlKWHz6qUT/CrugAO31ggXHatIkdSPYz033TqU/xJWkWqItpBFMUYz0qvjcDutoT8Fo8Q4FOOX0yAlCSvnkpSRND3J2XXlZXQoSB0h5McvCHKHHnMEPOs7eztafriN2xEpCInwuoFUFQ8z6EfjV5M8kWtMyCg3KElSP4LGjKU43pV63aG0yNLJugMIlj/CZdtYyF9oTXtbMLrPmjYrPaizoEmqEy7pQAsTfK+mnmlse8KUwMA2gCQVLtyFLHiTup+bMylyk+SpTVcmiec+I7Z1cNzvhHtMDGVY2T/CSCXfuGFfH4rQ/EI11dce7lUADXYfoEC9W1z39uvO6Nb4i/++Sn4yt//8V4zY2vThTNLc2NsXb92li3cX1swtdgB4FW+w8d4LnCxwmB9dnXXIUfw5G4+44fx5M7Hgtj+CRgwiQggGpG2FqzdnU0ssPciB/DmadtjrvuuDO++rWvRwvfz7uEmEAwoA0hsGeskkt5SjPCFvO3jRsxD9r4O/8m4ncli8H0Co2IfWPfOnxsTdtNLZ7zyWJ3MJ9Rngf7f7HfzU/SjEoEPWO1OCb0LRnF18aguNJml8DKJZuX53qfGuY3zdnypLCtKbF/x0sK516voO6GyGLp1+P3OePYEZKfK2ubfj4TaF+rIDGwbEkDT3kVsAv40uh/Zh6SPEhjXUEcHmm6U4NRTtvAwKp97O53EzRUsoZJtB1qe2Rw2w2xyaO0aTMTSC/9VwYAyTQMtA12Y26oNLCZI4lHN75CK0sxPeOOZWj0JbuZHJkDxJbDTawLyxsx86uMbZNoNWgjfe/8Td+gRnx+mjGv05fIDbF6tFvjfN5Q1ZaIatQC3zXwOKEgRtgEyMhOajiHcD6pTtWMc+MmuZmlmazz+wB1WonfUjlzgTW27Q0crPZJMG8aJYaSwWoTQPK5p09sX0GWIKiqhqCsRf2UAyqv9ZopxsvICGOGOHaVMO2VlrnVloHH7Y88Gm98879L+Xz8Y/8zpiBH2A+TpCPXimdri6CTaY55rryCXuG5ovhR1cbLWCtzmmMJym3CQJzZ1hkXXnIhmx0j0biqPXaOHY7N55wZa3h+/+Yv/yr5gBmY1vKvXIWBIRqgK4jxtePRx+Kj+CFpdr1+08ZY/+q1sXrtqtTmrseSjzQzD1jNmmZMuzvaCFq8Pl70wuvjm1/8SnyL43VQnV/17MuTr1VHx8r40Ic+SqcSC6q5hflFf6OV0dZoHtDE89yPsaaWA1DPOfOsuPXbt8RZZ5wRNZ0ZiYhasmnaTfPE7FFZ/Imk4svpFGkBhtJyWm6BZ0YLuDE0DtXnRAMxXfoQHlh4y6T8dG0gKeJ3MMsLjo6Z+licS5nAMZqIgzj2SiTgYpZ2abPLF311EeFSbNWJhwFAysQSp3cFXwWqdMai16aDXOtyrBZCG/Zh7MUVmDRpSj41FpQ8FuayuNCriHtMzebf25/ZwRUMpETGi13hMQmeWmBom5IZkJ3/qQ6JGZ56SkIgwpx5Znu9WR4e72W3uBJhqZnYTIv0SjpRQaCGwIyTxLjQt+dEZbDfFEjTSp/d5uSvAKKygwgIAMakelwAjrzhdDVCxwp2TRFaNLk0cK6mIPqn5MlyqWEwOKQQqAzK7ErMVayzZnTuK9sG1jOvq9+HINyQAr0aMNOK5ijbN1dgzcaGedYBNIaLQJJtosDmbv1ife6xIcaRfhXGGyoWplLGi7xYJrU9i7WvYHYpKbs2o9/uKQzQr5gPAveaO9gtv/oqBNWIVRsbQMmMerKUta4DoehFr3hJfBGTn3t+8mO0PWfHju07kr+I9RuErEEGKv+MFLZv1974wT9/LzZs2BhbzjozHmIXeagfPzoyVGOg2d2BQ4fwuWAegPp5CP+HwhhBQdevR1NA/RDcWzAr2p/IMQCm7A7YNwKbpaSkOfbE9Gz7QU0imyJoHdT4yRKWtuvtZY4bvNbxsFjyvvroSOef+XotbH2oohlrE96L/5MIy4n634cTMDDNDr++kV5l/wmMisGR95RUZlzhj88Lc/d3k0L3yZLX5jORec1LzJ0+F5NsNCSNDn0xey+fJ76rAdHkS9+zSjYZJHNIwj4gRXOxDBro+8I/6lWGhtZgsGqJ0mDhhmpCDHi6C72yQEbfMctkecbS88gnwFMVc0BWAkshQGBjoq6DeRYgVcAki3P5mO5fQx+dQYDYMmji72VTC7oBuxRa7KpYgd+Qc3iBMm6phVUNMgTXhTrua5gDNXXncNwNLbXIFQjYDWxopHpByFDHmtAzhDkhNysAoDSxfRwil07auwItvuDIQK5Scgt88+d0wDE/0ycek2jBBhVkMFhTcmzJyidoqiBvzzfYq8eMuyXI0kyvqhZ/P7XcMO7t27sv3vjr70hmaX/9wT+J515xWdyLT9NhtVr4GeknNDHGmGS+S1ongG1+Q8tRSnD0ib30yzDa7kaIkNgM2TV6JF72xhu5R2l0lQ3FtsG9cXbt2njzv397HD10FO1qUxq3VQCVl7z6pcRpog+Y817966+NQ4chuqANJF0wIO5r3/x/YXpcG6Mjg3HDy16S2uPQWE+sO3dzrDtzI2NmIl55w/Ww1V2Mud1grAAUTfP7BBsdb33X2+IAmyZtAKFy5t1KQNmrX/0K/IsYXzASXsqmSGH6/DhCcN9rb3xJXHjNFdGwoi32ElKgH22bc5xjaYS8igFn1trLr6diCywDpFOx158BdXYqO1YwdHFksWyvgXygPA4QhHCKnXSXSM+dM2pa0AAsOgUmaXc5V7Mo7sSuWrvlIWzal5ZYqLj1OGYbNWgKFFSSdgmNhwJ78i/h2DGJQ547iCnW4TEcb9m58iyqkCbqtMBb+CUm107rgERqxosnjidNyShCnDc6SWLNy7RxQ1Im6Ll1ckFqsSyNMD+MbT4iFD9nIo15ueeaM6edqDQKIkal0ldKIdQ8spRabOYzAjfC5lPSdCFkoAZEYKc9ZgSS2cxmPkyxSz2JWd0U9Fnj05jNMVYyn4K5UuTXuMj6l5fKGD2mNCYW6ZREgY5WRJBcgcBlcGLPXZjUDAidxmlHlQXW0dNGIHwwqHDeGsXXmU+iwEdg1Mwogxe0fTp5/hUKBAp+iwkG9lY2Jotzn//Z3AQBmgAZcysbgNbKP55VsOc45AnNHWhU3Y1nR3/j5tOivqUeRq2RaN3UGa949Stj5xO74opnPwvTnOfF975zCzvKq2Pdtc+LdRvWRW1zbUziU7iyZU2c07c1fvzDu2AaG4vLEPK2Xro1KrfB9Iep1rnnnp9G2W0/ui2V44ornxVVxI6pQ4A9+/xzowNzvJKmiugbhQXPNuK4IEmn+QwkzW+b+TXNvmU9lPcTmgsBAPXUlMr65smAuOaZn5kfz989LgCuou9l6pOh0I2elOaySfOJYy6ZYdlPtjXXON5rAUqanDku7Schc35P+1OAlICv+RblOXOXE77lp9uvkr5454VU8c45akn0X+HnJJzqz5JagsGqX5j3nUYAl+ZdDYcaL//V8JtzwBAaOLd3ilPSCFYxdiYQ/MlfU7VqgILtNVmOwI/pnmPW5OhVo2t91dbYl21od9TaCBgEDxVoXcoxT5tACzWJyd3UGL6ACMbTtKuMcE1o6Fqh+O6vZDyg2WpNxAqQr1gs/HY6y5uiCfAjUYT52Rberw1NqRtaE2h//F7LBkk9Jm6a5o32DsQD37wtvvvhf4hLfum5tI3rw1R8i8C1q9BclQIWJHEQ2PikzO7N5GOAW+cAyXuW0q62i/dJlOVcK3gSdGp2WcC80OP+7nW+226ljI8p6vrRj/9tAiXXPveq2L//YHzgf30s+gCFR0plRSVMAlogNxbdaChlg2HDRWfGaZdssfvIi3mHuER0BzGReGGfwx92jByIg+V9jsjohyhjFG3oA0O7AZf1UdFeEXsnDgB+GR/9e3kGS2PDeFViJexrKo+1Havw+CKm1djuZErpaKjqn4zagVGCYddFL5uVDwwcxRyxNs7GX6sdvyWDwNZT56oGNKndT6C5GgR0Amzb6mPd+rYYRuNosOuWwZ7YzNgaH4ZgBeBXgSZwiAb+5649jMHKaCGW1G7Y9rrG+lL/u/ngA2w9s3GfvVLL5XSKtsAyQDpFO/4XudpOW/UsQomwmMXNxd9JzTXF3ybZeRxjIhxF8J3Gl8aF2Ml7P1c8yOR6wZQ0y9n5SB7JZMKYN+46tbGYtOMfchSJznVxqVOk9x9lV0ykpNDrguvO3gDl7KhuTv40ZDcvKZz1TsDuxQSd7x4u9X7zMpr5kkQx6nei5E7ttAQETyEpCCCJJaHrKVw2e6rgppnV1EX3KFoFgwzWsEAZH6UaQKCAdLJk32q6pv+O/jp+N2XBb1mwqZcmbfVoK2zXJSdPhZ42DaBFLnL3eqodcNSMDwJasCRMz5y3sK/MKtMgMJYEMKTUdunT4i8SSCtwOj6N8eO/4yUBTq2SPOeYr/+yb8e7Ihvjo5rDsPh7bjJZLAZLKS937xWw50wFi3O0Xva+ZTtefaTDb9ekjv4cYbdac8jUD9SpFOGLLuNqQAQuF4KAUTYh1l94Bg7jmM8hYA1CW37m+Ruj8/zTgqchtlx3aZx37eVoTjBjVOvAc7qhZGXsH+9BW8uO8mVnxpbLt4oGYDwjsC1tuOnyc5JQeGBqMDZfdV6ce/VFqV/ruOloH2xX99yd/GDWn74RoUz6ePzNKJXlHKa8BTSU+r3pQ2ZZl5YysV6GO4H+XNIlHydz/Lc0sztZ0hRSAhYDHefjd3YskK8BTqeYoxR4FRAnp9kuACA1E/OlRQ0L6SgbOv1s0ozR5gLqDNDQPgrfCM+ip1nw5QV8P1myDAKcKurg5sYo5ZhXS0zmnLuSTxTPoEJ5mdoMyAVsDrUQ3sZrUv9DbuIPtrCmgNXkbds5hy+WvL9+Sv5pOpvHT+oXoDAmpjFxnq6gDFzsppT3EURKmDIM8E4aETQ0Un1XQ7SgdqsSc+Fp/iahn57u2wtYGkyCsaVcg3/qYdoZJIVZMQQBaH6OIkTXQOJT4kYJ9cfoOZVHoGeyjAmI0XdWY0VdK8GW0dzh//aaM14WN/7Ka+L0jvXx3JXnJ7O5dNH/oZff+79//5g7S7Vx2oKj1q0PIoUvvP/T8eAFG+OXb3pb6sRSxpt7PtNsdrEdkOpuQPAuqPJt+7RKsKsmUcJ+zO+kLbdN/G3aDQBiFT5Gv2l+eWbVKpgHu4klBeEQPSiBxRBar2GY6UC7kBuxIYYma7qmIloYuCshVCoj32k1PKVsfHJOJc/sAaxGdjLnNHL+GCbN3c7TmNmfhem2wXXHuKfPjRuYu5ABhnnuxwHJPQSuroD2O4U54Hkpd3OzjDHkwF1Oyy1AC5xcMllupuUW+P9hCyTabco17c4Y06+TtKZzCsoN7FRPYS41hgbJxStPnrcDu/YmJvBNmGx5boEF3h3tSpy9y9lhcoFvYxLeN8Uk/ZQSEzCLtQw52TKdLZwDaLAKU13RXtWUWODy8ihsdI/3JbIFy+V9/yXJfKsRlOoxCTnp/P5U76WAo2BjEX/WtYNriTzB7qsxUiYTKMo1LXl7naz+npcY2FjEFL8VPOsREjWDPDqFiRxlW2pes/dysQZIl/CeUHOqI8Idgp3mS9EAwxQ03gp0Ol9juMmdFxfmzNN9YIU9y3aypnIhTmOXV28r2DtZE2d55jm7b551idcdL+W/Weo5sJQJvt4zaTsRKtI4XDQTy+mviyfbppFAyg2wc/m5qoQgwpg/yTLWiz2Ucbp00DfOSIUaAQSb/cSXuX8SQymEFe8vUDyKcKMmRgBVirCkMOx91YB4c4E2OdG+07EPwUqwp2+BAMD7NsAkZrvndO8K9sKcTvxFxvYeTsEkzz737Og4fU08Ujg0+5zk7eOmhs+lYCVR5S9hebRNBJb6IOWBoj1m2eoYm0sBR/8fe28aXGmW1nceLXfV1Z5rZdaSVV3VVdV7u4EBN7iCAcKGMTAM+AtegoEJzwATXvCAIQYDDtvwweElHHgCJtrRXpiwmRhjbBxtbGy2btzGdNPuvbqrK7P2XKXUcvcraX6/5+iVrpSSUrlUQ5V0MnXve9/lLM857znP/zybVLWe4R2T3f+2kmvGn0yqY1r7F8e4Upx1mcC1OvaOSDuIODqJRKFOO33njWmV3wBnA9UcBQo5UKmG8dLfkqSjEh6wAu900XqOh5LPC7B0pqIUvAfo6FAPx3c8QVbOmxF0VfBFBSIr5iAN+7PjBJuhRBW1Z+riu6k9ns5DjIdUADjjxFmz/VIVOigRUnKa78vt8zg8xPGt6q25KIkR1Kyi8vybVz6T3l46m86NzaQGdVTSItAqGOBxPOZVpnEVvfQKgWF1770ehv+nsTvaqCL9oO5LSPX71A/ZCsC9xTjPgWdVXzOVkbLokMK+ij6i387hfKGFl74/9Y3/c/qpn/qp9Nf+2l+Le9+IHz/8f/xw0Ozsk4+k933n1wM4GAGumdh/DfqbawIN09ueY6uzhgMMpG21Ugf6eUpbSuArNNSlv+ucLsPPT88hoWO+4PcM/XIV5x4t1DM7OG0ZUYoDHfv1HHhYr6FPIr07gcqy4GydfhnhHbG/FrBr+zjraMKj6GkCBYd9IF7+3rVeRdURdTkcwyiZjTFIfa4g3aJBMZfnGvPpwWayfsNrcYzp4uLx95GjwDFAOnJd/uZocLGgulQ6+Y3DOFSc3Fi06+gmL6PusY4XtuHkPKgixydH2mme3agatjhO3EZ+H49dT3TTWGjn2R1zd3Jo3hzO5rbH1qlI8iAaB19uL6YuqhsyXkqYmizguqX1zu37/WWdi28OD5mc1Kdx752dQuxs9yGzOOA2mFrUy2LhkBO7yyQD4862PRbMTLT1zjPT+x2wJZJMiTFI9PyWWbA7y8+FeA2PdCMtZCiou2DQga4VTH0dVTecMqDcH90hoyrTW8XYWVsxkyPEnhpOd0odbTJk2GQUlDqZo7S5XbIbBBLaLu2uw0HPFvdKqw7PmovJ88W1OLH1YW1U05I13vudUOWpAeNoz+6u+wiSohnouoSUTpfMGtFb9gobFauKlSJPZQuCn231ScGcbTMVNFmD4bGO3us75J/JXWslP14tJBE+X8SiWkBq+eBj59L/9OR3AxDxcte5gaRl0wYvctj+sP4RU4t5xDElWNq7NwSNt4Ijc/Kd17GCdLmTFMwZpcH3MQ9JC9rO+BRsaI/TG+BooF9DvWgdcKQXtnV2w5VYs/kQ71Wmj2p9AhsltS0Y2ghaSh5hU0LmAq5RBpASkWFm0LpKX0FqBM4VRHFG+xrHikA2jxHyoFDV3gqwIZFC9QuGuL+OChr3jgPI6oAHUd4690vHCkAi28TlmS5sj5gfTTQ1aOqx5Xh/kWhSnLSF+TB/h92TqlGU5XDQBkrC9XHysAoo/+jIUnr39IX0VO2hHfmZr3UvAZLWGw+k9ZtIQNgU67ARVJ3i3UebYAmmvVAnlMm/1LsejhnqA9xlo7Klq2hpWkUKoUMFHS3ocKKK84nf/uWPpPe9571vaHAkjQR+L730UvpjX/9MenjiZHTKOkHYR8uMBaVJUpX/1UdOpKm3nub+tXRl6Wxq1JbTTH2JccsWB+E2HNQlgmkbEHe+VktnkOCZ7IMZtCwWAKDLzWUkgvQjfTmBemJjsh6bH254OPc6HixxjD7rQvtOr5N+H1XJGzx7nvzKao4wJh+nf+aiSEAZkuEuYLbO5ucCL+Yi6ndRYT55QQFU+7yjxeArCvX+43TkKHAMkI5cl785GxzzGROpi/QKO1R9ddz3mPuqeER7EMbHvW43iN3RrLCjNIK6F7M1jAC7UojrDSxZzJH3SjGXcne7VKUbXvrzEl/kLmzAWw+VlilbQcVvb4Wn4v7tb/MxjoPSo63Jf/vyjiMXJP7fWeKBsQ67/LEL7RJ1bymzSveaR35ett0GHUZNb68Sg2lEQjTAfbc7zxu4/WUVD8YnBoDE2qSXIEkpUpcxpkH4BpKw3eb3MqcymIdJZqubcG13ZPAFz5tFHeJxVX2UpshN3106TE9aH8ehjOJ+96v6Jys9nHxOBnkeBnLQgmEFC9WnAELQx2CZKxh3S9jhdyDnP1zK9vHwfZZT/LYcpTQ6QrAGBf22n0xIAVrhsKKE23+lKgIvqeY9xf0c7kiFVGvv6/uDo61MogLDtdi6sueB5UhjPaTF+8G4E25qZL+B2tdqB7fNg0qarXXSLODImrcFRzxj2AGBiPDa+U/aKLGRiTTpHIFToaKnmp5JNbQRdvrBQDuSDKN2QQW4UzqnbYrSNV8FN5QEXNJnx0RC/n1m1eXOmdReadD3a+ns1E0AAwFYARfWyjlKVT2GfCTb2QXcdFWVUk1QFES9veyYUoIzEvMhjg9G8XqIFEk1WoteGllNqzjAd/hrd2MQWaXAlmP+uueuoSLnvPuFtevY++DNjHt2J9vRA7yVavN4kGunz5WbqFrirRLme4xr0qF46hU84I2jnfDw6BzztE4gqAt1b6PC1QNMSdMx1Pi0C7v87MvpHU+/Y3dxb8jf58+fD4cV/+O7//uIQRQdZEscD6TW6kr6td/5rbQCoaaIlVSvtNP15dMAmFo6MXWdPSY2IwCeSqv15jmN/aHjqsWEqn1XG8dEOlnRRfw4oH2KOGfGOhKY2z+uxK/ikfBhJNMG0wiJKrPmEpuci8zBqutNYy8GtkoNXo1TjOuQ8yON9UUXnK+wpj9HoPU2Th4c91SFaR5x1OZYzC3Jn9mFPqXSn5tNHL58fHyEKHAMkI5QZx+FpmJnmwZzVaKosyyjc7w1i3MkA/wUove3o0/ODzx8qf5BgrlyojSg5ZV2Mz1bxpMPjB3Ln1fvWyqYur1mZV/Eh3BD8E6MgGURPkp9XmNSl+k5TKqon8+icWCNudiBWSmxy+dCc+C9Q4VGDfB65w7vxgmsdHdzVUP3vhEPYxcdo2xTUEXCwGztSPyUodPjkozc8jr04FyDxV5mrrhbNtW/4vfuPIIH3DzpeJCxrY3jkpbe8/ehwCOZq1AUTCt5HW6E7KjJIX8onUC1atMuZq9yinO2azj5M79B1jOrzI0DPpuonF5fWwnpzvb7MPzknR+bj4zxQUkJmHYpuV75/v0kot4ja+TOtSq8u+tp3yqdGlar2112lgbtPrv3b1lA7XA0bpehN43CzMv4DZDGLLdwLgBHd7bRZCcc+y7uEUhZR+tifZtIYQQQFYKBWrb56GBFN9Zuiuhiu4uxugy9EinjRzn3uUFkCyMTfju+m5zTIbVSLMsZAKq8i9MkPixwR4JWjN+V7sm00p6N/GYmlgLI6TxihIo0BDDUy7rI9OrhU/W/Do4NBM16EK2gaqXKXhWJwhQG+hEkmXJkd1WXDHVF8upJJ9/Doj7kVUdyVapnt+LObeaZ+9fpCtDH5pFqm0EX7g+HB9Ch3WqlFn8j2J1ewyX3NWK1GSJiHDo2yNN8VJ1cQQqxBBC40b+eXqjMoLY5m87ghKCB1wI9bEquaAd5qgr5wMxpGHmlFW+OJC0vPP5YmjZW0R5JoP4rn/lImnzyNG76V9JSa5pxS9Qq3KefnLoKnYhLRD+oJrmIBN7xJPDUbm9pFeXFdiu8Vj40PZ/m6pPpKp4GBVEmh9tVnlkd76VpvA2GF1FUH2vUqQHIGVTWwpthG4nho1zXBblhNlo6Z8BeSUnR8wCpi4l1HRTlhkEJoKar+VsS9Yl3kEuqTh6no02B4xFwtPv/zdl6Fs5unYUNMyLW563kzqITtGyobIgTZEyRLoIs1F1cWZ9B1e69nP09GGDCSMS9WxnclwNLDJYkPl0o9J11gSCD78GVs2wyKtSoyHDfUN0PKjqYl8h1n7vIx1KVOHSJwdE7gQoJEeJri5u2N0GEfZ7dPG1VNlaRrKl6hgrKJrd08ENvpKssjAenvHCGAThOAbIXO5m1wdZuu2QUUBjXSJBkkol1lHktq5DhTAIJocCXYadVFlcOCYzMkGRNtZVRenSIrotnDv7IbbeuRbLGqrCFQTPt2a+ceCJesu1nizzimxdtgPRRRmijMsAAfhkHDlpy7Zfj9tPesU+u2zcd8mh3aaqQ2Ttt5B77SeGCmaYG1nW4Hg4VlMyCcd6r+KK/97o2fM46aWMlOFJt07FjH+jhbQwmbm2tlFZgNKuAozNTK0i6sdNAfUypi/OXz+c/VExhFBvYgEkx87BN4zCFgpC2LqRbWR5d5v0dx2GB3tDMxE0j7TYy3OJxnhXERI/zHbv15FUkmX8LVTWuSBuAidXebPzpP29+Yjmdn1mivr4nUUzcr4MD6x42ZewuKMwC+qUnRqZxrgKjS74rgOg+7bUc57UihSRLGtk66YSdqEkJsGpgk3iWE8atoLY5EBChKWCQUAGu0qdJvYNEe2hZSKaYZ1GJExypTq0N643OcuTvm6vXR6Vxuu5exkvaCrYx3jeGpOsGsqsFPI8+jze2KeIZPV4/m95aeyBi4Qkk/JOOb6bkmDCt4HhC1Uonr0liEBXtNTit66uzXb3SSjONhbTUnAMAT6Qri2fT2ImXkS+iVstYL5JU6mL/2cVjXQUVuEdmTqZT5LnExuZNVBhBxNyRwa6bEa8hCZ5gQImNBb2W7bs5jS1TH9W5Eu71SqzjPcRS2qKVHBu4+n6OXr3EujeOnaTrq0mwZgqg7WaYefEe+D0MjPh5nI4wBY4B0hHu/Ddy0108ZUT2TlxxtnYxH17IWVwvjvbSY5v79cUSZi4D1H5M4yy2D7FoO9v/LmL9LgvsfqXEA3f4QY1YsJX2ZAbA3fXT7FS+E69UWLzEsmp57mDeSdKTVKTNRkkfD/2UcZCh0yYhDNhZeFZOYMzOGtFYgHFyvYu79yiRyuCZNS3Be63MEheJSPWadhW02+OJN+Up21swi4W3N2kbhv1I71ST8x6Bi7Y1FfrYJIDSkUCHBVuX2/bFFIzsPPZijt9MxzulZmaCo4D79KHqWZv6yQc5RmUUNMmXab/d+LeNTZiaMruyu5O8x6ALs8Iu7gbqLTK6B4EjaaI3P2W7BQjcneetv/NYv/X8/mdkrsJuCXWbtq5Vhhi34ilzDb7wdgQoHuC76Mk8/wxd2ONQOKTTDAMnOy7czQngQt38N2D3farSx2ajhYYS4wfm0HdYaFBUSVpWnU9Q+Spcz1uU51XV1dMXxkapNjkD/XnnUX2zTwUZa+RlCILsSS6PRUeygCkgPH2GVQ7hDnDEzP18wJnmsjf55fjR6k+hWneC+lJOqZseml5KE/S1Hu/0FOhuvuQVtAWwsqn8k74nxxrpYf6mATACl1Uadokoq6tQxGQ7pWkPGl1exVKFeVppml4SfT5iKqFeNQGDrYriEtN4l2vrgiTfS0CSEqvX2nhUo+06daliCyNj3Ab0qJ6n5OcKtixXcA29RlBVmWjHoABqcWU5vh0I2hrNTk6HnZEVsw20KF1eX0qPlM9gS3Nnc7bt+63f+q1UAbB+1Vd9lT8jvfDCC+mXf/mX01cQTPWrv/qri9Px/Zu/+Zvps5/9bPqWb/mW9BBxvYp08+bN9G/+zb+JvP7kn/yTqYadj+DvF3/xF4tbtr7/6B/9o+nxxx8njtBK+qVf+iWCKU+lb/7mbz7Qw57vi4Fs/+W/+ldpGZA0MzmZ/tR3fleanWVRIBWA2b6yx05OXkUtD09xK/Op2Z1MC8vzqTR9mfGG7Htz8PaxF+utNqmz4OhEOlGfiM2TFYIgu6GiiqMqlmQX78drOMl4kI1E41IV48d5YkK362R6Qds35iHBkWmN+55nHD5L/LhR1tO8vuYaxg189HEV38fTXqXO+NNJkzuox+mYApsUiLXwmBrHFHijUcCd34OmMnf/tC0ang6dVIl8gcezbXsKr6tT7yI+jrOGmLxhVM6xkM6i6uECeD+TdX4STz/fsNFIf2xjMn0j7q/fi9txvJFvlUTxaSKCbxy2ZI3T3aUHBEEX9a3jDynYMjudxlkyaKhqRts0g/mZRY/7gWpaUyDEFZ0d2P74o2h4C1QVUfU7ARNwEjUTmJ8buMQ1SOofpiS9/JMR2k8acD/qK+0Eou6CZ9YtM306WnBsFckxI2Pon0xry11ogpL6WwZ3CfeyS/RNkUfx3J7fjgv+/ChKCMadMjx9XxIZCYaUfOlu1336Lju2hwFHli/dl7EpclwM08Fr8tVod2GbQd/A5Hvvfsn2ydTPwDC76y/jf7vkMzkQqsCBwoIqQbBNCu1fnvQ3SGtdV/OCiV2F2RZeiX3T7rYWN8Z5B+S+SYALgw6NMzjKINTnQvXL9xCIU4O5m8fmqIwzhi7gSEcJMo5WyXulVQM61ZirBETDJQYFuFcAMYFNR8O/UjU8aU7Q3jGA4ThSFu3eVM/VyYY0n+A7e4xTsU0fJahFaR9E/sbX6bewKdIRQkyUSLP6E6jWnUBSxRw23k1nJm8C6gDBgiyl4NaMYwO/lphfSzDDJT2GVjkGqMxX60gPmGdhTFUbrdGF89TLFun22Y2kPmpSLy9fTYudFYJ4ourWQkUTplam3Tm7vGl/NkFbDZIrbVSBXDHoNuN6iXfvt658Kn3o2sfSZ/uvpZvMh4Io4wPVia9Dcen59rWQ4vlWWd8eTh5utoRpKA/iqW5qqpFOEoC0pvSNcnUG0ELNq8Of7qIvA8ByoF+afMj0e7/3e+lbv/Vb08c+9rGtJ/7+3//76Ru/8RvDCcSP/MiPpL/1t/7W1rWv+7qvSz/zMz+TFhcX0zd8wzekT3ziE3HtS1/6UnrqqafSF77whWSejz76aLpGwFSdRvzGb/zG1t+v/uqvpu/5nu9JFy9eTEtLS+mJJ55IPus973znO7M0Zau0Ww9WcX508flL6eu/7pn0LX/im1MDaU8hWdq+W+pDRfqxMb6czsy8nGYmFtNqexp6zvD+5xcq1lzAifR8bP4U4KiBtBpa6k2TZ30bBzh2ifhQrNeOwOuoVj7PGtTVYRBg/+VuK60gVa0zrh8dmUIaSd9wY/HKPo+a/bNj9nOOhaVDn+Hk7wE0ijawGbBGX1qvHS/S8APHx0eOAne+5XHkSHTc4D9sFHCa6zGZVVy8Y+rcu4ZV1E7aI8QVGWLKZO1XgpEr5DUycSiGqNbCwlgkWRgZr2KyLc7f6zfTL8ynOu7uktuSXObw1G2ZGrgPn7tduUqIVrHvsK0FqLtd3b3eqbEwnEU/f4XdZBh/XaJarn9KmBYnYczK2pCw8FBnwgASu6lMrKjsheh29Xq9r9te1YNsvwyktZ8A2N7WHusOKyajrGvkPnpBAxjbUNMhD024dTm/f2/hLpl7dOG8xuIvzQUey+zKT8Ac3M7roPniKJ5FHAAf/3R9fX+BoGXo4No+v92Y2YtsPq9LkRVA+BzM9lYiwz6eInXuMYbKq6pk3isLtTvJ1gZYQZpqPbylxK7vGKoxtwO9MrG6C1dltnAuYB4yPjLRvmeWuVe51sQYNuKZDi9nUUercLcp9w/lowYmzIj2DGXmmI2YWtrS7EMPrdiqSDNUE9IuSOZ7GLBqj6Mb8ewQ5FZ6WpxtL3bEC0ZWGpTY+RCCjMFoZlfiGVzJu9o/prjfQ6XLTlowjtovaadp54wHoME+qn8C0DLJ70E604AhnmyGAwPrq1G+cWp0JmHOpq2a8tOeUd3Uem4nHHusA9yojBsPJeajZ7H/kdk3heSLMWVdRgVH7PoLFE22zXFUHMsAtwBUIXFC+tFEMrG+cjFd6lxLD2BD9DDu3ys4wHixuZguE1tL+uoJNavR8s5ik9QArBuvKYLdOrdyT5O1p3ArbllKli+OXcUzG4FMiQV2GLvRv/f3/l7623/7b6cLFy5EfYuPf/AP/kH65//8n6f3ve996fu///vTmTNn0vd+7/emV155Jb388svp+eefj1t97i/9pb+Ufv3Xfz397M/+bNz74z/+43FteXk5feADH0h/9a/+1fTBD36wyDoJuL77u787fdM3fVP6+Z//+fS1X/u14YbcGyzvP/7H/xjgbOuBXQd20xqg89/+23+bHn3s0fTtgLtJJElF0qrN1rd43wWYjqExJEZzjSus13iqa0JvQPRkbYW70Ebg2Slsw3TecZO1a5H+6fLXQpXb4Llu+IV3WfrZcd5lHfpk/1q6xLifam6kl8tLaWZ6KtXLgPMB8w4bCWPMH24TRkBtnDU9xWbAZQJCv8q8PUpMJVOo1TH+dAqxzvgqY386yhze6zYD1IeqXYyjPGbjoeOPI0mBY4B0JLv9jd9omeIOE2iDRTimsd1zGb+VIqn2Y1wRF0+T7FudyTAzJnHKlTUMgIezyEBGUX1+bvPOe/6SAVnU9SkFDJc3nHGfIhep4eFLVnrEogRAcCE5/HO5dQNi0+jWtsWypSTAhWk4D8FRkTxcXmsGCHHnxTg/4AAAQABJREFUvWCoiutf/m8BBAsiTEpRF4O56k4674HfrxpBETgEllSYJMdWzlcVJUFSUXY+K5W2KWg93JVXuleQ0nhZTZiNCjZvxbk42H5ss+KxH4tzA9rE8/av41qm+ZZbN5+4sy9rDuAKJvbOnhy+W6a/ydiZRAKhepbJdq1jWKL79FI9S0z2q7M01NA+0zIe5zirOsHDHJh8twVRqjbKxMXtm894bYzOEojK5Jpnngt21kQJkozRCEBL6Zk08Q7vvU3xO+rmM8L1AGwcVwBfOZdcLyWKbRj/4TJ2ZLD5Q29t1lXApsdEVXEjURnLULpixZTy5vhGnr19Cg90EDQkPJtz52bOWw9rYxJ/zlFK2yln4OYJTGYkEJN2R82e6lMzlL+eTk0up9OAoyneO9XTBEVSToDXpf+db4sk4xxuvwFVN5F2rxHfxrfIFHdRZh0GWeDheJhkvJtnhzzXlCpw3o4uIdkxtlFhS6pKXyggkr9ASomX0q4Bxvtugk3BTJfZNFvE7ftr3Zvps2Mvky+OQ/Be1waIbycYe2rvu6n9l54prbMzTEiNmF+sGydjnhEIvtZdSP956fPpbRMPBfgK1b2hDbftvPPRI488kj75yU+mH/qhH9q6dP369fTqq6+md73rXXFO8KEHuWeffTbU6r7yK79y6963ve1tcc4Tf+fv/J3M9G9effHFF3eo33n6ox/9aAAvyzT5/E//9E+nT3/606mJquGlS5fShQsX4tpeH7Z/AsD4A//b9+M8pJR+/v/+ufTSe96ZnnzybQGyXY/P4sL7/Wun0rOtG+l5NQ1qzFPY0o0RBHq+cTldXnowXV85DajtEccLeTND9hrBfK8pkA/6sinJGFtnwZHW2gmNYpPmyBaYrrGDIaC/sYE6JL8bU/U0iQRyhHd3gbGA93HiXfXSGN4qJwFH7+b8gP6fWdlIq40KXvOYtxlDpd56qgPCl3HG0XduwPOgkqQ+gGkMyRSDai8SHJ87ghQ4BkhHsNPfLE3uu1Cx+yQD6gLsTrITtcxNxJfhW/WLTl8pTV6gnXg/oxwEb3EnmECZXmMxdBL2r7gzghfCCLA23tck29ACyCidMrDjNtuQi7H2lzE4fRHJVzBBd1i61d2d522z4AGfk5JVqNGCgctn9n5SVSxjy5Td2QuK7X3fl+OsYGES+60uqhSrSDBM7l7r8reOO/f7C5LIe1PSktvmLrdM4zbF81EeNE6u46owwUCFW1tsfGR4vapKZIvf04xAHxd4yVrr8Sv/K3pAZavcCvMWCMv85RI4cY+JakTZAox7ydORbF7Gv7FPHMfF6FZ1U8Y1A+99Sol3oXgiN0opXYkd/h4cum2+XfK9tw7DyXOCP2YKmCOYagBLBJkm70zV7bsFnxOAND275RhKe9fVs3tfyXkJqpyJdHBhffQkZ1J9MdsBZqCxXx6ej/HBOLZfbJIgJYAFv0dx1elsR27B0EEl5inoHRnul6s1MJkbAAXA0OeBUcZmfi4ucp6ay6RCM+90PtWL3bpSmwDllj0GuJ9JS5156jSaTk6spLP8TZVQkYN+bfKIDRvmZwNxC1tUW5No5gnay8ALuizwDnSYZwUiJgOwKi3SFjQAK+diE4Lraz1soQBB0ldproG9lUCpjqWsTnU3666qVA/j/wEG+8X9qvhVYew1MbG9qslpz+QotYbStkjmr9qhjjxsLaSIfjBunXY4MtJBDymhR7QyYwYvfS8OroUt08N4pbyGyt3pibkiy1u+v/3bvz3ODZd74sSJsDv6R//oH6U//+f/fNLeSLU5wcu3fdu3pR/7sR8L9Thtj7zn6tWroYqnvVGWeqT0L/7Fvwjg9Qu/8As7yvwbf+NvpB/8wR/c8kKnbdMzzzwTtk/SW2nTW97ylh3PDP9Qynf5yjVU966nd7z97Wl2Zha6QJ1Nukk99v1ShXHyNCHBTwJYXkHF7VWsyXqcq5VX0mz9erq2ciYtYJc0jj3SGDZhw0m6l9moQ+eSgeIYYZSzFK0zjgxQq3qzmyVV2jszhQouKpXOCloXOU4vA7bXyfMM8ZMq/FNheHFphU3U8fQuNrKWGL8zjF2UKtkkxe4M4PZcfQ3VPWRObewvKU+JEo3Kg4T6HKejTYFjgHS0+/8N3XonxSa7ve7m62a0MFJ2d1abm1Ax2ZzrivWPn+kqRsBXYS5UB5hmZ/+kizyMWAMGSZ13l+pVGI6sdHR/SeSCq6+kl9h1fZRdWH9bpyJ1+PVFJnrLdhfzsMkdNj0ujRnP6a4TgDIYnLyDbjYuWjtrmM+2UInQvmluDO9F/PuDTFJJ5Zrh5K676h0ulfelfjQx2+hsAwlbXYbJq7ErLeMb9YARlGaOPXfFlYn4W0bUwKM97BWsraxiFwa46Y4n404HCUphHHsxbjmyRUoSZCOG++Hwo4IHD5Hs4Zxnrtfd9SYud2mjhtID6tyE6cU/GFsR5Ea7BByZ1d+7QoKnHu+t8WWGk6pkvpNdxvfdJmlncnNENUfVASPoL0yTrrGHk6AMpR/awI41dRKgWIcdNAky7Rxvw3l4bJky3k3e5RFjD5Bsfz6Kn/t+WNYWMPIuGUWZQxhNXRzreGGdeqtaVuqjYsYrbyBZbWoYdgemACpBCW70/9D9AqC18ACWWysEE+S52aREdgR6OW7761NpqX8SWpZwyQw4It7RBHZH0lIG8xoBP1ewGxJMRNwlUIm2R5N4G5vnHZhmjtF1NldhStk8gKndIG/B0QpG++OCH5hf+6JNPxAZlKDelC3zan0hfbnGm0WbtXPyn3aBPSRFWaVTQKfUSNDIAz5GnmsAZIEn5IsxGU9GfkNEiEuOVySJjBPVruXj20iZWoX9VWSYnxl0AGWUpeRhHMlDszMgeOmN9IXVVw8ESBSzZ9LG6Id/+IfTX//rfz09/fTTYWt0+vTpdPbs2fSTP/mT6Zlnnok2/dk/+2fTjDZRgIUi/dzP/VzYKP3ar/3alvMEr6map53RP/7H/7i4NamOd+PGjZBYGfRWW6hHHnkk1Pm2btp1MD83nz6FBOoT/+0T6Rz1ufDwIyHR8TaBdRdjwxXyMibZ+UojPYqHv4+3L6dPt64yd+JNsEpIV4Idr7SxFsKWaLa+sCn9HCqI+0zO2WGDJNjF3sy+VFqoSt2ZakOEy0Ye7r2ZHXTOsQp47uKgYZ5yZ7GlK9PXrVUCstPXs0iTHkEtL48UhhEeXDsA6NOMuXOlRvovzZvpOaRJIciibMG5wM/hdpyONgWOAdLR7v83fOtdyEzDS1z2KAYTUUxwbhs6+7mwkQrWZpWTyyz+L/E0WmaocpTSKUCLAcJf4prRGobzjYfvw4f5fhqYNAmjcRIG2zL8c92GTU4LqHvoleeOEk1rDjrBiKvTfXcpS9NkvLrYR7g3q4qQUg8Z2GGgYV0XMX6uY+/jIjV87e7KvvunZDw7ML727jDVsp2aFkDDZ++uHMvQqJ49fRb1nJ+fMs85yGtm7LevuBxnqlgvQZC0UoVRxtkk47mKs4awYWJB9tm4EkxChuc4gIuU883H9/MzgBybA1MwBUreZDZsY2ZRDl8SWvwE0JxIZwEXSh/WYUzdn7/Mp57JlJsZGna/JKXCQxlM77D9mMBSW6RsrZPptl8etzs/TEPBGBgOZsgxv/N9cbwoG3WjxR4vVAaL/O1P/3akODF8ltI2CyzejeHydzy7zw/vj7mKuUDpl4VKW+0z1saQ1OHkoFLZlLQwvg6TAnwr0QL4KUUpUjCEITnKcDy/U9qBAMgAFwbVHGfTqIdDmdXWaZjRempUVtPc5CLArANAITg3c/FSq4lL7FWyJwez94/YMx2kLw/1qunduIPWYx24A+cIqKZiR6oqlVKZFqpeqs/1MJgXoDawLVEG/CAqVyOl+dSu4qCBHtFedITx6mvoNoJUj/lpU4rG6IuC9QgoYy0RVYNTFdErUa/8sfnCWc1MP2MXrSP1EuT7/qqm14Px77UZzSKrIFnBaps3J/jaELxy0ctl5t8NxvHdJD3X/fZv/3aovRksVecJjz32WGSlTZJ/YfN08WJ4rSvK+Jt/82+mf/bP/llInYa923n9n/7Tf5q+4zu+I83Pzxe3h/c8gZhxjfz7M3/mz4QN0vd+7/du3TN84PhQ5e9P/+k/jfe71XDQ4FjqY2skMHruS19MLTwN9aGRjj26zgE4UXi0X+H9b6TniWs0ipT/BN7tev1qurF6IlWJN1jH012m6XBpjnNoKu2V1tEfNbzMPTx3Ms2XiDtHuSvcMMv2l1LgheYSnxtpujqRHiCe1SS6ez1szyK2EuN2jHfE5HvoWLHrdf8uoBprj6Wnukr4a+l5AtpKWzdPBrjID4cN8eTxx1GlwN29xUeVWsft/kNHARck/4aTO4+q+RRJhpY5j7TzTpcz4YnTpxroNwAFn2Hf+xMb7bQAS7bzbp+/X8nI3uvp91E/uAlDKiMZ+I3srbcBEp3O7zRFkEcD7DHJ322SKdB7mOCoQdwI1dQm49vwizspIvN0o7cCY3Dndb3b+t3yHEUrm3C3f2ftPM8uINd2n78lj9udoAxBTVsnGDJhmzmab4y1OOPZOLOZW8EWb2duFA7j1ch8mvwUlLibvlcqcru3+ltKLm+vMjwno6Mhu0b/9rUezTx3+EQcHjYXHoBhCQbUPGGoqjBJhpWchtk8STBN7UgOqonjqAXTkqFhLt1ahBTpjuqTnz3o077Sq6Oqj7vrZNvDsoxvvVv6b5saMH68u7LDw8/JestAryuBYTfae+41WaaMfR0VrpnGROyeT8xMpvrMVKpOE7AZG48uek1rGKfvdMYwXLNbayEpg5zxQV1p44Ad9T5/qqhtsHUeEnmkfqo2mpu30qPs1J/G8QGxmQhYO9u4AXBaDengKv2mof16lfg4c9Np5uRsmp2fhfmeSWWY23G9jiE9vYTq2QrSmKxqikqVcx0SmFUkRwbyNfbcazDaq7RNEGXA2jWkEo6ft9ZO4BmNjQjA4kDQwnPGdrOOzn1gJkAQNANwKWGy3FI9e81TBW4t3l2uSxKeKdQJbXuoD9LIdWycOi02MaiL+xT2gU5GeDTeiXAEglqd3vPGMe6v0i+nkKw8dPJMemj+ZHrwxKl0+uSJNFEj7tJdpPe///0BcgRHSoJ0AX7hwoVQrVMFzr7y3N/9u383fdd3fVeU8MEPfjBU6z7ykY/cYnvkDXrJ+5qv+ZodtVFi9O///b+Pc4LAD33oQ0n34PslaaXzhx5u0a2banm6Fv/kJ/9b+n9+8RfSxy9/Ma0+NZsuldGBAJiKcFTNrCDefDsqh6eIGSXgKAOm56evQv+RdHX5NKBaldZbS5XODgDfqQo2Qg/PnUBtrxbvlSEF1rEjMvBxk3EzjRe7hyZPprnqdCozdjvE/dLjnmryNbwUlvGSuJXsR/JVOtTnPV0MML+WTqN5oZqiAZorfI8Lcnloj6ptZXV88OanwM6tszd/e49beAQowPQcu74yzi5wplAtgZHYCHWXW6c975Np8tmciieL3/f/+xq6G7+xgSceGNMz7MCepNZuFLsrdjfJGrsorA5W0xS7dhql39rS2+WcmeUpDG7dYZbNN9/xUH0aNmTOi0cTpki31dNID5SS3AoLblfePVyncZYXIIPvvZOMarBEe18+xFlZxDbguYXNQgZB+SH3mLNxuRTar/ztAmTc8IkV6p/m6T+lJvKIVRxe3A9J13ZpHlknmL78Rf5FHa3vrcmr9nlF1U+AsU4PMnt86707z7Aby52qrU4AAovRq+2RjM4YO/4DGJ0QjO18cNevbCtkvCiBeVFLNw3GAGCjMrVbbfA9MeUese6ZonHyUB/m5dgx5pggbDhpq1SjwqpOek8OLEs7qIPqkIKr4T7fgOGTiZTWoZYlp36PSfAtDdzwUGVU+lk+wwhmnfyhr7GMWpxT6hegjouqw8l1Do/V4arICMK/BrMtENBWR5sdbbW4FEDAWF+tzf4fx55kFGP4Zn82rXSmYR77gKPrBARtxjuvmmkhp5WvtV7+kwK9EnMwO/i9XhnX3L30pR7SB9TlTkF7JTzhaY54PT2Y3lUkR61GOc2XJ9IZclQuvdxuhWRJmj6GhKCJF7QvMmf2YZD7SviIE7UBMxt0gkAjqOYpGgxAQ/kqTKv+5vwf9kqOJSbZtS4Uow9VWRwg/ZERD3rxeFbvI0fpCt21ixlBvUunDdocKcEaZcetB43sD5eUEc7PwYjXKX8FEJE3uYapfrhjVez+wl/4C8RcwhoUxKctkd8XLlwIF93vec97wjW5br21GzL91E/9VNgpDUuIlAj9k3/yT+K6cZP+4l/8i3FcfHzf931f+it/5a8EcDIe0jPPPJO+8zu/s7h8y7fA6EP/7l+nd77rfekktlIXLz2XPvP8c+nyQjtVHplLZ7/2XWkDL3EXWQ8arB1PjaH+p0qmfXxzLV0YJRZS70baALhOVYgt1ajisOFUurEyl05NXYWeOzcU3GToonJpv5+fmUtzSIautpvpyvJN1PQGSBUneW4u1XA13ihNxVhe0UZtBQdCLbRKeFcYhgGuRpBojfjOIo1SxbLN3wJ/q+MGUgZEYY+8RmxA54AagHeauFo3VbHEwYzj6jgdXQocA6Sj2/dv2pY7rem61yjywwyVqiL6qw7eZms+lrW6nynvkstuuRO9M3d/UT7MlMycx6ofLWMs+iL3yhI2Qp0oq7ncXa1Uc1BCBUiC0RiDDneapJ+Ly86U67vznJKVjXS9z4IH0zQzPhHqZrvveV1+Ux137VswSXoM2y9Z63tNtlGbqyyNGiIMh3eyhPqkUiQldE0WbJ+1fqqlGAhUpHS/QVKXKL/XmlUW+7E0P9FJExhOl1AfyWmoLZtn4ovOLzMOVQnUli+P1eEbbj1WwfEKgH8C+74z2KYUKRhmfnR1qEJj9ymxuJ1v7T+0EcpG8pYtnQQoqsWEnRaZSic3Erymyo0SifYGAVdhWA+brItAx/IEHUV+Pp/LxMMgN6m+uQYD5waAtlTaou1Ovi8yYjpeuTPpmznlNhZj1bJLMIZV3l1HhF7veptzmdKdkHYEk55BjvNcj3dgAulfhfPSKALOilDIa3dSoi7legCjLjY0GsF7n8BgnDboGa8NYFpHNU4cpm1NC6cMi6hFDbAZmifWka6adcVhPxWe3iynaIPH9oQSOkGjeRhPqY1Xsef7bVSZRlJttZ/GaY+0u4HUaGxqOp1lDpnnmnnblzpDMEkhofdJrr+IF80Weep5rNMByCLJoXNSG6+QG2yCjRLjKeZ96GByDtSg33o69Mep89go4J9yjBOlVAaKAQ6hNmBqDJsV+1DK6WbaA9+FOu+tdVXdrCu4omEeK/O8xibRMmpdJwCSgk8B7WGS0p/hJFAxvpHSGW2MhtNP/MRPpB/90R8NNbBh26OLFy8O33bLsQBpdzLA6wc+8IFw8mC/a99zUKpw/aEzJ9N//tjvpAVU5zamkIY/eQaVt0fSyDJtbg1SmQjiAwj0uZHlGItvRbLDwI1+PINa5VnUMq8AfHzXZhqLjIUasZHmNu2RFreGqmqRA5wm6HHuHJKj08RIuoJd20vYTI0yOGcAytOTACPsr6qlCaSabcDWAmAa6RSgpsZcoYc8Vf42mI/m1gGbI7U0juTNPq2yKdCg7/GByNjEuQNz3JeocwmveCcmUDnEQYcBnJsA9uN0tClw59zT0abXcevfABRwWdRg2J0+GTz2CDmTJ7tY+Jj4XNhcubNEyUblxdSju08u7EzAqIFMMXFXWFBVQ3P5lRV2t5S9ymDI2uhuR70oVjU/k6p2N/g03tC9TM0+q1vgFWLtTFWmok5RwF1+mF+ukUe30sn2LcG0yPTPEjdEoHS/Gf0dVacKhwFHMuf3RsnNUhkrMp27k7uRgrN1dkylzGGSqmyT3K9kwlEh0zXNWJGsCwPig3DdncxMv8Pmuk/J5NkDIF1pNtj5rwGUehhGN/E6hjvuCjFm9tJtKbKC0SkTQRNfisEAHqYmA/K7yfOzvATVAqfIYbNj31VNiWu3UrEocPvbe2CP+XSbISfBifGtipTrU9RqA8snnVmgHoWk7zBlFPl4r8/oIcs5Q/CqxEq1LftclUr7eXAACDcv5xWBWiQzLaqWz+z7qb2fwVmdA5RQ6rK+Agd5enwqTY3D1PFPz4bOY5cHS+nGYBkGGTAhWLRu0HUDZr3CvWerqLUxlgR0i9i2OcPkagxTZLNi1NU6+46MoQYlePG3yfd5HLU+2EzOETR1YzotNeewI8J9Bcb1qkkJQbQPizbzGDPpVhsd1+YkwFHCElcFIcx/pTKe6/B2p+R5BGZ5DDWsMmVt1MbTw2yyTNMP7GEBXpgnmSP70CQ/n/uhSZt65Bk2TuSnWmALqZJjTCmHU312RJHro/SlBsipaZdJeQPoZX7RVivJbYI3eOWt9scsXvQltzinq2AcbeR+paWh5hVt4+JmewXar7WX49399G99LF3d+HxIabzjTtNucFQ8L63uZxoGWgflKx3fcuF8euAdj6aPDK6wYYT0DECKciTzCO/eVRzQjPZT9QTHDKpPMRPo8P8sGy2+R8r4HmFdWES7wf2TEveeRNWuv1BOC8unUBvs8h4gAWJM91Gf7AN+z8zOpQfq03gEXE1XV5bTyRo2uxOTaQLp2gZI9xrvQo/gwYsGDgZsMxyx/WImwIh4oYKrfQbSmbKhL4ytRQ3o+g3qrJOTMuNAF+/PbbTSZ0eX09hkNc0Cbmd4/4HPaQ5HD46g+7J+HETY42t/qClwDJD+UHfPceXuhQIav4+6a4mqSI47sp1bLJAAqBGMnWNXlh2lnPLCun3nYY7ys6q0zSK1UXJj2THD7nrcO10wuhVUSgyKh9F+2911dhy9dj8nZNXtdIWuy9p7SzJ/ergbD+aroNTOPFU/Imo9O6mTLFL6Hhtmmnbeew+/6B4VrZQcFQ469stN5s09+Lvp0eE8ZZhVuQqefeiC7ZMpEugOOxYYuuWWQ8ed6otKB2Qea6hXWkfVuOx9nTjIqNtnqi2ZZNgye3Zno8Oy6nhsOje1kl6CyWY4pJvtOjuu5TRXIzZJvcNY3W+nWwgq35nVlaIiB3woVVESOgWIWQFYaVxvEtjYCwz5O0i3Hzk5u+1MaWqoyo3COKk6ddhUjGXr7/hVoqTnQDdQ7B/eTN7j7XIOk69QUPfXo+RFVpH2ysFx9VAFu5W1KVz6p3S90klf7F9ODcbEg2k+NZpIPVDbunHjOswcEizsepYJZrmBd0bbq+qYKkgDQPDp6kw60cb73itLae7UTBqdNDbPTRhJRk9IrK2GdOUfA8E5z/FRruLlcbh91ENwuo6ThHE8z61v1NmZn0+t/gSqdQMkR0gHqs2tvJQQkVXUp2iotmb2ew9QJLg0hRqb5TLMZ6o1PJrVeGsEoY6yPHeMIC0asHGgi36lOl2YZDeVvO7/DTa2VpAQDXjnrHv0EaCojRreGHWlyLBzsY1FGuOZsH2jGwWTXQCZKpxK5HK7eaeKQWBJHBfuxYs84v3jgrcpRW7jWW2vDRPvsLm2+e1f/xXpPJKVN0PScUEbdTdtuK4RdLU5aMWGgrSyzSPT4asyDV6rpB4qj+UpNkR4cz7Rv5FGeo1wqy0IPz1AAkjfvcK6NwaIqY21cfJxI11dxPX30sk02niRdxhAg0rnZLWME5AarrnxhsgYeAwHDZNsAqzzfhvw9xp2bEu8C+0OoAq7v1GAd6M+kVrgx4tIjaq8G3pMZIlPrwCC6oiUyvSNqr6OHSWH14nV9LkeTkamsL0EdM2wbtVAWSdRuZvbqOKJESmpImQ7/jgdSQocA6Qj2e1v/EY7Z20vg3u3x4XSnVmdDYyhduFuvxKcnYkJfhgoOSG6Zt9y386n8q/tmbMMEJtHWpPdXvP0MNMx9GiUzmO6Eq4h8h+sT8RiopqALp/VxZcpUJ3oXpPMh0zf/fEyp5rTzmCne9XPHWf1/oeZlL3uu6tzkETmbRVwpP7/NvX3zk31nwwt9r5+2LMyAVmqc6uNlSNKOyIBzWHbbJ1qIzpCcJTlf+5mTqJnr9cmPQjqqcyF3PMyaII94ynt9rhmG6TDXqPFcwLb00qMyqifxZ3em5lLNU4d6ps8PEfbKRg9ru7FCG7ftX2k1KHL7myLnWH2Y9NcjIJ83TJQYtuzjts5DB9Rv/g3fO72x+5k68HyTgBSkat9bJL22XNgcaa447DfUB2A2MadsQFyqyXdHgt+h/opOgtVI4o07tKnfucTafnGQnrymffiWEBwDCh6+Wr6+CefxZ3yuXSJwJ9EvE7v++b3p8drZ/LuPQBG6VMVZtL2zlYm04uf/nz6zEc/kb7m696fzv+Rx+MdUZ1XWxBtlJZ6TcAxRvTOL7fMT56j6gAeQaKbEG4utWBw/bPzJmqraQbXzOP0sWNSWjuGA1wGkMljyfkWhBX2PXmMk5cEoMGOp2klOozla8x1ylGBNkELsbp2ZmHPxfkITMv91msMBvhGGakA9dLw3neji2c579FOaATQMkZcpKiQZZEsmydjkPdx6KAKXhvmWocO1iec9zA4s2zTey2I+3nOdyR/Iv0gI99CUxewYIV8Pj/HM6aYs/nmXml44X1Pp5/54z+QfuL//PHw/hb3vEE/fvYf/sP04NsfS8+NdNI1nACFoxqcGWSKBDnS+GlGDCqZg9eQ1ADgxxujaQUZ5u+hE/Ge8gwaFQBx1tnHNibTNebuDjZgmG0BlnGHNFGJ2Ejl0XkCyrIZoBo8uV8GAEn5Kn2ypCo1EsAVpEtLqGiGd0FcyTP4szMO1CzL9L+eS13jezzXIp7gKHVyLp3gfXkYl94VJHC6IVeC/3nU9rrYIWlzNMGY1NHMGYDRyTXeXcYhGnpbbXyDdt1xte+RAscA6R4JePz4l58CTsw1mIgWaieHTXV36lmU20zOqr25rDkNb6dNoOT5UAehlABK23dsH/nc5vLASjnCLiXLZky6xvTYbfC9/dz2kWW78LuLjDyBOCLVYEwMHtpiAWjCdGtXILNgTe8mCVZkGu9Hkl2UWdfQeS8bjKIMwdH20lmcvQ/fkEAmrwUDW8QcOihXnQ1Y39xPd0e/In+ZxSyBdEBs9vvmRUFom35Sbe5OUvT/0AMyfNNYKIV6iDZdMAT2fY7/k+uv4/U6M7Y+BotayKTqVlibh/2AgfdOwlzuTubqGNwv5ToecMPQgzE+kKDaDo2gO1yDrY6EgINzguZb6bd5y44vS3QXHnxB6w6bdlP0sM/tvO9uYdF2LrB0MIhV1L5uNmfSancSdcZlPNG1OU/7BSAYkRs7pwqjj3lEWlpcTNevXsMlMipitNl+nDkxl6b+yHvCzf7zL7wAUzeaTjBTlFfYHWcjZopAnZevX02vvfxamsRQ/fwj0+k6oNv5ZL3ZTZWFXnqizq48O+XNxZuMK2IJ4Wzg+e6VkIxt19cxAO1g8NcofwCD2WUOUw1qHdfHze4Uu+4l6t/Ehm2B8ScDKqAB/CEFdWwZi845ymOlzEpTBR96Q3THvweIUVKvh0TCrPIcDhtoo9InA2arRDfG/dpwjcKkqnqnNznHixZwN5EIXEcy0VL3jkImDYwKMNwYwYPeKvZM2DWpmgo3zB9j0AHEfcaF8rsZHu/cdECiR346DvFaXPcFQJoEUbjiHF5DYjZLfVSVxgX/uP0m6EaauAksbWdsHEg3j1kvenjai/lWOxfWgwtPvyX9uZ/+y+mtT701/cq//pX0jne8I+7j9jdEiveYNv3oj/1Y+r8ASD/xOx9MzzeAHfRdA4c9G9BwODke1h7EPu8ScYleAfI+jH0ZY3uF+erTqNWVeUZnLdfZCDSoMVTDRTgql8wLc41rqYML+JvdE6xXq6yFSzGWNgCjgrEmdFfFTxGhWyf+14veBpKjGrZIpRqD1XlHJwxoTLgGuenZUTMDcGSg5hVU7gxsu85vAwp/iTn2Nex0x/Eq2uDdcFuvYl14IXVc0sFd/dLSjXTyfB7Xw209Pj46FDgGSEenr99ULVUtSTWOwxplOyW746r7TpnabGSrclTeLfW6U358syDKW8cuqyd2JR53PmZVl53KC4Wf7rw2UTNSbcqyIu16Pu7mY/h0wdrZHtWvZLa1i1hExK8Kl2pyMoyu5TufzEXs/anUA7UjFoC8jO99152cdXmyXQcBpNzqaOWdZH2Ie7Mx9O3BkUTaBHOMkXttu2NAsLIKGM8576yq+Xc03GcksTd5T+XJlExhTDxGx11jAXcM5PGV6elYNdaVgWnDxo5FXXu3CuWm0R6qmrfKR4vaZknQ4ftFRkRguFebizyHv0MCNloP8IYCUurAGE9qfwATPAIDqewxKxEOP7XfcfYeNz7SRdKwbXe0392et57BdKvD9QeeGH/0xwyAQmb7ZmsWKUw9TdVXU+/yK2n9c9fT2DIM+wON1PvKU5lZVxcvJhWnldH00qUX0hd+91PpqaeeDucJOiv4Lx/+aPr8Jz+bnvljX5eWaovpQ//hV9ONhYVo/Ff/d1+dGpM4SYHZu3TpUvr8Fz+f3vXud6fG1FT69f/0a+mtb3s6PfjVT2MDhGG6rsjVi9tM2ZMdvUZf2ecD1c9gSNtrSo/0ZolRO04ZZms6zyiHSrBgQKlmqNBtZuXoktEsRpmOIuSFVW2S0VWlruFuPTv960hy9HbmnKY9kuqyFzcMMIvKFMFWS3ipU6XrFcIuLFbxNEb8G8d5HzC0SkwlPZLpfS/AHZnEONPrGBIB6y4pZZLBocEUC0xHAVijzP86YxDAOU9YQZ02uBL0B0gy2g/S5ikAIUB08jXai1UYmawOkFoAIPV2p3OGIDpfsZnmWw/AoulRj0lsZb7ixGPpO37oJ9MHJs+l//V//4H0X3/no+nhCw97S9CnmMsH1r0gGNeoGVK0PJ6jhjTE677Z0VbuMcUjfOR8OLF54HsYMZ+8gXPWtLhWjK+8rnFlc7z527nHvyJdvHgpPf7UE+nce59IP/vcr6S52WkAIu+y9SFXQcb2bAO4pr82UAMdfQDA+jKqdq8yg5wTSq9FyIwP01+qe7aAyGvYjZVQuQt6WT0km3MTr6L+ewYpJ/4LSwDedazNGPMbgNqwB0SCWAJ8mofOOdYZB7pujxhH9KWxktawWQuHGxBwDGcigu46anpVpK83mRvDCynNXmBe/dzaTTDxBlJRNk4DAKtpIU/BZk5rGXC0EGVs0a4gzPH3kaLAMUA6Ut395misk/5qBNyM6f+ARnl9e9IvfsmATLDjaPR2wZJqUtoAyfjLIhS5xoKx/fhWOXlx3foZJSidKrO7pt2C7pE1KM/2Ly5SOcciX38q2WEp3M5k8yju5brfZdS2lA6swRz0UUeJHVcAk8xuLHK3PL3rBIzArSXsumePn9ZNA2zrICDZTrLN+V8BDLevecRiT91V6wubHLmj+5TsBlVjbp9yh5U0tueftb2X5NNK9bJK3x6DgeuCI9U3y5R5P9IEoGCAsf0VmIDd9Xd8huSUDdUpAIl0NjnajIfjrunetdz77H71ldLB/O53w9B5x4L1UKqb65vL8rgHQ6ldySSung8KFDuUXRwKzzow6mUkIIexI3NzwuCvh3ovdhf2uvwWJA1CZWiyiu1eH9uvNobsL6/BPD+SnnjPw+l3v/ip1L66uoMxjarABLrz3cErl0yir9Hv/pffBaRMpPejPvf4029N//L//f8AAGPpz33f96SP/9ePpZdeejGdwP2yffHA+QfSi6jlXXrxBTy8IaXi+fnzxC+CMfTd3GTRN1sNcwyDOIbNh44XvD5Kn6E0mpqo1g0GzEGoZ9YBHm64KPERW1WZWEJq4G7R1ohzRuMm6l+kULkdpwzmLCWJPuNd2miNOddyqxL3LgDjUvNGeg7mObvc5l7aN45HuQm8lq1Bh4UV2OsuKoLUD054+82mPgNATAAfqxOTXgl6T6OSRWwcHEtMVwCl2rfANGtPqJROBtlMAhwg7VrunkUFr4EEo5feOb8MMJWpdoMJgA+NOkp02SiRTmvUwbGWxxuNIF8Z+XHsbN5eOpMeGzuVJgl98CM/8JfTX/5ffpD6W+dVYjpdpq64eeBZ4y/1+P7keCe9gPSrT0cb+vQ9XZyF9MbSdIM4UtjVvDLaSh/tXks3AY9WeIw1QSmV85v2QT3HCS7UpUiVMfLk1Nn01CixqLjeRgrUarZwroEEEQBtfL8vLF+jrbyN0Ml5zbZUp2l3vZa+avRUKiO987396Nq1tARYmSzjFAH6ryrhBHzUjStkP0b7GTOAo4jlJi0ZJGOnGWevAJIuazfHOaU5BD+X1tq8Dex0ytYOyH2BVhOpEg4aTuFApjsyiyRoDlqeYHdP6Y/z6iJ9h0wa+ljmuqiXpFTJ0dTD410PG6nweMjwLuNwwXFGcalPfUcATys4wPkM/bMCna8DdlvIJpUkauPnaOUuAsUzl/KyDKCz7R2HxnHRwo7TkaTAMUA6kt3+xm/00PK4Z2PypOdK6TR5ayoYT1VSUNhg11E/Re7WsRCgqy7D5cJo2juHnXkqWYFnjXvNW5AUk3Q8vJ1DcaQEQBBlmVtp86J7c0qOcmLB4WAcfQWE/yzstbD1yBIwwZLrRtGarZziQF146bS9p7vz+l6/3BWuwSygEBEMsjFPejDd2RefFMk02etZV5M2C9lN4zBhUCv3o7OKoRbu/dhtzubn7cvD5STdhYZ7U+U2hd1y2VyKXrvlYpyQ2WqjEjkJYLkvyT4gMKa2I4U78OF87VO9mtn31qwOMB9j/Bm/aA01Lm0y8pWCcvQDYFmmJuxLePB2bbI8Nw+G8/HcQWnHWOZGVQT7OD/pDagbzEx038Gk3JE92xYAzz502GS89+x/GG/GpODosNLkHYW8rj9kmgEAvEPl8aW0TvDThem19CUkPFdefRkpkPZhj27WgDbSPyX6MRh4N1Acx0hhlvHg9d8+/sn03j/y7nT+/Hlcc+PR7sr19OlPfSotXF9gx7uV3vr4EzCTY9H3s7iH7rGb/tlnn7UT0vmHHkxTZ+bSi3jBG06OgfA0BwUdNx4HiIGZHvTIA7fMMo4lVO4qgAWZejdpVJEKKQWZyaRXBB3OUvS3VnK7kxtKOoUo0x7V1QTxbkpZfsx1AIYuwVnXcDmOSCYYV6VPxhwSvEXQTyUQ/DMJukBP1IzxLQPsi0CS1hu8C511VRvnUqvbCInD1Cgqhpyvw/BqiG+tb2DcHx4j+LUOWFvsnMTT4wwM81p621wrnZ/QW145LbeIxcP9dZ5rwEz3ao3YEPEd065J74fOTAYXbSDZfaJ6Ll2onOF9y05YpEYAAVQM14j/1FtFewHJl14DDUraoC1P8bouIBVZYIOjCZj8IoD6nXWC0AIsmsSN+hLSDqVs0s4NA8FYsf5Joxre4fo4qdgA2Ojt42L3KrY1bZx/kEcL0AZhBsxP16DfF/A691p5FTDG5gt9ssbGjg2oIYme4F1ts/7FNg/98O4yqobY5qxr58VmzRLXrqP+/coG8a+oh0GUPT+8KRF9VIcmJwBs15QS0Usn6WuejfFMGxDphMSnhCMF42+5pIR3QaRGkzNIfaqomHcaaWl1Bpfip1GpnEqnZ16ln1mFqMsYEqGNtq75cQQC3XorBPZ188zpjuz1wBgjwnbzzIC5wfQl1Pd8vs/7s44NlPG9KtRBWzJdg09uYM+3KYUS1NW1dYtM4/HjjyNIgWOAdAQ7/c3eZAFBmcVKh6jacMjAhora5gJ7S/tZuF3QajDz2nfMsPNLrPe0ssY+E7vY7qoWC1J+Nk+bTsLuU8kUqGOdl+nt3LNa0/bv4SMZOniEbZDk4s4/vf8Ya2U3s5eZAxgQFoEJJEr484l7NEoVTCkB21kezAdrRgfJ0wSL++66Dddl+Dhr3sgYs4BDl7qKLTC3HerrbmNehTLjPfycx56tQQf1E1VJMzWYYYhnf+jy46FdH5nO0udwSWat8AB3uCcOukt1PVmkvCO5152OBgGko8Q770fS1qsByFSvvmAMh/P1nOqcbRgn49/M415dOzvr0glQ6y4rOv6Ma93NK+GxfwaowQzYze34TsQu/N5UdbwXY2643L2OvU92V0CTKQ+TCxMdqqwwkeOUZ5wnAdPeI2evXPM5AZK0NQ6S4EHq5lzMKQN2bcCMW3L4EZLz/vJ9ZqAksJh9/ATAaATPdK00/+CpNHF2Jq1/jLHDPFNHWvP4yBzBdqvpJdwkhz0R/VTD49u3fNsfD2Dwkd/+cPqmb/ymdObUydR4/3+X/vj/8CfYPGGzBeb985/5XPrSC5eg1kh6+OFH0m9/+MNpeXklve9rviINygATnBpIPftLabnvtGpTG4AMgc5oCRtDGNoBBkjt3gQbI1mqVMXJRJndfMG185JuyH3HcuBV3g/OU7lghnePJucld/gFOmXqKaDQu50eNteowwoe0VrNJvc4tzBuYHpH2axap69bxDhydjVv1anc8Q9wxCQY/7jXUaC6YNiNMFe1uqgzYvclZqpi9zXbWEjT1ZU0AzN8cmwqNgpebq8Ec29dVf9cQmJxsz3Hu7KR3ja/mh5udGkbawdSrbJjlntKAJo15jX46dg8Eois4a7cfyUkOifL9fR4+XQ6U5phwwrpO8x5eMPjeSvp8TrSpT6SCaVJNAVp1hj0h57Y4kzi1GIxpCzjAJleeoF7y0hxXmKz7iXkHQarraGWpqqiAHMTEzLkM8VLAiTsDM27D40v4SrlOWzRpol/dm4cVUnm4S5qZ129IdLXI9R5DCBmZDbITv/Q7+Td1FNhn/eMts6wUebmGwIYxshomuXu83iGEyRfxIGC2hJeL1LYdZkPIGR0hjWJegxu1NM4GwHj05Th4gUx7C9DcFh3gWLUHaBTMp4V5TqepquLqVFdxgX4Cdx4n0jLTVzY05djjAPHwgZgSppuIL2KISKRPaSf3VRQmue4kx4xO0HncE4C4XSCVACgUeZH3wjBUYQKwF7Nqql218Q7ov1rrY/T0aTAMUA6mv3+pm21C6e7fVgBxcRmrJc8Re4GOdskcALUfsTvWPBgiDFLDimIAVBlwFZhRjXSlUFzWY7FjQVe0FBhklXy4rOHTd6pbQs8ZUgAVO6TyesDjrx20KScJ213m6mnO4i0tg0QaqoaMFQBj3sAlSr0ODzbrs0NKnKARZNlCRAa/HX507ue9NidrK8Lb4VF1V3Toh4dFvhxFrS9dpZ353HQ79x7rIC3SdZVj3KOg6IOt3nkwMsyMkFnAIa73UXLzNs2KzecRLo3BRNyv8CRFQpwirtZx5b0tj27U9HGFdRNZchOwwTbb9ZDULvGrq1jQ+bXfrTOXhtHha8Mo9RjF1n34jI6O8G19wnGYei4dphk/8g4CcZMUl8mrtnRbTbe1lCVyszcre04KH9rrZqnMMkxpCt9pWFZXou6Ie9fgKMhRm2v/Bz/BauTKbHXXa/zOehhINK5t5xNtQtsG7Bjz+sU7/DLL72SfuNXfjU1Jurp/LnztBPQw7E79XW+33LiyfTooxfSf/p3/yF9/nOfQWL0ePpPv/kb6UO/9CvBEF648CjqdNhb4K5Y73PnHsZR+PyJ8Ox14vyZtAKQzraD7KAzLjowwjotAIfwPNsJDvTN1O7Ws/RFiRDSo3IJWx/HCkym48cx5jsxkBknD4dmRWkPc6AAqugKVeE6qHfJKOt5Ts9jHY4dq0ofmozbJqpe62GfQg+xIbA2gl0Wtk8dXJ/38PC5BlNvAeKv/MbxBc3GcRZRw0OggWt1IrEGKFnHWMe/EmBupk6g1YlFJF8dxmQ5zeDAog4oWIQRb2o/w/jXvmUJScVCZz4AwZNzy+mhBupq1G8DVHC+N5IubEzQTwCB0cnUqk8BWzvhir+JhoBzdTNUWtfTA+PzxK6apT/zTCstlIbBiVvxSI4/HVYIDEeos2pp6+Tt2znJuwap0wBJnqqTF7F9epX3vg8Qq7AhVkeqB8+O6qXA0jUty/SLvCW684EgN1SRobVu4FfRhXwOeyrnxEnBBeWH3RQ05PYMMqCFzwpmV1lHYpagMB0eGHMrCM5nk3pfHGkTWNWg2bTBDKJfyIdxOi4w8XeMCfphnrZC7/BsR5+UZ1w/KB9VvTbnKwD/AMTYF1XZ3JFWfSQ7Wbrm/LOe5qeu0x+ltNCcxwMdm32VFfqevkYdsA4YcvNNtcc2YMi4WeO0WRA6QOVuEBJJ6gN9bUUk6ifIajQm0xTqp4KhKcbGo2xLjEJbA07bCN87DN2Kp46/jygFjgHSEe34N2+zMyByni6mxQA0sFQHpe1loFgO8pRaQSJSRRo1ReC4JeIpaKBr3qYyE3qo1sUiuDUF54uH/BQkqa4hgyqQM+8i/72yuPWaoA1dahbALn+qwxX3yKQK6nqAlBpMfEGPvfLdcU4Gochk6IJG0ksEoDSfWByHrrFEwrhmuc0wJZR/aPvQYBG69ZkdGez/gwxV7ZM+O5O/tyuq7ZQODO7VWcLOMkZwEYvKITu4bWyRlGgo/RM26IxjmnGhdEMlsEPTd2cB+/5SYqLr7+4etkjDD0kBVXCu9YkzUpqilwCJAXC3Qe7w/ZlqOHhgbMvsytRqZ6WEoEgyeG4zCApvpXtx1/a3niENFlwVwFC+ZbjzbKDaGv5y3e29pfu2Hz/wqOhhNxFk4rrkq4qX9I66MV4PSvn9sFajsSmx067uoCdfh2tUVcZcAesajF8TIj39le9MM6fmw17EXe7a/Ew6c/JUOvPEwwF6ziGFa8KoTszPp6/99m+FYe+lB86eSZMPnkxf+Pyzqd6YSE889XjQ5OyFc2l+ci4tLy2nmbnp9OhbHk3Vucn0Wn8hNj56vIuG99SpgR2irWEBjqRzD8Z9tTPJNxtM0HVM2yMCw64z5n1/a4ANpeV96q3tiq9fGYZeMN1CdakN4Bl3HhCgq4IGo15GulEHuI1zTuP+Nu6ZV/qr3Eu+XMclHXPEec7Pwwyj3rcm2HJe84/E8QjMcj4GjI330tlpPOpVkPADtFTj1MFCHwncADXTOipktbL2OlQO4KT01A0sA8wu6WwBkGbdmt1aWuyeAwSW0qNTC9jAtPGy1seNNPRdG0tTqKiVaGcH+57y1Il0qmJAU7yNQjsdqOhu+gbOVFQnfqAyz8YDNXZXgFGZg9VGjW1BgERpESCS8h2T69zvvW5gTAGsVIVTY8FnlfCMAHYmeZsr3HeSfpnkXT2DOt0CwOnja1cBvTk/m1kk81XMFTZevIvFNVUAs0SXGZlbdJseEkroNwBcaBs0gROEeN66cd71w40aoxy9CjD6EnY81zcAtDzvuClSgJzNsnzGNma1OzbGzrDh9wKqvwtIA6d8W12PmD+hQa/DWAHkCAgZHGSXZ1DppJOFUTZ8tPc6OX0F+o2m60iTxmbx/kj8pArz8QPlRppGeq7sfrHeS68RNLYXEjrU+wSeqOKZg/+LtWcU0WADYDaB8wbDJpwdqadHR6bTBI1SzbSCDZebeiP0sfMXVTpOR5gCB3ONR5gwx01/Y1LA+cxFRhF54ebZyfFu5zmn7OLZnE/xS/poY6MayL3No4U63dA6Z+ZbKZ9XYkQNYlHdurRZNgsZE3yNXS893u1IMAWq4Bl36XCJckLt4NY2uby5kz+cXFCrLNwCtGIRGr5u3UP9D/36e5EiBY1pyzaNYI5hKNzJVJ6g/UUVmy6Zoe0eG67J3R/bLkGQbdQRQla5hDHU0Fxundgya0hIQuWDRX2LK7n7IuNJmZMJpEht2qUtUmY69s/UoMMrqOrMjk/BdGxTar8npKlt8z2xz1XN2U6c54dAJHa8ty/seWRebbj+mxiU11BlGoELU9XGGFGNxhi2Fdywa2jumdEBJ4sWWZbSkL3G2+7HvTekivSf/9xpV80w21ftvvvL8zsznhiMY4x/EfuhtWmY8fc+lKYsnkYyzNNVPqz7BvYeMpyreGj77NJVYr7U0wyA4woBZeunR9Oj597NeFxPl/B46RPnzs+n1cVO+s8f/jBBNHvpwpNvSW1271dwW6w6pvfyQsIAy8jKiDtec3LbQ691re4E5WbqRswjDOWFyb5bjhWlXj4nY2yfCKRavAOLzSWeRWLDe6LU2qJUP6sCKpRo+l5qG3WzdTPAkWDCnfrO6EkcKpymT3ARjmRoAknBOMzqqHYy9JVVLHGsHVQJiUp5TEkBEpwYr9SLbi3jVt0kPkFTjvpnaYabJggMqDf2PMyNSo96ALRWq5QWB2eQno2nB6YWcYbQxHYS8ChwpD0zxMOhCgECy/VJvKU14lhpmFLMEhsjui0/X52Lcot3Mzvw2aZprpNgkpkK8KWgTtorgylRQF91O8oc4dgAwLrPFsw1oKHjVthwFpD0KCp3Y6jilQmw6pvZQHVO9+pKjOx3AYHjxTkoNiOiVvnD/NzAaQM8jOMkeB1hvRBY6ChCm6gJQMMJ2qT9qVO8Y87+Vbr40sZi+tRgMfVQk1VzIlt/0RA7v0hBc3oYIB+2r6ALQZabEvazLr8F4rrargCWN3C7bZ0icb6gXz6hlIx+UIBD+1TRPTl9NV1eOJ9uYpd0YqrLHKdTGNYcJVKUbfgOiVvCGcxYifEG2LN+ToOxZtIeHW04Dp3L6WQAZzk9TlwmnCTySzBIfRgPejosM88zBHw4V+n480hSwJFynI4p8KaigJOrO+LuDMq2O0m7w3kYhupOCeGi9Hol6xuqTjCvZQEf//aarq2DRrcukc1RmCAWpOI+j1yognEoTh5QYUGYdlh7tctFRHBgNi5udYBRncWogYTFeBYoIcIQZ3fYBxRx6EuWF31GgS6g23XKaiZtLbYAw0qNJkexL9in3ocucJ8bXYCjLu5k809QHKsvdMWPcxrFnmSEHdkN1Iw2TuKogcCHsWrvk9+dnFYqd4odzptIZ1TrUQVkmBLmZZ1k5qpd+g7VkhF2ZdP8nTiMkOWCseId2QYOSmdyuw9bX5noVdyQd2C0kE9RT23pMlOkWtf9TDEuDpmh9LIttkbAN2adDvns63Gb49iYSOvskl/DpXV/7Ap82Pbo3rtMACeMWwv1txfbY0hI2EUHlND1mymPCtUxH0Tu8OATj6SnJ9+Zaudm0qX29dRiVzxkgaAW+zhAmozyJgNoNn0kN60OBv/YIOUtJeYf9L7GBCowvM4xXQA4og7mJV24K71BIgQoaut6WzfYlNJiF78HMA5JEh7otHFa7WJrhCOG5Q5ADacMAolxpAAbqKY2WyeZs5DSE4j23NTNNOfroxoggE4VUNsowFE+bXW1K+0ovYokc+1BJoSxc9CUgsnN76o2VbbRufEmdWzh8a2F44Kl9TMwwxPp0ZkWjjJQA4OxF7873yolm2NTomKfgK7GcRKg/ZEFxSYIefn/sElApFRkrXsTOmIvx8Ov8Z40sCmq+uJC2yugAd30Gz1VgOl65Wx/kj5/GCcn1WgkmzP04zqbMg8gkS9PlIgNtY762Sr2ZS1AI08AdBjikTLogM6cUDosoAxaQLs+tjY6LFCSI4BQZVUveuhN8hufmEihVJsbpe4dAKVSv3CaIR2GE9dV6fO03uwG5KsHxi01vnUcHTDOq5N42ANw9QBmozXBMok2xaglD5sXc7zn+G1yHd8AFIJqoEknTeE2//oydnvYlNUBxHqjU8XOMbIEXfNT5O/YYmwLjtxk8i+PnU1Ab9H8NZjHSwJpC4vEmBEA4rXPTcsJxmceVcX14++jRoFjgHTUevyItNed0j7MemhUuwDIzMNs3gljtUUqZlDYiqGJdOvK63bg4ljGs5CMq4uXqgKxmOxRopO4UhwNX5t4L1olGJ/swVZy4QsGbOjc1sWdBxpex67fHq3NCwkLDnlPol42X55CLrWpxkX+VVSGNmBMlBoMp1zq7cveeoaCVKeyvS7u9gnoJFoAAEAASURBVFkuO3+qg9/eyOpu3qPEcF1XwnFfvmcrr3s8cNFWDdIYGtoD6co6L7PUDd5mDKYg1C67MDcwhqNLSFwIXFgwnvdYPC1SlXM8nRibxoaiAiPQClU/GQp3hu2tkJ6hgjK1SOyWFmCghhoRO6kjdQy3gxzQhrqGQTUZythK0FADcnuecWM+tk/1l0x7+8A95mGp3e1bI62WB00YywnGLy6aUZ1ZpE54C75vSfoXY8L+99/+iasQIZhF6CXjWeJdkQH68r7RO2so8JCp11PcOu6fy2NuLBz8jlTYwa/Ulqm7QBYq0J7tJ/LREh4kK9VSOv2Oc9HPzzevY2OzFCphttgHaHrYKYW0A7Ao9TgFsCGQK84ZsvRIMID9EYzoOBIoS5LJX5HRhn7OTarurmJj5Hltf7IdkLafji9VuXSTjW3IKp7GkFT0sTuxfI3sy4h9RnDasIz9T7eP/QdlnSRO1JkaMZccM0hbuoAv60UVGYtIn6KmGezm1nJxj6QEgwyjztpKOYcuw0AvUdd2ExuktbOoU02nR6aaqNaxoUC+S/H6ArwAmBUyL4fjCl8TnJ6sop64hmfOOWiKB7YR3pPNFyvGVfQDfbFvyi9hXO5z/BL9+Hk2slRfbCj55uW8Jp14L+vQJGxaqfMcNX8MtUEc6uXxS12U9owAoJ6ozaNO20+fXL2emitN6glDP9FI67zPeasMmmHPI1hA+zD3D3RZAxQNADtrXIv3gidrOEcolwBb0CggB3Wwo1RD7FCebsQFvqMAhiL5zq3hNS/ci1PvckMVat4oJVmCV/6PVQFCRIo1QOzERJbelKiPQFDA5riLESyILTLm27wFSYMerXKuctggmW9UV+nD2fBw16g0o69Q2gTTAeIVE5pL/McOOQCSK9lmGXzrECMkkpx1TNUBbjvKpW+UxI0EQMpeF3nJePI4HVUKHAOko9rzR6DdTm1OwhqaD9AZd3KWoT+InbqFLNwsY9FmQo+dsltuuP8nXHDr4Wo7SypiwbhNrW2TIKoCE91BVSOYITkhUmnTu1n8OOBDhlsje8vbK7ncqPPdRFp0YhMcDTOZ7tTVAEnw2uwgy9zknJDf8eQhFxqKlkFXAigTW0NVB+uFeNpl1HMtwFHhBt1z2skIHCI+x14Vv9tz1EVVroUuCzNMv5KqU9UZbJJQH3IxxQh4RO9bLqL+l2x4ChthwcayeouJutvii+fM1iIauFwQdLRg4mSItAVR3WdcZhmGcgz1JRf+EcDa2HVc2iLJCvYXZmNMF8D8t97u31rXDfX+G4AF79NQmndDFcIVdre9ITw/cv+dpCBBAMoBjG4lTcIkXV1AytdBLglo25ZQ3Umu+V7ZGW2mBISOVesXDhx4N/M43Luuni2uOF7KgKQeeaxjw/EHlcKmBgDR7uE6uk8/ApBul3JXCPJUB7LudPaupIrYi8TMebV3g96kf2X8+ZA+SoiU1Gy46cA7jEgqgJaASGcISqe0QSq2I5RqqfKmtMttkXGY1JAaOZ/C0K+r/sZmwMYA5wr9Kl7fJngvkR7Srvo4cYRKq5SKcwc2MJQijQHcxlQBY9wpiemsVZE4TlGncaRHzTRfxbkCjG2T92cJpryv9Eop12Ybi3mp+L2r6ds/6ey4F+7YfocECHqbaXW1hbOd0zibOY1aXTs9No0Uhym2g70RtQymXbXdGtNmiTZKF18841H1+wTt5t0Yh+7jNVyyAZK4Jd4nVdEMQL7fpoggJVTfyhPppZEr6QVciVeqSHjJe4kxuIj0atBhlgRklpEqOY8K6nDVgettKm9BJGk/hrOGagWpDG2baG6kMy3yYD4anyTANKqXS8yNjhPtijrEQKriiEC8kicnZg02QAzUGu+DzeOfMZLGATEd8hdQaJ+meqwxlART2huV6gAg6mUyKKsSqC5lmLngSNU7yIikaALAAi2ZG0vMVWtt1C0b0BMpkE8LWN3IW2H4sqJGftZis8fit3WKimxedc4YdNmQquCVD8cbi6uAauzDatrG0RLVF00BkuwzGhExrvIoILe89eCa2KL9rkdl6qCzF0s2KfHSk6QT6Lg2c4wLbdWO09GmwDFAOtr9fyRanydBmCkmPIOv7plcVJiwi0XYe2Ki5kwbJjm7uN7zyft+UomBO/qxiG1+3rYQbg5PX6ycUyygelhyQWXNRbVBd70uEznH/fIqpEf7XXd9nEQtZSLAG16Y9shPNS1j+JRUp4iFnSCEgK6DJGA7y0NiI7sC02u/6aFII3DpofRGWxwj2w+n6N/4GD5778fuct6EMXJX3nbpCj7btZE3pFxHpWjUumwyDlEi3MmIevj3XvwtOZirjhtmdo1hXdpmLqh4BAa6ye5xc5fRD5UaptUIQAZLdbxNwFTNo1rVYKddVT5Um7zz0KC2KDaeAhzDYF3DFuk0qjpTdZirJcrpjhG1foyd+mygPvTIoQ6tSwVG0NhQuV6ozcDAa1Ogio2AWanxrZTP6lXhMUxgwD/V7MoAhCwfez166nZNgrbUfRwA0AeQtJHcVHE4oNeu2yaqGzUeHnNDD9m/tlFGn711gAnghilPlru1ijvr1jwMdFYrCgAAQxhsMUVvkGcBjoJRBByVkCBl2XV+wYbtW+IYWmIdRKlV3k8krGXmS9xE99M84J1Axki8yiOKACjA5llv2r7Wx66qfQKpEqFRuXYSBwmzRAjoMHau442zS5+GhDMXO9TC2x1CW1TNQl1UKQRgTWnECrZe7bVppF9nQqXuicmuewMZBEHRkLpAM1npacYGAukABDLJqhGqejVAxbWz8moap37jdcKw4kAlpjgA0IGJNjtmlwCJL1awmUSFzxh4Oq9xlg91ujpe4yjfDQ9zE9ReZyNkirq4zWGSHlUAFJkBXnBEAK0eqUyhDjiRlnEd/+z6EmATMKFHN+M3kZc2SkXSGYJqc0qulCSZ9EqqC3NVpw3MbDy3RTaEBEaul/h9SSs4WaFrY3y4wSI46mPfJpATlJWRQAmelCaVAMEVPMzputtpZL2HyiC2cgyTXB6ftrdKXZrkT6uizeFuHlpY2xi/HJv8tPW+2UrE6qUl6DgTdnKVOiCd9nqXan0jzI3aV1nHtmAHMAvJwzugXWS+XaSYtnmAxGzARuKaqpjcLzhSeqTapynckDOPH6ejTYFjgHS0+/9ItV6G171Ulomd7WYeFFy4M6+EwonflNkFJs9YBXc+8nr9cmG/M0BBTag/WvSoXmUllHBL7YrG5B88Sdxy8GSfGdC8OB90p3eguU2R+98l/XSXUGYhyizH7cFZ0JMshaj203ayF/hHnrBbsZj2cL2+TIwqz5v81kuebdgLtG3ndcijqMdaqIotEqhxFCayga3VfGU6VBmjDOoTO6quvMOksEqb4+eQpd3xbTtob9mqmCwRjZ6d3a2ygzSZPlsF7PoZ5OP5EXZ7Dbh4E2bDALQFXXeUs5XJ7Q9gW9IrxCl5aHQCOwukA0geOk1im0zjBVF9mTtM1kdbrCoA1T7O5M6fAm9jb9kXLU3f8+mtEmyy7RBElXACUKhs6oGyx9865/8gkq0YNTYU7ekguRlgVzGG22pH874JRt+xJz1i7O17Y75gTrLmjonsfloJkrZDmVvdLslB4P9h4imlojTGvs8IavKs6T1ey2UI9OrlDn+tMH6Xvi28LuqmfBRkFgps5BFcPRnIvPKSo86nMwikR4C1BoFBZ6uovsFRLzH+wtUy3sacC/dMVpc2xavH8fA7rzTHZsjsWmHl2F02MtawnWojOZqp9dLjM+00jR6djkQEkmoYaMuopMI8dQcuhcKZAkz/ADuYZcVK6NTOUfmZ7gJ4j5ZN4FWtNBl1kcHOzgCk4yZxhipPldLiKEALBrwO6IkZkf4sUmgn0CZj4Dl/uk49x2bQLK7OT8P4x3jZVO3rAPYERxXAkuP9Aey4gJahatZD6mMg1BKbKKVGBWAjw5/LEdBWCECrB7t+i7WOd55skPzhbZBnWniV+3RrBTo1og5NanGTNgvsXDNVnVPtThpXGgBb6Ks00HbHXGEx1N0uFsz5ajE8AGquQtt96W1KcQl9y6pFGAC3vwSgzD+nR3AUQXsXafsiD2vX6v3h/IHOGQOkTlYInNuZ5pt3hhykuAVZN8dFlG3B/NcDaHhs5FjJVw97OftnDVD32ugyquKMZW+leuOAJh05MBCgC4Sx2sfpSFPgGCAd6e4/Wo1nCg0ghMuDzSWD9jM5uhiptuVC6dLmTp7Jz1uXurj0un2of56XZxkS49A46bu8bC8wOwqnkqoOGPTRelvf7dofvv4uDJacn91Rwi0/DsM4F/fsxSzckuHmCct2wdTr3TDdC1BrXtZxFvuWDoxEnzZLFd1VKyU7TN33K3v4vAzXMip7N8IzGOAIF0wnBEcwfTJURdog0OKGqiPaH1Fhqb8Ow7DOrm3Y+xQ3vp7fMC2jgKO0uqnqd4dl2ZoenrEWYVBXANjyBMO0v8Ps4nb7fhmJzkujzfRWIkRO1ZBMLUPHPkyztgJDNDxM/noi08YumLQ9HpDp9h1R6lGM/t23Cbq1L9GOy3cppEgBkBxd2326+7nX67f1Va2uhEc21YU6GIpU8My2X1IKUhjVKyGx/tsdRWY0wVbISJu3Y1EyqzrXG+BGGylVEyAmjeKeuDuX5r23JE71+hUcABBLCYnBGJKYEhsT48RP8m8MZl//ab6AMpjm0ANQdWC27Y8a74HexzZ4T9u803KgsX0BR+8W1Wp3HlAisMWbGPYk3RHcfqP+ZBs0sLcFHvuXa+cnMzhMtAy5AHcaCY5SQ+2csmdJepLrnII5l3FWig0IVa0MsD6CBPIccY5mBEf8awFqlgBPq9hStZESmWKehdYd2jzKu6XNj2/FF2nzAu15H+BmirE4IFBqD8cTo6gaj5RnmXsBbIASHRmoArpD0ka+jrJVnAoEQNxuVJQpM64TDO1jBrStybcN15L0JeTp09SqTnsFYb32Yjyj6/QN2lYiQLCA5QZSLT0VdgE6NRj9U9MEzAWYuKZZ3HZCYoNK3dgk0KKHgwNV8bA9Up66jurdTfL8fVrseNvgXS3hsKOE2jTdCNBgrlEKRZ8rUYtEXwtGwzEDZXm8Dj2V9thja9BkgPR4V5MDgFXIq0uZPeh6Ai+Bp1mXH8XZzgRzfBOp48XRpfT59ZsE8kXVD7W9Et7vXBkma0uM5WnGUIOxoySLMilAyZD10HW441zAGxImC6dePZ2axPjLKoLPjt1g3ezQPjYpAI2T2B69S+cX9IfgWAnzcTraFDgGSEe7/49U64U/OZilLEGx7LJDyj9F/PlMQZLijuL3Qd+bS9DWKlDklM/LqBy845sfFBzV3Q2nKBdqJUHL7MS7+6tnJVmMIsVCy7Ljwqv0qA9Dun+Ncz0KVqPIY/g7dnwpoQA2w9e+XMe2zp3+TI1cqgyQ8YeqtF/7MWWAyJHSLLZQbVVh+NcgDkmOvVO08+5rrLqa3uICHMEVTJD3fHUq6D8MjqIrkI5s4AhhpEPMleDQKVfEVmyv3301DvekA0ubpyV2RWEA7qZcad4sradFGEAj3G+PsMNVYa+7zAMLsvQyY/c8jOkUAGydWDWj2CPUp2CO6WPJdJikRMJ4U37v2bvQQDmMjLDf+yWvuNnQBzA4lnwX/qClSNVyF09ZuJduzuEcoZYalVWAx95Mme8lfJz6STB/HNMgVeXylo5vfm67zOIaerUGT21jG2TQ1zZuu3sAMO8QpFiGIKdEPCEBSh8vaWswwmsYkSgxKkaBv5vtydTEK5479N5r/jpuKPNs2OMYsBWPelXdbsNo9xmPSlyX8M4XoMV6UuUyTKvMNR8hObJeOpuo4dJbgDQeqk5KVtgk4UPG1g0fx0mooPFOqfJlnJvRkgb0tTSFaplP9AQvayu4TQeKwdhSzRjLvBQE/7TqzpEN7DNTmqPrlcd0ACRXkZgs8a7LSBdz54B3fgl7pSleaUyOmFk30iL8dlfHEo5Fzvmq6ylUe55e8zLj6hr2VTNIZhq0A5UymG0dUCCSCDfZbt6oon2lvxRS/ioSkpzoR+oh8A01WWkFCNoAgFmGtHgJoCBweIBhIehwtJcAQCjkxTM+1wI8XGku49bdfiil8zPzaZagwa8C4Fzvdqe8ocD6AsgyKKvOFsapsxKUPvZWSpPJXgWEACYK5XTBbj9QwxgjA4CjEEKpjPZKOdgvYwlbSG4IgFWbmUjrZUBdxw7lb2hedPy68eFYqbTX0tOVyXR2VMlVlEBvldMThAuwr35ftT+d4dDPY4yjEt+TtZW0sDqLcwneoXIz+nCNsUG2GcgxzpQ6RbJ45kf7Znji0V7vC2k5xvY4fXSGPtbB0ChzlUA7R/zL/ZAzOv48ahQo3tSj1u7j9h5BCjBPsoDCSMkg8C8np/mcYOFYmAAJLDr5rE/cLjkJI/rnr4RnJ1OfSVbg4nn/aY/jDlfEdog7dn9YjgFJs276Kou2gGp1HUfWm8DHxQk2kfvUl4+lCWlYXiQ1OjV+hSDPgJ1FyrluMzzFeZav4jC+QyWPvHef33HT6/2DKtmewo34cHEuZLDAMA4wOqysssICugY2DlmuEHvTw48c/phypYbMn4u29L7eXQ7Dcp0yzLNwGyh2Bzgqcmc1X58EIC0LUGQgc48Xl1/3b5lBvHKFBGuI+bDcDbkamWkW+hH9Hu+TCMWTmnB9a6qaFC/CPvd6umAkPT5ovFjiMhKbl5EiPVzFAx92D/BrqcHO9So9bU63S24IKDnSNs67b2kFHabE0aCd2q7sccdWET7vKNJ427fbdmh8rqqPu/8HtWUrk/t44FjTBknPXG08x3WR8HSR2AiYrF2RinZniYQqgahH4bFwHTsf9vO5l3wEAgIrAIdOFtqbsYx6OIAwcKqgJoOifkipqqjy1bB5Mp5QACSeEUB1+dNhhBInAZaqeEEt8o1EYXrPM06SfxksCTCgIQywirX2R7i0ZixtgHRsixIOIBXSQ/McTSvt7JihDKM7P7Ga5hh/qtOt8Q46t406ZnmZpFGFZ3XMIR1UP4s+5l0b4FlPO8txNpSce0csy+d4RpoE4IinOGau6KzVY/40nyZSoxuoWq0Q6FVJgc37/9l70+g8z/O+88L6Yn2xb1zAnRRFkVosS6Lk2JZjS7YT20rjpM3quGmm7Zw2bTKdTk/PmTMznQ+zntMz82E+TJekteM2TlKnjpN6nHiTbFm2ZUqyJFISKe4kCAIg9uXFi2V+v/vBS4AQQFGWbEcGbuDdnuXen/u+/teqjZoEdQHJ0cQM3hztE+rQz1y9kmMmEstJz521rJMIPBLBDTaIGdS6FpAMKZ2ogJlSTjy0MQDcOJKk+bp6wF8jki5shJTwwEiZQgqnFNU4RAbanWe9yexoqBgpSWlSC6wpXkkZu9PsBw2MSQOHytljKny2OWcbBVcjAMPB6fGkcrcNyVFnXQNAzL6gT5MkzZzpo5Ql46EIaCmlmEhIeFU3rFCtsaouKnCoorvuItKdckATBaaeTBIZXIwnr4UAoevSMOtr5qnvs0VE2yfdjs8TZGie8AMySFK1KVcpYJG2VwPOqrmmG7f1bUiXy7Bfc+xMRcCnDJveRTwrLjbF88yVGdprIV7TiG3b2FRTcthQ3aQDJtUX7RNBNXVJfeWccO9lfhmnrpS5BSwl5xgDgYpoLfsLey4zsJZnpoy1oYm62WWbaeP2QIlK3Lg9sNnyDdUDEkdyt+FDLS21aV1no2WR1jVx2kyLBBFUAztbkNOKXOqltGL6xspaWnBZWNuq8tHOYu7yfbVqKgZQzzIGRwdBO8mVMudiYG6UTX61pCrL2KwmUBWR3cpeAmHI5sFGplH+MC5mp+V0AqAWJCIgDNxkJD6M4r4VF9DsAjFdrQerwVQtl3a5YplPKsgcCyDfjIte4ipmB5Nnqb8GW4HAZy0gYm/LCRV2lpKEmMmAwNmWXDrzBj5tPpsjuzV9BrGJrcw46iGJi8gpyAX6GgIcLm4peK5k4PUkUcAmSlRMqa7U7wmUrLjk+rU/pC+ZJPHGzFXxiyZAXSOep7AvKh9GBQ81wJVqfzJ0Z7D3noA4naqlrfbF6ySbpZqbcVrsl0zat/aNXqvjam2R2pTwUc4l7CN4DMzkllKSoia7o+VHbeWNjpqqpapb3mpKc4wZoxqrhJSMEr2urc+8uNWcf7DrcoAV47pI7E3M5AETSEgRe5QlwMNaAJE7B1CZh2AXwMwAoop4jKsAIDTW4AABSY6gY2pGFboGztcynbNtXVBUWzGdJD412AhpJ5TcdlOGk9WRcz5r+6QESGJRACY4SmAJonyGsuYETKkOmQpuibyG/OR6AMFUc4yrCJYQNisgeaRnkucjgT3yLZtGqsXapiTBetUDDFvxXNdZh4oT9ym5cs6kQLRy+kkTAF/vF6YZ+0jC3KsMUjuDStwwsi1RvXZzE6jEusaZh1IJRQVJ5Zivi6qILRD1kz4bARQVcLwyQbwwx9xHuJp1sgLQqeOCMqRmZczXYZ6hszhnGeTZr66qj1bW4WouLnNxpqN87go4MhCgCLBdj6a4fgqp8jU9TeoefXYSJy5DrFEEw+XaCQI5C2pxQUGLWHYAaoKAGxJAMWtFdrSM9elScSo66Lc92EFWizKsdNZSPqk3edRjj9TWVIezi3qO2V+okyuN5/45pVRcIwCqwk356pR63ixpk9+rsM9RVbAC6WBaGFJ5nAfU6KAhqQOmFnDM+7I3v6Rk31QIrDw+xRMGwKSaaTysyxSAbpp8Gutr03p/gX7ZAYDcguqfwFivdJPaWQmIGNRetAWqct3xYtlIAjDW0gDG+YbhuDrcDSBtjpb6QZ5jSizV1dLpywrVKQHPySlFqmtWR9/9qUfIMgB4bQJD2IBxsEoVPc+neZS+br5t0B7IVqIN2vjNZv+k9ICbzKrV7yZNk7ibZ2NNnCYXem5trWqIXYutcf7U2di9d2ecY3EVJEGpkFPG0fTCdC8bjzYAma68ZHREV0VDXDt+PoGb7Yf3YM8B0QE82VXZFhdfORs9vVsNrhFXi8PpXmss9zI5hGBRdzNQelHAi1grG3JvtMTlCxdi184tSYVuRAIAjrwbmO5Jq+DG2uI2DHRzQ4V46cTJuPvhB2IQVZNE+LGhG7xV8ON16qIrPdNoWRmMx0p9tmqLTmd+9G9ZLSSQBEnZ33Itsvou//abaityng1YW2rLjVfc5BdlwCbGcno6KicApuyus41wjmuM+WFdjNeBNygAhoBAOyS996kukwiKUtYQUovGPUKSoz3SIl6c3JglNn7kyXmkHlEzuvrNuAKGU23djMtUjhoeQWcSlxxtqhgjkv21PHNOri2deysASSpHOyydIszx/AgxdOcuI2Ht1i7GNebs82VD0EkwDqbg+AMkq5vl7N68d+xjnw1n79p5U+dUb6/wmvWuWi7HK6yrhDO0Ykp6DauG+JcAX68Vyzm8td+cIhWwtZtqCSAKEBpHnW0KVTulSDkcHzgw2gEJUpTw6PFOjrjjVbMIkYlEQ0nOJK8iICaBCcBeDuI8h/peDYyaOtTfqitnWKuWQVHyXrfUlNRrilCWkp70KgBLAjevKwGmWeLxFFDZU8rldwGbEqaklseUq0MipaqT4EeJdnIjTp4KMSVCZ8lrDhCCvAUVsWmcnsxEE6qXeuy0DhK2K58r1wDHV8aIY+S6q/FLBc+pY63K1DSOWhqqDRKdQz0xF0MAH6UALRU4EIAwHoZJVWSe1lW0RE090ubKSeyOpuFl2LbSBCyL7bXt0VTGeYCMMXsMTmqXlI9cREVvjHbhBpuynf/OSetbQHI0x8u6LCJdmiL/cdTU5lkPmnRMAkDRjlHHPxOAIwOtOvdc35ILatqX2cekESDHLNk+OiIlzwj6BHIXCSTWAziqsVNISv7SdbRD25kDNZ0xU+M5GGUwz/RIZ0wzVd6K1FOX2xW6EKcvS/mnjNZ6S30PCAEo2L6SG23zTqpyVpHx9NxaSScJqlTOjXN2FklSN9Jjri0CjnQdroc9225cLMGUzL7jZQNImdWggJmIdK+A2qBAV7W/HODlNj7R2owX5q8tFYktEiB7IjeNnRzjyxyX0bC6bc4p1QiN+bUAIyzrPo7xRccQyTMp66R2Y2ojeGyReV1Ov84t2aWt1cbNYxujBzYB0sYY55/oVsppfiPEjUChwMZljB03VNUmtla1xOlnXo7/+//8v+Kf/PN/Gjvv2k/QzWGIQTmqcrJ4cW0R9YlBJDptACIENgl0VLA5V+Hp6dlnn4NbtxgfP3h7bF9sJgCfHPzFePo7342fbszHtu3tUaWqAbueRHRZDdw/iXT3GTbW/iLeeeCaGtdmYmQsPv2vfz/+/j/5h1HVDEWLW1w38HaAXAOxTNycazFa1fX12YvH46t/9ZU4+v73xK7qzkT4l7EpSAKUk78bs96TBmbHIDS0Vbox6cp2DhUoueo/tkTfwh9FHRFPW4n7CcGKZECCau1tOOs2x9EYHsrK3khiXwbUwOUdQu8rlQAxrlenVsYDl7mlQgWu08UZ7DkKMU7cjXZUZhoxDr+eKHseb1Fp966HSM3DqS7dfP2iH80XJWDznXCQlRxZpNSVqRbJI0Qb1DKcfIJBIjEarNIwHoBuP6zXwdnd6V1CI5ekmhJNEr3lSTLqeM3g4ERCdi2CyfG7vAC4T+ozEB+TEJpNzszVs3BFYTd8Xf86n3vrNM8reT57nX43J8fT+SVhbrJd2oTIMMnsNW6hM9Kdb82b87AKTn1rwyBzv5DccA9PtkUl8bVqAElKtypQL6oBeOiFb2YW8IuEqMBnAeAkmVrOIHpvDnueWqRE2gTlEijKJGuWsRIU3azmqfUQpqXxWQmYGhbHrwMmJUy+BEg1lGfgzkpV9vjLSWwyJoKJ9EcFrImOMkrzREm9640zgcr5fj25XqkyWWT+VqX1WccIMC9gCqlGPAPxrHy/CmJ6X21XXBvGG1kttm5IT4zjtgAQV92us7GZZZN1EunRYGE0tjS0xEnAZAEHC/MCEcoxgPi2+o545fw5PNzVx+GePfFX578Xezu2xpb6NvobwAmDJLGZeFAWvI/+lvFUpfTYPaSlE8kGkqwxAspSt/a6fPS0tEc/58dmrqY2V8I8qTSQNnlkUt8lsEX7fEwT7CJPVbusmSlhJfqyEiA5CMDtY29oRFFQFo3JJ66M9aeBsA7bqceZRVz0M7/1BDjGK8WiA5TIyKvWe12S6qRbszfnhfOHP7M0V0ciPcceSj8AKYArAemiYAWQZpDZJHH1PCmrTfZuBhUyiqj3/CBtqQWoIT2eVWRNqmAfojlIkhllJVuMpxLBc+yp1eP90Q4jyn21XqYU7VIFr4w1RvuvHWhKnJ7B1oqxtR8rkO411Q3GzOjWGPSZQUJYU6nlEAUsVScVyptqhRWqStJWNTMEqtpA0f0pORe3l2MHtYh0lhxs72syyS7dfN9APbAJkDbQYP+kNdW1TRU0JSpy5Vy05Q6zvLlOr5PQDx8ai4nxAt618tHU00ZshdpoXqyLP3riyRSo71t8/uZdd/K9LK6cOR8jA3DA8Q40PT0VR+69O7a0bouhC1fizKnTSe1j957d0bxtJ4stG9nA1Xjh28dQERiNu+65J+qbG2Lv3t2oP7TEtXMDMXjpPEarWVR5JVX9VwZiYnQsdt+2P3bv7I6XZi5Re/ePuRi6OggBArjhtxtyd1VTtE5UxukTr8T4BFHnO7ri9tvvSBug9hSVgK/JV/oT5+vwoTvicl9fvPjicfJbiL379kXP9hYEJhOJmCxtDHaSRKwevrS1kaD5cSalEm5eMIAx1q7EEQNepNZVoWKkGWhtEzIVuFuve7qyRJjRGdKEBcZ7FknHa3LxPJ1iTKYxOKK1bOIoZi11E1ejYrfQ04iKHgQBdV9N8N1Sf1JAIkyWCn/D48B9CxrBA4bSvaW2WbjfpbYAbwt5CCUkoFVFCSjJ1qUCb1JJr1AFNfMAt3y9PSWRgaUIIAU3wzx/ayW5tTiHirk6ZiLzV3WXFGdkrYtXHBOELZe24sSKrxXMkRxSD5153OypL93iOFpPVaJKDIFy86CPkvrqOm0o3f/D+BS86Ao5XzeajM4nplFXAxjl60eZ17pFV6paRrDTfLIRUsurElsWbYgEURqqG9A1V4k0FDBlcshvBRQtzzPneIIr6f7Sm/2VHo6lkVgJmLL8yYH6SPSX4itNs2Yph3VmJK9yMHNUQ6sApGs/o/qvkMOVTWbVkhymVGSyT3E0W5lXvRjut8PCwnw/BpAYjc9M4M65Is4gC18kppDE/V88/2T05Nvi4UPvjDbAyb956j/HuaG++Nvv+WjsBug88crz8ZXj341fe/DRBIIiOlJZPm+q0wpJnnz5uehp7Ygdrd3p2oUD87G3tze21eDKO5UCMKBOoxDnedZi1cOAo1HR0BEvjg/H5557Emcbo0giqvCuNhn39h6M9x1+J/O+C02EibQuVNIHAsQ5QJtBnsuqkWbCnFL92pleCSjAzUXyqGegcIGm8aBGUbGTAXAN5tYs+Wt1RdXJhz4ANFYB2GpUq2QgrizSRzjLcE0vB4w0IMmx/kkzkGM8Jmms/KIUR0BWj32OwNK4dZkKtqPOoAK+nBVJZY48st8worArUvuhlKy7z7jj7VwQfM4MsBfzrFdvRxKklH3pYqVLORiHObUbqA+dms0druijjY5xBevwfXUtUVcOJyfdCMCmbnmkp10wBU7ODANUOcHteoHsINrvaKE1BsY7oq3xKuszGgHXSyzVMqtcWousIzebp89JLQzJLahV7l6st2k8a7zRGO1cN9PG7oFNgLSxx/9t23oXZYO+1sIBdKmVoySBpJOCFNcCotlFcHWaJa7FhW+ciAP5LXFltC/i/v2xbd/BGLoyGGdfPRv/1d//rfjD//BZQNHV6Gjtiv/4la/H955+Ot7z0Lvjmeeejb6Ll+PvfPLvxB998S8BTBrmlsfjX348/tk//W8Skf7qq6/Gtq09ceLEy9F3oS9+4Rd+MT7/nz4f27q2xtPk89WvPx4PPXA0jj2LM1U8Ad31jrtj6NpgPPXUU/E7//0/RTqBBMCNi4ob2M8vrtdyyrdUNMZ3n/5WHPvO96JnS0/85X/5UnzyNz6JeguELxvv8RdOxJ/98R/Hu3/q3TGxbTw+8wefSRtWLlcb3/7Gt+Lv/e4/jHZA4aUZ4nikErLesSxBSBW2D6oFUtyPNZXKlwut4fcim6EG2akzbqgZG7NXIFlb2Z4bLln9I2XOG5zhclRpSt3gYbzRRlHXTf5YIwkIkkIZG6uERQI0XCcHFOoGjqv3rnPzGvl5KHMIsrRhO4OZsm7iAjDVB2+5XdbDgVyv8ulUBv4qIU5Uk9MW4laSpI8xiFQrzbjfK+/KCKOUPW+pCitPL31XxaW8DibGOETxBG1soaavfTxX3GlOtv+mLUrnZZLkABgzEJClMVmR0Q1fHR3XBY3yszHM6qyqjQSjEibXkR91ctrYVmMKaQ+UjbsdxDfWNqVGqtlV8ow2EP+lFtUiJTfaFGXwnXfyuBVQZNvM3/K0j8nRf66fAmalPDfrw9QzEPpZbc3JMn332HKSwTPPWqt615zSb6TdLaifKhlIl3KTSmcFy1yxTpuVQGIrXur2l2HXiQt0qoa0ARvOiRG8Ns5EN9R+FcyIK6wL9k17XVO8Ongx3jt/D9Ih3EMPXI7jfWdjYGQk9nf2xqt8V9LegAOCxpq6qEdFcAxPdXqozGFvk0/e55JioE/dkrpVZfQ2tKd18eroCPZFBTRXUcMDcBTRHdPtxEQNBDye4P74609Qj7L4jZ/62egEqD17/pX48+e+EXdu3xsHt+yKqwCoAupuSuq78TDnWnZtknhDMNzq8JDZ3tgC06IML3y6DcdzIHnXoiWwiEpYDobH81PnY6A4FgP01EUYWdtgZMlAygFSZlEXnISKM4hyOb8N9CoDIBtfgBySJdeRcWxYi2g3FKawg4JBwSWsWwib6xvQhqBd7DUCq2n6GvYdo5AGlU/nH4UtUYqutQKhOdZJVeOMEVjjPoyUJ60E/B7TdgxHFxyKysZsdnLL9ZTWEMum3Fry9j6lOgI0Hd03MPbt1V1oW7DuF5H2IdmfQe3O/bJrtixOYruFC4mUnxK0ptahqM4Vo2+4J0bG0dJovkJ12S+odmm9shTntUBTlkMpGT1vZ+TjwAIaIUvX2z8ylEo9ULp283Pj9cAmQNp4Y/62bzHrWFKP06ubJFRpQ/d7DsIvx4Y7zuZp4DmvLSW/GyCvZnw+3v3I/fHNb387xgZGou1AQ3zxqS8TRK8m9uzYg4pAZXznqe/Gxz78kcThPHT4cPzGJz4R3V/dFl/+4pdYPBdiD1Kh2qZ8TI+Px/PPPh+DQ0MpvsSRO4/Er/zaJ+LLT3wlvv7Fr6Q6zEIkGGTPjeBOJFOf+MSvR9uWrvjCf/5C/Mpv/lpcudwX//v/9L8miVFNN4bRhiBfStcX6aWNpK29OY6++ygEUk289NLLcfrUy3H7oSNJWvSp3/v9uPPI4Xjf+x6O7xw7Fi+88GL8g9/5R2wwxfj0730qzqNG0nR4uzEFX5MkxbTpkVB0M/nrkGy7UgRV7yRa/bNmacP2E6KiBg7qLavXmSFzYhHpYeUYDgMm2UQ9dovNVWVIF9ECt9Kc4+4sZVRi6dfNPylTOM82zCtzdpC8qyXiNDEvExjJQWHY9psmiZeUSp+SLzdP7P1wZ3M4uJ2CzLAW6ycBqHOiiueqRGysvtrnTgnTjQF+b7wqkUG1qMIBJivG4B2jZnezeWZrKq+37ca8Vv+SAMRKBLso1bJu3h7zFQQl9S1dS/Nn8lNvadpWXfeWls78aN+cRlmNVkxMvzJjtLFoqh9GzQk1WSRMCQzxDGRPxa3X07Y6XhK7gktXUYtQCqvNTAEC980k58kCAToLBQhSQF1UNyK5qU4uth1S7WOmYWQJyJKaWCpMqUQGhMoAVFuQGdUDfoxT47OmdoDexZQ8aSe0E6bPFpgSlahp3dbTG9+/eArHC1NxdXI4ucHuyrdE//ggKovjcWFkIPZ17UjMoVevXoovHn8qRokZJBR+34F74917jiRQZL84l+1/bY6qKe9LL303nj//alLJzgGyPnL3T0Vzc1P0TfSzx/D8jg3H5Wv98Tff+YFobsgnz6P37TqI5KY2uvKteFkbi9974gsALNRzG5rjl9/xgTjefyaePvtKUt0VzPzC3Q8j+WqMzzz9l/HIHUfjrm374msvfy+OXz6TynMdKKdPjGv0Av0xyBxvApTg0iMaGf8ZpC7oOMTlIjY5gCzVAKuQ1hn+oLaM/qf/puh4IYV2OPMADFWwa2tx6gBAyqM6NwDQcj3tQSp2jTkxgtqsK1Saeml8snlZRd4CaqUsaa4QR6msPlNBFKyOo2kxQ1gGveGxWGL743rECDqxlzJz/TbuVAHA6JqaVDJVJaQ9rbhuv6N2ezTj3GiBfXMWJtbUzGTMACbNQ3u0CsBc+dJaqWaF0tW6qolozw9GPyAphy1fK3Z9Ius59j4uSPZU1oXirq9jslZvExwReylJNJ231EnVRNeCzbTZA5sAaXMOvC17AL82ab1duYB7wE3PlXhNLjCrYxV2GDP5svji418mjsJE3H3kaCyg7//EV5+IOqKDf/XrX2cBroxvfv0b8TOPfBBCojJq83VwWCGg4B4mDiI62CdwiqA3uTwbjMbDqqGUs3k0skmaKiHcBVrW5TpBz/lauJDz5FWLikZ7p5HYMepn0fcadevLIESvJ44pTdA5QIXen+CcXjh/BYcMx2NLTzccNTYi6io3/ErfFa7FvKOlBfuEInr512JsdDye/NoTVi2279oR+XxTIjSu57/ii0SB3MAMhPjrr0/KsVnJKdTNt+TLyj8JmjeU2HQrh6ewP0LaYIclPGEeN8ykNbO0XFVR5DK/BiCteccaBylGUIRCWiLmSxKLUitKNUlj4VRO9VsjHw8xn3TEYBcs2BadRcCZhQJY54bSYYkc1G/wDjWCOGe9q22vUqNaONY3q4ZzV+LGsVi3X6wjdS1iUF4xBsELowJfJGtW1T4QGKtqeatJQl8fkoFdws2AmvnZrXLJi6jsaAtTSpZZjZ3IHPMs2ViUTvyYPx0fXWKrRpcNLf28wrHCG6meo6T9lc42BEkm83es/b/pc8BCktYHxltiNV2e3rxvOWnbXljA1gcVqXkCmXY3FHGEIOhATRAJx5SeByFEs7JYq5FsGAR1DrfS80haZhigU1RNlzL11pMrVRPrBtQvsjzWImXJoT5WyT0VeDvb09xJfRbiCmDlLNKjrS0d0dvWHRdHhuIs4GUCD2m727uSOt1nvvuXsQUpzqP3H41vvPxsfPHFb8XtHb2oODKDUxdkM9i6XhwbjC++8J14z/4jcc+O2+IvUKO7ONQfnc3NcYKxaAKQzyORcY9oqgcE5uqjb/RaXBq7Gq2o+jUBegbHRuJU/8W4a8f+ePSO+2BsVcerA5fi9q07Ym/n9viDb38xvnLie/Er9z0So5OTcfzKaY5vjWcunESSiNt0HgGlbGq0Qe/HJEysU4CXcqTA9UiHmgHKqrkO6EJ8cgpAwB4CEyKHKm1D8gq3NL7MF0dPhGAsoWriJLWxd7XiGW8WZDqC9Gj/Yj7uqGyNcVQAnypeBXTJSXN2ZEn4mD2TzBYqY8wrVSh9bpw8RSQvY+ypIHh5iBxx/QDQcq1geA5w5lZZrrSdvOxp1Su18S3jfG+uNe6o3h7tZY14y0OahUOHWW10lXCB8xZQXVwgOJX7qu75BTypVZSlKnp9NXZMSFRHJtqT6mk9ar8FAJwBcN33czjSsE7aPrm+NjOzelnbXBHck53TyVNi6iZz3kwbvQc2AdJGnwFv0/YvL9ss4UsEoaozEp/JJSxcttULnNcpJep9+K4YPT8QrW09sXPnjjjzwklsksbjo499BGcG1fG+5ofjc3/yn+LcufN40alOi6/dZDGqPl8bHo5nn3kW6cw/SBvAs8dwzsCmb5LgtdxSndLB65V1S8h+eF5gY6bZtcvc7HQPmcxDzA9fvRaNZa1wU3VeMBvffvJbce/R++LeI3fG+YuXAEnFVIeDB2+Lj//SL8affvY/xY5tW2P7lq2xY8eO+OkPvT/yTU0JMHX2dMYFVDXWS7ZPnuGtk6Xr5fTWHrfPNNKFxFrKuNSLb7AcBwZAutCArZWosQZJEBtjmZswBPt6yRHzVj0dZV7sGLb1Ln6d40JQLQS0fSjla96rk9KTTJp3s7LY1OHML+AkYrGBdrXUU8+1cludewZA8gCkKbi9xhFa7z6lM68/HyCEkrLjzeqqm2HYF3XYVUwg+x2C6Msx5zMafVUFMy61so3S8yRh93pJuw6HFRlQIoDWu96ctD/Qbbx2SCtbqD3jPA5XjLmyJpNlvUx/yMfTfLNxbzJJsCa15Nd0vOuQfZc9WytLEowVkqtvQImRV7lGD3bGQZJQztx76xVUYrfkjQ/vmtXF2JKfiB04PamhX69BhCfnASukfHNImmZRm5PTbxyiGuxTank+x7n+VcAAcYWjEbeLkrbNgNe83uaQ/C3gOGXWwKmou3W07wCQNAGGLsdL/efiwX2HsUnqwDbpm/F91N1UntuW74zz2CVdGrwaW5va40L/lbSmjELQjyJ1oVvSWgBWSz2gRLce8CCwuopq3/lrV+JdB+6K3pYu1MsWcNkNc4wr/U99xvVKMY+dfSmeP3cyLiG1+pWjj2LTtCVaiEv07v13Rk9bB9ihOh46cHecH7wSr1w9DyDEu+Mk2geMx5HevXEKgHeCNlwZHYqfPfJgCoI7TgBYXYKzEfHvnuE/+xz2kv3leITjVw43/ruJJ1RW3RxVDXpCzJh600IQxm8OZsAEa5yqrtWoO+YBSO0wK9QX6Me2soZrdqLCDYsl6gFf6XHjGchgjrOBZ1LJDZ+O+RTAY2xqIhryjYBLr1+MSeqpKlxtriHmpojxhVe6Fhw2FAFxSnfNNIWnACglTUtBDm0hy+iqzsddNTujAztbwfI4+7FtTjGbsPmco46zXDyKs5cK6q3DvsUidkRKfABStqtG/zR1qCKOYvc13oq3zH72RgCRY2u3AeYyhmJCVEjQcfZBvRpxQuE5wVF6CKhSiotl8zfThu6BEsWxoTths/Fvvx5QNaFEJkvKJE4UG6+c32xZX7tNi7DiGnCckG/JJ9JIj3GnT5+OB9/1YLz30UcwEh2L5vmauHDxXLzyyivR2a4eusQsG2ZDQ3R0dURTPo+K3Z740p//fyzWqH2wCcgRa21uSYaxGnvXwa3q7OxIHoB6kPbUEH+iGaBSCQGgvn890qquzi73BtyYVkcPoKYad7JTLNQe071pA+V88/Enol7vTJx7EK7nO9/xjngOQNaPWt4oQE2CoqYmF3v274u77703hgYH4hvYG/3tT/5GHD58KP4CNb5O6lwEBHRt3RKFHHYnFvCaBNHBsUSQAsZKffuay35MB9xH2b3efOlspIttsLNxhZ3iBTly4xAOSBFX518qTfAgQGtko5bAKR3/QSpj13v/mkOwlKGARK504o4uHVvzw0x0493dqIghcVRLG/ya1686qBpJEx75kgrouq26hdZKWZMkqvy6XtuSt7WG+ZgeZc6OMg+RilR1rQJJ3K/ajao0cqsn4ZZLrNobCcxIya6bIFKRBDiR4T1zH1TROskaz8LUqIB6UppSAoh+qnpTsJyb3L9Otn+tDzufknc52fhrJFeAbBUondQ1d2VyIz6K4wg95+lCvAzxgLGOygBIJj8FSzqWmMN2poiNjw4n2uvHojt5LavGsxpxiyByV8aB01PYLC6flRY4cSogVLWJaYSJ5SxyDRrheB/usheRTuxG7WoPMCRP2UXAU4Fj84UJvCnOR29rZ3z/8qtJdW4btqO727dE5Yvl8e1Xj0cH3uyakO5oC6Rt1LXxkfQ8z7MXvGvfvdHV2Hp99kvoO39dB5sg9B+7671x7NzL8cy5V6IfCdVHjrwrdm3fRn2pO4R+M3ZI9tkQDhp0EPTuPXfGXVv2xL/80n/EacNEbGvO5qDAQDukYWyPPvv0XyG9rYnbundic8aajyaAu9Y9Ow7E986fSBKlSjQDupo7CAA7GmOCBe5VTduHLBH9XD8NAy1JSyl3G4Fwd/M8t9S1svc0J9Di/C9SripjVwjwOsq8Rjc9avC62q76Hc+KkrxpgIH2Xo08YQIcAdNYOSrISKWVMlbxaQwoHQHJTChy/QjAUrChREyX+aqzJw0I5tYinlsDG6SO7VWoVVaSH55CeZ4qMZyyDTppmV8CSYsc1+713rrd0ZNj/6T3E1BJ8wpwQ5XPE0vqynQfHgIL0Y+q4gJrXgI0tF81vMRgZEpXMdeMDTY22RwT03iRxU6vHtfuugmvwv7N+rv3qqKn05AiAHO2SsC3VCb9mBKfukdffJOqpllmm+9v5x7YBEhv59HboHV3GZvATid5m3E3Y0HzmC9/+rpZSos0G4wiejn5h+65M+rr6+MKMYrOTQ/Etlxb/MzHH0OFAGNZAIgbyDDxM7bu2RY/3fZBAnBWxi//1q/FqZdPIYVqido6wA5uXbUrUtf8Gp6Etu/ZEW3trRh7VMZjv/rxaASkHMrr+QhvRJ7fuzNaO9qTvUNdc2P84id+KfJtSHqI81BkEa9paohf/XufSGoGtsWI57XtTfHI3/hwdO3bzmJfHo8+9uEErlpbWuORxx6NaYJG3v+Bd0fvgYuJU/83fv0X4/jx4zE1MR17D+6NaThsI3D53IRSt93QSVmvSSL9RKc0QdjE2fSTUwV/S1Oj/gV/MzW91AOesp8loJshlnTvLYnwZsCjm3GN7n7Z+AsQLqvzknRVBUpVvmyUUpXWfwPwlbH5+wyk1/pXvuaMQKQOqUsddlU+T2uVJ9GnRyxrk5GOllN61rLaS9wpFfPabBa9pqh0wJ6rJJ5LeSt6UtgBzg3Cv8YWpaLNHid/PyDqJGImcFZQqJ4jbo2SPaWagiZUaxgsAYx1X+tJtw2CWXK9KUDyblksgiSVJrVjK819x1xA9tdJzY7qvumkuqR9s9Y4m7mMJlW50ncmqC7FRwkCa5wl+7q6Co9vSdVvNrkRdwgW5gFEvAwuWyRIrQCjG1uQOuylKvk+BEGsWt2MYIgeL80PiylJjlKBZFZbVwvx7lz2X7sjiG4AzcwsQV2RLr20cC0mc/OxZ64u6vi9gIpZmZ7ckEzt69ken0ditKOjG/uTfHIR3dXUBtg4hjrbrsR8amtqjk68id6z+/Y4uusO1nVACwChFdsgAVjyzAbhLMGtpO3c8JV4vu9U3L/j9nj00P3xL//qD+PFS2eit7s7FpFeDc4Mxa6O22J3Uol7JbY1dUZ3UysAD29o2EjVIEHRq2WKd0Qj65F8nMYGahCnDx+670NxqHtHXB6+GmeLfUgs55LHvbb61nj85WMJiFXC9BiECTaDGp9JJlkexlsO5lk5kjphlapr+DyMAwQpb0OlMdfYxL6Gp0jBvc8jbcTZHw4PWFcAMwXCOTSoXsv6omOISe43tlJvWUMKfDszMRUXcYk+hk1PA3uQanqlmGE+3c6RcdQadXbkeVVUfW6nYU4qlfXH3GhFNABi8s2o+rHO1iEBVFqTLM50aMP/wixMTcBNOczFcvKoZQ1yXiohU11SEKMq3DnG/JnCmRiZRRXY9jBByyYE1HSIBad1wN7heUUaZ/wvpUgzYzWAuNaoaTY+F3ZsSxNvAakTjwA2SRnYSw5+GCP3VzU2NIRz3s0yH+YApR2WWZq0FrOZNlQPbAKkDTXcPzmNdRFLyYVyKb3RdWyOxfb07EB09TTBcS6PkQKGnay8V2dHozlfH+VNBGEkf8nmM7P9cMAgurpq45nJs1HfhKre0dtY9GG0sbCPUB8X4RkIi/PTl1DPQI2oOxenuK98a32cnidAbF6D0sW4MH0xcTTrt+TjXOEahB9E+PZWgshOoe5BEEMIi3OVQ9FwWw+mylmymf1wUueJKdN19+5EQKg7Lvk4tjAci125ODF1KXHe63e3xSvokLuhtN2J2gIr/Cj2TQPTV9IG52ZkXYtsjpm8bbmMxHWUvGTTWI+Qyq7+Mb+ncZGklZixpkKLN5DcXE3SEXAzyeB6MrdKzquaUwentbWmEZCU2YatBjTXb3oDXyTAcwkk4VUKkFRKVkHJUQ3G4BLoSzUsnV7/s9SW9a9Y94xqaXmA3wy2CwKGlcm2Oh90GlKGn2455dbR6ySUnDs+hxJjOgyQ5MhG5MZ8rueJlKGSeD2V2AOU15GTEocRnqkJStJoQf1VJDr2/1wbtmLtc+m796cykRrgCyzNcW2F5G5Df5FWjb3zAcmw+dxsvLxVDrxeL3VfnRJVoFapXdmBH8I7ZdhfSSmNei7wWsTGUMmMKmyZytpbX66gUgmA7V49Qo6ba1MaWVQMx2YaY3QCe8Y5VN6IrZSvG8ZJxBR9bv0yNVzBVgMOI6rKpgAy2FAmXSZjMhm/DJVg1qciwAi/aanMNFSpWYwvgVPnILIT95/KKImvhxnlmDqddR4yDZGq5ERw5EHtTM7jMnuqvBg7AR+d1XVcD7OMOmzDRXcncY4O9exCMhwxSpDv/T07UInrRFKzg/V5Kknw78GBwhOvPBcXrl2JMdbaHtTtuo/8VFJJ0xuobsi1HaoBGNQTWPWl/gtxeqAP73QtlF9M9kFKoWZxRjAGcBtsGI1HsGP9/LHH40+e/RpSszyOCqYg1CtjZ8cW8kFKiz1SDptUJmXsbO/GeUNzfOnEU3Hs4stxou806m719BBAhj3jQHdvfOfU83GgZyfgZYZxmEx9VAW42dLailMFbVwNgosElufBALfLpgUeAABAAElEQVS3YZhl/J66BmLgsV7NUa/CLPY6qC+mZ5N+U8Jcbjwj+lOJEEsQY5RpXuzESUEtS+AYNkyCkwnQlDZeeqZzpujsM0vsN0hWkp0Rkhf7SxNIQabOURw3MsUJDh4Lt7DGEZctSX8BbHmk76NzKvwpaWQOIk1aYM4oTTKO2jhOIpqxNRKgGMxWbQodJuQAwRUFbKb4bd1SPCZRPH0p+NRJg2CqjPZV0+f2TQNSpJEpJZ612HW10a992fPNXDFPJiZ7ObELuVdmiykBpBn7DSBHHRIYS2c23zZyD2wCpI08+m/jtrtYuhgub7r+vOHXLbQOnWZAR4GNpiEZa2Y5GnuiP4Gl5SyUNmACy6bFxkQa4j43D2tgfBjdJvtbLtoYKgXDXA17mmMQjtDAJYPoREBy2I1iEmlTSqzZUASJKHOxTyoR2grdYC9kXibaeJ2mXnEsO5m9ExD2eiL4rISrqjV6Q8p8VmX9pkcx7bVUV7Fe9p7uvhcgFrNAjnDSuS/rles5/vi/0Gzjhch1VRUmkyxoBcPGm8DSqnnA9YLO0tG0kfvDjZZgsRWDjhVET45e4DhM1mjBd64BhGux66lkky5xgd+qxqs+piTJvl52KqD6jLDsJuDoeltKrXlzNfKRgSedHDY4b8n+hiTJrFe3WYjgEgxRUuRczyBFRiwr16nFsEBVV6UyydZgdW6CKNqrfKcStdCK7ZNMcYjnOYhi7DoCidEibnznh+CATyMxcnyWUqm1GVDSNTTG6RBSuE3hT20gr8iucnanWcuxRICXMlnnc0oXyAATHVf4HBh8OHHD17n+zR52js3BSJGAM9jqbDGTwhjTqBkgUo1dSfbM2Z6bQbw3VhPBkfMr66esb7MeywDJbHqesFWZaUANrSOp19XnJqKlcQgAgfE9t9i3rgmGHahjPWlm7RNYFVFHyuEgQxDm9HAOp5hHAFC0u9LaVhrNBQHGJBoAEO5ebzgDVZKrAREIRNPzMCM4Yt7JxEkZ2lQytr5DZdijEHz0mkBNUSzXbanpiF9616MJ8IwBhgaxj9lOnLhPvPsjCZScnb4aVTPl8fDhe/ndE2evXo4tTR3xjp23RQ7154cO3om2ajVEdlX8NM4UDDKbx0vpLz/wCHZMJ1GXG+f4/bEXSdXp0UtINvXyNhcvDJ2Je7r2xa889KE4ceHV6B+5Fp0Ao5/d/hAuvelDtA8evesBAse20Q8z0YIK4a8f/VA8d+5VpBjlce/u29KzIigrIAnTK+eRnfsBQ+3Rh4QqhV+gTnlsfepx8CMvZwK7wSHcX1cCqrcLFNl7auracETQylgASngiVB13jqGDiJSmEmcMi1GL3dY1JDGqutnvSufyyE63ldVHEcCnZoXXCtiKSMAKjN0UdUp7LaCiCECcQatijrHJ57ExA/wJ7Gfof2epam/zBWzceC6b84wlU80xd2dspl2TOMsoWAZUp1A92S4pAXeIOe7L/a8Eelxzd7Ev9+dG4xX2qOQoifvSDGYuCPWtg6qZagTAPkx7Zw4mTEP1ZAwX8dRZQJqIGmZjzWg27alLkl4RVFZPgErGlVrJrihg8yTQY6sgb+Ya7dhMG7sHNgHSxh7/t23rp7UfYLNflhygvsOmIKHkBs2J0ttN2+iGn/2nG9K12bfl31lOEl3p6izrpSutgV6EXLTdvuX8S7gZENCr0wbBjtBQjtFsIr9YoFnIM6P2G8vQxkKnrBL/5ndjuvHa7Nxaxzxz4/FaNtFatqmsPtZoaeOCINTaaJrCpiEKS0nisMjGal8qYdBjkAT9cl+XrvzxfCq5mGbDLAGLeVR4ZqlrFe0xiGIizpb63o07EdW0KSPos97RSUMFdke5AQy0p8iLXXyKl8RrFZzN9inUrmQ2YmiuE4QfRrKeuhMuytUkWVddresMQhlSNlLpBHXPam9bnOCqSzkib0Uyr5bKxkQ0TTPuEkbWpZT8lri3fvKyXOfCUuST9L0aYlmbJntKlbVpApz6DGR38HE9YdsBSOpYgCCsno0RpESSdNmoAHUA/zDgY5H+X4Dw0jPkylT6ZQ3nOa/ijrF8NDd3NifuNDf4Wc5glsZ8ZR6rv3uNhCiWEWn8k+ru6ove4t8VGIfX5iByCXRZBQAXJFXhGU0VNvtCEFJDfwr4ZyBMlcksj8jNK7OoJIeOSvK8pQ5zTVSFzACb2dqS5VbCoIIjn6cZ1ORUq5ufx+YOO6K2+iGIUFS80uXZeuY6mNY81tsJ6jYKET3J+uF67Nrn/BRo2o/2rSC1VHeJ6NkplMMgzsth0CQbTmIRZdKIFDo0XVvJuSKSo7Rm2QYycI75bMhcGme8xlKZPCsAASUVW3u6U7lDBMNWMluDvc32bd2Agqnon4JlRSyjCdxkb9/WGYd27wLQISlD0nIGyXpTWx7JwWK8Ot2PqnMjTK6ZOD34UjRV43Z6777EYJpjPp+ZuBIXiSNHY5N0w7X6ueFXY0e+K/bv3BW3l++z+TFEmU8OnsFGqTl6sVmiaxjHKeyGpqKltSk+0H5fTFCfcRhtuuKWeXUBj3vn8YB3/55DeGHLxfAooBQRWQO2r7oNV2KlzY4As5k1qgfJ0W5U7WoBNJWUg0tL+gmGEXlVIPWuQJqkVNL5lac/t47MBr5NaYvjSKcCbrahmlfHYzqJZEmgWAcI24+3gxPzo3EFD5cFgNMcfamdmE4RZEhVoBYnWCPLmAEAKkXWg50eCGMSBxBNMEuQEDvmFJFAyyTSuvGxcUDifHISUUHwWFXcBT1NqES2UV8BsvfYf84YHTT4HNxeuxUbpGsxBaexo7aR+EkAG+cZ1+hMZZz6jbNuOT5FVB9ht0Rj7ShAX9BJP2KTVEvMsCoAvM+Tec/RnlqAYRX3OO7mlUlYfXSyeVkNWPT6zbRxe2ATIG3csX9bt1zvW26eK5Mc4CqCzBWKEEtsDLVwiVjhVl7ymu+eldut+9AM5rzmkusH1srJYxnwyC7zu4u6CkulJKGgGoHSm4x4z5wg6LZ6dZmCp7cyuehLyFrPZTIlK8FtIZ3hZPZ9uWSvt97T1HuWTVnitwSUMhJ5+dqbfjPjVHJWerbhZPW56X03OVlqjXUspayPJVegKSCYHQOLVkXMTf26SmbpBj5zcCwrOV8JsTONh7VpEJF5q+3lzUn6oPMGCAMmVNZJK+5/81/pE4j4JTIwZSfhr12BgRuti70mONLewCDIyc6HcTFIcg3g1WtW9sMPUifvr4G4qq5oBtgUsLebSOo9aehWZJgBI4hjiBMljJZsLZ0PGdGddZE2VM4sZj3jceN8rmM+7kgMg8qYxu5hfGGU61YkJX2JzuOoWEHEdcMF2bWlNnuqBG6qGTgNvq8zMnz217g3y2H5vZSXEETu8Q87WV4adQqrhHCrRQkNai0RhvapLstVe2yCqeLzMolEaRzpw4xEIHNh/VSGIBRD+zlkn6ih1VQhFYBC1SvfrM4WaNsEa2INlG1mdE9eSYIJ/OI50CHDGMbtcxCVrQ0juK5G/bcik2atLFOVROPQzLBuFpmTMlTstqRuqSRgxcWlvk2HaIuBY3UYU44HRR3W5IjOmZwAMCe80budMa7JUuC6iJ7HU6exbhqRpNShqjUI+FB1zD7U25huw69AoPvMq/bXitoZTU42LKOo5A0UIMwhohe59hIqzaML0zgPIFAE81hHD9MAvAIqyEpLplGz0vDfOZ3+qbPTqBF1vm31HdFWhSuD5oq4NDWU8nQFn6KPXxgeov44gcBJBbJIXjhPWcSNtqCh/FrsBMTUoTBt0OuhwnD0z46jpYC6IOW2ESfqQK4n+saH4ojBZdt6Ge/pYDiijvvqqSuNjQmcFJh2o063h5duqitxfV5d0wZoQQWWdUFQ4UuGhpKVxDCwAYCArdwxUNMCsKNN/O6knzrZLxeYV9VKzxgPNQ3asOXZglrbaWJFTdHXumE3CyU+VYCYOhxT1OQqE4CdoU+V9MzRb/piqMK9e3Mz5bKm6iBijPZdwCPfBHZLXkc27I3M+yLrB9foNbYD73m1gLjr84aLpidRzKQNXtPO+X2V3fGdqVMxQh0WqWsOlecpmEk6/yitMXpEnBkHVDJ0tY3Y7MKA0DZuerYeVcUGHFgMZzZPs9geoypYw1jMI1nTwYhSqyolUdSvEmBUAVgsyDDjt3XeTBuzB3gEN9NmD7w9e2A1wT9KML3ZQo4o5U3RiAebbU0TqIGw3bq63yStzucml77mVNo4XJGXkiWt5O37W87sLFKCanQJ3MRNerqTrESxJP1Ox1iO5eS+lYuyBF+mcHS9mBu+SJDIeVsvWX83qrWBkuTcGn1Lmfap7ZAvL4Hvp6mS4IsZAQvx473pf4080tVrv3m1xPrqfvK45GNSCaNE0+pr0sGltwJEabSj6jWCrj/gCKZ5AkfGnCqX9WmS4INgKjMQR8otHX1L3iR+dTqAtXSSItlPqc+YL/aXjgOyPgRqQMTYtqVaEWhxFmkAgACQlElSS2d+sKqlfiKLOmyN7FuJ3WmYEKUSk7SLuasXPyFIacZ73+rkMSUMdXjq0o6iNPZep1SkA6KuYq4MwrABdanp6Ierb5lZou9rIVxGqANqdmhwvW6ve6ezbEbVOOyaMnDMnKMf30gyH2hMUta6FIjVY7w8p7e2bClZq9Vc8AZTygUpzMokuG+paED9p45aqOizyPf6ZMQ+Rl+NQoUWAQSlcSndu4DUSHshpT9F0EFT3QhgiXkD2CmialTETbctqQIgaeNE78IYgLx3TZJQpawpCEnzaKsfR8VMlSTVWF/7hCdmBCDe2erf9VUAopvL02/erievsF8XUKWcnQU8VDZA0GNTQl0WKKNCKSHnC9TFdVIAZt+YxfwMAWeRYlRhg1INUdyEStU4mE3Pb4I/JYyLvLobW6KrrCWpuU3hiU3GkMR8F6pyt+Fq+zIg4xIqawl48SBN6EJa0pqCZiHip/GmN8192qgk19JUeEFHEAyPal97mwxdi3QN7227W3qSU4LL3GO8pzm8ns4t5ngmM2cVyHdTm9prp2JffjK6caLSVt0aJy6dxYYIL3MEaF1YnEhPkSp1tnaWfeqBHXdgf/RCPH7qubitdyc2WcSRYqx0JMDTznO0GO2Ar/08o830jsySiho8o+Khz/7V6cE8a7kurzPX2w6G4IZ9ESCBS4XYU9cdYxVjUY8EqhtvgxWMmTZG2vj4DBYBibMzSGRmJhgrOprnuBYwlAOc1gDCKrHz0Wur/abU0PKKAFjdtJfjBaiZOtdjazsKeBnGIdDQOA4T+GRI05hwW+pXGg/4IS9AcA+uyZX7Z4k6YAekNz1TFU6OBOGtBE2rwbhshICxY9hfuXdkeyhtFBBSDz0i6tjBiTOHGLqhZhjX440JJI1MtuAxEGldJXZQOuTBLfoA9bpUMRWNzKl61tHyGoAdjJ9p7KsmYTBMMh+3pZmY1WzzfeP1wCZA2nhj/hPZYjfhWTaoaWgiOUduUiMzqPzUwx16nRanzYUNyC3ilhM3WaabaYmEcPH3JfkoaZPxy7Ic3exnBUoriDZjrsSS8b83SuTJjfXamydLoSw+MonM+ldL0LmZZHesuo6DEq+SOq9XpucFSkrCVGfLJEpsa2ygiUCSMkptBnCRn38SOnJ6JbZL5WOenerMVsSGqQ2JfSV5ln1aX68t9emqGmcnPW/fLammrb5mZVtWfl99neVM1NCmVuwkAEIW7AzQ65PAMtVDbjdBZReIN3SzvFbnfWu/lRZkEeSLEEgSAqqlecy/bIY5fhIXqB+tmDvmr+4/dE4ioIAcHLGGS7VMH87Qpd/ecEsJT1AQC60QsVeRnDl+qq7l4K6qxGYp9ouvmyfnCG0A4Uwh/SjZ9Mjt78eF8A6OY2Ife8ubkFjJBV6ag1RX7nMaACg3W3ArqdROmRH2o/1wa3femLvl6aZaoDAH0FBykeymUInLIe2pRs3nB8n3xlLW/+XzIOj1abD1Jj993vLs1qoBjkEEulZkKavvRAG1sKk8x3EygHpRTaXqWHhMRIqkepG5pRyZ2EW46rMAp5liDd9xA5OhGrq8DIckk9HTiJ0K83GKyeVzkKpxQ6NLNVvqZari3JQ49fnVGUDqfX5Af/OYKsFCjRCQVmSVVe0rVzWJJEubJdoCCsGlQFonUlkUaXGqdRWIcSPhXwtxniSTgiKGNwdGnEY6I9vAPxy4xeWJ/vh3T/wZDhXacITQAjhEsjQ2FD99+33x7oN3R76qLqnZqTosdC7AACinbKxz8ASJc4JcRvDrxMZrBrDlVKrQlGuM3vquON1/KV7qO5tsl3pqt1NJJFBFVf6oE0C3HzA3gne2jtpybKIWoqt+kf7UnTbOHzh/vO9M7Gqdjb1btuFgohlvcgIl1kY6eaAwlo4dx2nDJSQuO7dsBYigms366vqtmqVDUZrVfndgVLdTbdH+H5/IYgcJ6EyV1F3vrIIfj+kFb0dFOwyJiAZU4xYBIRMAm+Rpz/WUTtdV9yjg80yMAxiwbwLM5QGXdaj8GUBZe91Z0JHgSMaawV9dh8uwp6zApq6uuzxmMeIcRHVwVOmT6wfgyvoaYsOXk0pbp0qAVw2So9YqALOFp4TWgmNO/ayzzK4r2NF+f/w0kkKBr3PL54B8+HdnWXSe8GIipTb4VkSaVFM5nmznJnk2tPcbxulIdTOAXJd+3Ht1AUk5eelyPXn2A3jWEMS2AsmS4EtnDZtpY/fAJkDa2OP/E9N6IUBjbjzyeLCR3K6FE1QJV+/1AETWAW7OkEZsistb/41dw3pKruacJSOvc3kiXF2wE3nPF4mSKjbD+aUgnMl1rBeQlj6yH7yrEuESnOWpaglEhvW4fsV6XyTaKBFwZr1XE87ZXdZYdT82SUEY1+uMQdDi5uCb9hvJ3oQ83kjKVO+W7H7oZ4lzc1gLFJXaUvq0HNudVBDZPJVRqAZiYNTMbkTAkF29BJlSP3ufBJzjY73lXL6pRB0EblN4VlJxSUa+xIf2R/WoYCDUYZPkGBt6GY4cyhoRZcBhTA19UwW/9mbL1R4iOdKAEJckWglqBdyeWy0RsZcEA4sQKHNLRFGJgNKFr2MvELVlbyQ5r3EYnKQY08n4XmCUgWzHuZTb680azwuSCA6W3HULxgVCA6jebaOdVdhe9GAHsIPf5+fHHYWMVicYZBlc3PkpAPQbnJtZ3Uo1fCOtzq61lRLwfhZRA1I9rRqAUYML/Soo86wX3ni+t3rHeuuVgEgDcueCHhUlVO3PGaRDw5OtybFCDvDW3jAA5xzpBJK06wNl4QxGNnbMNeycynEIsVA2jt1INcClBikKxGFVEYIeEGhAX4CDf4sQqOZTmldLWV1vTkb0snIBjpJKqmcouxxC07sWsA9yRpcz3nLwyyrGmRMySbKVVgJXe6SUHGv/KW8ewr2AIweJXp+NJgB1G/OoEo8Pu2bxkIcL8gGkqv2sBuP0i7F5fFZrq2rj1x/8UOzfthOQVxF/+K0vxZMnvx9Ht9/OOgjgRdoxgR3Q7vZtqIlV42Z7IPonhrm2PHY3d8dWYiINEBjWdXtLU1fUITmeQG2rvLAYe1u2IoGoi3akNnMTk7jansLxAIFm8TSnl7v9hHwYoj/bmSuTk/0x3DcW87UNsbcjj9SoJt6x/SDux2ujGZW6Sgw/J0evwMSbSB5Ntze3Rz1t1INbkv7Qd6qRoSkGKK9AYoZUh25yDEvJMZkHxBULeGxDtdLAqnahTgcqJPQZh9TPS89QOdIf19meYjOAazjGcbigyqP97avAa5S5MQT6XCCYbC92TXnsV5XIjgOIBKTuH5PMPRknyWU2fV/FNYXR2YzB2IhrfurgelVL35UBgASbgrCkgulYqWqHuaF7XxPItoF1IM0vyhcczaCux9c0309OX4gXJi7GtamRBLS01VLg6OqfzTeADG1I4IgTAlr7L0nEcEbRXoVzDgLkKkmanG1A3W4cZg9zBTVD57cMJts2zjyq43gTqotNPPMoDBLYWP+LGYOKj820AXtgEyBtwEH/SW5yZtMBF4pNt4FNrxzO1nUKe52GC0ncIG6aPJ92J4K8YvzaiV60m2iRjV83tHmOVcvddGPCcNb4SiNwcfuK19JtpezdqyRAJR6yMiURhF4Q/mw8LvrZ+aXySjemLcMKZJz5rirUEshAsHB1bhTi2XOpgnxmyXbVQ1T0lLGho7awiAelCxi7aqkjp11vXXLiUhEp66ywUpEZCVP6Vco1+/RopmoDUCIHCbvEDeV46Y7S5413Lt9fOu590B8k7QrkaLpdCgLdxPhMfxL6mXRKbqq9drP8S3mv92nfu2EnRwJL3SYoasQ5QAOemFbOh/IpNuAxCEpiIf2wUup+WpS5zVg1kvSDACXrgRtrYB84hroeXpk8XgmBJKNAm5ZEgKy84HW+2+/GYqKL+LZcH4+rBuaY2X+eWeq+dXJ0vqLbD6Gnup3E8rQcZoj5TogmSaPD0RKNEINXIEtGmU0aYy8yGGWo4WXPgzX4wZNtz/r39epKWymqGslGrm42xVNRgqSMIQVFBUXfvK0/eB2907zt08xD5+q8ZD/Y30iF6CtdFGvwPlasRx2pHsIbN9bYDNXySQbWeHnQbsjK9mTOFJRWQZNjBzJN+1CDSrnTRtqcgAv5O84yJrQFuSFRlYxIZvZB8KZ+sfNSyspIz65AGHUlq2NymRLkJWcLrp8AsBSXTu7/UpqX0Edy2wzJ3Qqg6MDuqAfbmTYkLpMzBGRFWFBFH+xCqjSAVOPswiROCKqRBiA1I39t+AZmRvBcVg9waUUSgYczPIZ+9ntfIbZRf7Q1NMXfOfqzcXJ6JL7w/SdZyIj5hMOEHkDO38bD3HfPvByniFf0Nx/4IGCzIf7Vdz4X9xELqZHO+uqpZ+M3H/xIfPWl78Qz51+O1vpGwOk04KEQ//XDPxcPdPTGnz73VDx97kQCCQKg99x2Tzx26KH4i2PfjF2dW+JDhx6Ir710LJ678AoqZlXRN3YtPnDw3njsyHsSc8iu8lWL+p0qkE7KJGnPBiiNq+dlxs0j8ZkYHYhBerXAb/efBvqlFSkIEZmR+rDu03fuMWPUZYo1H5kSfah7efYP+m+K1zWkKiPY48zlCHJOvKZtMleYY47/CM/tCOXIwHO91KnBouqHnNMeaU4PeLoqrGKuVDNLea45hcc7JEFIcnIAqPocFlh8omEdE9QpY0guRlc1NlH0gTNWGyUBkp86julfHI3nZy7HDF4La5XE4fnSuIQpfhP9baBcO6MqqQBmHgiVNOYSOGe9gXlULoMnfzVm6kcAhPkU20vQvyhAAgzqSTE5jKB/CsybQebSBABLu8ZZG0H+m2nj9sAmQNq4Y/8T3XI5rhPspA1sjplHsKUd+qatvvlimBm8VsQWFvXKKzNx6cKFOHTvXTFKdPlmuM0nX3wpbj9wR4yx4Q1e7ov977wjJiZQL2IDclGXkJWUkLvm5qJqhZ7XJHbcIOrZdMohJtzgra069F4r0ST3eE7bAzbBRsDY1oV8vPLi8dh/+LZEUF7DGDkRr2xsentyf6RINnX05i/3x3PHvh8f/PmPonNtNHk2QgBS8v4Fseu12j4J0NyaLbPMctkkrLN/66W0UXtFAmjZxr7etTc7vnJ0zMs/qpmSanmmjNDNDq68Pp18g2/mpXRDD396t7KJDEfUwFLU47TSo+vJtk1ABODNrowYPokKu37yrf2Ste7GPK2rRKVc2LWJ57X73TGekgMP2CDqx1L/LRGzFKGdhn9rJU5lZa5xUtXQSjxoKcMQaKe4IWlml2qf5VnKWWJdW6tZ5to8BJqzrA/1ll6cEOjBKw8QuwOQtJtBuASh/uLcQBTrAFO4+2ba80yQb5pfpRxXVWrpsLYXSQq8NBe9yrmc2SRlcz4BkDVafeMcF5hlZfhkmhYVMf6Qk81w3VJFNU3IFeUJOWxHkrxSp+Sxj/7M4yq6Ko9NSQ7JOc4coF05u3Y/ZaNt22BDCGro1yrAgZJomQMm73VtEnxJJEoIU3RWnaVsJSolfBdU03IdIz+ySGtGOfYdqkbVyMknLxlVyuOWujGVkeO8Tj6mU2uUMFIzmFlKoxZwmmBmjXW5eKC6K7biXTEFTSaLWYAT4gUeTlTqUNtSGrKNynWUN/Ds1sZx8nMNO4Eqm2uo3iEff+XZ5Na7pdH4RMRG6twWf+udH8DOqin+7be+EL0d2+ODd74Hla5i/D9/+en43vlX4kDn9njy9PNxdWwM6RCxjsZGoxeX4CNT4wkMSf1PTaMiiB3Vr93/Yey96uN/+Pz/G5eHBjlVFl8n0OuH73ooHtx7JJ489f04cflMjOJZb2YWwECfzmDn4zz9AG7Dd+By/LPf/qt46vTxePfuO+mfjCmgkxbHepQ2F1EFHGeNUu1Lads0a3WNz2ACIovRhyTq+8THm2r0GSeoNSqNd+IVsYX+LMyMo48IcMSmbQSJyDnssLZWtUQLjLMFxkgbnH72L+0xm5D4dPM8VtP/qsSO0ZejuAafhCE1y1gz0Gm802rDmBnrqY49aghJGuwShk3JoM4bWHecO+y9s/TrLM4ltGmqoUynQiXraD0Sqm6YfPtznawM7jeoEU7j1IX2ug5XEWi2bx5VecrpKEMdkT2tDhCsRFxZ8wx107GCnhDr6nDAAIjO0R/2yTRr0jBxlXzWDQGhO/Ma2ljTOICkDWn2LHHf5oXf04BoGJjMcR4tpqhrxCIe8WTUZX9pwm6+bdge2ARIG3bof7Ib7l4ux3WSzUV3ohJK6yUJxcz+yLuWKIWVF3MoeephodWotIaF+qlvfyM+9W/+XfyL/+1/joN3H4mBocvxmX//mfhHv/2P4ehOxsXz5+Le+94Z24k0YbBEDf31EiR5OsdGUE4e1fWQrRBeC3BLNR5umOM7KhljFdoMYEuwgB0EwRTdBObYwPoIYKvdiUv3GBHWP/17n4r/9n/8ZwS0hTrBQUUNnLiuyibiXRiIEXfRRKY3RtPpK2fi6e8eiw9+/GPRjkpTIxtoDte6Sd1uQtBFA+uqkEShLsKm5GbVwGZWpM/0EKSuuRy/jIjM3ld2zw/ru6OxMr3VJQs4cvTPHBuisa8ElAiP0ufKcv1eNoPailIkNu4fR0pcd+pr3KrV/XKz+ghwjdkyr9oTz4HgUyLcRtYk6ZJk7Fo5ZlxrifKVqn3OX8F6NYSHruOrAf9F8lbVL3mD5LxUkLn67y/vd07JqFDi6Tiq1vJqjFCnJgykYQQw3yFzYze5Vla0xvNVw3EF7u/slTGej2UX9Gu2lUIER5WoQVY1E+AZI3LbKeFVyzzOvOoxttSx1BZbbJ0EAzIHnN9/HZJEnfVJqrbUr5TsM6voEeGTye8tNQXU4vyO2hkgQcIxc/Ty2vaolpvsm+grn+kkAeazjDVFwjKp7ZJpkYKSCp/rlsTiqrVTF8mFqSXX38ypCkBROWuP0osU0wjCu4b5IchyvpSS33TeoURYYD0vmvO8AMu2Qo2Uw9mvQMygt7paXtWsVfOOD3WZQVIxAwFdA3hwzlp/pfjlfKpKJgNLZwTfOvlCnLxynvMRW9q64meOPJhi+yiV2NfTG53NrXEel9pjgJZ78Bq3UDUTXQ3Nsa2tM84MXIr7dt4e7QR3vTreh9OLcUBMd7I7Gp3EYoVyEoik5nvatkQH91XjhKFOT3OUd4rAsnqd20MspHEI8KOApHf2HozOetxwU2elL0pU9nX1xnMXX4mXqOelkcFk+5McSHAVl9FDqH/Rf6M4SphmfJTWuUyPApRO8L0ZKU8zYtkyAOUJ1Oyu4mTGXqkm/xHmwDT7SgtjMIed0fT4BTwGNkU7QXGbqnoyL33YCFUTXLWGutYDthrIvI6n0DxGAHCWoyqdsno7UhXKNPMYK+M3qWJei3MDpYtKr6liqrhSf+R/CbzWAYJ03S34nGOPS4HJsVnKY4+2DacVR+p2IB1s8sYEjKYIVJukR+x348REM5ZVA3XahUpiM6p48klYbtLa0Y9dkoF7K5AkNrCXNrKWybAZZV2ZBJBNsnYAIXn2dcWRqfdZTg6g5GsSG8trY204wsABCPutfW7yo7QeJrXRdHTzbaP2wCZA2qgj/xPc7tIC547lRmzgSuPjsJavmdyMfLn1vSZxSH34a+euJNBR24pBaSMLLhy1MTiLn//cn8aOHTtTDrMAHzftHBtDZ2dnLKLjffxr32XzLo+BgaFob28j3kZznDl5mjgRdfH+970fjuNcPP741xDz52Lw2rXYv29v3HHfPRgnz8T3nz4Wly5dThzKO5BU7erpipMzfamWclv17uSmarNUh9ha1RY1g4V47ulnYhy9+a7urjh6/1EMouG8Qbwsosfe98ypxC2+7/774qWTp+LZZ56hfhEHDt0Wu2/bGSf0SASRZpKwTCpfsJclgBNxzDk9BiUd8Kwma/Vauv/t8CZhaMyROVREJKrnEB+pjrI6GSh4cRJ1Fdx+/zClSBLs1sD5mG3a2Wx2Dsk9fR2osLra138LDhy0G2Y4nNMqpJHrJW2YdJ2tTcPK+xJgTnY61lKiW7fRELIcywj7jMBTsqACpgDUlJ4zrvWZlPA6tTAegzj92IbXtl2QQnmAUiUF7YR4qa4vi68Wzsbosb7owMVyNc/HzdIMnq2GlY7ehreq7e2p7yT4HV+fD+uvLYuvlck1oRwmirZW9vuPOzHNIPMyYOF4uyb5p2rTDOuYI2F7TH7aGmvtLFGVUulNOZLzwhrtsS8cJ4lgpTLeKRBSoiFB6fxXcqGwTECS7Iu4ygKsw/V1lYJ1Ie1Lr2bVEMqCE+uW+pDzLE9LYNTaZcmRUFouwHY+Cm4sU+SnBMn8lZS5Hhlf6TwQA4WqqEfKpdTKWgwCxhoguBNZTZnWMdkjkofgsgHg8GsEbT2wdSf1ATRQNx3LGCfHZ8t22eZsrJVw6CjC+iJxIt8F1LjqADCHt+1JThUuopL3wduP4iK6MWsd1S3NkwQwmd8LSI387p/gx/YYF8j26QhCFULPW3/tia6Ow9z61n+JnR09gLFDSTJ2EmBlX1AVe4D35Zfg0QCwxgVzHpzm6amiDWoKzNGuSVzzV7OGySBTJTHPIpGH2TaNDZegMklSsOmrIAhzNWrCBdQey1Clq8ZpxSHcfE/R9mn6WyBmv4/jXGEY74LgpjSuDkgZTBCboNdAGS3VjEOOC5TUKdWyX8FMUce8KnMNBbzpAXCBB9r9ZL6Ofmdeqjbbm2uPI7XL4IjGZo4ZyEfAVQSsvVS4nBxQHIFZsn2emEvkl+wquXYSFfZL2AqdpY5u6rZPr3mqXju3xgGFqh+Wo+7nvDSo8RTXmFyTTHVVE7gMb0Jl07XGkCGOTylRZx3UsH+nw9ktpZObnxuoB27cLTZQwzeb+vbugWzNunHlcolz85cQMLmgJzLATZSZnh1Np5bfyMKYMm5KK5fI0gVypofO9cXIsXOxc2dvnHjxxbgLffRKOGN33nU4LaB//mdfiIff/zDUCsQFgOXF48/Hs6i0HTpwKP7oD/8kjj70UOQb6uPTv//puP3w7XH49kPxxDefTKDt4B2H4j989k/iox/9CJy9+fjMpz4T/113b5y/cCa+8LkvxHvf9544f/5ivPTKK/Gbv/13iVyvS9dssVcyliUJnkpUEWrjG999Kk4CfHb0bo///Cd/mjin+abGZIz79FNPx1/9xRfjsY99DMA2GJ/+d5+KbTu2AxCq4w/+7Wfid/7570Z7Ph9XZonpQSr1h2SLns08UkN/SQjL0XRjUh6QPFjR2dn1GaGQbfApmx/zW6lWWTVsy8qUSTbgPqKPPiNRCZvSPVRu7epUjmvYGEZ1A2cN3vdWJwkkSWDdVSfiHvLX+Sx8L42Gpa5RtVuuSqnWft5KGyTS5byXJC8WJIQTMCtdMlkf+zX5uEsFZGpCgiOlCClxUans0h0SmgN4phqDSDUO2V1lbelSCcI8hHwejv3enQfiXe96F7YHddy2fsuniNny9Scej+fPn485jOIrUdHKClwuNavIje+eFTTMMaeTDeCNp3/kv3x60nPFs1XqX+GSTB6Pr25NqUdKnxn4UZUxAyErrxfAkDuvEqxyyUIS4NjgMXAKW5Np7tPAf2XyLv9LhVfmALI4OFCyLfEpoSxQFvRoxyER77qZbFVWZGRdVL/yldTp+HQlcxVTXaqUv7c4x07iuMOTB4nPpZRAwvwa9pb9EMYHBQOAEcstIlaYxMvk4qQ5oZ4HSBjEIuky6mRTOFiReXSoZrvZpqSL/C5skzp4HUOlrg0p0OgCUpjxkbijd2+SQN69c3/8+QtPolk7HXtauwFeOBuwn1IOqUfoEp5XQEWFAI7jEue3dffGl195GsnQubin+kB86+KJuDB0JX71He/nCp9lpCOo+k0jFd2DPVI3TiHmEoDK1vQEhlIZvsEo4VkwXpNrgyBLZxI6IdCGpkAe06jAeawSINjIOr4FJxJdMPQIPITbckAvfw3YntY15PGVAjOELtJld5KeslfpBCVP/RvYI+cAVe6YzQC+Z8uuxTDPRFoIuUbnEZkjDo7RDzrm8ZnXLTvTMgPUSJZqmE8L2E1NpfnHWPNpHcieelZFb11r3FW3k9hHTalN1mMW5kZyzCA4Ykc5PX8tTi9cjT2V+diF+qQlUYXUH5ZXzlzdvVgX1/COmdgaVGASiZdxrGbR1FA13L7WSYe2j2p9VNC2bLaZD/MLAFuHt9tx3OI31o7BCKKvGNzUz3qJpE4FvPltpo3dA5sAaWOP/9u29XJLS9tVqREupOocZ+eyPT07t8x1LV1b+hQYJcKudGDFp5uh6/LE6Hh0IxE6gHTn+OmTxFpKbgmitaM9HnvsY/Gv/9W/QWLUkbi33u6in1RGyMBrPvrzj0UzsSpeOH4i7j/6QHzgve9DpWIuTp16NQ4BkLZv3xE//zd/IeaminHx0qV45tj34uyFs/HAQw/Gz33843H24rn4P/7F/xKXz1+K2r0tYVTyUso2bPcxvkGU9O7eHrVNcNzYI2rra6Ov72I0Nd0RF86diz/41Kfjgx98JB544IH4yjcfB4RdiA999GeIe1GIZ7/3XFzGbirftj3KMeBdnTKSIDsqOZRAKO2UkEme9Nh+lDGl72yKEr+le9LetjrDt+B3aXzWzyrbmK0NNcs2aYglpWIrE92WVEFSIE5+6NlIScZrkrs8thdQeN7wmtNv6gBZS0ooJVD10RckJj0N5xfixJmofvxa1fpBypW4EYStBoyr81KKlINQUk9/JYEhV1gbupX3l+omgFc5RzuEpF6Xag83nRwyIt+Ry5LPrO0eghM+DWFVl55rCGaI3hZUgDo6OhM4Uoo1C+FXAbFTBTGoG2BfJiUZSmQ727uiaroPaSAcdtRXBbmCdwGmdbs+X5bqLdHFFE5tyNpx/YqU74/jzXomaS31ztg7jnz2NN1KfbxfQCu4UlK3csZIYM/T9pXwx3WqjP7LcVw1qGnAufZWpfUrK3N5vPxdDhFs3wpPVKVzPXBulEqD3sew3tXgxmQrkr0aFzgPstX1xrxLdzge5ncSKaNOcPYvEmgV72LtSOcHanQLXhnNSCMqIfK1cxkF3OlOurelg0ezOsaLkzGI62znaRNqZAKNrua2JAkaQZW4pSaP7dED8RfPfis+d+zrAJaZZKt0eMsupJp4lmtsBOxsZ75VxdYGvM6hktZI2Vua2pAw5YgT1eJym4h38+5pak0e6na09sRPHbgrjp19GTW/C3hfG4uH9hyJBgB+e1MzKl110Yva38EtO+LLx78XT716nNg+4zjYaEySuGYkVV1IQ1LQUtZ0GQxKbQRJVUhRJfqVJk/iGGJ2CgIeYr4c1VLtuhppdxOqwGWjnNOWh2NV1Lm2CZtZ6lxSlRQE+Iwa50kgbeynUnLv2oKUaZDexwIrgTIDxSp98wHymcnmVCY1mwNorJxjmB2luaM0SnVw56Mj7Hh3IrG5syaTHClds1zrMgMQyeqwGOdxanSyoh+GpnciNfN+v1oKY61ErMB4N6JGfgeBeKdQPS8iqhqGuTWDi/Ukc6UN3jdP3XQckT0PSprIhXItU7BXVznBfXiALGDDVDuc9QlruxIxYzulDcOiN9OG7YG3eJffsP242fAfcQ/Uq5NsmS72frIops3eQ/4muTBnaflb6YifHpUAdIMv3bPyvMcso31bd5x54pnoe2Igajux8dGWiAVfUHLo9jvi6INH488+93misOsNarksvynlSXEqOF5XUxd19XDCLRkqxaB8ku7qz8+p4821jY0NSR97lgW6IY86BISmevl68ZFAZJvj/uXkrwb19SEYytk0jn372bhytR9nEftTRxgvSCJxbHQ02jva4KhOx8QkBsOo8E3DZXzh2edpY1kcPHwo2jvbof11q6ux73I/Lpe2/C3rr4xA1lgachuCibGgLZmqVRbTye3T8tOmtGYvL+e59jdLWm6zdRWcuel5Rm5hZtWS1WhlHuk8hJoGzhmRyX6pfYNcxRUgyVZkUAFbLwZ8XuN1UJKY84bE7zL6p5ydVhUO595bkshGdSBMlKF3IHBWZCpRmXFEV/bCigtWfF2+T2noTepGvReo/+rnZUVW17+ap/NBaYHgTSPzLDnmyyWWbnCc5QKvBEf2kwS0UpA031fdJzEDKRtDEDnaI1lzwVsOSYVJIHT58uU4B8hvhHDd3rs1RmFa9A8MQAjORku+KXbv2pWudR0oZV+wPAgimSaOr32ZZjUD62+TxJcqbdbtpn2Wrn7r3uy7tcqzVvbVSnghLrdfbzWZh/1nG302spZmUpnM1oq87KelpBqSrppruRbhCmvAcumuX+nS5cvTvE/jQ7/qH1Gpp5InpQUS3WVKYeUyrLynVJbrYTWtR03KNiXVuVLT/Fxxj2uvkuqTxWHm60LckWuNfQSDPUCFhgEsE4CiZlS9EIDEGAC7DdDyiw89AtjIx+BsX5rfAnCfKcH5h+95COlSXVxeGIm+8fOxu7snfunBx+Ls4GA0Abp2sD5O48Hw/OTl2FbXFj/zjvdgw4YHNtozgyvwfS2d0XrkoWjL5eJnDtzN3Fqgz4Tf5fGJe98PgKpF/WsqHth/OHZ1bI0hVLA7m1uiA2A0idTr4cP3JWn9POpuP3//+5JkyTyake5ox1NF3KG79xyE8EeCDHOgCNhxgiqV00GBMYO0JZzieRAozAGCkpoj2gyNeG8rwHTrwzasiz6szCMtQl1wWjVI+rmOPCrJK+0HlJnUEgEoPnsmu91n3HhrAuYJ+mweNbMi5WTOTxwNriIPmSWzSHzL2QNVsUvr4NK4KTWcZkYYv8jk4bT2U7edBMltrconiZN197n2fAIyjGl/YTRenr1ESAWkg4BBy9WZyLygBWmZ0iOlTT4P3teF/Wgdng3nAXA6bhirrI9retzjWb4aU0m11/1MJ0mCHuea+3byukge+C7EjmoGKVI+6qvGkAQqpYXRR3leU0X/baaN3QObAGljj//bt/UAivTHCi8hq5oB7D62+FtPkg565EqL+Dq3yXVt3tIe+x89GjNsPs3tuEy1LG4SDFXg7OB9jz4S3/nWd+LS+ctsMll+KVPyXAmYMoJoaUuioikKPJUfHx2L82fPIsmZiSuXL8V73/VTSYXlJdT5Dh08FK+ePZUMoDt6OmMQPWvrK9XiJnPl4pVoKRpfHVUT4rWcfPlkvOPovXHwwMH43jPPIe0CYEGUHL7zSPzqJ389/v2//v3YgcRqT+/O2Ll7Z9z/0H3RSmDFAeKBtLCRX12cgrjCLfM6/bHe4RKxJ+GXqVoBmKiox+Ueys2eQh//jSbz808QJjdXZUiNvEsE7hx11fBfVReJv1I9LMf70tUQgLpstd/kzhtMmBNJtarUTq9VtWiBjXwOgiupt5vJ6sQNK8tYffoN/SYv57AEpvGojFO1VkrjvdaJVcfsE+0SbJMEUMn1e6mNqeb8EIxZchFJgQFIvY+u4z77iNLS/3KpHtN2x5ldYO5LqAg5VqcMHCk5gvhJ/U1PpfJw3wvRp/Qg5b/qRksyFlV/2UxsxQkx3Z+S95quYZv35JPfiAsXLkcNjkcODOyNlpbWuNzXF6++ciqaYCS0t7VmF6949/bknRHiyHJLs2O5Zdkc4VQi4lbc+kP9muYvczLViEo6B6xbBuAEBcsqdUmSk2pjrZc6xN9prqeh4m1li7Jja/Wztws0LKf0/KSs+G0Oxq3xyzje1pJTANYNiWaPrc7Pmkhe6ypaaYHjbZ0WmHc+nVDaZr1mMq+S23C/a8+pR7y0dgqgyCetm0vlut6eK59iDlbHAZzeNPLZgZ3aCHNyjnlVhcrVKPFthkB3tdhbXpm6GENFYhDZYOpRYL6+PH4J+5yGGF6YJgDsOCpZMIp4NZT3RmPHAe4r4BTkKgQ4jhio/oXpYdTFcEKCGlc9jmxkKJVhX9NKmTNDFwBUqnxSAutFBZ7RduFSvIz16XRhOC4goSrD9fTW7Z1J+vvqbH8K+1CDfdT83HhcGzwf7UiMWttw4APAV9KlDc/wyATqXrglAKCMFkZQPYXIp18l6pPdFPUSvBoAN0l0aJ42YLpMFzQM4bltBvA124DNHnkUADNDOPbpAcbdjie4OseH/UP1sjTjGDKnjhJq9yLttQS+2gqNwuwr8Coi3akAgOUaCaZLIdrwOFN1m0525AcET1taJrUZYy7gqy/l495pOQKgctT2mnAD4bxTWqRE2EQWidE4zrgcmz4XMzib2FfTDlOjnDKKMTgzFnWTro3Or6y+1sCVfZF6zzOfzbuZnaGFebETb32q7X6TNhjbaJw9FXiU6poKXPFmPRpyIwT47cU7IcFiKzMX+Tr9qGzABQ1AeNWjteLuza8boQc2AdJGGOWfxDayWSzIpWT5U+1A42STC+6tp2wBf717XOjrWhqjnpcOCgRk7e3t2O9shQdFgLyWuvilT/5q/PF/+GzUIF1qb2uL7Tt2oPJRDWd7Z9rEdHnauxOfdtj4zLFxtSGtWWQDUNVhbGw8vvTF/wIAK8SefXvj4F2HoqO3J06dORmf+6M/Tlz793/40ahjQx2ZvMCmDlBAJ74TDug3v/Y4XpSq0SuviQ88/P54+H3vja8+/nicefU0Gz365ZTXgIrI3gP7Yve+ffHhj304nn/m+3HfO++JB5F8fQHJV7OqH7jB3bl/T2obXfum0sr+lAASMEmYOVorz71eIV5fDQdXG4cSKFqdh6pE5l+Em52AEhu2hJF/JjdkCZ2VqiDJy5ebOg0tqWMmjjh5aas2j8RuvSTxltzCrnfBLR43H4kHpUa6U5YoXr/UlZlKHEgi3Ji8V0mJbrMlHuYrBEgAL8CK4LSUlOFMQfQ5pyeJL1Ig5lAD0lj70f6T8FIuIBhK76lSWXlK7SRxDCS6OmXgSMnREjiyn7hIaZLgSOnCzZIyC20KJtENxYLohktHRkbgBi/GQw89mCRJgwPX4sGj74o7sOX7OkRMBaCwra0j+nBnv2aiIko2Tav7ONVydWeumclbc1DwoPfAzElCRmwKWQSPSrGSWhx9NwOQF8wT8Yg1IpPAJbUoejURt0ufzu9qpKIZIZeNk80pXbWy1rY1MRGW+mLluew7M4dnrbLK/neWLfVWypC7+ZmO8en8SSpUnLM+XsnU4dmQoOfRguC+fv9rC0pHlJ4kNSt+qfLky/tMFdrJ8KdKlMn5cXKeeYCDgb2L+Wgqw4sbDkYmKbMMcKVThEvTVxOws6ICy+RyHAaAEuyBqaEEmgQDSSpG3pPz03GteCV6KmogsgmzwHpQj8MQk9dN8kQIMOrHkVRNIxFhbfEp1YZnsWAAVFXYqqMMyf4UwGOO8A+F6cXYWt8WZ+auEgR2LBHmjmOR/Ptmh7FrQT0a4n8MGHGhbBCpD/dRf4GWALGF2a+jjOzZBUik9meSlDmcTSQVMUFJqY8Bj4LJcSQn2nHp7GceqdogjgpGAEwFx4kAqHn2hx76bI56qsrq2M3wTNYDKLuxW6oB+OmxUOg0gl3T2PRUAkdJ2oLUigkK007mSzYm1iOBHMoW7Dpqzj7rnQNQ6T1Oj5tKmOwzAZvP4LTOMpgjCWwx/s5t1SFfZF+7imc63alXkedwYSoujBGwt1gbe3HgoqRSTQsXbaVmOfZWGX9ONpljlq4jIqWhRE5CfqREmCFbsfbxczlR4XlsSlHOA2B2xcRsS9QSxLiSvqpGcu2akkDo8h2b3zZgD9y4E23ADths8tuzBwREYiLXTO0SXKIlMl1w30jSg5Nuao2wcLOUNgousJwpIrEffuedsf/Og3GtMJ7iS+w7cjB+e+fvRkNTPg40H47e2w/g7Q5VjL/1c7GIysA4XK2HP/ZIMqa9SgT72++7MyqLd8YAXPGt27bEBz/y4eRNqhv1ocvlxDRqr45f/ru/QaylS9GIk4Wm7vbkwU4bgSoW76qWmvjkP/6t5MnOersxNAK6HtyzNbYc3Jl+6zFP7lpjfX184Oc+jEb5VOw/emds3b8rZvC28L6f+2Dsv/eOpK6xbcc2uHd4A0r2TRmRcrP+eCPnHBG3ScnqN5KzfS04SkRi2u4k/F6bPJbi3UDWz9E3SiNUBcvsXzKApltqXSCXypdomWRzrQNEZkAAwhVVRbox5v9/9t40uNLrvO98AFxcXOxbA41e2Rt3NndSC0WRWrzKsmR7nNhy4sSpVKXiyUxNpqZq5sNUzXzMh6lJVapSSSaZSibJxEksy/IW27IsR1IkkqK472Q3u9kr0I0duLj3Yp3f77x4GxdoAN1NihmLjQPc7V3O/p7z/J+1C3Ch5A3VjY1JtQ86d+Ph6/9NlvZEJjXKJF/efO0cIVAh/NS3Ny7QRgwnQZipksFZ5U9CXNCn0wmN4vNkOTmA1H2y8bPmUCtqRwYplW2LUTSkidqxCJLsncyDHj9JWX9e3TNK5wRlED88g7ZRtaYKUkOJ6Wslr5hlfMaI5dPT0Lnu8k5AvvYlp5CyjgxfRHrUnwDByXdPomo3HcePH0cdj/pvSK4NBZgo2Ys5SF/M42tEFcobTc5FZ9/13JldeXUJSjMFR76y/OxNJhzHmx1TPnUgkKScgMVJfqtapWqjjjuE/vZlDpgswZFpZZyNaebIpyHiuJ7V0qyiwtY5G1nHnj/GSIbDlYs5bzLftH7WN4CHVqlQUoWjqhKO1l1iV+lRup4CJCYlsBOgsX+zQrOMt3qnPJ8nCfslnjdDE/gAGti1SZDmfBRE8RK0OW9PYx80R9kHsIsz3k8i+Okz1csECgUYKmmGW2+IeiE6laTGzmKzzHvew8TYQWJxBzq3T7/+IvGERpDAZs9ND7F17j14axwsDcBIuAhwwmYFr2/aATUjtRHECGia2Ttq2KTqUvrczHT8m+f/PH7l0c/F/t7eOI80aRqwUQO8JQ+ESv+R2lqXNE60vQvbOZ9T+EeJUaLntywGVTbWWUdmHUgzqLP9bOcyVtzvMUFAo21BfbCL+l3CPfZl3JNzIXU0/ljEG8sTcY6+mQdgVnjOfC6X6Od2APitSIn2LWDfRB1KSJFGF4j3xD6QzYVsX1Ui3bDknkv/CUyYPgnc2ucAlgbWEmdjO/NQ9d2F1M9IE+nPTMK1Eq/OX4hztXFizRVQpaUPF/AuR/+cro3GyeoIQWZZbcjrPHUfnZ1JTj8uc6zENZ0wAbqR0An0DBjbQLuqc3PYHdEO5x092rbSErNo5Z5emvVJ4Uj+NGT9l71zzLmLvZ22t/Zja3ECidmemG/tQpJIv3GJT/oS9qb276bZ1Ge58/0j2wPbU4Uf2WbvNOyj0gNFNs4imw5L2dbcom0a69Kqe9C0KbvqXyO5Xo4uzEalGZUD9uI5uF5yxyHHidjdjLEwsV2gXhuISj45PxqLHcsE58NwnB1QF7RKCyoszF142c+FqgAAQABJREFUo+tH5aMJDuQ+PMkNAlAuEjn8BJvFFNwzOam9XFM80kvAPrijqI3MQQi45M/CGTyBOkhLnyoAmZtmF/STS6OxXMWGaJ/HkBAQjNO0woYn/TtXGUsSk2I3aii4UV2hTq1DJTaw1hghgnitKgmmDcxmG0vK6n2/JRWcDXdLKrDdp6OWqNWEQM8N3/Z4zLr4/Vopv0JJiITmIht18qoFYSlhpC2BnMa8PPOToNeOQfBkjB7t0ez3xY4ChCob7igGGYCovDe0O1rBW5bqM+83uXFrVyYRlNSYrjujTIVlah6CZxF1ktI8xAxAhvutnyBSSdrGvkrWN1yQNvrVlni9/ZV/ytV1frbRR0rUPGfdxIc5WDJ+jf3qecdts+R9ElW2Ed51UsWzvze/en0OXiOwvcSdt8Axrk9Du3fHgw88EM/hvGQOlZlbcXwiUXT6vTMEiWzFzf7B7PK6gqxLC0b8fVMwDuaAIRB/CzyTE2Cv6XakFbgk85qtkm30L5uTXrVKKNK2PNmyDJRkT4zXciilrL/XrvSE80xwZN552dln9u74NSHNEAz5muSZnCYumX2YX5/naDG6fq4tai9Cniu8JFYZR50GLHJuXsKbuxs41ghhzNRmgJh/AC6Bgq6T1xJAGiJXyVUmzaSOSglUf+PT9qh6pDvsRsEL3ZA47AIYj/uckH8K+Jp3wlrm67/ZGK4VYNDklBB8pt+Zu28uSJll16W+ZDK24j1Sr3lKXd9YGkNyQ5nMA91UKyVpEnhyn5oFycaGXhMkpazoi8zFs52wlnRcYBDUb772FIQybq/33AKR3hDPnHo9nj/7TvzNx38WyT1SDeLTqo5daiVuEFIX+1EwZ2BTA3g3AtAXkHhcIqaRset6lHJFJ7ZBHUhFq3FmZpixQrURwOD+YKWUGrI4J2mVEpwWwLD2Ro59YirYcPuKzsrsgCw2HUgNUFq3AvhawWV3tuo1xGX2jknUBMUwGBOJBVIyplFZsGjyHNKWJvJSHe6VFdT5FkpxCAlTpbYYZ2H6rVuvHV/KWULvuJFNz7okN/BWjv8EFAEnzrt2pEfNnB/nHoO1Wl/BtUD3xPzZpBbOBEt2jW3kJdPKNVjpVCeqgbNoVeidrwhDJPUHbX+HOEXAyLi12B+DJfZM+D2VSiU5qqCjeGYMag7wA+idWKnEDG7PfTbXj3RquR0I8EFlj1hJSZLFOtdcmCGbPTFT0dFGmfyyZ1yvsjvp5u6B97/T39z9ttP6vwQ9oMhdcq3IJrfEQps20husl4toxrElvka2q1wzBwmIKUBSnlyKyxCZvjYmVT9mVSvgT5WNLBnXhACYbBqH9w/EF37pi4CZSpyronLBQm+d3FgucU22p2VLvfuaSXJJI2Xc3mUH0nu+HbBjLaJHf1XKNgxK5nzuBQ8Qx3dds7axOeZE4VW3fsADCXbRZ1kN3bFRe2PDU59/SuKGvnEzTM4XINogORK4saVbbHPXrJESpcSnpdMkOJwnukKXe5on6yPx6TFVz0oQza1s2jBjo9IBQbUA0YLBUsEDpBW4mUu72gC/UHWMz40mub/IB5I9gltwluv15yL8sY7DMyU4nqU40jdJME36lfqpZlpPeOe52n9KLgS+JulRCfkMCKdDvGG3wDjImW6FOChKBK32va3MwJK2JaifQGjrtCFxvTe0wOdPOYcxeJKr55RzXsa1P2VyqGY324gXLy5PHGzzgPDqR221r68PT5JNOEa5M8UgU3XqwP4D0Y4b40ySQQX4lyi0b1uY6h2AIz/BC1Go0k8wuot44piAcVErcuGG5BHnit7ZEmCGCE7Ah4wlGjM1RJ5R+lwwn16Uln9asn2X55x/Wozj4zNcf8zj9clRTG7HUWsS4DtqtmWzudLo+leYB8Sw/hDheAF1pAwkOa9RLUOVqgA1WUCNMr0YOztHe7dF+tkxzJN1ksj0eahP9v0Kz5Jjq01bk8QuY5wSx/KrZTBJldv6jJjfrMYsZ0gPlpAGFBnjRlW3Vi+TyE6AKf0WnLFiSpSr2sXgGeAWVk4iwvXwWAVI2I7MloV1wrWbupqss/lmWVEnfivJ4C0vLl2XXUub6JcC9f/UsQfiyfs+Qdy5pjgzci7+wR/+PzGM/duDh26P98oX4xy2Rw08I8d27Y87eSmZfeb8u9gzzeMyupReyZ6HUlrwuDc+PB6DXb14uNsd45WpxADQSYJto7NTf8kK0oHAImOVVizGZzmp3XGG/vZaGTNJQgqoyZBPRsBb//wZUSJ9iQDlCXTRTuuRpHrkDz7m2QY4M2f1hiczqAWw5rEKzwDagvFekRWQOWTZ76HBQNeuJQbZKjtbdJjAUp1sNdPgU0dj8TmXGpu5gt+OzzQ2SnOo+S0i2VvipY0Zhzlve2DWoS5YZuV3bFSN6+QZ7gX8dFC/RiRhjl0aP8EYBflcYEWV+r+M5GgO+ygmK6p2qBSu7pljSMVOYTtGHNrkaMK5mfLgMyXrilRIuy/31wT0CMY+t0CIaupRnm+LuXkCqbfCUDTz1MDs1p33m7MHdgDSzTnuP/atdrF2od8N56qbzwrENj6tcE9q0LcbT8ZAmWeTRYHiupZFCYH6tPF3fk6usKpP2oJY5yxxL6v3FB6PzqKiUehvjotIjpRErV3jhrS+jPxuP7c+t/U93re+nnC16bccHHn+w0jCnJW041q3DBwdbGyLWwj2N8aYXcTuZEEizE7hkhJjYL0k4rdu5/Y1TZsjm3YreelVT5U7jbwl7yRyPZ8nayWATRzx1e7TDqm8i3uXMN5FPmO9oOjeNziyQOVXEnVuvavF5FW4vk828bbmpRhoqxJlvpX6ruUiYVSgnY5v/RinXxBd0Abblmk/2//iPmnJBoCqfZWl7NPfcnwlWAymqUQpJU7bfzWIHu2btHNZq9lqFtfxYSllxkkj6/0+3TwbZTwuGo9EguYgYKjv3vuS6+8ZPIQ9+vDDuLDvSTnPc80Majnag7TApyjOAfYARwUIwWXGLSU+ELpF7xTcewixefoyt03KLsj6yLg5LUjTJFh9ULPWQ1wyR5OUjnzy9mWf2Xt+pWfz8/X5mk+WV3706k/zkNiUINyYx2ZX65msUJxjXsxxfQbqFFDI9FHFdKvkGF19fn29JSCbWLuWl5ohdpF+472kAMAvAoCbGgFfuGIuGByIlEDJVoWtHpehVZnHuUJFr2FlYrRh8wF4y2xLVi8iuwQKAB/GB3LiWg9V2rgwzT2dQghaS9wiUyoRyIyntil5p3kPwYLARHxuAoyuVJXynPn2dRl1rWHmVZk54vcWVLraIMDfG70Qv//y91DvakOlqxJ/9uZz8d9/+pdRuyvGP/nu1wkM3hyfOnpf3LXnSMq2DDD45us/jB+cfj2+cN+notBeTOpsjdTHZH2VZhXSvLRknh/qIeDXm51SuyQdovnJwQBzeIE5ofqffzgATPVVfS7FpGJeen96MsnOHF1vF5EGLQF4XCYE+32oEO8jFlKPYBOPpw7dHP12nj1zuKESF1phFKFyqDOcZZgJgpp8wmp7a3/6nPOgp+fGZzIBIADiCvuw4FzGyAS/pwzWyhgKKK2ctm08iYzt6rymTs51x6m3ozuG8OTXhfTUOjnUpnyOlsmnmzoPMg9rcwAvwJFla+NrPKhZgnc7J95Zmk6q7A0V9jWUKPTGR3ZZf7A+LrA2LKs2l46yHhNjaS6GeA4GmV8ZgJutdQFGkWjRJ863nXRz98AOQLq5x//HsvUuW0NIPAZdNFmY5TCyJGLe2oTJZeY6O1sWb6B5acG+geuv81I3DYGckoONSUnU8MIUO1u2ENeDo43Xfhi/VYloZTOUr+pG8mEl97tmCE5tGVrY1PcBWw6tSIASm4Rx7LAf4KASdSOBiGxT09Yl2+A+SL00pMYfERuhmzqqdmzCAQHuRp5vlHn+EnmORN4XibsJ8QMqunJMgu39JO8SINkH2Wi/n1wgHiAy+9pQOSnWsJmS0MoIjWqy9VESZ6/5PGSl+Cmhr4QsT0rqEhhMByT8Ib5QT1INsbWxBXCKxIkxsb72kYS0xuKJOOIeJXxVbFzalRjQqUK+aSSgUxi95+pZeVk38mmNtVu6hGR0Hy58B3C7/Nqbp5Pjkz179sb+/ftTTCTHpRPX3h04FjHA5DB2Se+dPRMnT52M1pam6C+jaoW6KExxCE5tWiCUlTCsS3TcJgNhfwn8lPVsnB/57fW3Oa5rMya/4urP7Lqrj292xDookbJvt6pDfl/K14mdEkSx48bBa93n5fkcye7d+r0ZENPWokpYN8ChM4H8UkHJM1IoQHGD+ovXmZqwdwOxxlh5EJUziPW2CeZshfZmTAvBkVKjvP4a4uvGexFJqeOiVE0vii3MvwL5NAvkaXNyCrHaDem5TWAp75escvbV+iPZ8bT6ceKtkRM4GGAnQUL82vmTuOjui0MEiZ1Fbe2xW4/HgY7BZCf6D//st+LsxHAc7tuLWl5L/Nojn4+fuv2hePMyqtTU5Y/eejrOTFyKX37oc3Fk3754HfXomVVpfwY0BJ7Ox2zdzeuUgBNSM8fFGEY0Fym2EhodDtjHqy3gowGpSwm1vnbscToBPu4vFe5VeuNldCPA1ud2CUCL8wee7zsKAJHlViQoGRAz+PLu5vbYj4jpPdSxz6HSOYp6Wg1vFYUS8whV8EUBhbZcFr1afBodgM+CLrdRV1MdsAG1RteHy6xD2l0tCo4EcHjVa25EO4F7DY+gBKeqhAwgaDt7cSB0gGdZxdMykp0S7XY66XlwBtV37RK1P9pLsGBdfc9Vygkcee8Mkr+LBBO+hFfCaQD7LE5ntMWj5YA7pFoA+CSzFSyugiMOJCCH43TsVfdHV6ETtT3yLJTRCqnF2Gw/jpD6iIs0FsU2SskHh1x30s3XAzsA6eYb8x/7FrtmHUe/uwlg5OIsgeaxLgjhPkDTSFIfubFmNrOB/CgI8o2luqdIoEqUrtPrXr1QUvb/j5TqBSEsT9jvH2aS2GvXyICNuBe4eAs2E4KmrFy8R0HgHYA72MqGdxniu8Z1P6o6SWgpjVqBNamqo9z1VnnPenBD/78+uelKtOQ1k0yWk/9+QVF93m7aSsTY+z/wiBehNlpaMnCUl2F/JUNwiCTVFXXLbXucX0n9hU/7QhutTqR3K+ThnxxpQbIqTH43edx7MkU7SDNA2QIEbBUbOFtgWdrSOaclWgVHEzh7UGqR9WHK5jrevDqfBdnlwtZxiO5Z7B1270E1aXIqXnvtxXjlrddiLyDpln23RF9PTypnCqP4c8Pn4+1Tp2JkdDy6dnXE0L7BAD0myUcJ1R4J0mVUueoBUnIwsNr++kpaE5kGgmp7IqtZ/RVXf1fFKSOifnTPsTllUiSM3anF9ea8vievrms+No7v1onSRN185OV6dbFQi74O7GtEKzyvjluS/GwJjtbyyctSapJsPLpHYhxC1Pgz1fkSdjpjGMdPQECr2pWp3elyuhEQwBRLBK0Ec3I4wngqYanwu1VQn1yTqzKatSrVuZ6qpfKJgLcSSWKT12b9p+N9eXIi3mo6k0DS/r7B+NTt98UggWEXJ5fizOhw/PDUW1y1EqPlaQh42QQwJABIXaiELWNvs0C8tSkI+Ncvnoq79h+NIwP7YxKmwSRe2pJNEfXyr0SddQyk7ZPrgf2rYxMma5KoJE4Ox1LsHsCMFygxydMKgGeRZxjzVQLnthEzSMkL6xv5jczPpk9tnZrbAE9LrXFwifWAe3qoZyMAokg9CoAOAZaDrGT0dgDIPvI8DSvpLGBpEiC7AFBaagVsEIB1meedDuSV1cNwCIIj718uu1a0xEobXixR97QtzYBMpUbaLJZoayufrifj0yiaM3YtxIxS3a+Nz0mA1gzgRInRIKBNpxbT/Japo43xnY27ooPip4nbl4+lqopv4cj7PVXVW6wbGiV4NWzHztcHUmBoUGTdgy8DMpN3RlQnfbYFbg2NXdGDeuFQaRK7qQaYO4AonEMst88zN/fAaDWo8DitTTMq5b/zdvP1wA5AuvnG/CPRYjcaAUdSA7BFad1mgeX4KHu4e+TaluI6nv9a++ZtEpBFCEQNRs3zw0gS2nLoFyDQP5wSbrzW1kNuv38ZOXjjedzIHXpZUilrDxu1pHs9kebIaHMyBPHVBmf1ElujUUyuEA83UtAm11qWZbdgj6GXMMvXs5JETp7sD/ZTJ8qVlM2Y+ppeOfU+vqQS3sd9m98iPbUxWUKS+jDPGlEtEhjanhZVYwCIEg2qe5a0IWLm12dhK+tbmrfdMnxGtDviJhyFaACd/dmXwqUJHAks3gA4Mj8JpxSDCZpLomfNHTluf1HhOgU3+1ZUaB68/544duuheOrcyXjm9Fvxwqk3Y3d7L1KhJgjV8ZhtQXow0BulPXdEYydqcxB2rRBYGtTbRm07NiYdvDEdN080PHkK03CD+69OXuB/xtN3ljpvBJ7brR95cVx6XSmBWqUMjNm6SXldd69dlJVrzZjzoI2kokWdlQrWj3d+xxJMp0VU6SQMmwCRyckDIEgHDdo8aTuUp6wtecvyo44nBLzSHbj661db+xapdbEcu/AUad7T1a4Yr+5F5audZ38YidAkUgcZXkgu5frjdEZi3xhlC4ypZabx8W5U8Dog+lubWpHsIO2AyPV8qhFfBK/JDofjSqIaknRhrZ7138Qfn7n7k/HkcVTiCqiHNc7jDGcOG8ly/M4L38ar2lT80gOfBpSU4sSFM4Bu54BJRwfLcZ45q+80y/nZBx4HUF2M7514KT599wPR19gel1D/omsToNPFu3aPizgk0ElEg7Y7jIyqbUl8kvKlHZSxpN2Y4qDVpD3S7PJAuq8bzxG9OIxopU97YDodWiaoLUDmlI4KaHsbXueOoca8n+f/NMwglF+Tw+wmgFHujVA7WC5FgsLayx54Fyvlfpz2vL04GW+h3SBbJ7lLR7JsfyeHC9xgIFuls9oXNczhCw+/Kh3dmcTIKGnmqavvXpg12vN54PwUTixmcNVOrh0E821D3W8OqdEcEqXURtp2HjVZH7tm6tMB4OlGlbcTb3ezs8SW4nyR344/X/AuiFSRMpYpQ1ZQNw40WnHuoLrxAuWpDlzg2hWkym1oLAjSEsOBtXAACWMnUknno2MvQ8m/Zkaxv/1ijM8NxdgioTiGGIQ0ofIR2Pm8mXpgByDdTKP9EWqrC3BSIVjVk3bDmmcDdxFtg5hbgltoBHUBgITAPMS3NhvNbDiShlzGhq9etxHk19zufihdRFnNbFIuzxnZ/6GUcsOZyrFTqqFKFt35oacu+r8Twmmj3UdesPtQNwOpHdgIhMaMhuppBDNixPMfJEmGbJWHpGB2cq0nHKsUKwTCbDvi9/rqRA5rWV/fLe/zqlRMak4GRJ3nbfSqCv55OzKOtldu1SPrC/d5E9hIAAq0vEvnDbNIeyS283zX33X1L6/TFmywiK6/oIskEasHO71ZCcAES+/iDbKkkwz6vrG1OfqP7YndhzCiHp+JiyNTEDYL0XrnHpw3YGAN5Tl/kYCg+CaZK8nN5omvwAHHy5ktTHYoqaTsTffGC/RFaoQXrKbUJsbcuE22V+mYbc57yNwkVXWdIJHn+iKxJhDVCYDXml12T9b33iOH3lwSQ4f76orMi173medh6Xme6y64jh+WZ70lIDXYTxZjeT2ov9JA1dWyJyvLMLWfdXKq2hPVmg4fAEQQ4S282orYZQAaXF+3S8sQ5eOoKDWi/tldmoJjL8Bbn1YYrxYkUru6L2GDBEiqoLa31Ml8Qt22OIoHM5zTADtWAD1KKpaweVng4XUeS6wrBdGTHs2JKpLGdoj3VtbxMnNRgt/B03HACmpcCj4YnqSytl3NFS6RXbwHIT4S7zFW04mJ8mjjMRhbeshriGnsj85OXo7RCpIGnwHv4XlQ0jGLIxg/O5GA/NSdj0Bgz8RXn/1WDPX2x6F9+3FKMM+8wj4OcORCYOwjPf81owamSuuCUnNU0HTdnRJrZVMLXiU5tkygVJPE/NxiN0FxicHXMR3dgKM2HI4M0cYO+qmROh2jozoAA+e5bxBHEXtpvDNutAHGAeX3MhNScHTKTlIW7hF8Mku4KpuZ7UiB9s0W8DpXo861aMO7XGNLBlJlvCxbJ1Tqiq0rMTdLPRfaom0fIKO0uk7a9zQji/clWAZA4uFvGAmda2oLwdUNVaEEUoGk0iz38iR5YnxbCownAEb7pBZA2Dwe6xiEKJVwhAEIcg0aA+5V8RYouDF1Avr6sBFz1l9Galelv3PPiq4ze5C0UVNcr8+y3yPJRJ1YAK3No2uhDnxKPCezVFyQ1Nc+nEBSlvvO+83aAzsA6WYd+R/zdivyX4Tz5OLv5jkHwTPBJjMN17MZ9QxCX7LpLMQMG9fsfFNcKqOnzebdhQFmB8bZrbj87WKTJbLFf5WeUGqheF8iaXUL/K9S7vaF0HcQSTmhuv21W591Y83Isa2vEYL2w1mWqNiOQLRv3MAOwhEts2FNQmDJx5T7ucZH3bqcTc9QoECwPmDq1depjqEqFtIHximv4yLEus47ShnZffVtN3BEYvdHldzcs34nRwjH+pyVPiRnAldawSWp4NWrvHfB3mTc4MReSTQ6a7fvq9fykTjx9L4ugQUFnvGYoEbvd6tXXslmuy+qsHXDGS6pcrlams9FO8+rjh+qEOEjuLs3eOTJFQnR4BlewHFDFpelpb89SgP46nYiwdGmGnynHZ18mSWuCsRhoXuZ4J6o/0HIJdsU5lGeJNzmefZ9bZV8RsuANeGJ98tAsDyJboGRBJVQKQMhvKf+z5gMSpIktrwnWdVwrdJK/wwEaxwzJbfXSuZtXtbh+md+9hRm6nmAotV62Of+5S1OVocSiFTDOuXJ80W84nWV6HfWykUI1yakR81IXhuVqF1joFXYnE1OGHohMMcSwMrz3vgpsV/Etqmv8zJqajigXsSRAQS9LloWLRP1pxJSigWIYFXqnCuqVaXxhLhuQi2qUSN86lRjL+jAZq1Eg1JQYiVJAAbnqHXW0USaLxsrwW/HUgB529DhGOrpJU8cxgAMBMH2j2q5n7/nkfiD578Tv//8t7GZ6orDu/ZCqLdHO57rbt19IDohvs2/g9+3DR2EwC/Gx47eE+cmLqXXnfsOoc7VjjohwJ76uA7pAc/6JUcQgLupKqFNkWivOJe4xpdA0JhLi7j2d77pYW20ho4E62gXAFTvnDXWyWbMuhYBELre5jICwjZhmyvA9ac2hBmonxI0NLTbk9gsWT5qsqxtzk8uTUkArLtsn51e1J5nUeVtRF3OrhTE2P9Kb5XqLQPOCjUAF81v7cnAkTZQuhS3XxcAv1WlP3idG5thFafdBUBfC8HUlZxVBYmUKnOhmZe2ukWkacZgs+ZV7JWWy9WYQA2zRwkP9cjGsxHVRfd+1BXpI22wbmkdjL2lTmZgM/GeJuIi0i89w8LqSCqIuoc/PzudmDAtxAX0CfY5nIRRoDqf4EqVfVdSGYeGCR5oP8+v27KO2Xm/KXugbne8Kdu/0+gfxx5gsZ4HHFXZtKfYTKGLYq4oASBBkdbQxI1qIDbITKUQ70yWMLRtZZFviLG5DgiYBTwoYeOAIepgG1w/Re2uvB9ikkApshmptv2XKS3KSWQjc2u4oeSGSa9JSNhz26kYaWyOj6PokJXLfZsl83CznOfaIgSv5GYX0qRONrw+wO9F+LPjlHbDKdUT4kIzZoj7lCiMIqh3xuX3mBumHHW9R7GLU2q2NNpGY5PoRjubXVkWN/qeZpfl3uiNm13PBm6/SyAltZNUWwjGRKhnhLVt2zJhwNw4Xk7R7Jd3oxsDgSQBJsmRCEPy17lISoyH3+YhbrQ7SkclfihfYl/pz7ZlbaiEUpkSHH/zqZ8K9r+9o4txXa3PrMzxWoo3l3GP7Lik8eIShie5Sd6Ybzs5dCLZwR5ipQrhRl8U4UY7p+pLQoCZXBsvwLlfV4EN+VmbRL6RgcRknlZ75UqbJagEJB73M3HNmef2SZpB+Q2clxEhV1zu9pW5mGe84dPbfKa00xCYbZcsy78UqyqBIm0/rNMaKLI99cm8dcohAnVsryQuLDVXYnd3pkopw8Bxsf+3m73W12elgDew7lbcz7foVW/7erseF1CB7G7FUQ1Xuwapiitk85wAKBHnEOsOVu7Ku65LOa4kM5u7qm3WyM+xX4Tg1rkAX7eUHtk/xkYzZteXP/5p5nyJYNzYQaU1TdWrpTiBe++7eg7E33zii3jyq0UHUgzdnRdZD4oQ5j//6BPk3xjj2E91trfGlz726QTkzlUux+N3P5jU6HymZvG8prqaEq4kSWQtSuAbsKfDmAogQkmLAZEbAUWCBNco0ANeCtF+YC2cqPXGPGChu5VA4qiSyqwg6h5gHwdFzJMCa9cCantLICIfX0GYcZooCEBlzCy81AGsLqESewlGRDtl9ONAoYNrZROmHYAyF8inHUnY7YCO+eYpytA1Ns8g5fm0Jyme/Vtj7s/jKALpUbGoZBmJEuAoZwAYU2uGgLNz5RnG07EABAGOtC2r4eXOmFpKeQqo0nbSr+1I12yy/aO3uxo2RyNz04xPS9zV3A8zk3OAqsx5SVMcbhmMXS3tSId6or+5MwGsFebAUEMvNlSzMYFnxwm8881ip3QB1b3hCUA7HgVNTC8YL5TPWKbYbjBWGtmcG7C3kinm2CAa88p0/c7bzdkDOwDp5hz3H+tWu7gNA3ImAEaEbkjuPDP+lRur0gLctEJLXygX4tSk+uluOG4aEFFsNBUCJcwROfzS7FLs76zEPf14zyGfD3MpzEgFt+QPt5wbHVgJYwmbtDne4M34gsuIdFpVgthKqkab5KRKXSKwGLiMEF4ryP6wfOxoY4SBm4B4vIVxVS1JHXaBUjvqHLskQtLYenVGwAtYth0zTto6AyQKciwrS2zs6U8uvyOT56ILcIgAVHvaAY3NEOqeUYVMtS8DqW5HJGZ5b/5unfNSNr/iOo/SkZIpquwk7j+ZWmcJ4mZsGFohEySqt5xnEE0YfkTjBDFInPN46VvsLUEiIimDAFJtznqu9dVavdIxyrfPVL25EdU6c3H2O6JZ7dbyrf+WeokyeFq5QYDD+FChzepTfx/TJRq7uLDM9VOUgIBqY49LcNaQHFV0ZHitDFN960u4+nvWT8yl1fol1dHsYOrDq+/QLkPwRM2ojITgVslsnN+CKvtbInuzJAySwFN1S9CTPRPenbpts1uuHPMZQ3cKyYCjnzE68pNKjOw/1eGuJ1lielZbUGFCIrRV964dz8EbR7jZsuyNEs+5Hs10y2+wW0FWCqyaBsyrrk7O2XmI/zbmfwFk4JOepHq0IcU/ysH+xls5PgfIf718jntbeMaLMYbNUzMgIms1ntKIKffSzClcUKNrAPhcqk2k8XBBc47qlbOBxWuKeHLObcdiAamcQb0F+uLwcnkOIr0azaiWOebaHgkMDIbqmM3OIz1SSsa1TQRaVUJTn3RYgcEP5XCUa9oQGTXTNp+nWWqD1RYAiXpQp9RBlCHImUcStgS4FOQeAQAMUz+9wp0AzJ1vrtGeRuyj2pJX0d1InHpkY7EGCGaaWRcO0+YG1FyfW7hM0OLsObTVxkJKLr4vU1ckfW3dADiqJjiqn9PGsaoB/DiYKp5smRhf67REH8zXkJixHiUmj1I46pcC5rLODuJxr9xejueqb8cwHgDnaV8jHmsP4nWuBCA6VhiIu+irkqp4jKMsvhWZCa7z9EMP7Rpo6WZeL8a3x1+O85Nj6VwJCaVPYBkJ1BzX6pypG8+mDXiSnXfs+fTcIs+nq9VOurl7YAcg3dzj/2Pb+vOo0rngZuoBq9su6zBmB3FuuhDnyqgt1LBFghMlOKpPAiXvcPM/P4NhJ/vPbT1sOhxdf2X9XR/suzmrWuFGskYkfLA8P+jd1kNJyfuVjKiKwD6fei3FI2EjlqBz08+g4FoN3XBqSPvaAahpM2WTHIUm0EWweVxgo3wV7n+hdTwulJDwGd8KKrcHNZ9WNsc5Ntk53ArLvZUgstbJUxuboxukv9cl8pS4hvQAHCFpyU9KRJAEFO0QRUpBHJd60ktisUz92pKjA7maEBts/s41bTluOFGkBG7mWvyDjL81gcBPEohEBqaq2M4qRI22Ad3NKpeqkrNJsqNniWEzDnff7/wvT1Wi0papnMlNtZ+u9NXGLOx7ysrKl6De8sqNd6bf1knJlOOVUXLrL3MMVNlTvc26JQkD4ypAqB+f9XflvwAqLawJuKPGfCSz5diEvkFbCZfR3GMdVudCnsO2n9Qn3VJ3EVM3isznkvMYNbQFbDBqBkBlXfEJsNb2Zq7i5q223LMS0xkrZ/s+NH6NwXuJV5zyc6zzZP8387zpzU2wY2nX7qf87uxT9UbVrJRG1Cfzympbf/Ta3x2zrVok3MmlbfalVzrjfJ7TWsIvVaIIYYOEhEGCgF0gP5b6JMFNammcvyqR1wLP54IqX6gGNvF9SWmnZQhgrrohO6AdkVNglnh0c42oYwESFunPOqf+ZNCYXHuXYZrYu1md+UrmMiLa0VKwJXPE/rFMa5d6gPMLeINLapkAphSolXOuI0rtVVFTCuXKk0lnlKSwA+lmM9V4rZ3aOa3ostp9C5XjFmP2MA+Mqab07wL5DWC/ZfBXwUcV8FElBlKS7qJGblm9gCwZPKewRRpG9WwRaYmOGUZgH402zCFFKuLQoTNuweOdneJYiUkPMBqV5c54jjVHNefUPs5Xp9Drm2aNRnpUwD6pyvotw2S19em6edyEL9W4J+23tMG6zcKcwfX3fBW0B4izjjINugvt0Qv4GSr0RB8KtyXULRdQ97xYnYjTs8Mxh+rjqyhbd7T0ogKKQw/q7vgmmOh+I7eHlJxP8F37KlUWa5Vq9NfaeU6pI21yNugKfJRAtj6DPagcCnxnqjjRoB+Lag8UqBuZk+1Ousl74H3s9jd5j+00/y9FD6ibrUpRfXLBrLJGnyu34BlJt8Us9CzOWyW3omWIGaVMrbCBD3dC6XxIKXGB2Qws8//vZB3cxDWUbQOEpM3wBiuVkaz1xBp9L9eX/pZgM8pRvtF7lfFtamxSbEfp+LsM1B9NMIYSBAxRhQ2xlYCXe1sqMUo/XcLmpACx0smm3sU9EpVy/MzT+i7BQVVVqSmVJaHl0bre5asE/3w9OOLuZJ/Bhqj+SiMGwKp9VFJcpIy44ZKUi+Olp6kCXOlUHiUohTJg5bpyvOEaSaJV0CUhWFfDa9x19WltFqoCPvp5Y7JWgsQM7tofG+Y9965AlBQERxAtPBgQLhDxPELaeCyjIrPNo5KIpiuSq03K31ifzX5bIwGS/bmhdmkO2OdTqP9UUZOybrr9amKcvUcCetvkaYa1EZAksztNlTUzp3SrBF8LtE8XhuXlkqCQfF1CoMC3y91zmC1mwTWlAVOiv/neUQVIE3Opgge9RfpwkfrOIV0zW8G86l56DXRcsnmTjY0lmu+15oPnVTvUkD7zzqVkxadPCafqihlDYrv6p+pu8WadctXM7Xthiwyu87D1M8aNxHBatRlTh1QiXwGD522rwWErXJBi23mAQdM+xed2HnDgPRv7LIFN7knjiz2PEpgy6l/1qpHkdFWSYNeuxgwbABDwQ6CLfbasTV2iro7elcRX26FjCEFLGXCUmAvUse4q5pXgk3WQii2RbwNtW2S9UX1LACgxr4rfIpIWifPk1tx5v1p+XgttrxJh7/wWVLAuJYYU/aHK3kXWlj14O9CbXRkwpk2NzmUW2SObu5CQ6AkOSaFlX1wYA2wDJlEXbEY1r9heIgRCQ0wyZ1+qzEVrrQeg4oPDWKCeJ9DoSfZdqC/CvLBqehdcGDdoNWrTPTJjMiZAif7gyaMvuIa3GnaOBR03sIanZqVckfDVNJrK9g6f7SOtu+N422E8y2FbyGSwXAGvzld6AE5K0FqpQyNrcRO2Qi14EkzsB/fTOnCUsl99M4DtLEGmV+jb/qaO5BHPvu7QxbqjRF9143pPBsQ8nvRq2Lq1ov5XRNUPnyC0iTfqtlbv+tx3vt8sPbADkG6Wkf6ItXMjOLJ5LGksqCtx765KvD6+FGMVYjO4a6bkMu41+e/sqL8W4Dq+PUHMCKKID+A2eOM12ZXv/91NHfI4EcjvP5cPfqdtTbxrNkoNuJWGSFy8b8LIPaSuWn4XBMzJTWRDVt1FuxZ1+VXbuEBJbk+WOsr+OLYIcYeHDYOfDrVjDttbQZrXw1UEDWTD7lI/Hs6odhvjuNtVzcR697OxsVVCcEE2QPDqCUlzXDf+vEZyne3zK23jt3OmEwcBg014zII4msTWYmxhGt12dK6QTs2Tf+L60xDbInfTPFRc4nb2bpwSWO4NOmxI0iP74Ert+HKjiUlkX9a0++EvB2mOp1I7VX1a6S9Vra60OS+De1cg4htHUX2ag8hRv54kYVTDNe8i+qXQ9VsmgZltsI+1Q7relLfXulqiLAvBgmSkxWW1yHKzTbNwtmd4ZWeUFGbEewaQsuu2e0/5AXr0BKYKk0SQdTB5zu8tEM4DiJl7JKKRnM20owKFLaJxoUzJsJ+r6wmjAlKi7tnG6J+GWJdGXK24gDIDldgx1FDnQtVqkfUnty/ysnnBDP0nMZ2DJMcnzbNU4nZv1inrO+e7xLbWcc5JCVCfL6W1HyRZR9eAvH8+SF7ZvRnwST2/2k8eV4qWwDufggn7hP/UD9oduTLhVgCGDUb3MG3aQe66e58BWDRxzDZnf0oxs1dd9mlsZUK0QIy36sYa7YJpHB8IWLdKqt+5Lil55U30QVkbQM6Gm5V+6oRDJpCSkQrMBWPtZLNrw8U00DXEhup5TVugVGfy4J+hBcQh7dE9uVKeem0I7ezsI72sLtOGZeZ0E27T1XoYr+G5sTDLWphJcbHmiVeQBMlEmIUVVWlA1oPUsbWtI3a10UakSEUYUOcJqDqlNIu2KtGaZ40toEpn3XzGZrCTGl1EKgSIMG7QHKqBusp+s2Ea2Y0gkG7CcUINKXRjpSfah1i7S9n81Nuks9VxNPk8tXSj4kYfCej9o3ok2oGjhvk5pVjzsa+0K+5vJbbZSnsKIlurwEqzfhSmR8vzs5eRrNHfgLZdSMeHWnroB+cYMIexMr/6pI1SBa93vnRa4RiPEC9pgX29D+mTrsVVs+9r7krqyM6k2hzeD6ljS4dgkRbg6S4xIWzwTrqpe2AHIN3Uw//j23gXXDf2jUlw089i+MDgXLw8XouJOYNGcjStoyyH6NfUsEGqT27m1YXmODlRil1DEOIbFt36a9/Pd4vWu4/L7frl/P3kduP3uIUlDiREtFznRKhwzPpIrL3ftNW9kgtVIqrb1nry5BwGszrW6GGzvoiHpEaQTRE2/BEM7B/u5uKxapRRwWhvb4tb9x1Axa0Yb730Wuy7ZV809/XE2ZVRHDa0xaHl7hi9cCmOHToSP3j1+egf6o+e/X0Q77oVdvPMCCgp2RQYkJoIsvzej0pF0zCGu8Tj2HfXoZhGvUYbkkYIsprBEdkwHSkNjd0fJcryTd/j84gmigKz1DpOXSNldQFosel/kLFPdaIuclUlQRw1yS0N7ZOBcgIeW4BdCMCmCWwkZlATyh6EVOsGj0PY4/N2i1ZkRCw87szm6YbakDnmaGO2aVfQAVHZ63f+FlCbnIb7nUFG6UeIIQi3SaRH9nvqJ4i2RQgZZ+lWtdtYab2RlVD3YaDhUtPUNgCNBC8ZWobzwXkgYdXKQbRqYw4u+GXcFc8j2JQoFQja14KcTFIDkQru7qzgQCJjoK+TtEnbC5Ka5JZjw5DA5oaKJe+J2qQwVtrVJbU2RjERjWkkr54ZtrkIk0HvW0rWqoB/e8weESwZOsc58MFSNr6pb8go6+0PlqvdvMCzrWSlAAGfrMhongS4a4FSCAOFCuzbiLeT7PwAlULG25Av7+X5JOwpfQogRxIyi83YIuMqMNel9zzrxzRP6RSMAqJvpb6xxvagc8fxK0DlKp0p0EkyQhh8zm6SmGNKm1bsW4jpRutL/tnKePX1tkGvc8bTERyVEziSYbAxf36zeOi0IIERfhYg1AVIefJbUi1knnER85IjgLqsJfQGeStrbUEqqdq4K1ruMr1M7KgCqpy9rYAHQJPzdZK6645cBwMCrkILrvHbUVkjTpSSsVMEctalNY7DcWDB3JbdQpuXkNYUkNDYfwKxUzg06IRl1G2J1O1kZSJONEwmZoq/k8QNDY02PPa19/NsWeVUPz7rkkCyDecL7jXix1lVEP1jLy7QJtULbdiDnbdFJ3GsZnCvnrk+tzXZ2vbe/GVsUueiv9SNx8AiTpX6EqNhbTiztd6ynMM6pFBqtKBtE39K6kpIhVTP7sWmqUQ7VT9OIeF5ruapU7VaTQCJiUg/YruFdH0e9USNx5iCqS51zdr5epP1wA5AuskG/KPSXDfzrZIbcRuL497uCdyxYhMgBUNqxGjAyO3Dk3uTW9l08Mob0bThLs9BlEkvmsePKiXiltV26xr/qEpan4/lKa2RCykwElCu7mcfeOHP2pT16/pS1355tr7NAo5h1NlGoCrRJmfzxyFD20I82d0abz39g/jBM88Sc0W7seV48KEH4vFPfCq++affjCd/4sk40n83m3RPUouYvjAR3/nWt2Pvf7M7/uT3/1M89KlH45OHPwNRwY7GS46oXsqqGF3LIbbVGgMXVSlhjF999fV4771T8ZV7bo+9xb7MQFrNP5JxV/APhTesJeJpEK7WicBcyrdK9ewlVa/fFglifW1Ht4j3lZR+KblyLBOhsTpDS6hfZeo9knWbj4dGy6rmrLUiq4LHW4ixUjPAKrY7q4/JWv3ITqmVhuyZQ4a1U9t9c6apFnkI1ZYhCN4MJAFQ0+zTmHuFOFd45aIlql5C0gFUZ5COoVZjLdM/BAugVUcUMhe2TNRRCYCE3+6WLgJQoiLTt4zaGwQkUskWvYJBQMlJlnBsgMBtUGWN3xLxVdaE3W0tySvmMsSbdo0a2I81ljEOnwC4QYBSHwliAVYCRBsqY69DcyINzfp5WYo0721PUr7u9HUj3APAxyICLn8pxpfnEkDP5paFcLEf3KI0cC9EXRtgYx7id6RhFokrwTK5xjqsS6tlrDu2zQ/nSQYmIJCpl/2b1gbq6VzKIKKZ3ngii8SAqtaAwsROKhFDSScBSgQqABw59Y6mHstsRvYSCkAwA4QaV0FFDcJ1HjWwVkI0dOAdrhnJr9PHcTA22gRe2C7C3BhGrjlHjX3GEoQk/5UEchhf+jtRuds0owFCvZHBE0g1MP/QtcsqtfEeGqY6o2DfOswmcKTE+uoksF+E4TbP2LU0LySnD6pxrh82VSaZNDTKvmkyrlPdOqOKaTtSEwOML8FsUgHYevqUG8x3qtrPvEb9rW2MNT6zR5RxomTRfEopLpD3N8QIoGECaY2BmfUguYzX1loBCQse25KnvzTvfPIakmrzy8vjzGeYiDwHbxOPrIIkx3FtBnQVuL8Bd+Ptg4xYKwevTJMMpNgmH1ev7yt2xsGWXawFbag8VogjhUUogLfKM13FpmigA5fpeMoD/SaAk2JYpR5BmgUwOlEbidZSSwziUr0HrYHDLbvTfub8tc9ySZPAytc8bfQzT804cGhva487lvdH12JHAqSC8yrtqc5VkTIhaUNd0Po6t+aQOo1VpwBUc7SVdqZnnnPrBy7PfufzJuiBHYB0EwzyR7KJLMxyvLJlvW4F47gL6CyEODxHNig3j9XEuXa8LO0i9sbw5BALI1tK3UljSszAVe6Ao3w1FZJnsv4z475m3Ce3flU0Mhiy/rorxaw//KH9srxi4nZCDFIjf9Oq9PrRFGpuN54EaBKczbhQPdA1Eff1IVG4MBq//3t/GH/lV/9KHL/v7nj1xVfjD7/+B3HPXfegtx9x8dyFxIWU2D10/N6odqzEnXffDjGL6g2Ejf3dNV+MkdPvxchFNlW4hrfecQeEVW+8+ebrqKcgJRgZjaGh3TG09yCEE7OG6hcJiFg4O4sufXPs27s/Llw8H+fPnIfabYqhW/ZEV097nMODk/PJ5GIpsY9n+ESEaFDume3GNnHSqZ8m3h80OdelveWBZrM8y1HuusEf5Y5ulrRtKHZ3xuJcZixef02DLr8hUNBXvGpySIgLMOV0X2+yjgajvL+pL4aQEDg2We+tqZVphD+EFFHX65d5L+Phq5xsxep6EsJuAe+F2ltJtG+WEpE0x3UTBBhu6Yg93V2xMjVDENq22LNvX4yNXoqp6dnYt2dPdPd0xZkzZ+EyQ0zPEwSUuTO/UI1zFy/Ggf0H4/z589HV2Rl7uLY8NRV79/bEEpLoceIxtcrxLiIhwjhB8C2333FN6rur1KDtlsqaZ3IvE69FByKCWqVQjo/2D7pubmONqZ2fSF7CBnGxrkOKJPXgWo3+k6c01pGeQkcs42nwrTfeQEI6GL3HBhJhmUs2dazgWuNvDf/9vJ5kPQW7cxDdOsQwqaaX7AYhxpVHzCNR8ZxA6UaTBLxrbG0Bj3BTg1Ek7pxuv6NYoeQMpLsaJUcuq8Pt8NpPp3XtzlwYIiZSM4SrzIomTi4iGWlg4mfOPciKfh5qaI0B7FION3TGadb5i9yrOmMaBt6UTm5efwvdZD5xKFPJ8lw2mvVtVxIpWFFlr4JaXK5GWX+N+c4DLMrz3fhC6eR7K6qCM9HXdoknNnPykF/PU5UR5tyjm/AmvbFllfehYwliLuClLa3cjA9IhjlVReKOqhv7lnGqBElK6TpbJpgLPqPUnX9V0log8AuA/SlA5iWC1voMFQE4xo9qVnpPe+wJpamuHa5lJo9ONdbi+eUJyiinOEGCnSSBB8QtjWXMhaZextITWS5pnajBnJrhmVIy1czicbz5YNxW2JPaUkZtrR9PeiXGrdH4Vq5ZMKyoPuPLzqmYKeWmG/xavFw+HWUcShzq2hV92CEdah4k7AOgE6mPIGgJoCMg8nn0t/fnq7F7DJXjmc1sn/YWe9OcHwH8lGusN6gOLqJyLMMkqS8yL637wjTnDU7MnzZ/DNFOusl7YPMd9SbvlJ3m/+XvAWMoyJPzzw3WBTEZX3J0mk12HI60hEk6v6E5Xa3TqNSVYpKI76v7QrrCfC5hdL2rpArIqkhhw71XfnKtm7BKHjnnMukxo0YjcZRzy73eTUe1mm054Vcy/tF8kQBpk1NO6XaPrx91khi6nnzXkyQZGTDYDncZIrinsTtOnHgTTl9bfOKzn4oRiNf7P/EIncY2x57pJvj8sy/Evn0j8e6778ZXvkKQRIj9P0BydPyOe+GqQmyxGY9dvBS/+9u/E50dnXF5+FLcfe978aWf+7n4t//i30bfQD8EQyn+y+Rk/Nqv/VramGsQDq88/1I89Z3vxxOf/lQ0I6343a9+DQ4shCwEQ8tzbfFzv/rlaOwYjLNV4mcwhj305+3oyhdR4ZmBg3mJ3R0+rNXcMjmnsln6oxuDjb3ub8mD9f28ViUB6WIbnO82JGp4rcs41ZznmVkpQZhBODVsQmBb7wzsb5XzWhn5N6/shFM9CCHk/dZrY7K/JrE1Ok1kq3EIdZ+bbFbUX5nZNGwFjtKVZL04BlHKq2G/arLVeP6734vBvoE49IUvxAsvvhzPPPNM/MKXvxx3331nfOc73yUOC26N9+2FeGyOublyvPPmO8lY/Z23T8TgwAAuhFti5NJIHB3sicPtA9FXJW4LKjqdnXCj2+mrRIihyoUthmPbguqPhJZuizvp31bjBUDwthIgU3uNFVT+ZiFqLy/MchiHIKgSPfWfvx29u3bFfV94LBGZzcynXRiody5jA4HkS3uUzpZOwhBciLep163cd99th4C/rDhKviDevI6C4TTggQvV0FHWu6TKV9+F23x3VHy5PuiOWts1kyuG6mA6SVCity5GUrpi+7eUJyCitw21LAj5eWxaDAArmORxz1L6VGog4c/cpf+cwws8yxdYTycg1/vJqIfrumDyCNCbyCs5PFjNw+t9JrsMZovUwsOCmOxpwyYR9TwlDPlTJzEvKEgSLPJezSarj+8cEHBDeYMwriaLvE8gqiRwwetS763dnrIANM8vtwJcelObm1GDS88Q/dsIse98yRK1X/1ulYvMuQSQqGOe/KY6os+f3hLlKjUj9elqucxc2005xGMCSE5U+plXC0ibphMTSUmV0g9tduZhBgyXpwFqi9jfKLGnHgxCAZ1iVRARBaV+15GIANsys/oaZJ3YTUj88jW+SJ6IntCVY63oROYLU0k37Ko0W7COKmZZU4Wlts39U2dw5SqKkJyfqRhfytw5DlNGD3csujhdADoSE0nA41llZa/OnYuLqPod6AMcoSK4p9AfHfTrXKUM8F4FQxQik8Og8DIpZ3CzPoGE1bLbcOKg2rFS4iWeERk9k7WZGJkajzKOKFZ4nm1fBZXvCjZueh+U0eYf3Z36nA5h7dpuZc9Haufzo9wDV68EH+XW7rTtI9ED7i0uiKqyuGHJfUyqZIATF3RVUTzugrtZUte8v3MM4gQ+nps3xHG24TWnRdEYMwY13ep+11EJP6OHVOF850SgpamOsMyOZlwgAVvKgxOqAOl57UaIGDf8zA5is1Zsf0ziQfLWvvowknlrPC1QvVZK6n0ANtV5cne+qHyTJJDYFInX0WIARnpyDEPidjh+n33yszE7MZWI+cc++cn4ic/+RPzrf/uv460334pHHn04ZqfLa0SGbaVv74QIPnr0aPzwh88Dqn4YX/yZn2HvXonP/dRPxB233R7//J/+M1TrzlLvgDB+OybGJuPBhx+Ku+45Ht/68z+PyZmZ+Pv/89+PsUvj8dv/7t/H68+/End//pE4VxmH84lUCaK/i5F0ruAsjRcGwOSlqti6lOaH22sGWiCr1p3e+CPNkXQwbdEbT3/g386BGkbbDd0QYhgkZ9WlLLjJDd1tUYSwX8DtLaNDT9YlqY3VNvjtepJtHuPJuMxrD2bQG1tkWyX8zuB04xIqZhKAa+2vL8GaMD+2SUvYGuimfBm7tTL2B81dx6KlvT0mpyZjeGQkLo1cirPnzsel0ZHoH+7BPqEce/YeiF39u5g72hvgbQ7wIRddUCDxWCzhNREA3kUQ0Evvjcc7r7waFe47duhw3H/f/XHh3Ll4+8Q72C7UIOxqsXtwMLlpvnz5chw7diTueeD+mBidjFdeej7GxsaQSA3F4XvviBXydF2xS415I6jKEjaTxY7onWuOc2+8E2eQgpZaW+PB+x6IVjjmEoENSNLGT1xAOnohbmce6/nx5ZffiOHhkdhN/ofuuZVx7Irh2iRzTqJu3Shu6EGABUSta5M9r8MBn888Oc4eVx1LFtRGNno2VhtHNb87+xQMaRvT33U5Pd9JxU4qdTVJ0FZQs0rkOMuHAKlRmxSSIKrMszyLw5xxCPwBatNFV7UxZ/RApldJcxI4a6fDSg84xLcja65BZT3nOpKcmVB9WyAAaOVe6z7HPN8OdGs3VHCQ6sAKWaR1S1XTlKEHVpP550nJdCsBSvvatRJbig6M19qwsWwmL/xfJi+YiUlWd1PyUIdEZV2ybP5l8CXpLUOa2f8sAmYv43CgKaZruwEeSFQWWgFJAzzDuK1uwDNdsQW1RhzbcL+qdXMAxd7WDtRIO3F8I3wha9qYuThnHOlwm2s8oVnmwgpxjQyKndRyKdfVvQFJVBNMlOVJyUWYR0iPFgFiqt9qu1lm/a4xFq0wHfAIwXf2RBgGI6yb47Xp5HhljmsWUa/rX+iKbiRJHdgdtRPKob0R5wyCo9X+PjM/FmeQXu3v2RUDqNbtauqKnsW2qACilP4mgEddlRoJjrxP4Ppm9UKcmB9hsFFjbeyMO4p74uASDj9oXBUPdRcmR2OG58QoCD0AAEAASURBVNj54bIyj7qizC0ZJS0CWO5DkEWb8roIpm1vusO7dtJN2AM7AOkmHPSPQpNHUF1IHD8a437jMtaATrqbYEaYbr2wqZvewga+u+tSujfnnbXjI0q1tGU5m6sL9mZ9JQhDQQUwxIZpuRsu0vOPJIQeuzLiQ4IDXi3628bl0Zh2exLDTV0D/JakVqM6Qt2euqG0zX+qItMEQSZ3+MNIEh0SVxq2S3Bkf5aUj0ZWqtI0XbTKqYZUSKoOgj7Bkh3nBqcqxAKuXxshBHtRLfLz9ZNvxEBXTzo3sHsA7inBEHu6YwnVCO+h+CtJgmsOYvndt0/G+MjlGIEwTUbP5N8Cwbt7aAgObXN0dLVTO7n/XHvyPYiyZlSpsEejbInqgYFd0d3dC6eyFoOoNU2MjqY6SrR1A8F3p5gnayPXBVe3Ac77DJxjiYV8HnhFWSNyXJUbE0ebBWWKG5NNgPRIqlXeLJdaGwJtjG4sWXJe+uZ32mdKkJZ24aRiFpCEU4EVo8p3QjgyZOvv5gD/EpraCziiN5IqjO15yA9jswhG19/vL/qN4z6r68vNS6Gum5/IL0if5TNj0TuxEvsBriPvXoqZ7qHoHeyPi++eidffegPudGMcPXIo2bKcOPlOUvXZvbs/XnzhpTT/9uzZm+ZSzh6xRifePBGnT59BTQy7uLffiTGAjzZxf/6tv0Dy2BLnAUhKpR4ACJ1+9zRSqf8Sjzz0EARcJb797e9EG5LQkydPx6uvvxa3HL4l3njtTQKElmLfx26DkHNlEsBkyZ7wOe+CWLxMma+9/Gq04qDktddej6nxqXj4oQcTh/706dPx9utvMDe74ujho/HMd78XJ0+fit17h+IHTz2DylA57vmJR7HLQSq2ai+Sl7HxMxsLOxdevpJSnk8lKxuTHhv9y0YrOytwUq3PVlxLpU/WQGLPMLnWPImulWJMsGXUoJWOLDPYAgpfaU5AZ0sAX2isArZhNrFudOBcpweJRhcuq8FPMFVYR5EOzMLsMljqCvXKWgUYUWWLOjrHUhwpVLl0QW0cpWsmpFVJ9ZqJe9UUzDovy4KTXpHmDsc95Usw2NsylgAHcC71V1ox2FOW6IsrsZys3GrKv9lP9oI9nOxf2CdqtMU5o0vyLKFSVxihz5oBSbtSjy0gSUKpDfU7yDmAfhPrsjY/NdxXdxdRRcQOR1s/559qnosADe01XRNspOuT+1Qb87SK6l5yVmJfUbZtLCIl1b3b8jgOYXpKMdDTQ1WydbDA4iiTYZB1tpfnsIB08+zcWJyauRDPVk8mdTsZg2nNxv7znaULSZ2zp7kNxkB3DC50Ry9BXbubcSeJU41ZpK5HuvbG3s4e9q7mGFhuTwBaaZBSthYAoPM9T67dZ3FdfqYBPVvUhJuRxk0jlf5B+d04Nz9BQNlB4pQBjFnTnSHuFU2oIHZ0AIpgjuosokidlQrOquYLKHIFriy0xSTSuYzFlZe283mz9cAOQLrZRvwj0l7Bh1uGkqLEEVzdZVy28w1ns6Z6VrfIbiJLEH8SpOqDpw0VrpLnMq72ZnevHdO1q+VvVpbHEvePjacdIlzpUdo82YTa2QQrbCqqr2RbzFqe9d/cLCVGiPoQZbl1SV2k/ortvme9YBkFNvq8/O3uuNFzlpCCwtqPECjGM5ErmfeKhIObmk4ElO6l9vMpsLLXFo03wlc9jx3YdyC5ZT0FB11g8u5778TXfus/xt/6jd9IG6v5mpIahBlZChtdIkn4UC3upRdeiNGx8fiVv/ar8exzz8fT//n7XMWVvLnhm5aNvcF9zaglPfToQ3H//ffHX3zzz2NXb3/sGRiKM0iXhi8MxzgqehPkde/h+xMh6IzYxbwQ5mXtS9mlN7RE8MKE691UmsQe4AjCbwwVEd2OOxfsJ4PS6i48Tx43iruezQRP9qfzsIJtVrK52HRm5XfXfVIeU+W6kpzg6O+IxW5UuQBIya6DutMxa/ebH790VGGcqWvOOy/eUL5g8fJimeCOHXjEyiRuawUw5hBmOirYhARNl5mljUqf9TfWfU9uvAHLfa09cWhwT0yfORkzSBV7+3vi3IlT8fKrr8Z+7IkefeRhwO9UnAKADKJqOTAwSL5vZMQh35SmZPKUrBGJaOT5lBN/9NjR6MR2aXJiIkYB3uOTE0gpCnH3/cfj53/xF+LZp5+OV5AwPfHkE6muf/zHfxIjw5cTQdnTS70OH46WO4sxwJzeLI6Tqo6Zq+IImQB33XMX/b0Yo4CyCup/VSRUUxPT8YOnn4mHkZp+6ctfiioqQm+ePBkdnR1xhPqNj8KlZ67WKjAYAITXSs4yOe5CiIyAv5oEUOGtxjNXL+0WROnKWWlIFcI9SRauVdg25+3t5IKb4n2Wlffn89ARgVUQSzhagZZNkqEViPRR1tMRmGAp+CrrxzJSUZNuwo2VZHL2Gt9NZpdrsO7VDaZrntdy2JDuN0vqc62EbA+CHXAAA8T6yJDKb7MONQEGwEFy273CGGraz2Re7agN9U3qaauSM8srLyDlwX6piCpdawHpKlLWBsYhW+uyGjlfzL/UPMX6QriCBceP/nJdZXxcSQyQqvvwdqSgnUgjJ7CrmQfstBjfyL7Wvot9z+QcdHX1adMhwgKe5ZZQY1tiPtmuRqRVxVaOjyHJpKz7WKurly7HzMws9WMNY1z2wYAagLH08tM/jBJg7Mjh3THcjHUhAE1plBIaAbV/rTxXtnuW8ZuavxRnlsZx11OMTw7cjS1hOQqXy6yL2CcWxlCNRgbd3xoXx4YBxPNx5JYjPC+0frWjfVYnkUK/g7c7YyV1ArpWUB80rpRqc+fLl2MSn4d7mroZn0ximeYHrs07uLZhHg0UGKVuC6oIKq3z3mXKWoJxMFdpSz1jP+2km7MHrl4db85+2Gn1j1EPuLlqiF1hERxPtgByCz167SSx66aZthIWQd2Oyi11cWxAIpAJj669QV6bFIEAIM+auuOr+v3WTkKjDcCkqkAVKcNGgjtvgZuJBup6TmqFhxpwU7cnVq1z1geJGOC7ddS7UzObSn4uz/9an24kpiyvra92s0uOU+nLxaQsn5VlTeSFen+WU5aHG3N1ahYddBxotLVGtW8h9h85GA8+8lD8wde+HkeOHIn3zp6N2+/Ew9zefcm4XvshOi7aIQob2Lzl5O/aNQCB0hR9uP/uwLi+a6gtvv/U0/HNP/6zOHv2XLR2tFI+eGAXOvpcZ+wMJVBy+HVacNc9d8aTn38yuYV94YXn4mMf+3i89Npr8Ydf+13mEl7EUNW68757YnS+nPLpUN1iwxSzXSpiUivU7KQ99NCEa/ml2QSOMp62IF7PSfO4LTfAYT5GzEPAkQEnlRyZDIxLS0UQiVDenku/2s/MJ92OC7LMub6vzWpjkrxqhKOujqA0UmYc7V08Q9RfiKuzc4PkStRvaPKV7GybhEwz9V+A+JAYzcv2E6sCpKWLSSUxP+7NfvfeNhkAfG41/712/czxyFrS9qxpsB3Jyvl4573T0dDVjWMD1IvwYrfAHHnr9Tfj2OFDce+998Q3v/ktbHnejkMHP4cjhq5MpYf5YHKeZ/A9/eCN50bCa3IqXn35FdwPz0QPc8wrkzqeteL8IjYMyxC5RTzgFbCj0FYu5QWRevy+2yHQlgDtL3K8Fh//1CdxEHI0tZuMUrJ0gXNvoQ113tZ45+Rb8dRTP4i9+/ZTP2qR1K5YI/Cs5YR0nKaQcgocKxiZT41PRnupjVg3bXHk1qOAMuYn47Vdck1Ruu1Lw3zHbuP4+luGg54FbY/z1f5oYZ75ck5kBHU+ky0xXy22K/3qc3kOm67dSBOUiKTgqTzI1sFnZZ5FLZG6rItKQTL7pdWcuMbkuleCIdHCK2+fKpXW81qJJibpc37fZte7hrcjkZaBZfBabWzquz49V0kajPc3TiSC3UFNxftGf3FPA2BbkMGQJnA0PjeUvKw2YJcpSOrA2UUJf59NyMj0WAeqYlSKrCUAqcVegBCAZ0NKuIf1RsCg2uIonuPcA7qKSI6pb651YX8qlMr2QdYB8knxnLS9YU913lIggAfQwR62OA646UQ61tUa//Qffw2G1lxSVZ0YHYsjt90av/6Vr8AweDa6YTb99JGfizs6DiRbYMssAiKN46QaZC8OF0QkMiCq2Oadq44TimM6aqjffecbfxZvvvZ27DuwP8rTMzjZ6Yhf/xu/jqT2vZiAyTEEE0ubP+slmLPTy9hf7SrhXIVnSWbbEvnUYDI10r/NzCHbVVPKOF+NAhIjnzmdbfg86Rlv0XOAblOtrOfEapLWlQiwWyJweTZo282GdOvO20e0B3YA0kd0YD/qzZJ4nEWfXC5rQeLgyla4dcvdmhLXjh1JV7DeI5EmYbrCK99C3fCWkCa5eWyaWC9djBvgCm6eLMnkwnr14ioXUNU3Nym9WOVXp1tW3zxWQVXApD1TFpxUE1ZreXXKSATBCgSNxA+vNVfUV9fh6hyyIxL5cpAllFPtecuI763zsK6WL+ysT1e1iwPzM3Nx7ilUiXBzfAnFj6bHjkfrYEt86Vd+KV5/6ZW4eO5iPPbEp+L4A/cCVpviiZ/5PGCoD8nKYtz7wPHEse3v641f+Ku/GCVA0M9+8Wejs687OuHYfxGJx/D54fiph3XegByQTfQnv/xT0drbkeLcfOxTH2fTJVo7VEn33v4o9nXEZ770kzF+4XL07h2IX/jKL8bLL7ySJAB33Hd3VLpwe1udhoDNiEO65qrkzGvHgLwIR3QaoDAOOFLNKQdH3iD5WAWENwCI2xhL+0rJ4gBusHXeYYQQbdc6cO3cutxBryzERHMtRrApudLrfsk62izTdwn23qZ2VFQAgxCPM0iuBN35nLtyb7oBghxA0+m1UmRQUtog6SlqCps9GQRA8FU7CUdfpsPqjX5Q9pXmA7jbqOthPEvpCbCKh7dTcINnmcubErt12fjVbHUioo1dlXLri8nOM//o06RwxcnN+t3KtO/rwztfWyxOLWIQ3o7BNcQYwLbUijoVIKkNQNyHjU4jxOwCRF87Yy+48VwBe5VkxG+7OOazKIi2/oKv8bFRPOBNxaFbDkX/4ECcxzsiVBXXMbKr4IpLqZswjj/vZb5WCLb57runKKs9PvOZJ+PPIPreO3kqhu47DDCV+laFayVJKMtnLyNhpdz2SowguZQAvu3uu7ArmYdYQ1ICANizb0/cdudtMYt3vqe//1R87NGPxbEjR7EJaYxPfPKx5Kq4HdVRKM5YxsveVimNL/NTcKROpauDbdmYHHkdM7i+Ok+9RmCk5FcCep7BcG7nXuhcLyzVT9em7NfGXG/8d6obfaO66YzrMUQ6PjISkW8d1+bnxtmzVpZnrJu2SgxyhpzWTm/xjeu2zjLdY/vN19hUqpNmTIbV7DhhUSkL6p25+BdcC3JXT3K3XW8bDUFRW0ZLANucRqQZ7S0zfGYQdKraR4hTmDqFKQCfioSoUC72AKKQHPF8aHdpEsYKYqxTKpd8mcKJgSj0cU4vMvaJLSioZ11sXsJhi0iTegjWlgAvOnPQeYK2eebVhrqn4REqZyajdhFV6buIjsQSPzk+EY8/8cl4/DOfjReeey5+61//VvziF38+OdFQlbEwhybGxUo8yrzVLuydF15nDmM7ByPh1FsnYoQ1WnXno8fvxN34QszoCp4KqwFw5/G745d+4Rdxw12J//1//d/iTVRLh4ZwlgKjS+cpS/T5wQO3RA3nD2+deCeO3X03wa+XYYi8geSLmHq3H4URcjTeOPVaTGjDSttvf/DuGEbtb5K1ua/YlbUZIMhSjJ+IpujE2+AiKtpTBoyFsdHAelFdIsjtJgCUbtlJN1EP7ACkm2iwPypNdfEexl1nhUjp7gi5mspV7XPz5uK0aUjAcIGbfwNe7oy4LpjIVBayO3NyQeJAwq0DgsWyNiY3JNVT9ISjaoX5pjJW3/3lbzdxty831Oz7+pyUsGR3blaKd64HSaoPaPe0RoZYkxwUoU8Nweyf+eab+PoSt/lFYZIdEuu2SS5y3o42OfOraoLb5LBpX9Vfz14FZ3BWdmk88fnPxF9899vYDI3HIARoFY75w499PLVHomiqVgY8lqMLdY05xuLy/Gh07SGaLAOql6uBuw7iyn0xDt92W1KzvLg8GXsfuj1uefSuZAAviXEWY9+2Y7tjHFugRVS+Wg/0oJKhaiPEBBv0W9WL0QqnsLNvLwQ+dkv9cP9/5mOUTuDFhUoCR8b1aMGouFlVGogICemNCbtmjuMSGk9iZW1A+NuYJBxVefT+DkBKP17LuivNcRnCe/eh/TEN8VAk0Oi5V0/I1o29D96Gkfps5rmL/ByPBD6YxxI0zoFupA8HVnqifJZYKMSK2b27O4bRu9f+KhGszONcOqVK6q6GjlgZr8Tw2Quo4CzGLlTO+vcPACwAVvSl802VzAYMrzPiLZufy/S/dmNpXpG3pJic4J7ZQpx45Y04cv/t0Y8RuEEWJb63l3Qm+iQBgxZmKSOzSX+t9p+U5jaJoqLYUYoWgKxgwtChS63dcejYEe5qjL4DQzGHGtaBo4fik6gVHTh4IBHYgzhWaGa+9aI+N7R7d/R0dSGt3BM93T1J9amKus2x246xvlRxhvBKcpQg06ELKZXj2FwF5NIP3d3dSHyGkCLhsQ8nEfv27+GFTRvSpO+/8Ey89OJLSDeRRCLFWkG90THsgLPfj63bm0i4/uz3/jgR0/cdvz+OHD2Cy/Hh+NM/+EOINOwwDh/GI2Mb+e9NjhjaUF16FtunGrYlDzxwX3z7u9+N3/mPvx2d2CU9gNfHvgG8xTErmCRX9ZjHDcSr4wLHWMaPo7hZUkXU2eV54BFAKJvNutAWDGaSJ50QeDwjys3HMowvo8qzz892KbszW9+2A1Se0wO9NdJTWwH7GG2mBCQa9ifpEUXJKNgsufYvQ/QvMde1N7yepOpbtiZvfbXgRqApYMyfL68W+FpX2W68WTG/0eG8s47oZCCTZHEaZoXns/FYRlV0lGsFPOxPTmz6+jISpam5fgh7QL7AmmO6+BYY5eDIEUjrGefqR1QslvUwV9ARFUB3A+jG/rMOjUqY+HRNca3UdXm1XIkFbHXsg1IbLDlew8+ciAPl9phDpa58Eduf26g294yOTcS5M2fi4vmLyVGJNqIypYroROpo5Ktf/934H/+X/4l1szm+/jtfj//uN/9unLtwPv7kj78RBw7dEq9/49V4HKB192cejsvLrnOw4XjGatgUWZbfu2FwyMj4/lPPxhyMh6OHDseLL70Y/+1v/mb88LmXsAV8mvAMB+Nr/+4/pjhS8zyDzz/zw/jNv/eb8Xu//XUkrjPxAKqph4/fQZ1hiBDrrUxcqo7EqCqlNaOKgxclkTXUEJ0vK1yH6xVUCHmOl5Dn06876ebtgR2AdPOO/Y9vy1nIakiPluYJ2ImKy1ZpSeVidgoXfDl4JrcTPShJxLlZaJ+jjQw7xbpstAVYQnVJqLFZSvZBOFFwVdUrkN6I3DhyYCIJIrFgvpuBI6qRtkPrs13ybJIkUT3teShmlVPrXXJy3Y4T6Xqlpt6zfa7em6qePiWIBCXaEdlu65v3llt2DVCmPZGSpA+SrJP67AKF517+IRLAStyCK9fBFTxwnTkP8LmUhsGh6O3HQLa0EudqxviwNhjRsknaZjd1jYoPEGvn3VPvJDWctgMDcaoKl5+UVNMYl2UIjXQt9ZZ8GFuYQcqhubKtWu0jGerpu7XjKosgSVR4vIjDiAakDxN4Y9KjWE+nkekzm6F0HW9adEwAwGZWpYHeZ3IuyLUtQlEJMpSIyKXVC1kXbnqf//4z8Ud/+Cfxt37zb8eRe2+PkYlL8cLzLybC6egjx2Nvc0+0UL8l2qstgASYdgFkmuZAN8qXRWiWF3EmMLh7MO4CEOhueon6GiNqHhuOSeL4aIStEfT8+en4o6//XiIcNLyWoPjEpx+Lex57EPUT2pm6hbJwVS3gUAfHgJML3F+BqUC4zpS3g9QKOJvGbe4z3386hg7vjYPdAxjSI4VlilxcnEyc3qwXNn+Xc4tJNzYCmaOT+qsSoQJhsgIovWZi2DRgl9GhXds4dhuHHrozbn3gHjwSLxBs8mLccv/RuO/OO3k+yQ+p7OMEFnaslRwdOHAIiRPc7COHFOBgsbAQ/bX9Sf3zoT2Px7GH7+GZa4JgxIMhjhsktCSOp4kV03/rvhg4spfxQNUQj1wf/4nHk/SxBS9ie+84HDOokvYg3WzqKsX5GnZC3IclfHzip5+I4489nIh866EqUQdA5+cO74vZ2WkugSGBwXwb+QzeehD314AyvIg9Pvj59KS3A5y+eGgwcfIFSE0Yzl9YoCd5dvO5l/ebvyXilSBlpLRrlJKYjVdmd6R1DVVQnxEJacfC9UAnM82J4L+ikJhuyHNRdbmR+2TgqGbqfVdVZvUOQVZSl1NiQUnbrYHm7+qWnNxQZz2kJTuRDAGkHLVzSWPLL4vNk8AoA1GskwB/IEJ+astPx/dal6VgqPUF2UfsJ4IxQUwh2YLVlUVnpDonpwdkT11U+82HoIi2gpKktA6nZ1CJ0xLzbYL2tvKSULdaOHuBSeM3HVvkq7SNEdKmxtcVu9ZIgRUgGaZiMEaJAUZdk00mNzlWc0iNBEeNzOUW5l4zdjrOgflzk/HIpz6B19CZ+IuTLyaX986g119+LanBnXj73bj11iNpf/A5tFts6yJri+uOtdThxiLr0n/6gz+JPpykPPTIo8mW7iXWuuOffiQOEEy2B292LUhBT7z5Vvw5wOyNV9+KNub5HbffEW+8/hae6KpxF9LVb37zmzE+Po4L/xfjPpyjvHvq3XgHqdSv/savUedi/Jt/9i9j+OLFJCX+qS99IR598uMxwrOxhHS1gFc7bZEuEw9pQK4WIT0WcJfvfjGzjDty6IG5GAIs7qFPpBlk+Kz14s63m68HdgDSzTfmH4EWw1lEX1jiV/ecWyZWfhc/gyrWJ9c8j5c1QocqdMMuISUwvzxJUGioDgmaFv38eP7pRqDaifYD7k3eucaVZQNUpYI8E0jKb9rwaRnXkyxLFSwohaSapxa2x0yWm3/PP9OJ+jdOpK2Li9mz0ne3WUl24ZC2UsmdeKJq1u8J9lyKUs81qtV80NSBPce+j98ZI+cuxe4Hbo9dEPZT5y/HP/9H/yT2H9yfQEgR7uYTn30i9t1xlMpS4QVUgiAotGlR6idsFSA1Q1v/4LvfR92oNX7xr/8yG1s1dcYyKnQSVRIAEiNKKcqAMT1atUFsSqhm7sYTNZKaJIBKZfHLfdHYN8UKILoC2YJk5zxODQxUy6BGN9InCUwBsSNoTJ8RuKASOPkc8LMXQHuQuElLExU4kjiVxYvcTK/EHHWaKsdLr74Gl3IxXsFW5Va4nA7kCnO1BWDehQrMpXOz8c7bp5JTibvuuCNJMF5/+4245cihRNyfe/dU3HbL0bjlwH6cCSBdm67FmZf1vHYpdBJw9K7bo4iUxPggRbrmWcoZuTwaf+d/+LvoljTFU9/6brxGLKgH774nZl47i+oOrrkHd6NWdjheeO0lvPhNpMCptxOUNwp9OD84He+dOkmsoBLEyt1kQYwg5nnTErNkGOnNxctxGLWaZewAzi/h/e3KzFw/a2gmuv8CbuBjApUeWUvZY2hnrD++dsXV33wOlH6MzE8Sdwi1WzjSFaSAVUDDIkCzDbP92hjqj7S7C5BbgTCaQ9JTWUC9lrXkQB9jyvQ+j9TxXFMZwgmFJvJo29XiE8JzMw+DYo46YwcCN7+KEbvzybWjBjFoU0t4WFtkzhUWcU3NHCn19sUUKkFzSPV0be7zfn5+PAGfwi6frAxszGJoPl+bYn5AGLcB5AF5C3jpLAIi22HC6BJ8EbUl1ZdMi+XRKEDAFg90xCjc8DJqoNqM2Vv2w8Yk6EneNO1S/ly3VmUbGy/lfpgP6UXdzGxDhluNiMd95rSZrGrHkdZEbt5wvz9bGrAP4vlNsX8APKqUZqT1VdVJbZIh4Z/TQVDrOp2M9T1LQS2sFwIgPb4l5gjZiJ+UtGaJ55SbV1xvOX6lSim/tTLFz567cn7t1LpvG6el+QrEmGqZGiVXk3WWD18SQIBpIbAqarvkRKMNgjrHQk9qrhdzzBWhjmmZdpWwQ9rVNpxiSdVXahkJ78x8D/NON/pAkMRM4NN+SX1ib9KK7J/zVIIO0VKxke/WY4k5m9TJUqOtrTGJBEeo4MKM8WbV3hp6OuM7P3waZgrP1JHO5PLbTeTTn32c+HGfjdHx0fg//8H/ERdxOe9aa5k0JiVdpqsUbpX03jeK2urkHI7Zv/GnyU3+voMH01jKCOpDVdj9pb+nH6nuXuyZnouHH34iOpHumql17e/vi4OHDiJR+n4q7yu/+qvxzPPP40RlMp4mnl0Ru6Z9Bw7AYID1wpzo6miP4cWpeLt6nnrQrzJJqVNZuyxUCTuXcNRA7snmkn6YWdkPk2GAoNNV8phEnVF1aBgg6arUpJ23m6wHdgDSTTbgH5XmLtZwYIDBaD2o2dg21WByN6Qbz/k7LY4QLhIgKxDV2vlIvOYLotx+DeA3SpHyzdztKCeIzc9tJktuQtkvt76rEqcEJsnzESct8VrJ3PQ+ZbwWZV55ystMm+CVnOT5Wp+sptkv94bsiL8l1nJQ5LUb65C3TSAgsZkIrLzQD/JJd/TCKe8/tg8Cxu2cDQu3rWMS7n/v70QH3HyJh15cyTbgFnbhNEa8uDzu6+2N/Yf3A0wKITBQJaSMdEciTnUbwdLCe5MYDvclVakT754kDs0Ejhk6Y/fBfTEGtplcmIMww/U6BImOEzJgCLFAvxgoFQFEFGq4FUanvVDGTTogqVGuqHOCVxUiZxjj+CrERRf2T3I8dfJxCY55hfzq50KJMbqrAQcSkwvxvR+eBFy1JRWk/ccPRE97T4xfvACRXcWG6mfiZQKaTuA5rxOvU5ACidC8fPZi/P5Xv54C6ErovfXqG/HFn/9ivPiD53Edjcvnro44994FXKH3x3/+1nfg4h6NARxXfPXf/4e4G29ob7/1TkzNzsXjX/gski28WBELRCLmKNze9sG+GKlOxBOfezKmhsfiwoWL8R/+33+PW2qkKdi4XDx/IZ7CQ9u+ffvjNdTE5slnaGh3fO2rv0OA076Y4/dp3KR/5vFPM8kaiC11Kk69cwq7gs7Ye89RCA3iotCOYQh/QvQmUG6f55Nsge6c4rXCWCq1ovs3JAAu/VooyJGn/zlvjJnNHqX6G52zPlPzSAqdV3mB4wDEOXqV2RTjqHjOoZo7hypPCanMEmqHk9NVVN+Wops6TqAmOYIHQkpL92f5MC8ovARYKaoKxF92FpU15mD2nQDVgD3LLHHNIoC60YauJueGa0EZDvYc9atPXiWY1JFHBSCmLMEkABMgKW2R4NUNsU91apdlwTgw2W7zWCstHU5vXuH61UY+zlVBfH792lXrv2W5rj92vb+sg7Y2Sm8FNvXJfDNwlrVCqVMDoFIuQ41+SX3tRXUN8asAL3+2kqMMJDQr2IwssB420qZMO4Ar6yaStLA2jHpkEwNoF5iAQX4N5WiDltTzuFbGUeJAeeMNJvtTKaPskpSNwIy9x+9KsRaoq4DEmDs69NDxhH1j7CGBojuE4CgDdymHKzVoLxoXbv188YoCNpmjK0O4Os9AM72Q7klSZtZDl6w8tpTrhyq2erVz31EFVE92yavlamfrNKGFAKuCNschjQVrX8/+Y8mrYmGoNfYc2YeESaAKg5L2zBL0eA6VTwcseZOlHCXcnQAT3bBfFjRRrZkZ7KrYtw4AiHoGeuPJn/wcXhrn0trG5I6Xpk/j8ruTfXiBOF+3xeee/Gxaw7/6278dn/zEJ1L+aTul4Z/8+MfjH/6jfxTH77knqbj2oya878DeeOInP5sc8mirt2cve4vjzH8ZJsllHDwoRVXCtMy4CATnoR8mVgxeC/sDhsdsHGY/IK+ucuzuVK5diTb2/0yVMevb1ME7bzdVD6xRWjdVs3ca++PeA01wghMnbpOGuFW5Q2izs6V90up9boduBgYBNE6FDhEkhgReEtByoCV4rkAhFl217E3JUHl1g0kHrvPN8uSaSqRfz3acIBobqZzGK4Arrf/ZRqb1iEpyHErfJIFU6VrdIzjGHxuE5/Pk97zs+k/biQYYoIjNnN1NcjAnTurvz/O57k9uzqRVuARXgoNxQQm7gC5dz9LXzWxarXira2UTLxAXqZX4Hd+DU/iNP/0G4Ag7G4jyz37+c3H87jvjX/2L/xtuYWvcd9+9tIFxYrM2ts0f/9Efxa/81b8K2BiNf/Uv/2UM4eZ5hs3xJ3/2p+O2j98X0ws6xJCUgNilbcsQDW6cSgpVKSvNzEdxEnfJEJ72iTS5xvd5oppwbZdiZHw6JmbK0YGxc4FYQhMtEAnMtbxH/ebCqp1ahejvGpjfffwupEFvR8v0SuwmxsYz2KAY02P/3gOo1b0Qr77wWnwC1ZMsTskihv4n4yIg6a//7V/HxfRYfO8734HoqMVjjz0W/+Qf/9NoAyD9zd/4G8mQugZ3V7e2SoD01HcvMXqW4KYXAADLfGZeGm0MRAIEqX3gTOnChmaosz/efPNN7Fx2x1f++ldQtWuMf/Z//XPA6C3x4L33xbM/fBZ9/+fiMMTNNODip7/8RbxKnYpXnn0hxo5PYAg9Ed9AdWb3nr3xpb/2y3GucQaDaH36YQOGel9pFlu+xaYY7O/GKxTEHJNS1yPTolEn6BapCU9UzRC/Eny2wdSIDUXiUm9xj4czqLD2aVurEG2LcLf3ItFpbzVQKESczhzonxpSmmnmz//H3nvHSHadh56nq7tS5ziRHE5gVKIYJCpalmjJsqS1bO36vZX9HLBO2LUNyYCxsAEvLBjG/mXDMNY27P3nYfcZBpzk8J4lPyusMpX8ZD1KFJPIITmc1NPTsTpUVXft7/fdut3VPd0TyCEtsvvMdIVb957wnXO+/H2nhuzRp0suZYMd91s2//bUGB7hVgZPKLxstMLHaNm1pQWGHeviif/Z877KFPe4L9mtW4tWm4Kp4HnO7JXintjV9DWzTGY4Ke9P9nxWd3y2gx1ft9YvXGzD0e0M9a1PXdt3YS2+VYiMeCfgdDkFlv0Qv2gZc72uwCCHdaijWesMZtfN1y4xCjwHtPJJA1zfXczjZgwHONi7WrJWEDq14LmW8hL4kT3fMnEGMDF5BsZA3jfaye+94jtMd7DQ9AXpMLNWIaQ4zQoiCmkKK0VcJ3PhqDeEo4z90s3QtOoqsLa2riVpuzJQnkWgrmKhHOU544pYmQg0a+DWNRQ7Xewd3b61mtimLrfidi1BDeOR6I9utiYkESplhLcK91uPNC9SwbNRC41yGrljfyrvJ7FQYLSuOFfO88JmUBadRbnyqte8kligG7Baj0RykhuI9ZtAcPnsf/2E4CDrKAo29v473/uu9Hd//ffpM5/8NElH5tJr7747HRw9kc7PT6Xz/TNpGOVLHzF7CrxveP3r0xe/+MX05JNPppER3EhJSuJcv+IVryRd//503+vuCXn22CtvTseOHU9f+PRnURoNxl45imJnH7GFZdzvZ8m2V8c1W6FdYa0IjZF6F9j7ddyGnR9ho5vmwaGZdMsAY+fGyRUXQ0bnt4P/3rXdAYE9AWl3zPPLbJTEduCnHARgy8gkVVWtPlCaBbD9VqK5fvsGrVxnLDwUUy1jaG1hJ7zF+B99sSswRP6DdYlDQBU4+mDu0e9KwterveIHbpUhD2bgMjfL0BhfVESICE0rhFKLj0KGVgbblIWKoGjHyW+WrT3ZSnDzJre7bvpTM53JtNi+91jf1jrzOq76vT3mGZIu1IBnxDnR5yJB12bz64N50drzX/7zx8M9wiD6N+Bf/k//+LH0uje8Mf3gu96ZPv3ZT6d/IA34zUePksGokX74Rz+QXvvKV6e//Ou/TN95+NH0ne88lO6//+0Eu59IH/+nj0EQV9N73vtD6YmTT6ZF3Do8v0XmK2dCHJPji5gLZnGNE+850CisSC255WDKMwuV4zTOrBMQK8S/rZACfA1N6PIYvw9QWwegjEuC/KYhkid0Yyb56pcfCIbk1aQXn5+aTQ+RLa8A0/C1r34tYlW+hRXpnjvvQjCF8YNhn56ZSZMcVPvlz38Zxmct3cS4e9HM9lZJC437luv08A2Hw9XUZtVO33rLLenUs8+kz8MsOLp730TCCWCrMF5hT+im6Dk6Cm5DXb1p+tyF9Cjn9pRhDiowDhVcFefRwJotynNHlheWAmY33XgkTV2cSudIIvDlz30xhMkTt54IxsfYhDnge+T48Yivch0KZxJyIQyuptoMDIprCfAcGBtBa03SYjNmdcBK+G4q3BsB622mUQEpgue5fu0lc7E8T6KOfYxxrDIYgm9eTw/zWIQ5niceYUAGs4d9tEPf3G9LoUjB9ZIxaNmR6cxLzt66v92r/hrCkoPns2vNPd1ECNqKM2xS4aqC+5kB6mYjdG9rUTK2KhQ3CIihrIj6slZ9zkMurT+zM2WfA1Qd93m3v7zQRWiUWdd1hJcoWXcuaTb6IvdMHxXcjG9T0MnwNb1fn+sMVgqJueXOynzee8tYJoR7CDxbW2EvBa6l3m3HDpEQRKEI4Vnncr3ZrXVd7XctFN4btIdMqKx3rUbhruZn1kyV/eYetDiGZaxMYcWOK1f30sWaHa5MYUHicNemZwupbAMSDogOBDmgDwqJelJEbBhryix1CrHVfjLZISRk06PV035jJYeqmEzEjHCr8yiRWFvdZKmMmEH67flK7/n3709nz5lRjsyib7wnHTTJTKWe7rn/TeAh3Mr7iul/+tmfSCcffxIlzGB68w99P656xOUdPpH+3ciPY21+gnTgQ+nwiSPp4XmOlMaSfn5xJr2WeKEBLO2z7NVe/Dk++B/+fbis3v6KO8KFUddeLX4f/tCvpP3gkvPEEj21OpPe+zMfSE8+9F3qIZHD7TcngrfS297/A6EAOod7XQjYgHVlEbd89laR+Yj9iRveGsKrY5wYmk5HyNrneXUFvss/SOP3yu6GwJ6AtLvn/6U5epBXD+byrcRM8tYLI+iBhhILmcLMr7s9zDaVFGHGPxgiLVF58XmUniBPfMWxLuQlLB4QoBLBKTKm/m7buvNkhxDmd17h3bohQApiEsat/c+flsmoQmhkrsJipFYZ0pW52EjIsyezUXTwEjy3U5153Tu961po/ID2s4xJgUDsdPO1XKcS61M4utjMXEXsv/0MWKDxrEKHqgSv33zHCd77cF8bCAZ9ZmY+vfLOV6ZuTj0/cdut6Z8/9okgpgO4ch1GS1kmgYCZDL/BwbC33HJzuo1YGs+PuYXYG13MPv6xfyJj2Fh6/Rvug9ncmdgJx7A0onFcNWU8lqTCEvEATIRuOrqodOOGhQTQdsUBzgFoVxmyFGtDJsu1kxeZaQ9DPIb16/vecneaIp5nBPc//egfwE1OxuXdP/RODsPkLKfxkaSA9OQzTwZzjBkHjeyhcId7xw+9A6tHH246y2mEwxi/+KUvofXt4WDb4fT5z3wu3Xv3PRBzhGcI/VkEmyFSoN91973pU5/8RPrC5z6fbnvDq4P5Mvj68A03pK9/9V/S6cefZpYL6Stf/iJp0SfTu3/wndFt94XnRN2Km8uhQwdI5fv9qUZgdxnh/DvfeTiduPVsetf73h2DN3GF6/MAWdbe84a706PfeTR98b9+Jr3lh+/HOrRARqxaGp3DHRSwY0BL03OLCFS4+YwOcLKLKgfnI4CYg2zTu5DtJnjdaev2vBgY4edSbMHWTuEyM0A65VtgUE2a4ZxbimjQB6qcY7XQTPOGEuHyo9vfdiXvrclMmghtxrqZDTNnq/3dta41z+L1koIUcMqtzeIVzwvLMv3lCyavOYOIgpfjNSuclg8zbzZRLJiowMQy3ZsEJSxy4LGFBrBmLGUsbz1k7jPPXHfb+hBMc/TohX9xRCVgUi6qBMJdEPSa46vO1o3ZMYkO/G4wrWI6z8tZYS9tLcI0g5SvGfbg6bAmdlOBypDcxazzWYWm9aQzOajbN4QrWSwpYK8gAewUJK5bAUF4qLB/FmfYc6ekSbm7suPy0N3sQN4tHYyndn4xiUCJRCEj1fPcxGcPlo1lhDoNfBW7iz4wNIQA3Betnoummu/Bcq1Fy0v+lXhQCC9gwZO2xeHpwLQxi9BU5vyjajHoaoX7Tq2QCOdgOfUSJxRrneceqqNQmV1Ow7gzt3Cv/fbsWc5LGkjj9x3nAGPoFuv9262zaXFmGbe4vjT6etzZ6NPXZh9P5xemmcnV9OjCs+nQEAfMtmZSbfJUGiPT50T/aMQ79iM0HegejH25iEX+AHGSuoifInX3N2tPpn0Do+nAqw+kfvbMs7jUPT73SOobKxN/dD6db+Iuy34XkYhLVkgf7t4yO56KirAeMe9D7Ps+5maJcUc0KQBbxZNA+OyV3QuBPQFp9879S3rkGyxFNoxMOGq7CXBJ8SPsIGC4IARBIdAQw9joaiEzqOuBRZKrhSE/+LKtA4zfst9hssCuauHy776Hz3hwxVt7E7dtfol+QBDVLoOEL/eEB8saD5UX3eeWgwnICG0n2r5cPfnzV3q3Dq1HMikSvZ2K9wm3NYn/Tjdtc32B83lm4zC+zayS9QW7w4eB/v507xtfn+aQljxcsXQxRQawp556Ou0f4Ryap07hs46TB0KR7nBaVdS6Kqm86c1vTDeQqOCjpD3+hZ/7+XCbuO/Nbwhry99+9KNp8vzZ9Au/9uHo86XsV0eHrU8mabia1vhbL1xvwiT0zCylFsKT/csL3mOpiU9i5zV/U0OM7Yj+kW4at7dx3E90a6mR8MH0s/cg2LzpTW9K52oX0/FjRzmHo54uEIc0MTEBYV7j2ol0BCHw43/7jzw/DPMxmMp3F9Mzp55O7/vA/0CsVm/68hcfSM1XvyZOsjclrkvx66S5ffrJZyIw/M677oy4EzPQLWJhevXdd6Yzp55Nf/dXfwO8EULJDPV20q0P8+wELilsgNQ3xDzcd2/6LFaoOfopPF7H91e8+lXpocce4SDdv48Ygxv2H0yvvfO16ShB06+689XphhuOpE9/8lNp8ex0up3DIk9jOYJHDuFIeBibMI2b5PJQmSQKwsurG3D023rhsiybgfjCbIe71m+/0gfX2CKWmCdXOdOK+g6TsEFLjkVBdQD3nSmyAbZWYJQ4Q+kMqQzzYP/t6vZJhS4TI1i3igV7nJf8k3tJ5YrHAWiBVjiK2BP3dpcxJ+KB/O6sCuHi/naH6XLHLRGfo2Vuib+oi/bQ/3OHTxtMj50EYWOadMzdMHn95Rpn56yEdSV2NYyg9b1YgpJ4t8phzloiQtZ0AjuGKZxMrSzXDloTkbqNFSNj5Jn6KJt1H3MuZKIV+CIFNpVpEzJBj3eFMMD71lJAMhfmsPqBt7autxAo2O5h8bSDW/q4tb5r/p4NIcYmTu/jL88e6JgWw5WNkXTgk2tpw1XSW+LYBIqJGtYLexYZINZCjFHX1HZfOLZskwU1j7mtacUK6FsZfwC1xam8JXK/VCuZV4EpaE43ptMS8TtmA91MK1AyEI+0Bu7y7KTznOG2xrwag1XG26MHQbFBHOTTC6cj5tckRsbTmvhmDYF6if3wONYkBV5Vn4vgrLn6Mq6qpdS/Uk139Z8g8yfnQCng0L8ZDpk9WZghqUkpXSC9/xQpyl1DzmV0fyHrh/GjPSiHzFYnEKQbjcV6KiKoKSh2qXTA1XCwWMXljnhYlJcRn4rg2qLvUVkHaNdhvPdhV0BgT0DaFdP88h5kCEcQn/ChZqgSHH269aWWEEX6URi0EIyCUsAuqEVCQNJCYyYqrU5qbvX5btOSKwItc/m4SuzJbZr1G20ha6fKJaAyXLI0IQjRGZmxjJna6annet2R0hJtqpleb3NrddzmnfD2aDyBHRRq0ECljhI0PlTv1tL+jYc4WYMsavOhmXSeNhV+90qkz4ZJ1+3wqYVJDDWr6VXVw+k+LD9f+ewXyPi2kB566NvpTW95M+mQ+8NtQ8ufxC/Oojl0Yxab84f/V/pvxMs4t5+CWX8DApdxNvvJlCeD5RiuqmzDsHSRqrlJdqceMku15nHOh8FzKem7XsEysoQQyApjNZHJmVV1tHsg3VTo5xtMoAI5v3ap9YVY33P3XTDmPbifTaXF2XNkmhtLbyXI2LVRJfGDCRW6Rirph3/8f0ynvnsq3Ic8HLTEmN/2gz+Q9nH2jql0h/eNh2D51ne/I9xl+jiL6H8e60+nOYjRZApjNx1Ip8igZkKLqYIpp/elH/mJf5ee+u7JEI4OH70xjXMGVR1B6Z3vfWcq4BozVVhMd7zxrnTophuingkO0D2IK59r8IP/y3/AbeZkJLk4fttx3kvpHe97Z8B4iIMcP4AQp+DRjSmmAj+i5Sgv8m8rrI9lhAWPYM5+Uonhfgs2mvd8hjKYuR89X0WL63NlIvP2fSeXXPo252U10GgfREiqwhypIunF6qhr7spyIY2tlXA/BA7c29H9zmris2tcmOgGpxDi7sl7n9+cPx/MMAKa7Zq8QyGpF9jl7p6ArF2ynaPFyIQNCjW65bnOrNvbrEs8YhxUXsQZ/UXWJZdmahwkCkPZXzW4vwb8lmE4xW/0UctTNLbeYF7FdX13HrVgGU+4yL7o3E6xE+i/OEfhNKJ3eJdx7ebGmBG61ykk+Yyuhj5TJN5GcUlLBw9zvzDbfjzRD/C6MV3O1aZi+y5KYNbFGnshS2RDbAtH9kmXSF0o6yEdPr+WNwlGW6oylsd5z1KkK2iz92T66YMr3nctm1nynmx9WUVY95bAZQ3WKW7HrlfvrSHsS1MV+oV54PN8GcYUZDMhtJ1Xz4Yr4xHQjeKFIZNGPIsx68eVd4D4zeFKf1jYLpJwxDgxEcYYgsoIruta2gilSjPgrtNkpuxa+G66oTWUCiTRqeIK92ThIkof4hTbmR3td44j7Fe3wrPtgodWsGrFIrSPDNtzxuokziiRCbILTxS9NcRVs+H+jes09EcX406Z0/r3yu6DAIrPTvS1+wCwN+IXBgJmrnnggQcuqfztb387aYsz9zXPZnjwwQfTv3KmwX402P6mheBKRUb0T899Mm4TGfYSp6OAY9FvWE2rp5wb+CtijyXOMlejJT6XSSiBGOMcJJ4rwoRkLjBkN6NPV1MkMMYg6QiX1XrlpzJGqQFhzCxR2z2h69NAD+etiMktdFgLjGevBA3Krq5/djzPpWR1SeR0MyqlXmKBOuvvrFNebApt4tPzwJgvRwebaZQpXIcUv+OcES6HBmjLMNpvWWFdHGZxr8vH0wkr2ztUHkm3Nfalx0lacMfrXoO7xpmI+zpYGuYQ1NH07a//a3rm5DPp2Inj6a777uH092acrn7i9lsRNkpYS05GStcjR25KJ586meam8GV/zWvSl7/y1fQkgsDBGw+me95wT5otN9M5Uik/7yKlr62k7mkYP9cX2tWViQqpmRchrMtpgNEfQTA6XhgIq4Hj5Qngg7AI+NSCNxGwmiRUGOC8ERxs0iSM86SxLwhbPazTFinB51kjgwgvB8vDMBdkiUJjG3EKaFhXCLJ24qpoXsXeatVlupoIEhWYUmOK5nA1marPpTnSm1uM9erntyEOePV8HZnNJQK2F+mzDFwZBs5U8oukXTbN+FCpL6yKdfbRLMkWtHoOFHuxTBCvRaOLaHedYSPk6nxeRYM7aGI1XGdqNWABY7OJcWWyV7HOrN1gqmAtBSoMcGtDU2w2Ms/wUYQ1xq/JHiwgiI9wdpMWEQ/gde8832KbLkzPX1J4PcYcjRDzQ+Xp8ckVDuVcTTdOdKfT1cX0aCtzBLxSm55N1mtyBUab1X/5J8RXEeuH8KfF1k2Xw0krUcCAefTgXsdszJNxkOI8i3jHede1z/3jn66+i9wj7Jbq1XRxYRwtfzX1VRbSUO8MAfjLkc1TxYvZzIKxZf5fyBL9YjQ1Uu87s1EYgs1WyahXpR+uwWwEgS6yM7YY5yrubrVQOGzMuaM3aYxrVbqRuaURbtJN9FIw8JvHI843OYIWN9d07haddaTjlYoDsjy+uYaOe57nxwHpBP0WE2SKO2jTVdKZ59o0oArrq0KSikOVDWEZAS7GQSnAOmDXk3CdBU/UEVKcqbr79yzwXhnkHC7Wa28P/V3NLJjs04BXdEwY84QXqCsUQe7TjRvWYar7YgHBYxh3uaFKFTwC5eSa6HSKtifBV+Kdo6X+oOW6jU6SCOeiKfDBj9KgLhRH5dUiyXyqaaYIzhH/Mp74x2dB6hlzRZNPtPkB91Rtei6OfFjvGM/o+ljBnbiEZ0A/xxVYh27Y4rsVhKdArAzrfz3y7pi7GO7ey66DwJ6AtOum/MUZ8Be+8IX0m7/5m2l8fHxTg/+R7GIDAwPpAgHoP/dzPxcC0Z133hnCVD9uVn/6p3/KGSKefbBzyQUkCVrGLHCwJZ89j8IkuSuYx9cLiFViGVoxkKhB8H0g2EGQcXZQLBnNIBOeyzIFo3ZZfYH18KcbgClTdXO51pK5yniqPW3xb2txTL3UnZ2/BAECac9zzo7v/iYl0h3QbGcyVmoiL60lbrzkxed9xiclIAaDq/mWUcuZtK0P+cwSzOpD05xD1OxJrxpdTqPwlBK2vAgzNcVLEE81ljJiaqtnOHxvsmHKZIiyGlQ+SYQcC5DkcZhViNPR0gRWGA8uradJUjL7u0Lsvp7BdKA6AjPlWTQeekq6WP7J6KthVzOsMBkMO4y+zLsaaIXkSKlLe57hNMshrlMreernvNfP5x2oqP1V4Oaj/vw9tFmBAThEX3GGC+YvCDfNmLXtHGl5pxkFRz6myoWFtATR3kd8Uj9Ckq42j6wupLO4jSAtpCIClCmZS4dH02jXAE90AJtvlyvOhWxODcHDOQrXP2BpCnGOf1xntHeqw3WQtcYrdUUljFPOtsWYDRHpYn/JjMRn3G2MRyossucYfxTuzZjfza2sYYFbwzLW1YfrmFr74NFgkvin8KeQrTCmO2ZljfgmhGSWXDrPGrqcUmFzK1f+5rwoJIwXKunmwmA63NVHKuJW+i5CEuFuqTTWSA8XEey1WuxQnTByPfexfk0df7XF56xThUy49EZPsgTRCoxah8I6EvcRe4iwpBCrRcXnjGPpQzjKsuhldWkdMfmJuMB9s1QvIyRNcLDyALEpZDbkTJe+6gIMaJN0320hSQ56S7F++3c9iutI69r8KriL/kWhcus3G2d/l1hXLn4Dwv4WZxdxSZyXC0HZwxuv3udTtiFzq/ui7maBu1lHsWxZoHoMrOC6Ja7IkyBkz7rG/URhTcvYR7pv8PpGb7Kfn++r8xHp+6l4iX2jIiCnMfk4nm8b2z2fC0juQ5WHvax14WVxlNE2vyl4SAfMWuf6qaEkWSDzZ/0UrppYpMdPZDFzWWZFoZzBPXAba3VlHgEYAVRYC0PjBXWLdV6jNSzdWoLMUnrTwAgWol7WwypCkVgRhQi4Yxn3UDPOHqgMkGqfjIbMyWm8Bk7NX0Boa6QyGSete7m2QOwSOIZlI1wzEw+V+59Jd6xFLFMKSHoYGKtprNMyglaLfnBbVvig9dIsfhUS31h3joM8ZDuSM7Rv3hOQcqDtzvcX1ra8O2G6N2og8Nhjj6VXcpjkH/3RH20Lj7/+678mEPxQ+uM//uP43Qw0H/jAB9Jf/MVfpJ//+Z/f9pmtF0XBItv5NtGRIVwnfH6WWIJs1TSJ2k0zPMRZDxMEgB5olVM/DKPpnqv4Nj/OQZ/nMMXL9GxbqEvN5RoIulrpfU7CkfUaHNyrYAWSj1S4WxoTL6vFKoLcc7GlClMjgXcURYiZooa/qol0KoB7AABAAElEQVT2lPCcodpS1SVfZa7KWNtkTLJ/3tLBLFzyBDwvvM355YwY3Tm2FMGswrmzaIcK1xgYXAmpc6Br0DSMrsS4AnHWQmE0iaKrmkrdS2QGl2D+Hlp6hqQIntWCNh7tsjPg3J1pzCJgzSJE4XKBpj6f20ksIxa/X2y0ffD5nBCgXBNe9z1nBCR+bXIdzz3/F9qCqDIgCgInXw8ifhyUURNU7X95O4vcOo00UZf55f7koaQQ7EmSUHg+UC9MxfFiP1aDhcQpS1TAPfxX3rAZjE7RTl7f5d5tO2wxdpEb/S7jI+BLCCVXAweZJgWjFsJPdw1LEK4xwTRwrcsUwjI00Qk+KzxZYDiis9m3bV8LK7jenFskQAuLCJmm1vrQ3CJsy6zomtfVyrJq2WstHbr2OJt9Wg3aFpV2a9E+LT6nIgxk2c/DhM/DGF7sXknHYAYPDPWkM9Noj2cQYEYdz87V27b7Kdul9vjqSt5n96znr62wT1ynKk6EqvXk91irgpTWom7G777L45jy1rL7VXpkO9p9Uy2upNH+SRhG3KKW+4lNGiXbGYI71qTEb1QJ/kLLLpPZLn4S3g5ZJUbWk/zXa33PFElaBh2VxfXD/2BGtRDWEdaMs9zoQTbuEFTol/FDOxV/cdyZ+5gsDKtE3AyyWo31SFvcYF1BA6IVGHgeLDBnLG6ohn2yHmDPXlzDHUzm3jW8c8s8dI1FiArPBji9oULFWbbz0TL9plPXs73O7rl7yuLOWKUKke25aN+UwUYcL1Yibgzcu8RRCMYR6W2h99oic5gptDJ8qrXJ/rp+PVPIZElI8WFNdw23wA00lLqEJXdGi9zbj2WoH9qjRfQiQtgMyjCx0SDJRW6AHo8gOJlZU83LLCnAl2sotBAou4lRMhW5bnqlVYU8rTsb43AJKxi5llVUlcApCmhxnR74nIffmrDDzth/ezZIjNwysDeJUygbeaBl/JRjsP/cs1f2IOBa2St7ELjuEFBAuu2223as12xZP/VTP7X+exUkdvvtt3No5en1a1f6ACqD+ZPUbUZoEWskOZCRyyglfsbFtB+XncOF3nSEwyH7TK9EyYikAbNox8WqO5RgYBCOtI5krL6kdef7d6gmLptVR22+J3hvx4ioOYWcgshlYrwX4aDdlG/SV8el65rE62qK1jIFDV34LFHH+qf4cOkLN9VoB6VaumOsjrZcRu7S21RDZqyirkAaQXD14V0CWO5GHGQMWXsycljIEHYI+wjtoPc6XuGgENhZ7Kn1ecijQkJ+HlV+Tyf8t/vs+rB0/pY/e6X3nHnInpcIZzDbVFdUL9thlkGYipAsNtfsfA0yiP0w/GdjVtfI6qSVoi+traxwiOFcOoglaYC4qSNo1WsIjLn7zRqJG+AUMJMy/1WgeZn1aav2WW29wmd7ubSf8ZBRXFgQNAZgRnYsMUnMBAHNBVKdm7mvC6HGSc/riw/0Y/27XOdlyuYZ5Ub62LWExcksgVWgNkp/hnuj70soKHQVk6nUJcn5V0BwzxmDkik6sr2uo5hrxjm+pI3L9Cf/Ket1lgL8UZI3zJH97SYyb5WXu9OTJOJYLNG/AWreAeZCIASK9trO673Wd/FKhsGyca1Dsz0othyMq4JjZv3z9w7oR3N+l231Nx/zr4IgND7A4cPVOeAGcwwCaYLzmmwkM+MJV9UaWauZcKR1SWZRBYZW+A6dO/ddqWgFdL+qBHAVgjdopz2MDI7BfDpfuprB/MJgG1MUY27DOeaT9Zvv3Z1bVQmTQUMYallQgWUJZhlXKy0IZTpgtjwTDKgc8s99Ei6dtFOPPSPMeJZ7oy87N3rNvzi7SyG8AU3aUvCA8496tOIbi/hCFFdDOVyntW6qZshgs11bMWa6FTPOFzPdsRSwDiFUArsekLUKDPG4/5bF1w7DF3BDZOpjGK4mPTU21if4iPFK7/pwqVvkuTksRzXm3rV1C9bb2xWcVACw7kxOo3tui/inu7rG0lN4epwsL4b7cIu08dL1MtbnsoqeoN8KvaxiEEWLd8ehUKxboWtA74El2u/BjY7ZxzpVBs+aLAPKihD12DQWKnBslUO/XZNUEeeXZZBygNtBa+/aboLAC7M7dxME98a6LQQUkIwn+vVf//U4iPKOO+5Iv/zLv5wOHz4c93cKR164ePFi+sY3vpF+6Zd+6ZL6dNX7+te/vn7d81/e9H/+BAhR7VxGbCSBOUJTkyixDISJqV3G+ibctW7rHkojWIsMzu0kwGb2WdRfCIQqcs8QvESFf22iruVIC4eaeA+ts+31Btd7dvUfom47uA0S9pIMitaFcBnrqDZu50XdrNo4x2E1lysyxlpmsrq2aXCHh71zFaJ04wBWs52Eo/azaiu7EcI8d0f4iVh6wq3j0iHa40xQItMVBKuBG4XuOM6ZsylkO4v9MA5DoleWir1QhYZcRxJILZPm4FIAta/qHWXl/Bd69jbQjSnS5VEmBE9EXO0uHa8syihnPs2TfnkmWAPkniIraLw/XTw3k0qcSD/BeSHjJAi4EYHyNOmt14jhqcwiJM+gweW8krVxtKskitiJYaeJKPY9rD3t7/ZLsViWZLZBym7q8rsw3VRkdrTwLCAUzWJlwHoU0rAC0BWEoE318CXAoUSPm6Cw8rvMrEk1Yo7dn/SrgKCUjOUiWBquJyDvHAtp3VddJ5l2l0rtH8U5wHEsTXBHA4GUiDUYflfNJSOK+6/04nzamzNYOxc4vGloCKsG7oLLk7g4MvE95NloN71elS25CsUQDO15l+3qWAF+HjAs3IocL+A9eV6UrSONNcm+8J+r1u+WEkHsuthlhd7Gg1rd+WNdh/WLW71fzbr7131cwE1ULbwWbq28ly+ZYKQw5J/JZELICdhsjMw2XBLiZgPotUDoFlhmbMZxmpnMllynZgu1lssXGGDxBZafFrjZNS9jrDVSoUOm2YVnivUulGLO1bpbYsA02wPauJtFdjv72Gevd9G9TDdX17F97AIHtHAfdS482+v6t+i4MRQi4aiEiy9XMSgVclqL3Osl3NSaKi9I09+9gmUJ11jdQQEbKMLU6Yo3zBeHfQe2dO6YC61Hno1UDOsRO5+6TNSg0KICqYErnu7Err0i8L4JX4oqArJ9dG0skyymxp87cowzywoIeE/juu3KMJ6sTspwM9L1Yu3VZa/IhgCytI345/qjb67g+EfbxhPbTw9t7sdiNIw7Zj9Csy0uYTny/LZYr6T/72F8VbLaSe9qZOO78vqjkr3ysofAnoD0sp/iF3+AJmg4e/ZsOnDgQPrgBz+Y3vKWtyRd6hR+/uzP/iwZa9RZ6mSM+chHPpJuuumm9CM/8iOdP8Vn65uamlq/3off8P7SaBAXibhocJo4E4mrWmYJnaduB7IHXR7tGUh3F0ZTuX3ausJJZ5F4m+lHHa16a5Gl+unMDQxhBKTfazA3/JwINereUkdnfVfz2TZlRjp0rOuPSTRtx2xWnFjBXVzJ/rfvMV7DMysyIXD9wfUPjs+n1CIS1Kq7Ev+2jnv99vYH2w0tJwSlBfMp+RmExtpP6MZli89ux6Re7jH7Y909WpTo4xrM0k5FApr1abtWdnrqGq7TUYmih6rK6GWZ5zYg5kw5E2q97XMFd7AB1kk/34ZYV7JgutrtNF75tbLDU9qiBKyNxRkfQEhaILkC9XGorAJSA9evhcUGFrvMSlJAe5om0ayytltDWFyC+8vq2fpqvVF3xw/2uwdttUkYZtgnEygLYk3l99hvzngqTC6kghn6gnujFvbRtRaZoV6YF7P1yRT2IFgr6BfVSsOEL8PMzpHQYYmA67CUERBtwou1A1h12WNqq5vstwJai/x8FmNzhKtM/CHccG7pIngca9sSzFcvB0V+F9dEUxQ81yIsrH8Ohn2uTL9G+HKOGZ8CcgSIFyrAoQMUfhTnyOS7ZkJgfq6N7/BcY62QLtQq4B5dMJupj78ygrNnHHWzNzdPTXvVacF0o7RLJhBdqlBwj5u8wOx2YqH10n5ceBjXYypmU5mrvNiuaLlRQaUlXItMLtLYg03ra/1hfuGZWF5c84k1hKE6fbGXavy1dLRHs/7U9h+yvbnGWrE9M1duCEbMj2Ohb7DoMc4OsFB/1oLP9cCoR6ZAmG3Bd+nu8dpzKwr7th8uYFSx5n5mjDLhFvvhJ/tx3QqVRWyb1iklmsuU6AXz4d5RKHU+AibG8PTiWjsNTsR9LrLfcTMiC7V59pcxS8ZTZZYkM3o2zPqGgKT1iQBQ3NmNRSUWjn1uUSjK6mHfgMeGWF8e0pxYz2RWgG6bOc6Mh5n6zFdpID+GYGb2PcfTRHFzgVTjZj4tE7fahQue8xwgVXjT4sVcSsOFcwHlywCZ8cQtyHN4RJBshuy180srJJcBryCZryHFlqrg8e4+3O44e4z13BUCH4O+PAhjbHsvL18I7AlIL9+5/TcbmQLQX/3VX6XR0dHINGZHXvGKV6Sf/umfTp/61KfS+9///vW+zc3Npd/4jd9Ivv/+7//+eoa79Rv48Ad/8AedX4OsfGb24biWZ6Dph8meQws83wW6lwjzD9SabiRbleb6Mib5nUivbMJNBGrrGBaIFiRr4H+PVBWzQDcMsAYmEXh1kNSkMGoi8msuPOJTVmsdxha0dtCWep+xI6tqj3lAJky3GJMfyC6aDWnnkrEnFdwaPKFeOORMwbbP0Ji1kUEVBtbT53HoweWogjlEBkLGR012Vus2NcTzGWtzOXrib44rq2eDOfCafTSyys/bFeco0/1t9+vzuxYuOowyDuWE8NuzfBz5uy24fjzbRYju4/Uo1kitkwpGlp367m9qRU2P3klxhUMVYb+XGK+puYV43jv6UOQ26ggWJsPIHk4F/RzP1yI+YHUEcUzzxpYiA5ExeVt+4Ktjsv8LuPCpWR7swSLVUWQICkswM9HFzlF33NT5EUEo4BSD5iX7H2eb7BsbToMIe17Ms0nljw5S9dBANS1gqZpHI6xCw1i6OvusDuPSy/pehXla45Bd4+1wsIn9bEiKMYM3c2DkIVJ02yw7Md3ePRJ76Qnc5JZiZ+QtXdt7NuLstRvXOpXpqxexopxhXY4gmPTD6qqQbxfHLp4xoFyh+XoWe9HfA7NH5sVn58hKt9SHcISQVCKzYXmZPwLXYSwVkrw3BHvW5c4Kk0t7F8Kd2n3greJBQacYQlPOEuhShdUAAXeFuTFZREx1uyqF1iUtv7Sb49UMepe2lV+xLplWsZFr3/utM/cCuNLzeT2++7QB+CbXKaNcUJjTmqEoZ32Ozz9jH8WBWWubWzDj4hIuX7r25hbOjAB0tvTcP5d08QNnu4cbWjfA+bbTBO4N2lQAyMhIJ2Sfe3s+qdXGLJVh8QkIb62PtU2jzpl/JkHIhNsOnEcfS1UstCxr7NcgIfc6uIr9WWVMCrJ1YGcRog2EFz0sXJBFrDAlhJbRcn+4sc3MM16s4WaVVXGpFc3Md718Djda6lSQFD5dWnfY967nZQ7G1jpY7kWxgtDV00JxhBDmgdjiDOuoNTl8uoXYhsWKKsigicIClzlXagiHXKu2yJhXJukTfXYM2lNLdHV6cTGENi7GHlYhoGynR7GjUtGjsiZbN17bK7sRAjk23I1j3xvzCwQBkZPWo85y/PjxOATzzJkz65fNZPfhD3849ZGl5g//8A/jTJv1H6/wQXRnkbhpZVGrvEIK47NkA5tD6CDfDa44PWE5Ml9STsQ3VWsVQTNbaZgzH0ahZGd5LuICwJQyAcYxyQRJeSXwEjhPbhcjXyvytLllGIS5FdqqoP2GeEM/Qcoi9WCFN3VPQuZJ6xa7aTphXQi0Hklco+vx66Uv5bZwZB8zSF16T35FGJ4h9uKZWYgiYx6o1NOhgTptZ0/KqOoGk5+VlD+3/k5HFBiF29aS9TH0qPQc+FGXBNGxWXTWEJ6Z04bX/Ns8Mp/LDrKVUF/fYr916AlhtN3/za1vbk9BziTsZqszpbewy/uU994nFF/y6353HuAJ2lezlUOqBupBKBgukg69SeaxWsBIK4tw6nzeJwFa6rrIQYkIM1D9tFYBMmhSqVoJk+IH16ixJkHpvUg9xiZlEHZ+zS5YwgKmZTHaiH7xotUVBuRKxcDyFmcmtXpZv8usQ9Pisl8iY57wAI5q9CMWsD3P63XSYAmGdmy0lIabxh7JjHSh2FhLc2wy2NVYS94vw29/fdfy4JqRsTTWyy7bd2F4R2GI8XSlR9dmY9/77PMpMnKlMdouwnBfQBN9lrkYRIAYp68IrRZnMAQT+qcCY7tU09md1/7quBzfMPuw2D2TanUYQEarEFBg7DS3XoLJRUgRJ+TPrf94mQ+ue2HZ0xbaTauMsxltqIjZ2GfiG/GeSROMG3LMutHq3qtC4VraFGbdMsQu1o4xdHy8TI83/+SaXkMzEX/AxD2s8iKEVta+ii7pUIt4Ks8qKyEIdrYprppfqZHxD3dSrUer7GzquV6FpgNfCssFXMuEFQZA8Jgp2hWcXN/dZHBTAWCr16dtZooZE8JbocpaZr6dQQVIaZprR6yw+U5gCv6x/zHvwG6DgiDsUIfnIa2qFWp4k/12ZplbBJUeLDZDpSpW6kq6SPruONQ75qF9H58VeGrgmWbRNa27Ie/gsf5KBdrN9TrCFHAb5fttWKLOlcALReDEpCqYeczBCpapOnO3CvwC19ALrUzuDftiEf80qGuuvsQ6p38I+kVwj1nzFpYzSzlN076uecwXUFukfz4dOJP1dL3mhYr2yksQAnsC0ktw0r7Xu3zy5Mn0W7/1W+l3fud30o033hjdVTCanJxcj0E6d+5c+pVf+ZV04sSJ9JGPfOSqzj/aOm5Rrjr2YfyYhyWAkIZ9XaPEtRCfAylQ019VG91JfHjI75FOlvfQcIvAEVL2oymbgxkgNjVDvtjkRZQSHW5pM30KZbq52N61FXnYRZD0E5wntIgL0U0wXWbrkhDh0A3xyZjYrFZHlyFrX2WR7IOE3ZSs2a/bty9x1Pfed++7UpnEz/zbk1WIZlc6PLyAcLTI+CQc2ZO6Uqid7YaRiDOOtlbIfRLerW3ZZwmg7l3xWWYr/lE39edFjSrsDYQ7E0bzmnymBxdBmQydBF+o4uiuTvsOIQeqQ/SGI1FjHXX2yVi2KRiGEoAbYoCONi/CJlgRxiJg5St0NB1mzTm0gxPj6YCaUWo9d3E+TZIGXMZha1EI6b6IX/4cjB3Mg8kbkDjIBod5g9iOIpyXmlldVvKng5nskF09U8vU58XiYIzHNuJQRTSm3SZPcKFdrsBstEbIDIW7XxfuNXAcqfsCySRwz6vQDw93XW98h3pkXiJI3bYYUwVL5RDr77xNCyK4RviY0LZ7OKXM/ALa7mdatTTInhmBnbERx1hlFAZ8e1TvIwhJwvB5F9fcMH2ssjIvIgyR5t5+Fvcj/BE/lhctK7pjqoEW7uKK61Ecl7t3AObQP8eaYYPoRozbXrjv7IOM60avdu5Bvv+Mx3Ff+V1RutYspHnOOhsr6VbrOqe014Fr3uMUVGwskD7ezF8y/HFLvF79i5bz61FiHPRHoU0XMYXyULowF1mqcIQEhDHXwrLZSSOtON+5X72PmUIbMNc+1y0OvhrgXUPHpQ8y+dnaBcLMj3A2lpLdEpbnOJsIi4mxVDk+vPZudD6RzVt2pb2CGF9u4zPW0/6Iy11dzoQrwJLtJGgbiRICd7AWurBidmluiXUi7TEpEnsReuDT3XgYrLJPi8T5SpdMsT1ollgsWK7LBWiqyi+zy9lMtn7F6V3QWfAcYm2/FiAGby+0Iink2KcKxx/09/bj9sZ6bC2lp9J8WjTzIXPawLVulgOtJVINBJ0mrnoBXea+sygg6647PTcT86yLchkLl+/Of8DcR/hjaBxOCy6Rrpv00/gqzonzenSus+K9z7sGAnsC0q6Z6hdvoEePHk0VtD9/8id/kn7t134tgi9N5z0yMpLuv//+6Mjv/d7vBSL+sR/7sUjikPfOM5COHTuWf935HcTloZqguzQOphPBi8ssWnkM5LZ0CkdZMCfIFARpth2pIlZ93mASuAYLkA7hTvddtKpVsuwRKQHCVhuOYGBwO25DJQ65FZlnKD2auOoXEbIHrN461EinFnvSdJ2+082wzMB0msVLYmn9tmAJ4UDXA4iqfxI3CfoqxG5jxHHr+ovPyNTk8Fj/YesHbphBOHpkmiw+cOxHRy+miT6yl3FfEIb2/fZEXbFM0U6acgUM28t6nT1YRLgxdiu/lvcnf29X3xaAPLgXplhhiT+fycJtMxK+9Zn82ef77tx3I1zLLFy5jUxQHQP+28V0LTI3Zzl3RafEBi6fo9QLvxn1Olv+ngPWhAVqjqNN3wF4F8TfpA8YXzJAck9+g/flcIwPavwXoeRkm7PzLZ7VomNWOON/VmHWZR5tT3ZIC1JeXDeek1RukvaegzZtBmklrXIg5BrufoaCEXqz0V7+YP6OINXS/USGxIfRGq8NV9Igwv/EyCCMDeupcwHxnE3EWPM62u/5fSa6GIQ5uUjDDfaiD5iaV8tquGDxsKzdKaxfBnbfjtDdB5PvWBxfie/jrLVTzMzs+h7a0ti1fmXDYrRNhX1oomlldQ7LJy5DhDNuKlq5ZBBl0zwTyZiW61U2wHipsiOYfxhA4SN8r1TEWeJGXXtlzrNVD47hwQqM6OQKqfmXymmcXCAjFZhRFgI6kSjuExnjRZheBbLvlRLzH/gc/KOg0QZYdymbA8dcB0a6bpHSp83gI5Rg9VQQ8ABT/653MeObVn6VEa6N9cI6DkGAvoLF43MToaBbjZSCxDUU3cC07uclFEzQEd3iCuARD3fWC0I3bV39FHAt2pece90Pjb3VGmjcpQo6kyy4mFp4OZg6VCHJIn0Q/ysg5aWAQkb6iMSDyycWIISaUeJ9lqjnAge/LmPtcT78Z8vuUVexAqp75nHONxtDECujGPGehlYlcIrWHjMQLiOgKKzsp69NqPPjWJEa0OYF3O8WORakB1pc6eNcJVzv1sA9Jr0Qx7gEYqS8+G4ad6/7bYXMoX7J+hR3cRmICH+K1Mr7mySLyNdS/LD3sishsCcg7cppf+EH/au/+qvpt3/7t9OP/uiPRmO62OlGZ3pvU3k/8MADcf1DH/rQps7cd9996Xd/93c3XdvuyyBIsx/kPNYizgaNdYYAN+4UAXYWtV9NtEZiZ11oCjyjtmpVX2oIh5r5Fr9pF0glhBC0Yv3EG9Vxj/DgOQNCQ/tJtcGyg08lfJtb6Wxx+8/SKBmQMoTnIgGwJkGQOZRQFbqq+NR3ECCQdSYkZMjbtuyD5yhJ0zPf8Y0+eJese4XsP5lYsX0f4iqVLUD7Hp6pwEC00vGRmTTeCzXiejam9itvMkfWrTaugYvCJmsOv0uQt9Pay1CtoinMGbG8N9acjSi/kreJAAIc8vqzHuS/bdx7vT/JYghntZ6XK/bHc7O0YGydeJ+sQbzj2F4GdwqoENGWxllRyHtoPPGZ73jI9Qm0EaSYKdbl1MxsMK+jpPyukv1xGGHctSKxV2BYwVXE+I1NsPOGNiC70Px2kZaboIrUNcB6xW2vCXfbVOh0nfJg+9YYoszQxdV5xiwjHHnE0uIgQhxDKy2upZEa6eV12N+2wNCwh9ZZdiouk4p8Yl81DZF9yk5mKyZ7WPbQfpjhb6cii9qPNW2A+b8A7Cw+J2ujC5sjt06ZtJNok3uZrxPY8fKTdKgeyx6pfBGS5trPRyXP98WxwDz1DKGaWGKNzNKLKoHgvfSpYzyhpYfRbCHgmZb/uViYr7WrzqvzZzc653b7ejI3QC1BW5UcPl/pWUsTvSscztmdvjNNXBzM+mjfPIfMEufBmAL2bbe67ev/t7kaWRFlgGMyxO0wu+yLwNVtoOgmPY/rtQvT21xJZtOLT2oj3EfXs1Cd1iMFM5VylxQu6Q5YRwCw/+LXFsqkaxPTTJZQInkHLD1tWUzCopJtGcwSSRGoX4XbIPikh3HqVudOUjzqQ/J334cyjeeXEXpruKKJa6SVLVzOE9n9pJUWcU+nksVr2R5nMDxTRjiyznnopS7uq2xIE2jkQgYzgku5VkuUkTzSQHk0b8pvhNQCF6S9Qkp3SMsiGeYswkcvgkMIQpPs6yeXLqZZ4zVpU3FrAIVqodpHH6BAgiFwJGNEuFNIdV8ugTPsY+AhaH4zBCa+c80x6M6cF+8Rl4SlUeFvr+xqCOwJSLt6+l+4wXum0Z//+Z8n44yKaHqGhobWG/OA2M9//vPr36/1gyj7GGd7eECPB8GJ9q9kLxFR6zZdIIAUikINbU2RTAZCkm5kBpLOwMg20cD3oMEyVoJTF4LgyqSpeSvKLKF9laBodXouRUIwCLdI9tTAxvbGayJ8QkX5tFG87l9nCSEJRlDi5pkUzbbLXQlCosueAkb+TF535/P+uEzXn5jD1Q8idnyklkarMHcSRn4LVhQYKaxIIDv91VdoS5qp0GMb5j5awc8/s3x5xRazIhMunPqwpuTXfU7wS4Q3RLv8iezdWl7MEkIojFXmOrJzyxmbLnwu7SE5FSKFdwY9mftWukDQu7E18i84a2TMfkf1WpW0TOiSt8D5HwskSeiDERjp59BEBKS8lWWEo1lOg59Da7pCrI+wu6QE2FmjxA8Q1Z9KuMqtDjK/nr0Ig7u1z9agFneqOQczz6pjUsyauIZ8089+XcPlyvOK4DMuKXEYpJn1Ip1vuy/sl25cbGQ6jMvKC9sGgQXmDWFtP4BA97A+rvwe331CB7UBtMkXec9F1XC/cWztKhX8a6y3x0nK0MOc3UByFVO/280+ahhGODnDd7XpARKuP+9C211V9gMud/XzMF0ISQVMg+Ea267cthTmzPrGEBAwzBG3wXg97z5sqSAfWwYWX/MrW25sfxVuWqpNvLBdccpKuDCNcZisCWBmaiPs636sDwtkJSSDYvuhjCneroZ/o2t0zBi22GS+sY7zv+iRjDFMdtMzxSjiHmHleENRBo6zBM5bH2VcuroX63ORdzwrrLUSqXDZuu+sNLKuYS3JhSfjsrR+XEtxjOJS27I4L1qUurCkiItxggyFlvs6UuV7D7dKHTwfqcQeCQGbfWIdfRzJYEa3Wp3oXZWG8yhZRtisbQFpu3GsQn+bWGRMzKBbrftSq3X0hddIs+3C4U/Bx4Nig2apOKOPAwhUQ6VelCLQPOdIi17crkdHJvib+ltLst4i40td6eFF3CUZZ4VzE/v5KwM7BxYWbUaiEFZhTs20Z2UzCGtV9qRzpPUrhFbqMqGD7n+xBuAh7OYSbV4gbgqNQOoBEa4ueJrfXtnNENgeW+5miOyN/bpCYHx8/LrWl1dWMEYBxNki2Hwa9GYrihYiuk2FC7KHaxAkfc69R59oM+tM1xdhEJfSPEGfsyDRZaJol3uxwIAch+AMzRinMJL5k+uegjsADEYQFpC5bWXkaVOLV/VF0UoiZR2dfe78fKWKTI2tMLQEEdMFoorQJLHL+qWAAyFBS5hxBW0WgB/9fWYRiwZWh2Mjc2mYrFhrQeR5BgIjTTSmYrS7PyxrC2S0O9+YjbGuIESuwfgXIbIW06zrqjGEhU0BY4EU1RsMMgwl95cgYjr0GL80jAtGEQ6yDjGebnDQLbPTyXRlfY+qX7QXx2vEliyK7V+uGAujUGo2NotvziX55bAYCeONIlPhtbx0/uY1rSpzCFDGIslsK4hOTs3gpjaM6yfrD6bDNdeP61svwscQzMLULElIFpdhYrL1l9e99b2bs3x6SaBQwNKxNszYekkZTf0ybdn85P2i3dhHrm+YGNbLKKm0yxw02sItabtSMD0v8UZrfdnasibdIhfYU43ZWlrhXWHffSe8pmHCGli1egaGyP6XiQ156531C3/De9TgmrzBe2Tq3IMySRm042qaQVP+4NrFNN29ko7CyBuTpMZ4jCwKvbjgzcKsXc8iQ1ogu103h1jqZrdW5fOGzieacn7tnYJnHXV2tUMzfT37ktdlezmDnF/rfM/3VY63zGx2+YIlm3Tio33ZkQqrjKEbhZElr+vyz7/4v7pvdMfaroTLHZYJBRF9A5p4G7RYG85RrCLWWDdnEnlKWA84Lltx29W087WY85Cx+NSu2Lew7Plhx+KTwJX+e+ZU9m3Hm9d/EE2LS0soJ1SIZbjdn40/cpasaaNhlR953T4XeIV378iv+1kcxiZDwSFNpS4ydHrTdokrjB/Uta6OwkYhTfdzhTIxUuc6iUNxrRnliCAaMMMJeGKZ/eG6PQHm63c0jN82fVZXtx7Td7OfdYGsg/NWEHLnOOpjGOXmvspgWqi0ENq5h7mtka5ba7b60jL17O9BpQkeE5vPI/AopKnc1A1V65iugCr+FvHUaKjMcPD8ed9ZaNc8VjghUwbf5i6JXNgruxQC22OWXQqMvWG/RCAAQlPAsZjF6JzEDWJ+AIEmLxLFJZBroH4+y7Rpll/Ef7kJszOF7eOJ+kw6RwCoyFOtr650PTBzNczwnq40iEZ1AKGjoWVpjaBQMOkIQoPaKJGnApRMYEZqeOdaTnTyflzu3Sefb5F5rIaFRmZJgSurVQK0vziUuhfo+zTCDdxnw0HK6MEo3TQKEz56PvzTM/FgjRSuJZ4hJSo0bZjzeJpTC+ncucl09M5byEikywPjowoFxAbpoi0KjCdK+9LqTC2VB0bS04XpNFmfaxMXoWGsDckoYLw9aHe0UU1PPvp4On7HLWkF+HpYpF2238ZHSCbDkuXFF61IwIEeQNI15XJFl42aTGO7e76p65xvp6fdOv9bv3fWDXkmZgnvegRO3WT6sBzN4hZTI4GJJ73vQ1AaHOjPmAdg0497ai/uMrNoNs/PzKV5zhOybNKY5w3QcAGmwxTiiAxplcBpNdddMA2mw7fPuoiaWEJ/zQrrvALDZQyNwmJrgL8a+2rZfbZlFNRrYgYWgb6iIdAo5i6goZ2fWaDvMNpYYevuN9imBVxaumCKzg9h42HvjLFXt9QYvfaawvMA95hNijeEHlILI4Cv8h4CHn3O1/g8QtAj7OupruV0nEx2B3FRLVG3me1mo8YdXpw0F3I+iTvctukyz5icoWdYxpC+zMCOlnHzwbLkes2LtYZChms69bgnX5hiS/5dWnIspIJEa7fxRplb3aX3XnIFoHvA7AhC0hrCRLHD5feSe78HLsj8rhdgHjPhOx9arPVVLCqN1TJrcBgLwRCrEZaH32T8hZP39Zbm02jvJPv/8nt/vZ2ODz4Rad7b3ZDGBAqJjnTc2PGxC8FZ2QapIrP6xFrsuGGnj7ThXFZwq6sq7IrU20XlxhrW+syRjCG2OX+VU/bP7uiSJ13cbpTuyMC7/F5g7xZJa99aRHBhfxVK7d+oQ2ucWe6M+zH+abBvINVxo9aqLQgyMGT3R7ZXG2Z84geVYVppFrGIlyAf/VigVkhb3w1eW9FqRd0tFJMF8KFWNc9HjPTf9L7omQe48Q0hwGuPl943OSuue5GkOBygbQKXZRRAi9ThuWtDSEw9zL2xXeIlD7g1RbkJg7qYIN19l8FLDQQss+/NqWSkZqloNgbarCCEZV/il72X3QeBPQFp9835y2LEOSJegagZhHoBpLcPgcXrIrplTsOu1WDqIaCh/QUBNvmb7aqn02idL/SAqKtoSFdJAo4mKri8NsGxDv24q2gXUe+l042FCGQV/RvQ2gsTKcOvL7euPOBgPmeMogxRnO/QRrMvNLAda84QZexBBgEzhKlJf+jb30pf/drX0yIuXJOTU+nY8aNpcGg4ve/970m9g6NpelktpGDqSsOcOF+6uJLOIxTte9Vr0qf++1fSZz//pfTr9/wfZCYybxsEWQKL9WeKMyiEhVrMEv56f/OXf5/e9q7709Dx0RCQ7MVATxUhsxJuH728C7OZyYvpb/6KQ4N/9UNpZHQglfV1DwIKoQOeulno4rCAZU+XCOt5MYrzpqZd4e/ybQqszT1ahtma1+zxHIrCuQHSqGQjK111hOT0ZFCqY4mZxq3OODirjj7BhOhGMzTIOUhcrGP5nGdee3AF1fK3teMhbJp4oR/rCuPz7KYD3NckdkerkWt3HubmAlOg/nyDNaDBKkLJBKIGZy91cTjjpkJnuhSOPDSEBA1ymTJdOPWwHjznqC8NkqhBt8Kz1N/FPuxeItsa3ydhfvpYRr0wOJ0Qk/GSQavCYN5IT5ZZK9qhTsNWLbM+FJD8PexmvFuCqbPO1nK40oxx5kkVBmtBeF6mmF65Rfs94I2ua2GKaZYtguUIBvEiwjRJG7rwGczjNPIm7R155VKR/af7X+c483uux7trIt/7eX1+dy2bSlpmWm35RrEnsZI2LnV8yupzOhWSEKFhOrP7d36m4/EX/mMHIDOhFIwX3D7vCBsRO6MFBHyulXQV74KVtUEUXhPMhnE4xtvVMwYcHNYdignQDfQA0nDtxTXrP/ZkrIEcgO2a8u5uV7VCkgeaqpzYrnTOlJ+dR93YqlhIMs+DjVrthVbLzKUvb1ybGW0oELB/pIwKzCr+OhGYtbhePHKi4R4Ddi3SZzdwYV2bLqVVXK/VCRrHpYJFeJvEwJjcsX2jnBXEPm2oLMsETttT0FnC9S7ie9srVGvQIhabebLOTYMPjjSw0KzxrIolMuXpSuf4VJIZ99tDsqQl7nWeFf6auCCeWllAIYoCReUdwtEKLsA91FFhbltcN/GMluNRks+MLhmDZHbPPmg+rs7M8RKuxgso5GY4z7C2SIr3ZZMwsTIGiWGiCAuFPul5rKWYwA04x017L7sKAnsC0q6a7pfPYGWUVqFqoMzwZzZ1agvts4dxevbCCj7nwTiiiTK15xKM0DM9S3HOkQwXXtgw47gEgf/C8NTGgzKgMl7DEKL9HKY5jxBgJiKvWjyXSJ4jUt2isRKBy5T4uM/JqI5wIrdI/HqhVonwVkYoOrP1hb40OHxzGQtDGcK1CIN7I5aa3n0H0sPf/FZ68vF/SD/0w78YljI1f6sXLqbGmSngRpKGo0eDCP/DJ/4xffMbD6Zf+9UPh0Ck734fjMaBWiWdeRZ2FdjuP7Q/DYyNpSeWz9MDXM5g1B956NF01+tfl0YLY9GrQcZ/JI2mxWen0vTFmVQkmPYgbVyAgV3BKiFsKvNYHM7PpqPHjgVRPHXyaQjXUprYP5EOHRhNp+pTYd3bOszr/d05lKF1TV1+zlw3WjgyYcR7tcQs8CQOZ1d4dudesxyVO4Mo17BSLKIBLdQRUDi5d5oWqjCscT4N/Qwyzs29HOR4YGKERAwwPcAzU6SzSuKerC1Td7fQrpodj7wCaZSzXoxJiDgUmAf7P0j/1bSfh3l0nVmiFX8cIF0vbfVMLqYuD6rNC3W0SGLCVIbw5mWf1TklNNjtseh2t6y1jTryeB2FMnS22LTaxXvZRw364H3ORZn6jVewvlPAtu4zxg/w7u+dJd8XJgo5s6aVUwjlVzvvzD/jmtskmHy5P9wI+0oIbx5Qc5VFZtOEDchkqamA1At80LZ3Fr9piQzXReD8wpQc72SCrd/EUJ4XZhxip2Dk3Cgw+C9nx/Meb0Aq0/C7BwLC8ZLf9cKM4JpqZW3EKtsiEIX7HMz3Ki7UkZ6a28wP1+waSout/cjwg6y91TTedxGhnbi1SBojnm7j61CKkJwEt1FQW+yJa+nXKs91UZlOxHnRu8B14lJVeOkAaH5L9r6NcKQV2wfawwxFiHOpYFRmT2QJS7L9ltuCVhBctMQ7c/mMxT4iltDkDN5dYF1sLc69Lmdxxh2/T5HZb/HpqVS+KL0DP2ApbeFtuUpCIZbzerENccvcLRxncNN4JoBBRONgXIVS3NSmoUFruHBbpIsKHBehTQsIRzWSM6xYP30rmEiG/iuoUFHUJY1xPnSBi7a478nlWjqP10IRgUjr0gqxSNItRLm0TNzUGko11y7TS1ZbLGVYpFYU9BH49umah9twk8+zxFaenSfmGORSc1D5XPkscO7VykSPs55vwDMGsvey6yCwsat33dD3BvxShYDM4Hky7NRBlGrAJWuiMj3I1NeagaYcxAGtGy5JMpfPthbSU5yhIoNopE4N1wHTkDbQXBkI3gPDGcGy/NYHkpzA+iGzNwWylzSLqPOim4DEpc1KxLv3iKCbEKopEH6ROrDHxLP5c1f9HjRV8meclZpBGR+Y2w4ivF1dni5++huPpRZn5OBdkNbubqReEmKMD+5PRy5eTAMDA+nA0RsJmq+npfml9LF/+FiamroQAbEPjk2k73/b29J//8a30jNPP5u+9ejDMI6QSZh13am+8Mn/Lz3x3aeCoClE/tQv/mwaKQ2QhWg5YNPDXORqWIOmD2JxWnjiTPr7v/0vqYKwNkOWth9897vTLSduDm3rLELTp77y1TjH4qaDh9M3+PzFLz+Q+rA81BnHB3/mJ9PE+GB6dtmQ/U7obzfy53gNOOv2EUSWNaPL2ZVaMjarDwbUiXXOjXSZaydBeM79lEjLyCxYG5nl+LiKG0od2K+g8fYsryoMRgmrkUnmXb/Oy9owB6328SzPtWAqtPSE378dUyVOjFAL65ErtcLaMXjZn7KeZ6+yT2PUpzsVZ9enOm243lx7sbMQsOArUve5eSyBPENfW1qlxhFx+nB7kQtsF8UM9+ASe9L+NrRytfvFYop91k9bg0pW7eIeMtmJrkkWYej5NSiA01NdC+k0ab21JGYZ/Dbaaj++/uZzV5q7/OZuXHKNuZuucWYamuqB8jzaa0e9c/35s96iq133EPDBw7F5kXGRAa7gyZ8dHXA0WgeL/q3Dfb2WHT5QuV0AxldTZKa1VpsaXlyF7jssR7kyJ69DBnQJzbrvmTiVdVXGNSAOrLuoI7MqCofvrSKzr2Wjc625bkwIEpZHBGzhtsY+aXb1s5/HsVYwt1gSyvhyjfZfSCNVXIBBUcZsailWgMlXYZ1A/ljr7hnh71/2cllAKLOtgZ9bBsBYmY9zrcKcaDkUmyxTt7V7/UqzarMKLJ4d51w0GZ8uYlWSGRg/5u8thEFVGcvMZ7ZHAxJROdstKzTkGrCufJzOte5qMU4+CwPTbutSG+sF2KxyvlrxiYX09te/KR3YdzCUGiodLZv6zpdnT59Kn/vyV8A/uE5PDIV7rocJm7luBbc1Nmw8JE01Rgy9JXuMZBC4DFc4+2iFfVdEaNE9XNhUK+B9lSBm66SfmnFc2w0Ep3PQ4CmEJbVADYQ4lZA9WLjnI37Y08+wsKH0kM4fxcF2H2beJXBHDQuRh8ku1h2c0AJHsFYGsR5H1tr2oISRgmcfAqi41kylNfqyDD3IQRpA2HvZdRDYE5B23ZS/PAZ8Bt5M1K5WbRmTPGwWsSFrqQ9Nt+4WMpCa/43tEAGHgCFiZPjGMtRwATADT52Ad90jugk0NY2AGqQDRU3uHFrZXA6iAuoNRjpjnyVIEkJeqQzUSxu4AATz4SW1ZTDOEMZeCBt38ndtxRbmiY3KTquHwNLf/kI1jfX000MIJZRwO3ZwBQ3dzMnz6X33vzM99PDD6eknnkm33kD6Cl0PqcMum8VnAfU3MfipVOlJ73jX28P17qN/8dH0g+99T3rXe96dPveZz6c3vumt6YHPfTbGZ+CuROSt73gLWru19B//7/8nnT1zOlWPj4Qr3NbR2Tdjk9Qi3nrLiXTLrbelT37iE+mLn/t8uuPWW0nhupg+/g//iHB2Mf3yr/wSVqPl9NGP/h19uT/deuKW9P/+p/+U/ttXvpbe9qPvTqeXp7dWf/2+KwwwbzIxzlKbXu5Qv9p3Eibw56Gmzqv/cNLAgnTlp3eoNLsME9E1gSudh7RSlcS7gIWmgNDumiOvVFqIzvkjwjxrWpeZNfrfIAYoziHipxZzbMhInLsCgxFCF/e7HrXGyPputyIdUy8Miydg6bK6QL1axXQbDP4IISsYKwUxKcYQwlEve8sFtaWYeOIsLiwKambpMzNki+x8rYHeEO+JfItskvmTaoHD6kQ9rhvT668iLD7dvZgebc5E/EAs3C3tPPevwA8BabR/GsYJR1oYq8UGaa1Js3HVQhL9ZCsioIJ1cLWrn4NBI2EDhmOsCTEQXrK15fpyrvy3UxEWwkDrmjy6rnnut8sVn/EO03ZrYVBDb1vbFeveCKJXjbOlxGPZ1cv1c8tTL97XSzrM2GHue7BiuDYaq7iH9cB0N4Y47HaUOeXwUdZxX2UhjSEc9ZZNsG8WM/YA17UQyBCzw9xOwJ2hgMhZuk5EBh9+93NWtusAPDfCv2bUrTPllXBHpnLd1ox5uVyxdvdSCHvE1BoLasdaHNhrsZ/immgHa9XSSo0EO9qsFYqZMQQD78/O8lHwgy4SVyMNjGekT+yzfBRaekiVE0ISD0Yb4ora+Zn0qqM3p9fedU+qkiHucuXo8WPpsUcfS7Xp5VTdtw/6AmwRZhooaZaJ89WCap1lBJ9u2hvGJW8cd7caWGFJ13U6swAeG8HaY3bZInFPJeBZR3HpeHTdFr+dXJpNp2vEDQMfe6pyrg+XuDkwb50kS9y5jk8GGdORZh9QwR8AXJiNnX4hdIkDxdp6kjy0NpNOdZmZsQ0R6u7FTXkcpWiV+k32YtzSIn3ZK7sbAqLzvbIHgZccBMzYJiHR+lNbrYXm+wniiw7jRuRZKhVO9NaSITugHsiATZkPtW8eZOc5FCJOcaR8RQsG0SDOfUVPWEG7jGudSP4IrFMf2XfmtbqAeE2BuwLiDl0cRKmXgzZDGODQO0Nky2jERqhjAC3WOgK+FujSH1NnTzZokRiANvkisL5GLV1pBLc/+6x/ebhytO/wmtq6bhjXhx57KE3Nz6b+/fsg8jJeQCGriLthvrm3C39vme+vfflrITRJQBbRsvWT7UziapYg3Z4k7Wqqi7gpfPNf/hW3RTgJ4CIDrHC4Xqhfpi6C6pkX8+t5iJ9JHi5MTae5uTkYlb6wQEydn0znTp1J737fe9BU7kvfPXkyPf30MxDc76ZTWK8qWJG6IVi288KWjEnSb14htA2ibZsEPIyoi+yGrA6ZF/4pcMxC3V0Lz4exdG66ehFdtMhQ7Ie++CEYMDF5v2zD9S7czRkl1ddxRqtOQIp5wgOFu9ozA+HnfzwvO7WAAqHcVhI4nrz42RHhjIfwR4AzbSzBTpzDNWmKdnTjSyOs5yESPXivDJkVbynhauQhsWiQZ43io+NhlUPb2yKLHYsGRtBnNxg+mTzH4dhcvy2YutM8+wjC0SyC66Xs55ZGn8NX4VkkJmGYc38MCm+w92k+G9vV1sf9xRH6DUybM9RxFlyDu133IEIOwpOuQ+IdlRyr3LNzkgQFGyxtWorZp8YNibfc39nMXb5DCkYRw7bDbc5S5l7nGs1K/r75ke2vbr7nhfmWt3zpisraC2XUlvXmilE8IAoFRrYfwWgEjwDWKMtJN7rRvrk03n8R5tysms5tvIAL3bcqOzK8ZgvOk9Y3AbTGs/bH+zOrlV+4st657EPcg0Cw8c2aNkp+u9kXt3R94yY+qXBiEcU+iQNKcWdzTt3/OU6JvrefCmzA+lCp14X2wrojIQM0SRwurq4QCGiaeelD/M6LVDBfTxWwhkL1eh/5FImIoDlHqyMZfvNBigernp+cDKuOHggjw8MhpASuxztDYcwxaAXWzVHhbRkXOoHo2UgFaIn9GCB7aQU8q6A+j9LENflEAas045igP1XmsUS/i2aw41np9hlMtI9WllDW1FOFhBE90HZhIk7x6IglaO8CHgxrCD2OUAFX4cwDuLXAqyBFT4RgLB4hrpPxPLI6m55cm4/7Y4C8FLCiTVDXAPTfmmw7EhHFpxxK+d1777sJAnsC0m6a7ZfRWAcI+hfxGpipK4LMxSOt2fQMBOKOruF0GARqOuZFhIwZRJeL4UiFsACCrkvYCDAXoWthWgU5lnoGSESAYADhmIYxk9IeIej7Vd2crIJ/tjEOMpkGos8WOFRPdwCQewWtE0eipBrPncaFr4T1aRBrTydRuzaww/DQli4WncyhaHqOww4ldApkRfoE+g/GK+4DFgoWN957ezr1xNOp78hI2n/8cFoigHYAYSMIOkRJwiYT9tQTT6bPffIz6UP/+4dJlbqcvvPtRyGmsqto/SUyuB6aflVNqzFEH//PH08/+bM/k0ZHxtK3H3wYgmjYs7VmRXeXpQXcWGq41zX6U6neSl/49OfSzOxs+skP/nj67ANfTM/goifFHhwaTO+4/x3pwX99MH396/+SbrzhhrT/4IH0ilffkY4fPxHJNQ7feBhC+8Jr8HQ18WBPZzYTdLLxbCWLwlh2wGBmQBTFvIbzPJkzHtnVa3sVgjJrMkV5vVkNHT3go4xPP3MxxDozPYgB0/bXu1Zh8k0nbqrxLI9Vtvrss2y2BF9rzjSfHIO6Ya93tMC3je8KS1Xum0CYWmaNz/K08ybnEjPu547it3ChQWPcOzFKDADv9JMIsvQsf67lLK6AjHPc2AcnZ3Y1NcS61lmn2uYWAtL5wkp6dHWGtU7gfNZaR0vX82PGPDrqIvs5hN7Nw7piY1242hXHYbYHYA5nEJDIbLe6AEM4jKAzBpOL251zpJCUOaJuV2U2VzYtHFRmeHaY8A8hebtHruGa+CITkK7hoRf4VseZg9qEELo7+mf8qIzsJdOe32y/eHgVC0STWJdlMmIuIxwt18nSyPNm3+sh6H+0dyntH5jH7Uu6wH3g/Ej3TKvhnqUQGmO0JxtlVSGVezO1UCYs+asz1JLrZt3m8+QW8Cwf3ZC3Lwpwth9PXzKkeIb6NmJvMkHDw7jdL92Mx/12aaE+rncjTBTYnwqP4oZciKyYyCEXjnhYEc668rVk/6UvKlriOb57tl297X7XubXdE489/lj6+D9/gmMGKulVr3pleuN9b0CQQdnRUXTttn3d4Ra1xrOvK2TkVNhRYO3nfg8elh7P4vI2tUACCKxFM3htTHPG1j4sgMcwwe5D+dcNTMQIp8lM+c1VDoVl52j29miJKucgqc004VCVA6lHPFjdg2lxa49MdIxsEqvSYY+SqFIXuGsJ2hYwYsZPQT9Pcji2WDOHbAvlZ3NtJOip/dOKuwxOqumV0o6h6hjq3sddBoE9AWmXTfjLZbgibwm/TLSMvW4I+jNPdy2lf0EcehqLSw2CtwCiA9VB24iLQINlLEMdDZe+yRKgFsRltedAGsNBfQCEKrtrlrpRWJTjqIIjfSrPS1LV6uqnPMZv8H8RYwGtyQgZri4VXGM8QSQjo88N0qJuzw6SuLbZ0fWKJG7zpGheCwFM4se5TjDsCkyQOwgeQfc3TaShY/vDQlaDWCnIwDVA1IoIJgPUINywFOELPjw6kr6JkFJDiNFHu4K6bYizahZrtfTYY4+kwWp/GuAZ3R/GxifSo488HM8vkkihCziaNtZ5kNBW+yrpWw9+K9U4r0KtYjp6jEQLh9KzJHb4yle/kh5+6OE0MjhE6ykdOXo03OlGaf+fcb37337xFyC896XvfOvbZI0upWdOnUqDI0OpbywTNLfCgSquW7HuCIKGqVDIlnjGvyDUNqN2GWYVq4n++g2YEh12dNWZxJ9ND/ic2F5Lp5xLXUtYYdgoEfSpxLqc+a1FQWEMy85B1ldl/WdR90bLakdr9GcGpk1Lkbf1Iah4cv159kGdvXKRhAl1Gh2nnmEYpCJ/25Vgorh/hjgHXVI6mrn0dm5W/DbpwjCM6zD9RHXBNwK42W8KZXPGDwBP9+sc+7XGeiEBffB/nknWpeYW5ljh6GFYommZohe15MLSNTYqoBi7glD3fsY3CIN9kbHMmt0SxDAB82psEvddCSfkM+F9Hthb7CJQHvcj99dGscHO7xu/bPdJVtNAd3plF67hye1qu7ZreS8DRD7KWouly/pQmFljHyno1HWPIw33qglEEHCqWEBvSgAAQABJREFUJRLMkEyn23XnY9FzPoDcgskH8bY87w3XyArumH1FRM8+09aTOpo92kv+5irxZFoOHHGJ+xWKqD5qCst7e316x0aRFmTrUGWYgor4QOVCqI1g+psw9QpECihWHwfUun7zwW5UFp8yy9WWix1frRnOn/rA+gqH9L+B0m6xB4bfNcW/nWbNHkTmPO4Il1r2PRWEMi9TLEBH2Pemw85gkTVsVx1Xg06b6trVoYWFgYHjbG9zOUninC5ow12vfW26+cQJPAg2s4zGRAW+ZG/XEVTcx2W8N0oIVFq2HNcQCSZMbnR+cSFdqOEZQXY6h1amY9PEGJ7luIJnqwvptuo4ik3upQvf6poFz+r0y1qxn5rKwV+FReKSTMBEf2kysVRSo456qB9agdB4AWXFjeybHuC6Cq7RU8Qxe9zASSxHzm0+Xc7bwtoBPElGoaszzMZKCNMLuC/WmYdYey7g/AE+7pXdBYHuj1B215D3RvtygMBZDi6NeJoGGBIkJktW5qwEmQGz+qj1rmEFWQEZN/lb5c+0oQ3OVvAEcN0CJDJNTnvsLe9Lt/RzeB2IUIR8sFVON7RIcSwxtvItxSv+2Wb4jqNBW0Wo0Ro1j1b5+WBU25vjzCW1yBkZprqOYu2662gFsg+5K0AQPTWg/HmY6xLCURAHqIAughPVoTQ2MZ5GDu1LZ3FfOjg6kQ7ggnfuzJl06IYb06vveU3af+Rw3GOKJ338b77l5jSwbyQdOX5TOnD4QDpz+lwaGR9L977xdWni0ISqwXD921caIiyln/YUPmHGaX+U++659x7iO5bTPAcK3vu6e9Oxm4+lwzccTv1D/ekAFqKbjh8NN4hxrA6vuuu1aWFhIZ3hDKDjt96cjt12AkaZVKyMYzs4dIDkeX+0foUkYaoQFPBF8DQw2kBhD8L1t5hfCP48AsgcGk30oDx57cU1VoZRHEbkPsyKG4NRNPGDQhjiL/82NJzWrtPnYe7thbG8dDVm7cvamOJ6EOEnYopYnRN8LsEoPEVM3lnOQyJ7OOwB2lFc52Q/iXqK9Z7VsPEqa3AeNuUUsWoGKmuplelS8NFqCNu+/qelwyQPh2B0FY4UyPI+5prrBvtiDcZSWJmiWMGpD4FUeMoUrrHxzhaW02NAdAaXGbX4+Zzn73md9vK5wHxjdC/UJ2Bk8oY+Zo990JpnRmR6OdRys5Bz5fbFATLhxpoJ+4gvipnbGHvAoA0IGcXO4mXXkDjE5AwKpi8ezGgphCGFIBVSMLQIQEuNCu5XxKCs9KfZpaE0tzSSZheJGeKvRkbBpXpfWIJMmlHpJnEOAmL0mRcFEZPeVEm8U4VB74NZ7i8303ClngbLHFTdgwsVMWu9JMvwt3zN+F5g3xZR5Ji5UWv4BgQ7Ibbx2WeMbVWocv9LExRATBywBm6LncDFiL8Trq5rmPUQllz7XMvOnyJbJ3TI3JjCY9vCvcYNhZIA66lteQDrmpkf+R599kHqzYtTbTKDTAWSXW2SuEBLbAHYFOiPMTSKdlqFehi7VvLOcTseBXiFhUbUZT8KafKp0xwDMJSOHT0WgpDr9uyZZ9Nj330ynT79bFy7AWt/eBbw24MPPpiWODG7zPlmWRpvcDUxkUUsRo6LZsCfzCdwPL0wky7gZq3Cznq1LhlnqZXGdOB1BOLzOrEDSxUo3dTRg3DXVFAJSVPLHp9R9pVx7RN/hcWKOOFFcIaJXYSTwk0FnSBJOWPIWq7FSCdRLD5Nlkv3RVbIgNc1hqLrhrSvfxnPj+xsOJUTinxMYoD93oHjbfi1H9t721UQ2KwO2FVD3xvsSxkCpnetaU2J2BGQGcjWg0j3wXBNITzp1tLkoDcRtamqm8swHRI5iJL0CqUdz+AqUBpPNw6itQS/qtkcgNHbvybbJ1rNkemlkJIQGpSqe5+aKutcwZVt5ycureOSKzwsQV0J4eiSXzOpLGhlvMQNfgr3Bp6L0u6A1yX2/jaNNa1vZDTdeN8rIivcJOc6NckCeOiu29KRe++wBgilB3rWESzn0r3vfatcARrIlA7uvzk91jif+m8/lN71yhuDMAkXNWxnyTC3hIb6XPdCOvZ9d6XjECh/s10J/Rm8x1/3/u9vd4tfoGpTMGxH7rktzWDFU9v4irfeDRwhkIz8zT/8A/YYIY/Df+uznFdBemn+vdhFC9jWVgWrf4oWRoNZNt3Dj9HXuLjzyoHspzGSdwzgsgMvDTOW3duLUKCV0pD+CyxOXeKsyr8qcK2iAt+5VnuT9a/As7ri+WfRS2SAs6bOrpDJkT0wV2qmEQ447YKDGEMoVDG7tZjW/izztMIaiFb5PkifDyEAtePGAxY5Ex/2S5oTPp1FoW1chpdazsP0tWDg9sEw93Oj99pDmmBNZMJRjXU/hBXYpCimJ64DE893kXlSaIvU2bybvyuYmM7Gvhc+MxbTmfeM0W+YOmOT4MtTD2cvt7DcxYw4L/Hh8h12P65gEQxGUBjwvQUcwgICjnOtRDwX1YQloqM610koTHhGOF1Fcx1PP/ePq6tYzlZLbasQMYxNrUN8J5vcKsL6qukZozf2SGD5n/6xZj2TqLe8QFwYRwJgQfHnXFFQYJ1WEJDKMNvtJ6OTuudxW4y1iSKgCOxXeWe7AB3r9n6ENPF+PHF1L9ZpO8K4gEWD5qMOM4M6ByFo0UgmGG3GFT6nQKr3QqbqsM2NnevveVEJtanYcf7EnSvg4hIu3ypsOp/x/vXa+EE3cWNpjbdRwDI5QZ314fpx5ndi8PI1Yt3+KYgreAVAbaRdTpxAWXXsWHr6mWfTpz/zqXT33XdtcrHTzVAhZhnBZAVhpRiJiXzYWlmZTMRkYzG8OPr7UDoiAKnUs3d6fsSB70xOZLGkrgvUsQ9FZxF8h5dt6iXVuO6X4d4OXOu43tVGECapR2TUhHD3NgdC0WLfVxCW/qU+yYHkPWm03BsZMwuchn3S7KC0mhVwCdnu6l2H0sHBxYhXc+weJeCai8NwubVB/BVNZkNpP7n3trsgsNP+2V1Q2BvtSw4CakdD0xwMB2QQhCnSJyIoHSqOQJyX0ml8jj0HtRvNY4GgbDVVoZGCAMW5LJUREirATOKmsUbqUd0AtBzJ8OWodCtgFDhEoNazQhascLuA8VsjyH4mAuTVMWbM7Ia2amst23wHEUtQF2EWwzUiCEzHffwehJF3iVlOgPI7vLJTqUFpHq2doUa0utTivVMQrenG0yEoxtlRMeLMjTAh+Ejkc2opLDKGo7OVjC3zyjMr0+k0f5spSfZ7J/tg/70/c2kzjUMxnV/BvY/ib7qy5UWWxv7+WxVHv1PZ2iutQThdxhkcKmuXYaLUVW4tsmvjWKNuXEMsQgBpz2jcZntFpIUDikw0cJ703kLL686F604G6HL9iop46bynn4furfakW/HNe5r6n4JZqHH4V4n3eXxsSmjdYa3yR3mYp+l6mU7UXGe2C+PbT3fXYCB0f+lGsHUsoSnHFUiNcGebG5VlK4KTaDiHyaxUxkCxT9VOUHyVkTeN9wRWzjsKg6kfAakXIOr6qgUmfqdDCkVqvcNVhli/c1hZYz9ETd9DLwyqUIJZHyWDGVkqGpMwepzpUjBQEcujCS4KZXaFlo6tC2nTMNBwg+Mypi3DJILNGEgWBDOWz5lQ3Cibv23ekRt3Xd9PjqPJGplZHMUqNMxn01TDwDpkxiyS4QpJOBDYvM4l7B1ZJ7inB5e4wepMGiKzYAXhSMGHJ+N3x6MLr1YRS+wq1qTv+ViN2XGv+Op66aYNM4uKPxSqL1cCJ1lRzMXmCckvlxGSmuyVVeYwMte1K8ysRvk8ZBelQ65xO2csi3OmxcZtFRvb29sT39mavzsGf4qkB9AYlUZmLXUkebG/se69n78GCVGs36QgPqwCUKWVioeYFyBVwrLcUUVeVVzittjHEfuktSXLE7N+zxNPPhkpuN3hI0Oj1ClG3+iPsUw2topAZrbTJt4UhABlhcojNyxCzHCFlN5YkhRWJ6HNZlVtcNCrsau6Corfmmhzls3eilDtIdHuG0fPDQGHPu6R9hYaWMWAs8JXxWx3CFSuAenKPIqVJSyKp/AeOdUgJpi1UEKyncciabftr+ngl9LBNNbXSP2VuVAMRpIJ61eYRvFpOvE1xrJXdjcE9gSk3T3/L9nRmz440DQUSPN6jrRlJcbQWR8p9KVHQK+PkrVGbZ6MiZnR1DxJgFog1p6evjTWK8vVjZl+NV0Ecd/OAYNrQcAkHZuLVitd9JYVjBCQdKUpkCq7iXA0h2uBTJznKNgxmb6MKlJHVAUBiA+ZC0bcxPU2uQvCvtBapA9EuICoN5X282tYHTwXo1Po2HTfDl8CTvxmW/ln6bTfdbMwPbSBvfr4y3o1gUVnD7zXEoQ5+xivm+vK7uj4Odra+oz1qkF0/D6ft+O3jA3MasjnM/v2vflq/82+tJ/1MwwTIvFFBiAGaDU9ReC/7nI5jByBTN4gzG0rDnXcfkyenKXL2jz11pgbn1coMRaor800+mRnvX7fWnK4xjsvgzx7BxrrffifTNKGVjr4IQQ5YgTod4+cHEUGS/ch0+cXtfqwJhaWetLJlRIaYtNKt9IEVqj9xnlwv09dTV90CNXisXU9eHL9DZyHInNjiV7Ql6xe+2VK4qwFBUQtayuszwtAl+58bxbXQZW9uo8dP0mGxKkKwp3WQRlGhMS+ZipNgHUM3NoCvM6tn+2HbF7y27J392l2/XsFALrSLdarpNouY/1rIugQR8T6KXGeQLm7jksVEjZdXiYF9xL3eUZRg2dKKAKGBzjEtTzP/cAL2F1SWPvCwv1lggHdwvS68k5jMLUwGV9q/eLuTKQQRjsX4SdTbcyf1CNLrb79/eLbIvSjiEVnfcU7x9KJju6Ks7R06ZYrfbLQBOseQQ0cC3fPd+iQCBVcoNxiJ3UhU/kQZ5hxQcHLusOKSEr6KokmrNu96JEWWo20vmt1aeIu3qMCsC242J2cfriWxO8KKT6/XREO86tLaR5XdWG8jGCRP+/9hw8fTl/60pdIdrCYvu+tb05agXxGwaaBwpEDiYKmSpvU4GTKu3ZLNGnSiAFoi2nFteCcWpoPF/BihdhZDnBnakPA8gnny6QVuob3k+Sh0M+cKnzZHshKOIX7Kt8r/PPwXH/10PYlsOQiY/DYjgIxs30cK9Dg2ATjnVZAygrMxi0BXNofT70oRivV6RAmV+m7h2U3SdykRcsz5bRu8ZDd2iu7GAJ7AtIunvyX9tBBpwgLLdw2TA+cEwADzydgBnXreWVhJFXQHn1j5QLWEvzUxeFkzimB1LvRVPdBtKmCNLHNdBHTvExaRSTayaUAJBF3AzeGpeVF0p5K6GH29J8mJfZ8haB93NUKEIFBmDmZf+NmJL4SRolJZKaCVC1hyRHn9pFkQVcrkbt2guUW8VG4BPqcrEA+lpgfG/dOkLbMaw8MgZpI64mfNm6KCz6fxU7FD5d9EWqmPNdPvJu+a6kIQn7Zp57/j2F5gGhv9D8by0uNHKkp3o+G0gQKBWCXW0ZMjrAP17JTMEA6bTiubBqDG+Aba+wyxXOWRlm/nrHkczKFF6irjpuSiuJuVKfYLIPJshqSdVGyVgKG8cJa93K7WI/iyThMqdbTZxXgiEXqop+wH1iMyOYmI8dvM8SgEbIUByZ7UORaGXcvLE7TSCQlGQvW/qoMGu2Ga4xpwK+iZDDgxnb/8kdk7jJhIL+Svcf9fHQPWRym7limC1Yr7r7aUlXc93xfAEXsr037kD5k32mR/9En7vPdPqi2yK/nvJVnJXUTg9Ti1Nv52gixNkSTkRxmiHiMLg6u7trPXlXbLmPJw/7r4bM1avnQGvLSKOIN5pC1ZNrz0YFJMtYv4Cqn6ok5QlAK4DCy/tY8Y0NoRJBaJi6pTFKG3iJxpJQMkvFx/UXYIleI8liTWBtloFkJXi8jiJiy2vXjBVeJ169UtL7pfKgXgu6kxuj0Afci/Qqh55IKEHahDVq4V1n74v+YGsabtZo9UETyKXOfG0PvhlXWqnvNVPIyWuLvzJrENQUiDmCS4fdw1bBMMYACa7sLpZtFQSVoAhvcTJsr0LAFXNC0wvSY2MR1quIPgcD3Mn8KmMbR2C/hEa527NXt4OLvK9CcmnXS36H9I+mZh8+kp546mQ4dPEgin8F04viJZNyRlZWI/VGAmSeW6Oy5M+kCZ9QNDYxqgqIhlCokSshc/bLWpFH9KFqGcX13757l4NZF6JxWoG7cfgfLLH6SOXi3cPd9UaGrzgx5LhLP/v/svfdzpOd94PkgdTfQQCMDkyPJYRApKlISV8mSbdle19lbvtq6q9pfru4PuX/mqq7uB9/trtdeOelMSpRsiZKYxDCJw8mDQUYD6Ea6z+f74AV6ZoAZDEn7jgSeGXR6n/fJ7zcH913la1vFZ0IcSEsylNRdQtDUBn5vAzcOlrrTzDzaIBi5doI19JArqQx+dm3cL32s9PGcb/ShYaykgfI0eyp85eyYqgHY2qFvJnvl+OReXeODsr9X4OAE7O/9/8zOXl8LkUEHyQL9ZxHg10BQZsoW9KkuP4yN3UKjnH6BCdgahFwP0dZKSLUqgVCyJH0RJCmjcBIkVAYw2k5RgK1I1ZZIZlpHuoR6H0TaVsauHm/gWbRG2qEDcsNfQvbGtkSEttHAjErGp47ZXPhEAdxFAvPYUZvgMQIqoN0KEyruKIikou/iXY1XJGsNRpC5EcrW0M7BJNGRvTnfFeWh9E1mpkD6xf07vTsOgw8ohRfNryARzKPeqfan95v9GgTBuW6tMx8kWESSu63BJxoB7Rutyb1UuvtJi+Pu5OyREYSIcBA0m/tdtOt69kMSTTFDAzkURYIHFMxXx2ArDxZ/9f4axNcUxKZaJH0fbvN+F4QuoYYFF2Qh9fjMYxAEhOyPa2u7Hdwn2dEfBFz8GC9eN7S2p9B9n+XMz9KmT4+EnW1KWqmt0sxU7VgT4rbatU5UwZV0lHMoqTVHn/P8DfA86Me0+2xorCjUD6FB7HF+XotLj/OuFsqUsxX+TGab5/w4LTy6biewQX/GXkP404+pBPRRqPC8GLlRhtQ9WcAcaBGhR7W9En9GJVQjMUtkLv35HFsV85/D3Zj99m2ka3M4vS/0pOXSCkw1qaUwwStVcTqH6NaUSkFFJ+dJotkAJbdXya1GvwXZ7/P+/9eyCuO9xnkrYd5U654lcAKSeOboeZFByCVPwFDcneWVSODq7ztpjSSXhRIF47wsnIQw9vmxFf2DKtiDBXOUG4/fNz/u+mabOQw2zwJL676GUAs43c7euv4BWFtaYBrclZmndvGDDx2bHZoWL1Ikvj2TalAMbJKtBfK1eJUJVttV/BSLA1wHjmyEyS0zk1nimbIEo8ZEhclqo9QELRPsxiAHaoy8rmCwk+ikRpYrg4e6aV8BmX6xwTzZEP14gtRMF+fIn83PpOBFvGSwA9dx/Mlj6c7spfRXr/4dCcZPk7T7iTQyNJL6YJQsk3fJaTc1lS5cOp/euXI+rZ7qS22HOM+0Qwg5gicICYAtMCxqD93DCvDBcNuTBOsx5YbX1dAsYf7mmEswME0Gq47MvZH5lWlVk9VEcBiMDfViPZyDE4PZ8XexhXuxYsoOzPF6MM2rkf5jnjQVjfmlVOplR1gbi4KVBsFCNAE9VJtNNQWcjC22AXiJki6t47OsT/Mq0WxWWfMq0fhyv9HEwcs+XIF8evbhxA+m/NlegX6A7BQSnk5VQJtFB/JRkJT4SzOxOaKiNXG0HAYB9SAhasBMKZUyJ4PRtmQmRLw6QIu4ekGQgt0stxcWb6TFxUXMCzA/gDjUxGIdhDSP6n8ZwN4Dgh4E+5SQetUZRxgpiCAB5FP4SUw3YapAbfpT2FZBwkYEIQJMWEQiziC/ihC3i/NgFABsRwQCsR3+mWtCEwt9eGQsdGQ3f0NIJ7kjso0ztta2tlu1r8wcRRQxPud6u9VuvfOTfXb+rn9JB4yWEnMCGToQnZINzSvy+7SKRNVUA2MyCP+xsmzNJ2s71o821PLczxw5ZldSwkajwdYSpJ0EWNRovfLg5wqEk6Z2mpRJdNunrclkqHWMXeRzFJtsKdYdgpCTcW+dqXfJjMtYqKGwnsXf1VZlOb60X35O7NdnQ5pkkjMWdflsbK4ZmANHdq6tF7+9PkxLc0+2tVMJ5puLMvuoSXaqsqffZKsljv0rxr+nG/dQyTH24At1iJwsw+uY+MysYsaDIKNvMM2XGjCtBBuYXEyz07ORc+zwyFhaITls5yJE6J16RMysDdXSCNLrSxgB6j90oouw+/OcBIjQ4/0p/QpibHGlmk73EvmxPpcq9Y401I92ifD4feRumYIAVRhz6ORgWsA0DS9KnntgEvtQwKU9TGXPVVzD3fZsz41I5HNmlL53488pgy7hv1vxyeBh3O0yV7OpWhlBj35rMghqZPxncZ80zfQMPE4pmCNhjDCggl/KvDCVtRWGLtKcwqUu5pEP1/YY7cl9QFESRcJZ4pzHCSKan/hzdD4rOUDCI1bVm4BzMQOYrXU0tWzy/d3mzmxTEzDwjKbd+tS6aWqnKgjrugk2pEmsbSlA0KTOL4XWS419DDDGp1khGmHOpr6u+uVaKuC1Cu0ee+mpdOPSjfTzd99Pb1+/mE4OEeH1xJOhYfrwo8uE6Z5O60OktPjmyVQerwVscj9NEu2+hNkfZm0KEdWG+pRqbj5HUB6vm2h8eQHIgn/PfEc9jfCsBZ4VzoCzDf6zjNlguQlj5RnZXMaYC75MXTA8+phthB8x8+K/ayKTZ+LcGvDIscw1CPDD+qwh3JF5dQlm6gPsFVE0S9lqgtZjWRAp+Sl3BV5dw9+sHbNfmd2oE1cPXvbjChwwSPtx1z/rcwZo1ojKNV0Vegr8KXzsAUP1gGQ0h56rLwTBIh7SfnwQ1He7C3MKgHZGGJgvQGAugXgsItsBiKOtwo0SNXXaUbpWJjFdJ9qn2wDpFUwKyA6U+gHSvTAvKwD7IZiudhCM/iI3cSC/0JiPELu9nRVCiQJ06asAtvm9+LbVY8ykIGmVnEoQ6LiaTbeY5yYz6LUwyQvZYK5XgHJbNeHhBqHKtzrc7iI+GT5WQlAi2f5kIP4tikjcXFWO1Z2Lwgf7zwQQ6wQTswqjKquqyWMxr6L6475LwMytLqaZlbkgGHrYj36cP7b6f8wGvU/tij49VRH1Li1JDiy6Ga0d8Znjyb7cf+HBQYiyR5CIiqxvcarCtMRbo2p+ffCu/ItXXeG8yvfWXeEsqpW6v2zXkhGHEKSOYfQdfm6PD3zxTM7hszBLwkWZ8t8igZ7HNOVJngiz22cy6f7W8/cwXeHjffzczpV3+NVxKK2+g0bHjCafRtk+i3mjRrv609FGLX30zoX081d+msYOj6Xv/OkfpOOEyP/o7fPptZ+8AhMznbqABy9/5+X0xS99Mf3sX15Lv/6XXwWxOTY2kl764bfTsZND6UaTelDUr/3dq+nKxQ/TH/+P/z69cGYUAQcM6K3Z9Ff/51+mkeGB9P0f/CBdvnQpjY6ORgLnOxO308vj9FkbIl9b9rVsEkzjLmu+YGivzUO129l7nHUpiOgw6dvhXOylLcl6AzM4rBJBFhTjfKLCRhOYO54zDN/Cd0RzONMXCPssrZqjvfTlPgt/ZI5ykb2X+ccUDsJcYjoSiEMgqykMnyT6sj979FW/vXvK5ncFUgoeNB8T1wjLHlVkCuCKYAr8y8wBQ2FiMBGYsgkiomc4LjWKJmMNKwKqhJCBCgr5amg9SsDLwvzMp76bSHIyJlkQlMdvfwo2ZFZkBmW2ZTIct9HyKpiI8xOME9of8s/1f+U4pmspfXh9Ll1462eRCHnk1Fg684MvpHpvOxpStE626djcb+C241xZJrQEDIuhvoUcTSYlnJChrDBO88ctaR7IfJZJ4rpU6Q4mbxHtoMl8Y9YACPO19YuP/Yk/Z6GgMDhScTgMcqwDYzZp7gpMlUV8NgCTtNTGOPitC7yshnBjHc0S4eQP9xG4gbYt+TU+RrP20XC8aLC0NDA8+UHZ3ytwcAL29/5/ZmffBUDVtJ3gSaEx0oY6zS2nWQItCPlyvoU8PVmo0a5KustpF1H6bxlEsAxi0ozIZJ2jOAMcwjZZQV5RBPidBHaogLDaq0h3YY64NfLR1EAufQB5VfESjarrLRXGtYGtuPl/qhBR/fxNkchOqaSIRCB8v9reLrGWJkR5FcJbohsEQe0rBGxYRlukWFJY3Sozz8Bd7JHnFB82X0TkksB6OUU9XkSc4JVgOoz8I/J0HCJTfaMCybU28il/lujOktsW5mizD+fqyrgOInLHY+4cTQCVhrZKQB9nWDQFI7mcpmCObFfH2xk0SZXuB7VYe23XMWqGOcS4dtIeeV3iQ22iiNnvW4UvmmbtpVhNQrPkJPZ4T9FuvtfTsn2jnzwtajfVSu1W3J0ww+PZsGy34Bky9PsKyWgXg+ixBzVP761NE5hiNT1NTrFhTG3c6wd64AcZJLWi6xD7j0vgOhbX8xqBTC5uzGKuY06aT1bCF47n1rOhv48kpeZXS3MLaXpyKs3N11NXZRY4wxXMbt7+7ZsQr13pf/5f/lN67ZXX0ntvvp368KO4+O576cwTp9MLMEt/81/+Jr3/5nvpmeMvcW7NAYS2bWY2vfnrN9ITz55LL589jl9Se/rNxd+mN17/dTBYBo45dOJYqvX2pUsXLvq4E+2waubf9OGHl9GCN9PoUZJZjx5KVzumw2/E58VoZRK7n6TIDPR3kMOMdhbWcXUHnj0uLNBETh+OdmwPS52IiD7pxjB/xxARzJicRG83GvHQPmC6qBmWHkEcs8coNMrANIsT7rl+MoX6/vjXoTkqJgj678jglOEOhEiaovnceJ/3tBavCEfjEXXMfqBNi0O7t3b8HD/KkKm5iXf6hmeAQcu+tF0VzKM13QZYh0UA0r54p90OtDwdIIIOfJRkjgaB3eYTW+CMxarQoRDTazHXzRE49mUCGCxrmu2VWDfmzzgMXGBy7lL0pzkfJncwORyI1EXwodrXTiUe77RxpTcdeQpmgwAjMqo9nG2Za5Vt4j/0p2kRH90Ijc18Yk1gOmcZmwEoXAs1+GpCiyAUMofzJCWvoAFTI7jGGhgenyPJWJupv6uH3FZ4mUX6DPdKZpJxa76niZ2N8myWYBJNsLuGqZ0wKnupbepb6aMdjdLCiknKO1J/hcTCLZvjOK0ZVh2MTRijKb0McxnG66Ds7xU4YJD29/5/ZmdveNNOAOtat0AMqdQCARTIyN0EmPaBsNVTtOofhrBNrhBdSWQrqlNSVkPifQ6i7gjaFs3rJCg3WYqA8Cayq/X2piaM0W2elHWI9g4QZg3k4V8gOABwMDwAWs0LjDJ0k7xDHZgCjJWr4S8hOu4DAXykbwKIsaRTqxIw/jn6PkZ7hhDHT5AwpTu0EtmXwUR/M/ghKG3rImLPXovtmllIYwsJKAkKA0b04SvRzTrIHhXzrChRZRD/2kySyFSCWpy2VQI5KbHLxHjxu/hL4sXw5JG8FaJAvyUJ2MDtRUXfXXf+iaQzWZJf3UuR3l3yKTU1IwErSuBIAMySX2mkbPDpB1prbfmBz47dUZhgtQonfc9cWmoTzyDMdRzRpn4zetJpewnpJfg3stjvdr9NeW8dUyU85yCQHlbT2vcWa2vWuaqkVWp7s8icaUaUST8rcc3rmrIEJshzCmFDcVPrO9WiOfamWDt+ivY+Wp+DaWmmZzsGCVWu745nrLXYj/+ZGURO7q/1+sM/u8d3zJe0TqYumDT7/STFkyTDrlS7IJbtwzwy/cdH0h+c/uNwfL929VqY+izPk7x5cSmNjh9KR0+dTIc/vApj9D6BW5ZSX62GNLyZ7tyZxLyHQC89aigdIS0y1VqtL9WGBtKdGzfTGqZ4XVy/efVm6u7pTsPDw2luejr99rdvpJOnTwYs0YxoaXYh/fKXv04fXr4cjOXA8FD63h/8IJ0jmfOd5kxoP6bIZzYDrHHcH6cUa6Dmrw1pvQml50nYO08KgAbMVy73tu1RKZ6z+MR3zenMgdQFk1xGS7/9nOc1sN7jjNG6wi2f+TCnohlbgkUCruqnAkMjZf4Yp8DnqYGGR7OvTpg5qWs1ELZryOgOYTIwwu8yFEstjKe/7VhYmhzUxt3WLFVfoByoR9NUZ31PoSEDMjTxr9FnxufatmWKumC829DkxKwyBxNChA0iFGg6xiCpyUmVkWJdBvFtE6dNAc/UKjoTfZB2EiY1MG9bQGCn4KPDSHzsl3OUMe/ivEZgCVpXe6KfV0Rw47v4TdyzegeTOkxJ1yowddzLaBlnXn/Hr7EjrnRobTTS9RfGyfw3wGVqm/3N597VEFe2Owbwt581gZ+Hsar1VNMKOHFdO3l8iJfQLs2szfGMGAqHvphzhZQC9htMDLA9zpTToUY3r4sIbhTCKJxqYx9KnBV9hL13gQTFPQRl6ib6ZgyEsVjEEYXfsGfEkRqIosnYWkBn1D142X8rwPE6KAcr8NlaAUFwD1qdAQiJqyAyTQWU1K6RX0QH2QrXB6EGDdhgBByjc5VAQJqWgV8An1lj80LHUDqLpFZ6TWAbALdlKQTGy0jrLhNUQdO5AepVAZ6DmD6pOTJRbBSQjSYOmhbo07SA3fyhSl861t4LIY3D90ZPKoHk2gDe70F4BJgXCdLeUfo/11ZL4+3E/OX7ptwLlNOWTnfU0oX2SfLWELq0yaO6Rx5JVKTz+CqmTw3WZXtemI9ADIUqifYtXquwLuCYf1UmSXO5bcIpuo4XVhGEp/T+weJv2smbo0NtksySBEARLlpCSUKkQTQj939bKwFrCCHkGtQhDiR8iuLaNCEqnHdB5BfXHvVetOJ9niFJFrZsq3jd75rXeQZCwrl1NZ87gyKUGc8Id3dxbqyf2y3uluEggAKM1C3mtwAp/LjjtE39jO6y4sOsl8+Avxl2vDVoBJwpfjbmE6Jvgo5s8Iw8zD/IcUgWFSOOj5vfbP9O5DBZCybpNGYu9zBJzFmnck2FsuTd1dt7mWSP30NzNBFP4t7v262m51FfOM+k/wrCUnPMC5zHE0Tu80xJSLozDRy/m4T399lpsofraEs01+3rrZEfZiC98tNX05tvvJGGhobSseNHIT65S8BCoYl08tSJaOvy+Uvklamk5lI9nTh1HFMkCGr60c/RkMS23wVxd/H9C+nC+fPpC88/nwYGBtMv/uXn6cOLl9LzJ1+iCiQpbXajCa6j+ciJpR3l4xUJVJ6oIFS90+drADjUjllfvQ5BvUNzKlryH0yR0UIYr2oEV6kb5qifKIclhDmAupivRHn8g9r0ec1k8g4N3/eTwRMk4Htid5xbZt6FIplgvu+GR3y1BQlr4Q1YIGr3wmB0IPxyVBFSG8bb8Slssf7DCxvg9m4yFPqHdiNQM9DG0ua+P3C/a8D5j/Mmk0BxjmolfY/2IOpbi3U3MLsL2EYfrqV9DLDGDQ7WAmGp1Qgr4HP/4tn0wG3CvBWuL5iWAmbHSbVxdhXeqaEqYQ6oNYFmge6XfkkWr+UCo0o0lvU5YO8ZNLbMz+cG2eA9xTEZfU/f0SbjD02PY+DPdbE1mRgZwi7HhX9So4NnSQaMjuv4+fZg4VEGPth0k6h6MpIz5DGskuyVMBHgUc2u8R9Gi9bkTN3BKiAYm9grfbEwZe8nQArCL031GE1eT66vQRE0V6v4+s2iMQsdWozfPTdEeCEwcpwGynDcEUq9tNfTGs0dvHwOVyA/pZ/DiR1M6fO7AvA7qdlLklFIvgWkgj0gi7Y+/GqQI8kM6eg5CdM0D0LsAx6OgMBvIhk1gaembCLYkx3VdIo7NIsQKEsI+aFADkrPljCVu9CNIy8ISofRBiYoR9dM8gkARVvUWiLhHT+sg2yMfnUGzdQIQL2dhHNG9RFLPNs+AGJYj7Fotz6OSd/X2keQvhlswVHkEoCaPiSwI8kd75oMPk4RtBsiVgRblDqhzBWLjZYGws6+6NF3o3UZnivCsLoWn2LR2bUgQDexVrQuKZJD0u7emaN3NJoTaUairbz7t4DZYj1MgviVfRap3VuKO7fnX3xy5+6vfe+9u38Tyc8wjn6IiD6Y39xmXmXZLv177kCyLMd4ih6321uG+L7Nz+53D3vhGnB6Qf3MinWSWJvl+i0IGeu27t92K4/+pBT1Bk7oyMzTGOd/jfHeoc0Fxh6jkhBY5HxMLaV2npUNCPWNXnwDiPwEFbIro+R4HGde72hpazBem0eL9Lv1aYW26RS6toJJkhjvgIhah/iXqJTB2GZot5q454OtS7LO8Iy/j+boFs+7y3pvr/fcsqcvxd5n3758S/7N/UDLyFnTjKgoXuuEoO1g7BJ0nayn5r2O4/bt2+n2xGR66VvfTE8+/VT66SuvposfXEzPnR5Go4BmBgJRE65Dh4/AGJXTBx+8H2tXq/WnHkzqzB/jurk+/hVlepb53rqN8zkRBPvVWQJX+nqZv092ZtqM4lZBeKMQ4XGLc1JDo2mT/cfM6b6NvanOQ2DOsfbhruNVCjcI99bVtHB2DPNO5PJEvAkvpV7CdfcSBKeXNZKF4SV+37w1iPxF4E9DgdbWFa/uXGxTba/nqMcQY5aW9ck/PP6rxz72HXhuREJNjEOjArCth2/dEvBExjg/o7mH7RFvf5K5yXsrcyGsVqDmO1vOGj04thzKG2YCRqAokdAWXGDxuVI7VDCVRR3AQIy5OB8ZtsvGwcjRIY9S9O2YHZ+tuVcy3nVM68IM0721H88Z12WyusE7Rmz0u4aVrgPbyndbABKB41anELAAEio1ZieDRh17ub94hzhN5su8Qi6g9auac9OnFhsyvTJxHTBaKzwLi3UCKXBtFRypFmmgRlx8zvsa5qz6YYUJHsEWhtFs9ggh6buDtB6DVXykMG29uTpLdLx5YBzCSeY6R6CfBZ6HNYRLoXnkWXF955ZrsS79JfDf5vDVHNUZj3DYn4piviV/0IKhATN7UPb3ChwwSPt7/z+zsz/fsRBmEENoFnQCXcV8bhhb+k6Q3mo5E4FzENDXkQg30d7cBAUYSlSgbSLZcySEFRIG0uf+AIwAS/M4CP6V6M6Ts2Se/AtKWf2thHN1DxoYbcK1ow5k4QWAfEiMaa+KBO3LAnTC3krMhEwSJKb9vNK0L6xj2oXJ2BK/PdXeDwlpqG0b2S5KBCfwP3qd/E06o4t8Pk7ZJG3uuXUOHy0TLh7qJiu6hLOIkH8iCj+JakWOn0YR8Uh+mcxRqW0rcWH79qlJUyuC2q1f60gYSGRJOM0jKVTax9JTfNmplQd/k4iwHecsKXfvytvWDoVKjt1/rhDy2HQJPdEIhJvsWiZuSbjI7ze1xWdO+gIYKvr+cTkiEfo16poYeJEz2gvRYNAP35WO1jknHfjyPDj6Hca2y0/e635O0NtyEClEceIXms/0DQ7MHbNktIcg4aGIXCJtUxDaRJiC0k3rfVBFVYhHrhUlnpVYg91XzTM3D4PxDsaBHK90ps2ZSYCzErQlUanZTv6haHnnd5m8K+TN+XB9nih6EUz4E61Jay9qLZUg6+x9f3HGzsP5Ok7XsUao415M6eYnp9NdzOOmbk9uMkw4dmNmNzxwMh0/dCT1VHrSEvlYFFT3kptFJYuNVMjJcurs6fTj//rX4Zz+p3/x52ni9p00c9dg8NSQcrfQp//6+/vTyZMn0vMvvoB/0xORlHNwdIjT5QkMHiUYnAoEfh3tWpjRxpW9vTg/NWjl0Dq03AODpDmuGsVmdXNtGJqR3lyPMMtqogmAue4kAEUTM6pufMqGYJAkfmPdWprzo0sgGe5Y9SGROHWOjyo+p5rFGYVMAU4s5aNu2rpetH/fXfyMvjn2VMGKDKz+NJrdlYDtVTgERyeUiFEyZ/ffuWdhGpBDfGENCHFNKtcRyCk44ecAn66BvcYINrv3mkR8PH9ci8I1E38HEAOQqTl0jWQiPZ95BrbLYVKw4A/Uo6sQGAl3xGcBv6kvAxbMH20aHt68SQZa8cYIi82z1wnuqTBm911fwTw8dwctFObpK+znCqHaTZiKxVpqX8QM9QgMB+Zt9pvN7zYnlWcRrzFW8GwwefSj2WLARWCAYccNDhHrzTh7mEsfZqbmFjTZrGfBHINVojia8HcFYYRrzADTMKbQPkedCKOazGcFTa7r2FvtJe1AX5olGNIsjO0ylgIz5GVaMp8h+MY8SvFs00ZzhUAQJCzuZF6u/yrPWjBHsWHbk3AdxSnO0+L6be5ifD942X8rcMAg7b89/1zMuAIQ7tGYDmgmMB3YAIhK8INMenRclTEyFDF+HLdIiqnNugRxP6j2ifa+VMZORAQs8pM5WgOAi6BEQNqIq/aXTuiinnblnTBHI7TALQH49X9qU3RHf21KYUU2/EkSe6NAX18O6R4l5+0Qqav4J3WDmJ5rG4BobSOZKMycDbYUEe2t1YX0q+U7aQICuoU+jVoZNdk+42i5L7dyb1stl7c+ihM0XSiDiPswa9BETSODQPD3tbl102N+cFxKU020p327zFGBioumrBOEx33zL67v/C5DBXJDKirB4no/bol9AUmvoCE05PiOCJBlLFZSCa3nRFmjRKjEnftK0HByExmxK89VEkNGXSLKUW3AJNiKpoGbngV83y5KdUHn5MhaIiR8Xh3b8N6+zh5MLiUIbf2TFd0X9FhxQrFaHkicmdunkd7W+b31gMnAYHaXppC0mlsESW8bOXwKisF1MCdQZmqjtR0H55V5CNv3NmZY4450gie1CNyg9k+ToTyYHW+PS2rjPiSZ6m/X7vIcI5Dg19173Lmd3X61HefiHkh478Qo21u1Wk39A2h5GO9GpSOdPHMyvf7zX6b/9n//57SAv+MLL7yQvvjiF8kNcze99fbv0tVr19Pc7Fx68etfCgf3NtagjHZbH6Qu4MVpGKSjR4/izL4Es3QKCTr+QwRgMAhMrR//Q4hGN0rznqfOPZUmpibTe++8m+7ASJUxw3rmxReRvvem+ZmZiLBZRpJe6eYZ44ytsi8PXdT7FsMIXb34JGoy5TOxVXim2Pm0io9I18r2iheR0wLOQa+rQVrXPIz6JjHNjNZ2/a32Nj/YgwaNjlXte0H+31+v9butGXDGiJ0y17snct2+y7nIXLgWnrUQgQgnNo+cuem8Jmy3fQn+Os94FypBmQrvz0+derDNSv5qZQpPB39oQzg7BlUzomkwIYwznhP7ibrROi3IWCDAa3KiefZC+6omh6I/VRdwWCbJezwr+sWJLzTZjiASAVOEz1njanuaDwtlbMX7JOzrmNGFkA+etg0co0ndGlpQ67ej1emQOWK/hMdGaMsj8PEXp7Ev/G5dhpIaMIor7Y3UWKQeILJ7kElxg7hVcaEzu79oErdCf/o+hskgTFiwXSzYIteE9d6nFklYUEEQWUMjaiqOMGeD2V6E+RniN6PROh8FikfKQ9QzuStWAzwv+ixp2j5HstomQSdm5mbxwUKUwtpuaCJJX5rAtuMTt8EzZ16rLhmjmDB7zEYuMgbXtih5Psye/Ywx84PnwLG6rTtOuLj54P1zvQIHDNLnens/v5MTmAvEAsxBBdaW+IYNfMLxWZOMckjgKyC/HNZUwI1hGRLtnjREXiQJJIsAESyFxJd3kIgOmgJiAaPy0w4IRaNODUJMGNY7JFv8LqGgZBNVks1sldyqI6MAtJVYdRKVSNMckwBqhjAAQSHAL8YQN1PPtptI7j4kMMMEhHMQk5gF2pf3Ccg1wdBMXe1Pa5FwfyAMbWuF4jMTE9FNNmZoZACpIZH7+O5YbP+TFseslLIMkpcxCoSzQ6OuTzZ2FMHvrXgPcshgktz/j18ycbHT/TJeypf9M0qdZJK7uYSEUiLJMdhz0btjD2TrBUqxK66nploynj0SQVt3SEeBfO0Dws/1aZ2LzZjnqo6pSA0z0M2TFG1/3JdirGx02lhCWEAun/Z5CMWtC0XL/MChX+c5QOSKylTiaXNivGkOuQAh7phax1zc3fru9VmI0XdWJ9F0bKTDzMW5aj6k9lXJ98OKcRVv8gwUzNHD6n6ca85Khldzqg798rZKhisKDZ564RnMfc7CsZbSLYJ9HH/xXOomx9Hl8x+mpw+NpZPPPJE2apX0rR99N10mLPj09Ex6/qUvpdHTR9BcE2mP/R3qqqYvf+MrzBsfnaG+9P0/+xFEHEKc4b505rknobDX8DEaSF/q/Sr+TNUgbBv4Io0dP5z+cPiP0jtv/S7NzM6ks+fOpO6R4fTO2x+kmWsfQfixPcP4VTxzHFO9EmfNNNWbe7U1l50/aO7a396N+ZPphPN8relWryD0mR/uTPM1pfit7d27XxvMx3wzeI7wrEtGPHCYduyc2x6rWF1GFvDOmSFMAwRvcAU7tGLEObUvRuLzjBqARq2WZ812YjY8A2rBivPr78GMsCf3l52ePVdByBY+bGhcFnlOV2Fyhd0yQPwPGOC9moi516sNCHKEY1onKFgzUATyNhgdghtgjp3Nj70vL46MpOaPaoMybM7maa6dz47XeIv5uOcbaOXCJJT90rRMe4dYZ170+4vId9ygr6lw2RJrES/ue/7gmGVekSmm0ip4gQTr5VHMLWHCHZNn+J4jES3lxmRa4l580NqN/gY+FXbKEJbp2zxPxflchonp4uwMV2tprIQlR2M9XZ67GT54K90kXdZknoU0ouSJ6mhE2XO/qggQbM8kssLmJUyIMYg0pgNafRhQcKK9xt4yBxlGDDnQmBF0ZA0fJZ935hcm2cXYeQ+c6tKzrrGP1InExHJMB2Vfr8ABg7Svt/+zPXmJU5HLCL7NQ0sAdpyfJwGQ3SCrUbQzx2EAdJafwwSlgc3L2FIX/j5AU8wFCkgfjI6IKbgOgG8DkAuwl+9RyLQBASP7INrRwVUJlfcGkgVY71biiuI42tasxFCnDA0YDPgWYRSYBtyUkVxGMCLZkbZu+pvlXi6CzCP0K8SqyEEbfyVrFtGaAF1fFfNR7KWIBCVvDd4wu75AfigCSOCYfRetUm51L63cW8dZKqs1z0hEnopvEl55jPfW3v4WqwNSAsNv//iwT6yZUsrcaqzww2o/cM3xiDyVYGoCcn+RUHCvlyDsi8h6bXxmZ4JhkuFTH3R/2WkkrqUEgmYegbDvu0nToTA54er9RaJ9HlMR/SPs81Mpno8FzEwm0BwtcxZbu2U91kuMmIAkUC5pHYKIcGRxVmMTHQD1lYTnc9t68+6js9YUWrY3NqYgmFI6RP4pGqDdR580QwQgL95x7Xbvce9XHJvPjloDNZ3K1PP58PcNfBgX0vAI8SUxlzXh8wxwQU1y/1Oj6QvPHAkN5K3V+dS2tJDGYXBe/N5L8VzOkwD66uIk0cUW4phOtC2kkSN9QYSfX7md2obtuSNNNG+kLhJuliEC54luiag8ogAKj/pInqlnRRVm7KXvfZPziKM9MOw6GqU7E7fSsepAOnnkcHr36qW0ME2C2cFR2sD0lDO101lrXRVhRx8pDXrZC8UXQgOLr00YeqPizeFAr8/avYfEWttFMtScZmqiHuhT2MY8Wovf1BrJvHCKWi898rPtq+luxxIAi+dgknLzm8wd/Un8GnlPv0u1XWp5V1g3GST//OeYuiTe7x3aI/u/v0KxZvoNGq/R6G3C7VhJ2g7LAczHmphoa04qXCmVyqm7m9rAcQVZYTZH3Qwn7GF7UKENYb6akknkG9itnXU2OmYkyN1c2wZw09xNajhdo0LL5fJbxFEG9CiBc2QW9TeyeN1dUMjmCsb+8ZvMXMMIe8CfjXnWjbx+pWFwH2308iejNUOdVtzlyQmBT+yrASD0OoS50/yQ7pyVgSD8EiHk6VwY24ZlxsnKWDrVO56Ih5Jeoebv5q4zZ8xL0dYOdfVhMj+QBoCBLqyr24kmrIy21W+OGSPCmIOR93R7qmBFUgZ3bq8keNebqWeYb/hU5sDZ267Ax+w3p6ml+7nOuVej1YZATNPVg7K/V+BBbL+/1+Ng9p+RFTAkaQOkdAagOCADgvZIbweMkTOvA+gzYMMQ2qRBkINJ42YXZtIiQL+fKDq7FZFredMPyUANFewolpEoIZrjFsC0EiglYAD6dggmmZ3dSiAt6qvdiQJi03zCYmsCYu2cjW5n+FYJCK1aNCmxltIuickSWrEOJXP+20SO0rtKVvV3kdCWDM/oLiMT+9ixMO6tEWvXDQqRdNn6bcebdv8xpJ1IUn2XCLGdvFK731NcKcYM3tpD/6wN66SkNBB60chjvDs2IzbVMGGT8RDpbhU+uv6LEFUyR3k9RLAErsD5VydjJbASHY57t+IV90lzTc2OdmJwrBNml9S7ZwwtjcqkeQ5qMK+71Wmp/uiPmM51TCN5RYPEIcr1efPcbRCUYX2QQLk9MEWeL6/HJrasD3d4vhRIeO72smN24l5NQqD8ZmM6fYnbDkPAPEx75MgkdhaYf51+/P6vVZydZpEl+rlXi0T/RECcNxQxdawnabm40kjXGpNBrHfjX3amPJoG6l1p5tYdGJqJMJUr1fCjkLBk5yXa1bjN488oUem6mfBUjWMIRfgtPtGBWoXcS0pnK+NwlvU0tbSaqocG0mxpJS2igdiorKeRo/1p9sOJ9NZ7MxGEZhziUwbAs6ZvzcMLhDLjrsEcGdGz9VzJTEzD1BmW2TE97BnzHBjgwBxKeX9coVwk7i2ZFOfDFrwyIEvO27RdO6ru6cV+jLK2BoHrc6imxNPlHBQo+HwqyBAea/KMuiOYFonyLATzmcwajb2e3UcNzL7DikCfOj5b1EYtwrSoBXTqJQj6imG86dsgCZqnrrDv1neN8115rDJNmuiugau0ZMg+RZhtg6+qtBH5f7jTtRWnNGCe/KaZ4zrCu9wso/IDfWu6p4mr+5RzI9ErlxT5rIBbKlhFFPustmsJs3J9grTWbC5jgkkQjgpCk14Yox7aaHBv65lxq8WXWkeYSsFrAT/cLK7Jj4ldZPI21OYwvwYR6tQune0/kZ6rHA+h2hpjf656kvO+gPk0TG13Hvcg5qQGOsklt+3+dvF8CT9Ng7FWwTxSX1D+nHMU+vYZa7CG7j81GYTRS/UL3TZqpxrPDivAn2da4UGYSLtmtLeNBzbbPXjbdytwwCDtuy3/7E9YwHaLXB3A1VRuVtIi+Ul02lzHHI3sjpi04ZuEtE5EEQAdALiEZKwZCAXJkwAbjZGuEAUiF3GoHdKUrRukZh/C2wHEdtcgPLLck1+0maOsAHwlb0XUgWS8JLCNq7TFUAwFHshq8zeRqQS22p5VGCP9nJaQMi4zkGXM+KYB3oZnvr1MCFMING3Guwhr2g5z5GgkTh2n5l8yRQ2QmmSCEX5kDntkBEFJCyCEWYmRIHQ2O299Y5yaXqxifqjEu2BsWqs87LOjUeLetakxkgnwN1cmr87D7r73mqYqD4vC5Yoq6V6FOFogwERBgN3byt6+KU3tI/lgraS5VwtzwqDVEy67z0ihiz3MxIRaBgnGTJRImHSyzq2EQtG7SFazGU2OXBO/77gerH8PJqCaOMnwSdi5cq117W/zqBXNf/x3J+LZX4aApu8onMV1JLUb/RXMxJDKojnSrCVK8Z6/bb26V2oI8d3eWqOtiw/54B7OwmR+QJDxEUw6eTrvmev9t7oetzGekSB2Df+1ii0rzXZ/OxGAtPYV67/ZcTECz7zSdL101Cb1rHalN1/9VXrzN2+k/qF+YAGE31NPpi9gZtczMMp5xY+CJdV612dWWKAGQCLZP30l5tDYaLrU30Z8TaTqEoBjXf3pg3d/k25fvZ6+8sNvpdqh0ZDCq1HTfO8uTO3EjenUWRnmrxYmUVWIXU069b+R+cpjzq8BBRlHD8/rEKaOJl21uNvWcObWLqoAAEAASURBVH+CoARmWHcbihX7bK18Pg3wou+e2qNC62Yj3uP6Saib7mCNOZmgU4CFPjYY0ezjQ1Mfuygk8UlFmyQstB3aZ2UdQvwVTQvHGRBWogQl4FmTITRQwdb5Lyp+Cu9qjAT4MkcNGTPguaaYaqoNf+1ANRUVHzhO18kkwmEqx7UVcIHh7123dRkj26N0wAhU0ORqQaBgTG0mKxDM4BLr4BrI8Ko5qiNVWDZYB/d20IbR5NQYqeErmCOZdLVOMg1q+7M4yxExPjSkTeCDPpcri2i+YRC6hzpTjciENdqQf5d5yIset4gww9oi9hjcqWQyzhKm5CXW2v4dz4LaGJIvR1oMYItnbamCpQb3+Myoma6xRy92n0xvrn3EeW6PaKAlgjM4udCkub4wRNm6g34YSx9RYEvgX9uLM8tvwaxRV7waKS74TSjc2eF3tHhd+urFyYlJZK1aXoNVhaGG2uce/nNuMhO+OduDt324AgcM0j7c9M/8lAFek0S96QYmLy8iyQQZdMHUNMgA3sAevIRGoyiCwjUcZDWdA8cEYdLADOM2ZnZDGCgPQJQI+JVuqdEpGBpNo0xoV4HCWYe4k8hpgDxKYqPNooRvhbZ0+LcUWiDQGQAZBI5mC+gcTJedi+QE8NpQ+1dHKnwNcvPySh3JMnXJydEk5OkGfzq6dqDJagdBCfztVcJxQaREXRHLIYiiYQirMUjOAc1dQLoiQc1z3idx52VM6MKXJgbnAPOHNog8nXb9auhvJcp7LY6jhDRRCXpmAXKztuU110+CxVHn//66W1Fqt9O13JoEmOYZYQ5IVD8JjNzLTvc86jcjDJbSYAlWkvm3mokoMTcyXTPaL9pxDEr9C9ZYNOtvEi++bxfIrmCIumg/pzW07v21tuv7yQhig2iy5pH7K9HVvElEn+/KTKFE3adSGEyY1cn4sN4bEC4bNbRGQ2inutUC8OMuTFFr/9Z7XGa6uN+ZTUPA3WalT8HO57Usrm6/u26LCDqmFGP/G5XQ5jAi52f/uxUFIAaCyU8jhC3P8t2JiTRMdLk/+OMfRXjv1//lV6mbuMjf+M630rUbM2kWv6RewhcfP3YkpO2zRMFbIrzxEoTYwEAtHR87GsTY0p25NEu48B78kIZOZNPKOYQ9ty5eTY3JhTQ6OpZGRquEYUcL99zpNHLmVJq4jjmUyjwGXcUUSYI5nyMIQvY4AiJwpmZhwhz14a5BzlxfEMwS7CaHdk4+y1WSZcu8zfCcqUXSpM1Q0L34KvkMKhiom58GDU6N32r4zujs75FV8q7wRpZJLchCW5P9M6ZjZo70qRN2FetWrK9RQGPFd4QBRa17363qHmXz1Hxtt9ttXRPGMiNznp92sX1hnQS+CUllWnIgBhhduvORkrh3vPbuHqhpd52EbW0wAobEXoGYb4K7AvdQUSbcJOXitE4FZDTm+IUH+gEug49WaLwKky4s89o6fjvCrw3+xEZtBJ0ogwfdF4s4TsbIPIHBbMWa5Gua1sli6N+0SojtNXBq9yCMUV8HZm5qlcGzzG2ZiTiXrcKc25lfk7ZXgZOhhZVBY27dwEID6rg2MqlNgr2szSm+Y2w0eH7xZjq5MJYGiTzrmWmgORrGrO5c57E01wasZ9x9MIRN8HkT/K05rJ2HkIE10VT9yPpAmmxfSB+t3gE/678LHOdMNzBv3ILvjF1Bk1Hs6o3+tF6eY/55Fs7eTyZ3RwmZ1ghaU4Rid44Z1ee6fj8o+28FPiUMvP8W7mDG/9+ugBoAo8zMgXprSKWBnBEdKhxlAdJbBSBdX1qEMQEFiKUAtDfRRNwC+Rt6lFSuQEaQgszRJvhX+tghEBbxgzQEkfoADOFZ2wUwL5CtALYNKZ9BD7QFv0HOhqswPIcx++uH6Ojm/gqIogqiE1s6XoF9A4Q4D6K7jA/DeWKMKUHWx6kLotlkeat8Lyk1hEErzJEcg5Ju3x2RCV+/SA6lsU1psDN2/EoLh2CYXhR5Mo9L9KEja0w9ajAn/E1EIP4TZQXDFYtDI48oEkNKLUXwlmgFTOK4NI1a5sUIZlVDnZOhNBtI2PtuRbKhteQZ2k8Pbcg03MVBPkKu7mGM3l2U7XYllLBrJ2SstvhbyJOKrqhBktXktN7L8gRzKUEiIZRLnmfRvu9ekXDJ/kKZ6Wxtp7Vu62eNqyTyJGA0UJTYVAJtgxIDEj47haBubWPPn2HUNa0LDZFriGB0Hcd+w3i3cfbdxSi+0Xdm7Jm1OW+25r5J4EmQtfyWb3z0qy0t4wf4EZHpxgmUUuH83L9O1nE/6pyfBZ6Vf4viXNyDrFF8VI/WZpQOdLPoy9bb25tGR0bwN1lP77//fmpgUnf5vffTqz97Lc0SbUuY9L3vfDeicf347/4WWIRGBXjTS3S7f/8nf4wGfDn95Cc/ITgMfoA8t9/4+kuI9FfTnRu30nIwU8vp+PHj6ff/9EdpaKSC/xJtunowK9CVaB70cemAcUGLDFFcBSa0L0H0LhAYAPPJucpAMDH9y11p7tZMaNL7hgYilLh7vz4LPJqcg3lqT6NDI+lG10K6vjKF/0c1nd7AzmqaVAOYWs1X19Md4MkhHOuHmhCv80tpgCS54WOJUEdYd+PWjXT4+GhaJcnmNIyZx8sj1w5jGWPeXDcJ8rU19KycCcPVPG5p2YIHbnW9hdEyeLKaBby2IpCeKbvblD3AE6sVxbMpwe+ToG7BtQuNHY3RVfgChWYLAlz4UZRirGphuhFqhdaEMWrW5ojUFHXyPc4FbeonVepi5AYP8ibHyRm1Hc3zNC0TPspsWWQa1OoJ2+ZhRtvQYPldmOI9jnEJ/NTg3G3QXifXiqdYUz5NufUvIrRrasxxhZDnvSMwSOAfpzEPEzSJFgiMQr+bzwC/O7R17lvBmiNPF0aNKfWCO2uchUVw3TTMShkGqVZBay8c4s/ofSja0gK5CcfLg2jN8DGjnuZ6x9oH01QXZrjgwS4qmStJJrOXiJJlfIzdS7Ws7rFw6sjaQDrfuIk5rhYiaOL4rVj6vO/UZa1kkOaWCCGOZqwMg+nCWG+Je1ZwTiojj3FfnJ9r7dyikm8HZd+uwAGDtG+3/jM8cYBXL3bZywDw290b6Ti2xeYt2gDYa68tiAxpHFNU5a5JXcA9vi8hebrVZSS0ROLMdSSkzXQUhKHZlCp8hUsCZz83lkHwEM4dRHYyWlFXe3UrT5IA1nwhAmHD9ErIX6PRW+RluL0ya8rayGujk+k4iMmI4E2IHjVVyMfI7bKA9IucREQ1KuO4q316JPJDEtglMoQ49V9rKQC/gHsJkdd1iM0RiKFtlJCBvt/VYn2xbRjH+G4Sd86k24QMV4oo8lWC2AQpbECErve0h69Lr86wjyiORmagCwJjCQQ13eiEIWrDblwtHAEuQLT6GZQhjo6i3jPH08OK4xR5O69ipsrxZb6qSH41AlnCBHCZ9WslcnZuM69WEBSbC+WbzJDmUGOVwTBpK5gja8uQ6ACvc3frGub2NWZhjbi/GJ8kimZmebS5E03piuS1m93uPLwdfi32N+bMnuhHouS1CwLFBXFNHhzXDg097CcHxXPRtmTUurzKbRDU7bNoAwzhHZHqbICKnIk2wn+3h58SBO0IGiaitLGImz0wf86p56dYx80Lj36jayXbt8j7dKVtnjxkA3xjdjw3CiJy4VxCME7AssrUZ5Jw89Kn/OaMbF9zSLV5jqCY5W5duXre4591PZM+05cvXgiG59pH1wjjfSR98SsvpnnCDx8+ejgdOX40/fpXv07nL1xIT5w9i1aglF7+9nfQHvWn/+cnP4kw3ka/6x8eTP/xf/1PaeLmHdZ/NV259GHkQfr93/8hocNn069++as0x7VnR54kQTFO55jjrgPHJhfVfEO6k3BJP5chYNTEe9fSz175abp961b61u99O738e99J03fuplf+4e/TXd4121WL/N3vfQfmai29+uorMRfzOY1gzveF779EIu5+BCFdaeKDW+mv/ve/TCdOHk8/+p/+LPXURlM3z/trf/OP6Rc/++f0F3/xH9LY+Dhhl2cgQsvp1Z/+LH3nT36QjpwaSbU6Wn19Sno6icpZT7ebMGeK6lm9NWB2vdmT+ioEqNA0+lMoef8y4yFzUDyXNu01tcH69Sl8UMDkPu61+Bwuse4KubxNLYnmk8uYx2lGF6Gtw4Rvu8U8nqge/WtWF4wJ50bzQ82cZZJ8BmSsOmAYDdcOpCYggT6uwJrNZxZgHeZx4idDgfscqmmy2I8zkRlcBA53yiTru8OPi+CvJfZgBRgq1S9UVbNo/WyyZv9AIB8AAhut19G0E5hhtEYeLODjbfzuzGuWhTZrCL6yuWIxN/2HNO2TYdEqwcHIHI0i3LrL10kCkDQ4n4NEoKsODIU/k/hDreQ4jLZm2m2M1wh4msq7zidL46wPzxhwyn6n0GrKoHU3sJJgBiXud+0nlufTu/WP0p363dBwMoMoPpf67rovMmNtMGidpvqAGW80iLvYsx18wXDoG5zJEgzcaKmXM4/JseCXNYHXYvldmIOyX1fggEHarzv/GZ932FaDSGbBGA2A6cA6kjlDqEIMA2sB+DAOIBvtzvUpqsOYCNTnYAjWkYYKGJsA3Rv49/SDiPpBNmqOClO7BUz41hTPcs2Q3LqzapMcCWKjJSVTGbllO2kzc0NSIwkzUE6jB+IJgDyDucptzNiU1CutMxTtChK+OskVlRIqMRYRZudiALvAPfbG123yOIPpTJj5q7O5Ria/J9tqkejQuVkkXJXE8YH16EhHZOpo8x0Q5w2S60qKUCWQspKzLhy/V0Aea0jWlEo+rNiHpjIacayzXqbLuQkRtIxmrUzkq+5SPXVjW95TavBHdDz+sUK7Nqlpm0RLUawp4RFMAsjedZVwUJrnmB9auN5DpChNf+xThC1Bzp2MTYKB80Ajzp+LMSp9jhr0v73KXiyK5jBom+hbnwd5BIkuSZzW+jILrYRW3rWijd3f3WdYYbSFnAvG430xbj7b5qdWeD7aVO05ga3Cb4ucUxLFrg/lUOLtJP5sm+GcEv5bTZOS5g00EEgiXMIoSt/1Cwpzl81TutXkHj44K4OrXINoOopZZxVKhK8QM8XNmjRupJmtPfnk6+DQd2pFQlVC0T/PXOvqFKPZ+b21Js8YMGNwaDAdPnY43bl1O/WRs8WcRhcuXEwTmMwdOnI49UAcSjy6v+Y66iHXS5n3MlpiCVcd3GsDMPD83oP/ZBmhw220R4Y1rpGc1oSaJf0qKaYPHuC5qHl2eEQWgXErTWATivCYBMPrJlTy6Pgo/U9gzrcEMVpOt67cgGG6nb761a+l8UPj6W9+/Lfp/PvnIUwRFrEJf/SjPwqm7Ndv/CYduTGRqs+MxLlfRguwgKnfhffOp6lrd9LTX3ouXbv+ET5SH6SJOxOYLiO1B96EmRbyEAVSBK5ObRPL6dLrb6YZmL/R8bF0+ktPpzUEJzeb02wI+wyDtLpC4tjyIuv/6RSfQwUY+tHom6K/lJvvjikEWTYiJXN1H8Kfjus+h3sphg+XOdIYTTiieaW4QgZHZif7N+WWhA8Kz4rn2P7sRY14D36HakQiAAA/xrngGdDdReiicGQJE0W12jIzYJ9o1DloqQBrEOGvGUYwOF50PAJI00gYYKgMHrRDBUuLnC3NuiX4FQRUaLMLeO2YZJDiXuquLiB0m2b92KPBUcKXM9NZmCMZyjx6GUyCAjGvAeBpwFfWUtNkz1D4fElNAnSbnAF90DSt9DzIZAjjbGdeRo3UGWeqY/jOVuJeB2udYi+y9jwLxyYROL6zej3NAqtcjR7Wp4I5qMEVbuGre6s5leGn+4jwU+2Ye9GB8FR47W8heORMlDtZVRY6TDv5bokw6ODf8JkjHUc/Zs/usb5ahk2i1YOyj1fAI31QDlbgM7cCAi61BUp5FpHEHekczlm4IQbVGGm/3SSi3RpMUJZuQezCDC31ZPJ2BdX6EhKrScwK7hLQoRdwKBGps+wCklRtn+3DsKySTzUYiAz/QUQyWxKcIjaAqPjJJHdzaDuUhBllJ3K9QDyZy6KO+shIS2sgGxmYLoB3mWABOrKKIIPEpnvQrKPIhc61+1a6aBI/mRdxgES/tuQWI32ZK+YJmKRAQEGoqBliQNRtAxG2I4nExTs93zGYurF5/xDiVCluMAsgyFUQaHs5+y6Yr4c7dyj5V9d6DaRnjhqZlh4CS/RCoMmS9HQtgpzNYs6i0EoTp9tWRmKHRvlJu3ql9/pVQWhwRzcITsYhl2wy6AoxYqe0Y3F0SlQHyDnTT+SjTMDnqq63CC98M2jD4rgkkyLcrpu3QxFZ62WlmZsMkpJSzSAdSzEvx8MOBRHhzmmqFf4Du440d5TnkRkrmVfXtSh+9HrLT8Wlj/nOeCESYsNUm3qIKCG0x7RKsxfPQjsMEwcrZucArNWm0zjnWVpinedhhbO0iMZVdm7rnEZre3+RTJrmObiF9vQsZH4+0dutaRRUU0vJartvhbhg7z3k/c31MZlx7DHn7RWVyS2YI/dzryWfG9rfbMp1U0J99MSx9N0f/h7KuFK68Lv30Aq9R66kS8EcPPv8syEAkcnxWZZg9M97JVArmA31YWo3cedOuvTeB2mKpLBVTIb1USyEHTnsc76nmIXnph//RBNPLyGhDyENRJ0+beNPHktfxodRhigz8FjJwah0IKkfR6s1MjYaTNz8PH5CmvphIjhy+FA4tneffy+Yqj7XjM487eMweTOTU+n6hx+lp8+dSzcu4xfFeTjC75okXb9yLd24cT099fRTQXC2MZ5//slP08xCPQ2iGXv9F78kx1NvGn7uUJpqn88aB1qWBM0nba87sHM910SGVzNXI5fyIDJvnkiZfL4aUj9HD8wiEzXp5qjq5bpn4f4x2J7RSt1o8z0Z/McEs57d+AeOkSngchQTsRbPldcNYDGCOW/k82Fc5v3RR2eso58UFF34aCGYa0wFHM9MAQ0FEGCw/JfZUAglU6ZePxh4frcEbGNsYUrGebLEOLiOHA+hG8wROMWoh5rU+fz2wpS5Ni5GcQZpiJHyE+8ri9SfFE6upb5DMDjlFfzNsjAvGM7oxSGyDjCJCwr8uJkaIeDyfJoTq4AKwvI6c9bKwXXxOa5jVm49BZNtMEjP9pwKJlLm2jXweSiKI1sGb2sVMrk2n4wRKZuGgRyWHJ4ZfOq4p9lBImaeH2aBqTsmhwg7OsGtFYSOWg24jiapXYI5Fi9XOucZDxBmcy3tL+AL3w1wcrdhaH7hMScTuO+Y8ipZ86DsxxU4YJD2465/TuasYPxw50Aa6z5EEC6cPQF3a9gi4wyA6RrambUe7ORnA5BXYFqa+F2skTROFZOmJYb+btJGgxgFErobIJXM/GSgzU9pFW3PCgiyBioVmIpgcjCHjJxsxyANSsEHYXom0MhQLSPnGBF30U5IEyMqDwn4MFPoK62RpFWbZ9mCgvgHGfsNwLzGTUsgI9FOJF2lnhIxnacXQRfCeFH2dRieU+298T3jGK7wX+LK3EttMiogpmFQbaV9iNfO9MHaLPfCODKXFZhIzX6UWJZB3hIW20VGwuVirfikBiGYJL45YgV0g0iuTf7Z4ST9z5/rtAJiWtNMxMHsUpy7eUTWiKYX68+9mpltFW5tR+KnlF7Eulsxn0cvjvG9SP9cu0B6tAVZEmYiofFirnl9HCYX91QktCRQjFqXx5XvLV49D64J+w/W1c9C6WehadqpC8cXYR8Yj7N2PfMKOSba2CIa9zrG7V7ifDJS23CEeZTMF03iOolfOySki+I6oUHEoSH6V8J8T/E6DttQ31GnfY6ocv0Qe1WT23784lzdD5mkSIRpP4w0jx1nas7EmY1eCKEm/kqYuHLN4vW8TvH1gZdcK89YNtZMYv1I7HuROM/Q4xx/sb7sU2gP2CfPZuusC4Lo3megpSsqx/MZZ50zDxGmNsZwymvAiTNfeCrNT+cgDGfOnkmzv0X6/eY7EKkbaJmGUq23L5iKnirCEbRHY2Nj6RCMyclKT3rtX/45/fM/vcY5ak8vPPcc1xBroOku82z2Erhh/PB4MDKOwOKKVTCrq3Is5+sQlL0wW8CxGaNSruJfyfMXW8p8XZVVYFt8L6TlvDsu/V48H3LMErlK1ItzEwQ1sKOGVqwM4SmT9P6776ZbN26kIRgfKmaiFyHLciMTwEbenCKx7S9hio6eOYWZIUwRgSmufng1PfvUIST89IWgptQBjEbD7p580mILwleZagUl8dButiyTEQQyJ6m1aNor00Tq0bjXa7H/4AbnL0HtgvnNJKRq/X3G/RMexlry4npFbjt+t66+l2fBR+Xp1XT78o3wOR09cigdw9RymZxVVy69n8bPnQQ+w2g0F0Kg4kICqmmbd4ZfBleJUBRk2V83fwpePLFNTPr0d2WS8V3Yq7aKVSVQg5oQYArP9BrCkHWe34FybzrbM4a5dzmCZ1yvA/vZLy0aTKy6zNlpzDECkhFVydFV6ieCHGfH9TFoRw9/QiXD4SuY8zQZYTU/r4yXNYh1kRmVUWIcwSDBUBqKuweN1jLCAf3sZNZklkYIlDNsYCDV87RXFNe/KFpwLK4sp9HyQDqFVuvaymQwPQoLhVViIDWsDMvV41xlsz2vV/hzL9SA6bvqegmnkRmgTXKltvsp+vMnk7TPgk89kwFtELRuaAl8UPbtCrRQI/t2DQ4m/llcAZDG8c6R9EzlKACXbNwB8wTWEPQARKPRtKGd0OyuBNKU7jfMswxCBwR5HYCu6l3TEJPwrQE4ddK0osSAhIrEw4wIB3BJ0NZAsUXeB3BBXDdvhGZyfd3V9DT+PhtExQstDUzaBpKyQNZUtv7Cygj0aF8a70H6WiLanrCaIoCPdwD/IhVzRDVQCd9FT6IdmYlDaII0XzHq910YQZmWCd4ncTo9RH6ZNRgumQWjAq3D/BlOvJ11cAya8JH2Mj2D74fS0TcxzyOBOfPXBEMzEaWkq5jrqfmJ0cS7Ya832ZdgNjIRma87J4YWyLkFt8Xd2q/7LzMXucW4cN9LlnCrnaOOy+9LS5GI7QimSaJg+9pWi+xZGQJ1wNDdbP4m7QrDBwvIfAwzu0XwtbT7OB/vv999MS6XfRnWOxgSfssMJLMGa4c0mytb46RDpb9maI9/Lhjft69LhjjX7Tk+cow24SBcF9qTyXW/ZAAMpFEUCd+NAWzrDeMr09PSxQOMUXGT754L8vG04wuwof8czP8GGthPWjztGGYxd9qzuc0p2K5DG4CYe6Z9IAjeWeYTfmLUzcaQ92qVtvdGk0UCFXDvMGd4GEJ1gF98Xq7j0fQhyTw9k5kBzf3cPxOfJzW9mmYV++qYimJfxbMqAdnsWktnv/yMfES6vorp2EBHevrlrwQhV+2pphKJZpcIEFOpdqfBQUzoujEqOjyY2jBbbPLsn/3ys+R8wa+ityd9qfL1NImPUd9gfzqOv09llZFCWFZ7MCcCHn31K1/ifoQJwKQoLFyFfT2E0Gd2ighdUzxrAIZOJOky4HlRrZkXt4wAQSZITWA7ME+4VQU2bkDAajrFpbRGJDXNbiM0NXeGUIe5qYk5dfYsGvd6+scf/30aYC6nnziTbl6/yf7lVdxmKklCTf6ocLrn2hK+b1944fl08szJCDqjY723dMIgdZqTxtvzEB3sxy5qhQJSsxkFA+++NEPz43o8WIQPsh0lw6szhhAqyRi5y3wX7ulTqXleZoQywNZ0uQ0zSIsM3wZw1yL+OFkZTaU7zfSLv/spQrjMJLz7+lvpD3/0h2lxYSH94tVfpB8eGiYqIUlQMX8WvssUTSzNBKMxUumnTczg6EMTYGFfDzAmxomwqNEB7iLIUCSABWctK+AAxHcxBs+vpnoRThuGboN2hkl/sXZnOt25cyMdPXcWKwosKbBo6FCjQ7sL+vngc1QdhTkiiqoMxzSR4W7iL1YCjijwcV0K08SYKC8+CRYeA3AHOAr85F7yxhXGQkMGHBIWrhrEgfcOTNhcKufis2hNiwyWwU788zw5foVM01gjjHbVUn8Pvkr4u9Zh/o2maCh590t40I6K2B1X06ewSXioKeQMpqEzK0v8oGkhjCDvMnDtYeEQvUbfxYtnXFSpsHMDuKeGcF0JbEyqqHXwvt9W4IBB2m87/jmYr+houL2WvthzIg2oOQKIaa4SfjwAQwGsBIAAt9o/BpAD6osMYRyGAaBLANUpghaogjdJ6zr3KBvrEqAjZe/CFKWDMKnLEN6THUuY7hHqFmmX/QrM9RlaNTQrBAxoNfVg869ZXS99PpP6MbXpSO/P3yVqDqYIAN4uRVck/Fwkm/cQlg5niAY1ACEj7OU/hc+86p+hh49hrY2qlgMOANgZszmOjm/gk8C7eSmuIl1Xe6TxwVUCPozBnEVLjG8DpKZDqlnJjQ7Rzj0WkRrxgYhM1UOEqXJ632wTIIF15rEOsaU/TtYiyZRpmsLvIKSy68TkNV9xxg9EfLPxluK9kiva2RsSfC/lfsaouEfCS6YhCDEHEeiQafHZb+5FDc2d0aHcZtk5kah/ErEfpzh+27a0fs6/5F81yZBw0MtKpltTPEdkfQnOduLCt+EordTXYl0TecogSSzsVJyexENBfOxUZ+s3OpKAilw79JvbR1rKnHWkzo7Ym7Nw/UwGS8CFjimIBqm/YoJbDT74QSlzR91nh2uODV8XCRO/fpLi/RI3Hs/7h+E112EYhr+KRnMe/zjiWJHbCy0Qa6cwYI6/YgVlT6swRAPshIzRCGHvfUY0PZPhtL1x2jJq5G12oCj+fn/JDCwj4yLeMbS4va/WdV9kaR2zpkbX16ZS/0CGPzMNGCQG1T+gToJzhxlV+SnMrNpgiHhu6kxK6XSz20Si83FWe4ZkTjgVK9OpeqSS+o+dDIb+0vpkOo2J1onuPjQ0DRghtAiDfMa8dQ1NkKvm+CXqRmsdaXqxM12B8eVxSyxBFK8rzFETIsE4BFG+/vZaeuett9PwrWG0QZPp5HMvcBTW0zvv/i69TS6nG9evA/8a+EP1xfMjoy2zKDw9jKZr6u7d9E//+Er69ve+nU6dPp2uX70efQT8tXM6VeCkyeD4kfEwqzt84kSan51Kw2jEGjwK+slY1LeU8AkxHPVeSvZl8Qlj9e8/NDTgXPWX6UT4ZYVghDmsQdj7vMVt997r3BcJXb4mV8HY3XcLK8lXzidco+kd4kB6KIvCR0259GtUyjR15Q4m1o00fGQkjaIlfOWf/nuaRtv2zd97OQ0NDae//S9/g7/X+6m/bzB8tsyBBtmf3n3vnTR9dzrW6rmzJ0MTdfPClXQDRlnTsadhLAdZy/fefjdNTtxNAwTO0JTs2BOnI8Ldh+9eSEdOnsT3sztduXg+nTp1in5n0/mLF4n+tpSeffpZfGvb0l/9wyvp7bfeTX/8Z3+SvvLVr6frN66nyxcusGYb6cnnv5BGh4fT795+O90ksMgR/MWOPX00wr13ca+7pam3lguby1OsQry7Vq5PLFPUFt75G9YOCFWMzGjSXMOVO6cmeHMKLdYbXVfSF/pOpENdAzCEPGeYKXqOFskNGLCe9e1FcKCFx2iplr7cfornZzHNErDBUPS3G7NotAjlwr7zGASeBfEFfNKHUnjYhwDAYBXzPEMNLCWYMHtNUAjqtXtOGHdRxOvE8EeLBBOlBg3LkK0DUVQ6eN93K3DAIO27Lf98TPhEF1GSCBes2l7oLBIXKOpTI4AVoXZgZlcmWIDYz4hteDOnwxBLS0igbnRMBdECrMyAEygbwRJox/sNe7oKgp2HmTqNLFtiS/MAmapOpXC0b8ytcgUjMcxg/K7Wqko7ZzHtm212palg0kAYFVyrAdRj1eX0RN9q6if8tVHfEPLBdEASM4YSOZlmkXYurCzwh28I/ZjXSFt5Ab5RgWqQbI5jDIatH0A/CjF4BdJxFmZqAXtsk8WK0MQYShjb22BneHd9LM4rEuGhSTizVk3zEHHXJT9BZJ2McR1ipU6UsRL9igw18dDEQhO3WCaQiCFmc4M7oUt7ycVxyKzEfcWPH+Pd+yvMfR0NV/j3MB6j/MU/xiWjZHjhNcYqc6AUVZM3z8LHKfYnaV2YPmpaIrFka17zLLkCMjlekYlc4TxV2D/DCnM6orZr5zeznqilQTYPobE7c2TLEqR7LZ7F2bWFyFlT3OOcHaPO4JlkKa54DNCWDnbjV4QWZW6bUdiuscunlmU0eEAHFONKSG13qb+nn1lPxipdGgxhrLFnNjOTNuE8qjA6/nmWnK+O07fQmL5PVMYZnpUh1nacZ2EQ5niQz4Qj4WzIPHh3Zmb4gJkd4atx7NbMbpF28j565d7iniurd+9kgFd4HnwuI6g91zxbEtUWT8Qsknz/Yi4yncCAWcym7D8LUjD147nvI3CIIZhlquYg8pZ5poPRWskjsS3c1zdHDYHmKcLEsI/+exEwKD5h9tFrdL71AuOFVuIuobVn0Np0dWNIi0mS4zFQw0k0UbXRwXR3dQ4GbDCdPfdE+ujiFYIsXIfhOZyeePYc81lLk9NT6c3fvhFjevLpc6nv8DAROWfTEHlpBvv7I5re+Nh4Gh4cSl9/6Wv4Gp1Lh8Y1GztObibCmwsTgDlDaJaOHD1KVLux9O3vfze99eZb6T1MDKF106lTp8KkzX101p7PEjArctLctyGOP84vv7s2GwpxINAVeNlPa/F4BkkOrNaUypw8HIHowyuhYeW3KAiBJKI3L8ab4yFUSdD0PtP253MUwjOeGd/VKPBzFK8bybMPv54Bop5NnL+ShqdS6oP7W12ZTysVglOcv5i+9o2X0sC5Y0Twq6Qf/A9/mLoWEcrB5DjWbs7CWz//dbp29WrS3PKf/+nn6U/KaI7wd738zkUYnq70wdvvh6/Ol198Mf3kr/8+GIznYWbeeuPt9EM0kQ7nP/8f/1f68//4HyJc+xu//HUa7x2GmXoHwVwdRqOeXv37f0jf/f730PwRiY5zso42bwbm61c/ew2c1Z1mYFyXqfetb34r/fVf/hX+aYfSSG0QLGKyawQ1MIjuhYK7YgE2lyG+x7kP/Bsb5fEHV7CUVFI4Nkfai6U6pnV8XkdNpr9bE1O7NfDNpcZEhI4fQmPWrQ+XDXOvAphFGJqPlqfRHpF8md9kcs2RNITp7TJnZoY8SaMb/UTIm08fkE9pSa2qN8bWkoQbAeUIvqh9CDrnYHYW0YrG3gJwHMfyag8m2YTUd9+5pygOYbUTgSAJtIUjWpHcU6GoePC+b1bggEHaN1v9+ZroPJK/qY05UjdAzMLMmFtILVJ2nhXUwXyAUEMylEEhv6wTsU4NTErHSsPp7sIsEecyIdUEGJo/Qlzqn7bdU0iZzEnUL8PAj0o/tRMPpoPWlIp1IxWToImEgAByaYU2zFgG1yVshPjW08wPZ+fuZTRHmhFgCsO1fur04SMhkV/ifYAwrwswKAsEPjCMuZIunbvL5Z50BPO6MMfYxNT66pxo64VRKqUJHN6zWY3QXuLCIYLYjVYEctJGXsLAhIT1iM63Fhqpp/DfmoG5EsFot95O8twFxl/CjKMd5ChbJHNkAcWEX0OWJOb1jQu7vEhqrMiUygV+zFLMpkZeDE3WHEqxpi6sjIf0jvmhNIeJQBVu3scszlfip8S5yYQ7Z4iWnYfz3yaOIZRd0uhKZtdw4Tosi1glJvSlcrfQalFJc7ysccrXHhyeeyZR7Owkhx89B/sMhpB+JSZdK4tMhmYxzsU9aC1t2HSuDfZgZseZ0LdISnKPxWOvywiRpQnWwE33Nr3HVnI1GY5h88HQv2ZcBlVxH02K3Fpax+9q9kJYnmRuErAXNmbTIOZ0Z9v6EZQ4oDyXfM+9g3MtBqjTS7+LMFa7lTBNVMjAZNUCrvLsSEDLKJkg1jXXlOvBks/iupOg+BpnU3jEeTDimT9GGG4SY9YRTOjoXpiu5t3b3nVZ7+toiHVqP4KXzDDz1K/CtYrIbNGJ67aSrlwjVxLBEHSVqF+fSOUakdK6iIRHIuCnXnohrXRtpMuLt9EsYf71dTQKR0YjGfXI0bE0P2RDnem573wlTd24Q0RLYCNakInSEmZcDZiAnjR4ZDh9ceCrqQwhb3SwH47+EYwY5nrAtC9+88upV8cnyvjpY/xeSmdRkdexeD7y5SdTabiK/9ECuZv60yqR0SbQuJk81LVwFTs5UMK4orgCMkMyNTImlvjOmnv+4rxuVo+v/BQRz3habXEd4rbBmqtN8nrmeuJDfhF+QzzHxWiH9QQ2xsoLp7R1Y+0dk+bXwRzxPepzyVs0Xa2RH6qP89sO8zz54V1Crx/F/6srvXvzo9Q8kgP19PSgtUTDMQ28fe7MiXS4YyD9/Kf4mNHuNIzJKz95NR06BpOJBuiXr72ePiBv1tPPPU3Uwj58z4gMSoCCD9A6nT1zOrQq/+6b30svfe3r/HY+Xf3oalqYX0j1ej1dufRhjLMTRtzARCXMN3vZa/nIn71OyPXvfTcYWuH+0+eeSW+88dv03u/eT1996RswAj3pN7/6TTpz8kyqz8+lr7/852n03LFgPAQNQiVXp8KYF0VsFJ8lz6FrtM65FpMZMES/Qv2fjBThuebRidD3MuC2ot9ug5xG68AevvIM46MF4z6N9UMNu4aFZj3NNuo8Zxvp4vLtdHltIt3qnEnPYSXCI0m77C/MGI8iwpDuNNLTh5nqOOLBRvpwaSLgrPyMORFHMSc1yu3d5jKmiwsI9dRXZ62rZ65eFxKAA8v6G91bPAsrwCEFGwYQch0Oyv5dgQMGaf/u/Wd25tIob8xdhoi4nY5iqqCdcpHhXoCmpDFCfYoMKWsQuDpgKq0MyS7A8khpIL0lPBcA0l67jQr0AaaBxGnjTjumASDQKoQvVwHsAM8IymBo3RWktLiCIx6VYDMggiWQipoExabYd2tqICE4CHE6iKTM7jS8GthA6o2fgYS0mqdVHF87kXadWadNosoZcUpb/s5GF+Y21dAeBSKPXuyHf/TbDxA3o7pjCGnp5nXnGdI8iAUE/lzH1IYxawrWhYTMMgaCH28upgv4T+i31Q7RM7c8gGPtIkRWnVFm8KBxxTIIchlkF4sVdz/6RdMeWQIRZFFa51D8dv97bAljDqQrUUr/mhNJ9gSrApGVER6/uDHO/f5GPsZ3mcFuJPYyR1EYiPHU9EdBnwCRIKLNWg/3UD8aiVmLY5RBk7C2rLIv3Wgh3HuZV9e/GOP2akRVXiQz2C/Owl5nYt1eiDTnrhO644h1phMZOkPMO5N726NGN2dlCGJ3YiEYpcehAKA/Uwm+qq47SzH0x3yX0TmC5vdsWx9zxlSV9Yrwxeyv5zkLNHZu1BV0nQZYW9eVINNpBPl/Bd2RutVife+/29/1T+rhOX7UuCW4FT64nsFw02pmkG11k5hu6SDWl0YVSOjrqO+EbbgXq+zDMmZx08AeGaYyms5aJ88ywUQ8U3OrhFvBrDU/Iy2N8tFcaZc2iOCFwGSEGapJUkTiPPzrQ9DTDtE5N7uAghrzJdq+Oj+VSmj5NP0yaMTicDva6GVqZwf2dSI6lM9pcrySbjmu5UlgYnsawkywe3gsJPVXVuYgVBdDG7oAgd+GX1N50OAwRPhiLUoDBLvRkR0Grg9mW6LYPduodqSJVTSaA00YA7z+OSe1k8wThsuEoDfW7hLieZkW8vPibINkDc5H4pddAlZpEtgRcHJzpzZhNj/mfuI+n0GESpyDIiAKQ4h5z0Joz6HVi2hpdtJS2AKRQexVHJaiC9qSo5DAlgWIc+jo6HsdGG6kNZmAEjB5qLMPKwGiDM5iPjaPdgQm8uqdW5xL9hczyGpPb5zNJrD7CNcMgDNx9XaaWb4ZkQld7/lgbiDc0aRMT02nU0+cSmNo9BbmyPczM5MGYJK6YbA87yvAHP3ZRjBZ7MCP8Ax+RBc+uJjqhF7/+ssv4Vt0N90lnPt3vv3v5MDT5N0Z5oD5ImdCk3GnZqTEClonmbZbRDb0bM+St0oB3xNEHqyAx/owDTx8dDxd74RR4QwoLAx4wrzFrT6rhcllbBm9rMDMdgLXInIeWlG30OIOu89lGDYFkK5n/h3LDNZDmKPptXzPnZUZUlEMpKtLd8HRmFzS5gcr19AUkWgY3GQ9gx+piVfQIPMrftfEUS3P0fJQ+P+5R7Y7QKoHzYvvwmzdQgC6Qv8+mxHkAlyuHUgHQovFFcyyYZA2j0CMz1FmCIG+lnsUu21OKa4fvOy/FThgkPbfnn8OZrxBgsSZNLFyN93G0XW8MgQQrYbJw1AZJAWBUCFvSEjRAeARdU7ECwKxCK/LKxAG3DuF9kXfmpqSTQleRF8NssLPgyDu4n9Uq/SmBhihl8sbMiIwGQ18i0Ti5pwQgmZbf1ACQDo0NiBBiSqlzQYQqEK8DCKRsvcSUspRmKNekpisEsp3AcZDc4QiMl4Fu2lDchNjjgBiMAUQa2NGqWOMrcRuzj2CGZf22xBmEY6WGoHUnCTIwuAREmZiyQ2YL5lGbb2L0s54iW+ULoGkZJDM97SwRCgHHKjbMAPMyAMCX0KPv5hscfMj3r1Xf5t5iBU/25rhVyVqWufR2kzUY7gFY2Q4caX2TmG3e1rv/6Sfldivs+8S4dv9ybiwqpg0NnAqF+Gq6emH0NXHSeZEIj+vcusIjPZEIA7MMc3J0obk2bloLrLd9nZ9Ebhaxb0WzcFq+LWVaVen7TpaxwhKwZqphdSJXEm3xH5e/82WOSvr5jYi71FHA38kL+61UHddQjJmu9ebtuvZ1SDk/ZMd+ubkc5DPK+fctd8kfrbvePCTjOg0TwfGTKkOof/++mwQr0c1sGOf3Iediqe+mzUzRaa5lnYvMATBIGWfMZkkS75j+77iu8yHBJmJRyXWTeIp8yMRKbNsctE6fkMm01xCCOL4R/CfNNqZZqMLEITum+3dvxWelFnmOAehBr3I2CVUDUaBthmC8RiMVm9/b7p46QYrsp76Tg6loe5aWr7K88w9zVEZZCJw1nknCuHGUCVNYVo0iRmvwgDP4RJn9Pr6FG1vM4UKCZSgS3POk0ZgyTPDAIOZZT3UIOREqySMZjyR241+pjAxm16rR7uu2dTifCSD1ZSuE630/fOzTi5cod0wWw5Ghe+blSVui+IaScCacFVz1sgT5K38FgIhrnaTaHsBxjk0U95w314HsU5f2XyqaPne94JJN6CE8Nw2vM+AH1XWZmVpLU3dZIVZoNEnjmDmeCeEICeOH00DQwPpOH5X5o06duZYqmKW+OMf/0MaHx5NfdVatCfD009+K/NlnX7yTBoeHU4nT51If/vf/zbdmSQZ8DPPEDYdhir8cZwfghcYpUnCzZ15+sn0j//971N3tZq+RE6rH//X/5Zu3ryFyeQRQrlPpzde/3X69g+/n3oJDOK6aFXhWi6jbdIfyMiJH127iuaKsRGd0KdwAJ8z8YnM6TyBEFZhehWuWELwxrsafOHTBu3pt+oBN5y7IEtNmybdHR6YYrtYrx40YR0wLPqDWnwm8vOu9hCmBUbnemMy9a9V0rwBFWD4ryzeTTPt5MbC5NtycfEWOtSu9GwJLR1CAc3bW3HYoc7BMF+tk8jdoonlneWFdGdhDs0buJ12TAJfhTFbYQCmqeguEWq+aeIwD5mHJL96tnrAUf7eYN/FXwdlf6/ANrW0v9fhYPafsRUwhGgnUXcamJDc6ainehf+O10Qq1ASgxCvdQA5mZGCaDJQQvh3AA8jF4OSKFT9x0tDRPVBYgfzQTokgCcwmheRwi2Izib6fO+dhdwYkoDgmokdRYxlGI2QWqH9kfBtkAdJzZMIZAHi5NrKLCuKxBViaRC1f5jIgD1kjgbXANao/xtE2tH/R0KFIcCYQGgh7ZM4KfM70B4TvmowFta5pzBGTQ7AMXHFeUlktPkDRdDvGvlBCb2IvtXHwzoS2d12zLic2zp2Y+tEdCpKJhSKnu/rv6i007tjo/oq5kxKCCWoeEnVVZzosTkP87WW+TgCbgkiI3yJWG8J04I4dYa59wK97tTpJ/9NyarMqgTuA4U5SCK0IX3sgiAI8wsG1YSZ1OzQ4jwsvmeCDSKAb549iYs1CDtOD/XRg7lXUdv61GGvfM/z3LzwiDf3T+LBoCAVTC3rmG3VIcQlSHRk1tSlHyFAN0xUq+meYwvCsxjAI/qRsDEp6Vwv/hrlxxnhvQ1LYJ5BAj+KyVg+tZm46kRwoRZVAjn8AO+97Z5vDjmk2bFWbZjZ4pNE2Hr35BDPu2dtpxHGCeIZd+5+ftjUJZ7NxeV+GA1RP7TW+rbvd331qvhAVfFHkUnKO+gV/li0DhatzDPci1BkkevLnBWoyXguIzQ+v0e0QY5P1kY+OK7cr9pJ9oD9tMgwTcMQz+NjOHiE6I0Lo5wn/B9PjCHEaUu/e/23RBbrSE/+3pfDMX7q/Y/S1XcupXNf/WI6/RR5kEgY3aZ2G5+cJvDSZ18fKdtX5+t58Tvykji3GxDCCleWiQCmwKMHJqR3XfaEuQAH5zh3M2iPXDcZRttx7SylTgMn3Lt+ceG+F89jmG55Nvnbqeh7qEDAlfazq1XstQyMZos+X0byNP+bvkOxogKXovjRv527KGrFWVzX9HPzXqZAABvwDUFLZm7zhXXrH0N40oeWpO0QM4bZ5e82r9/43svpNQIj/Pqnv4x1myNwwktf+mrAs6GR4TROEt9vfufldOXy5XTx3ffBOevp3Nkn05knT6eJ6UkCKryTZmcwIR3A+Awf11H8vwzEsIRwzhxWx48fT2PHDqejR47CWJ2MM9VPGHkDShw5djR9dOlyMBEVTCFdy8Pj4yK+dOH8+fT8F55LE5N307WPrkWkvBNHjqBtKhF+3lQZCNti//K6OnVDgWcBEYeBcTZNDcAF8aKrK2NkSgogNmcBuAgc8wz5jHmfWqwVDq8nVwGGUezilPBZxu8uPnu/al5OfSQNJoJFuraMn5YpCWKL8HlFuPDm1Iepa7CDoA7Ht5ijeJ4Zn7n7ZOiFexa1TvX5emjrHH8XuLQXTZaRaVfw7V3l3JexDFlW+85IFIpSLZ7dbpij8ibs93gss80HZX+vQMf/RtnfS3Aw+8/aCgjQftO4EsERBgmvPYr5QA0tTSfSfyOFTSPJvEZUqcP4JxgSu1NTA25aRPOjWUODPxmdKtKtPnIpGOWqHWmROSasI4C/Se4F7MzCfABYngZgHBoLME0gKQGvuSqC1IJ4WgGRGvxAJkRC5/z6XPoIB3rD5Y721dKhbtPQInXFz+jwmkQcyJ1GlLzxMcZnKF9NHdR8ibyXGccSkZG6GV+rxKzYKwkQ2zACkPXDzA9CJ4hfB2zxdxCjtuLBQOVf41U/KP22boJQbsZYQVs4ts5iYletYLbThZZsU1IrMS+RuKfi5rjYSl/jTa2J6AyzBaSghsWVmLQEEWUd/iltd+804wutUaCtqBb1iqhxMgWbs8sX/xVe1chJ6N1bIIb4TeZJPyUZDgk6P1eYT2gRNt/9HOY/XEOPF824L449mEMJCuZZFIk9CeWCqCx+39u7PgEYoMQ4ctQ8eV6ZPYMCeB63w1ZvrpznhCSxbUZ2Ks7KQzoj3kiarmHyUtM+H+Io9vghN+xwyZ59zp5rJ8ojY91qggvBuPPueZbw2o1Atll3P8xSqWs0OxNIqpdRg6KPUo5ed+8APH3TaPqQyZMLZm/n2L1t9QmT5LP46o52owEaJIJmP2ZU7r/jyvsXE8EPES3sDOGY+etaxPEbRqlCfqIqMKDTZ4/9X2UsYfrD/rlf/ntYcQ2LP2su0sYS+dTW8NFrI2BAV795azrTxV+/ByHYTM8TBW0Ajfqdi9fSpQuX0qnjJ9JodTBde+ti+ujN82n59nw63kvktfa+NHfpVjA9JwYOpYUrE6m0gHaEgA9Xf3cpXXwdgv3aBBE4e9PxwfHUvD2XLr3+u/TROxdSJwTnMMT5BsSxMEgCmbfN2UhAe8S2dnvX6QXcKvbeSd5XbEFhk0lY1SA9rEWDbARrRHvB4IQQaLvBrTO2Qz/W0iJgHVNq55M7QlAFId4LMzxzk3Wv478yhqBkAH8WzmAdzaDPmgF11MCMEBXu2OHD8WyVgekvfPnFdPj0ydCK1EaGUs94fxo+Nk4uLLTKjNQ8SbWjI2mQ3wyu4e+nMKU7c+5JzN6OpH7uGSRwxgxnis1Ox0n2e/rcGWwYCQCCxuoUUe3ahzHJ6wPfjIyEsGWMOk8ShGPsxBECdfTjI4VJWT9mdPhDDR4eDXxggIijT5xMvcMDqcZf76FBTCFnYu0ylAXicTaFdjLRWk6sMgafp8A7rBVW2iFI9FkZgokTdqqhdf0DGvF9yahwAdeBH1xzzrIl8FvB0C6ydjNLs2maRK3LMESGVDdghc+T+KvBb3WClpiOIwQLtCkknV2pp4uN2+laExNx2reuzFETXOweKiQ41IfJOOvpOXAc+ijLWq9zjroMEsJnGTmZI7WSIYgA12n94RxerJ4KuL19eg4+7acV4HgflIMV+IytAIhN4Af8CsJdJ/0eCG+BehMAeB0Ve5Pwq/OE8u7EYbmnF3M2fjf7u0A0CDGAYg/BD4bwx9E0YGFpPlTyYvd1bLPXyPdSxm9IkmQG6dStxdXUh9ZJrVFBwMlkRFvUkQkzc/ktTFIuk/3bCHhVJFejOJMqNaNZgjKggwhiCMIBaR20JnfmElJrTfb4Qaf1ZTRMDyUsQP765WgnX5Bmzg1RPPfBvHEtEvMxpkh6GN3k3ry2BgG1xN8kfhAiKxk0XNFjvmpJLAWLUMw3fnzkC+sH0eRYMuGLlgrbfZGNRMT/y96bPld6nQd+B8C9F7gXO9A7eyPZ3CmSkil6JFGbJY1tzYwdecaZJBOnPKmpmi9JqqZS+QtSlY/5nFScpPIh40lil6emvMqyZEuiuIj72s2t2Xs3uhs77oKLJb/fc+4LXKDRZJOSUyEbB7jb+573LM9Znv05c9Qno6DkUcTrIBrTSwS3qTHaWonkjs71ag508N9MoGq0XhT3S0vhqwUxHWYjG6OTx+lDzXJ2aAHDe0MKpkpJNI0uwn0bZORGhuyGR296wXp8ObeMrqVpkISKBJsmVM4TjialDjgdJqL3DdSwOftuWnRqMiWnR9fSPOthBan8LdC6Oxam/8yhHrRZtEECa0tiWjofnCOe0UXjt9zu/uGTNco6BlGvmd0ZIlmpg73MWtdE9AEen0A67Mo1WabM0QcYg10n6Ip1xx9wkFBzPCS2inWYn8rvrisZV3UWmsoZXct8+TpBH4D11nHjrvsD5os9MxifLfEpxcVlrHWDEFPDs8aGUBlC0zICwcd0VsNYhsnSb8a1uFNbutslDArNpGungY/Pch0muY5whfFSUHP+zMV08tlX8U+qpnfffBviFkYNjdXbL7+eXsVRfy/R505ffDe18Xu5666706svvpKOQmgfPHAovfPG22kYQc3C9dn0/NPPEDhgJM1Oz4YwYBRz35M/fzVNY85V4fiCF559MT3O/N370JGYa8r+NTN07sk4eA5RltELtQ9P7qW+iuQTG3sPD8c9JqB/N0tBOgPPIvpknAFmFDr2ibxKGA7G/MOS/lCZOSrq0fQKDeAcjG0dXENwi95hA7N4Rpe92xyzeRikU82Laf++sbRn/92MuQIhzuICv2hSuT46mU4RArwyjL/MQ4fBCUciiMApfJR68Ekduo8zkjB8zowzgQZKaOyOj2OC1k5XCdE/w2w/hqawWeZsr+b51E+o+BIa2YsrU5xjtZImj4+mO44/GN11HlxiXaziM1b7/OE46+rkOv5S+zHbPnAPcz8ROhtt5PpUKt01is8bkV0ZN33psi5JKDFfAcMyZ2T5cl/vB6fSQMYVdIMmbRDYTDBfaqzOb1OOAABAAElEQVSVKc48MqLsOsJKU/d4xsgxvobuFsfkVY7gyLI4I0mhZS+m72qTlcfpB+V+JQMzAzP04ty72YyesN97EeZNYXL4AQEdlljfPrBC+1bA8Y6z/lUjCE8nEZ7ikYbgzasmcCZ9rrBmYhoAgwIne7iyO0QEYnEuxhP5qXh09+22g0A3tXHbdX63w59iCMQGxuGraCU8N2iWXdfJvAyjNNNcSGX8d5Y5Z2MZ4qZqXl5hj00ev0sADyClkjRt4MjsSd9F4IU6RwqtlpA0sTdqXz+P/fYHjfV0jLOD9GyS+NIUz827YLj4mqZBLifxidB22XORJnG2HZI54F4JDVSNfbyJI6pbrgEjgqHhu5u2SMId201ZzY7hyj+M8hfFK1EL3yR+KDGzX5a5Bjw8+0gTEc3mNFuiChANKIk8EmJNkEkDRHENqbr+CAaV0DAm/i08klJ0iER6rIv2xuXO3S0fdoq2azK4QoQ0Dw806EMV5DkCQp0GcSL4BXHnE9njnCkKpLmBqLeUteWHY2fRkroF2WuGfN1+Gxnql5WsJZvMSSjomfHLKztaHXCK1keTg9ClDolBx/5jJQAj+al0Nj/J+FsAY1ZGUzFI0/UdU6PlrM3lQ8xJtCMhv+mAclvzqvoAzAVaI5kjfbM+KXPkvBklJP0hJPCZKtmhn2TKTD1rk5Z+FDntcpEYd07LaCrX9lww23mIEPbjEGs1JpzS6TPBHBkMwTkjY8T857q+bhJfmk6qGZS43p4knjTrCq0nCjeZJMtRo2kABjVJFBFaOihD7N8I0T8HN8Qh0eH/Z+eLRN06oZdY2hoZLleRjiNYsVZHaEXNCES3Y9j92MbjfHG+ROQ2CG/nZxtGd9kDgPEb8QBQl7ja4tmZ2TinaAAhzdWpqYgGV19ciBDUY2h8vv1PfjO9jCneO6+/yd5TCpOkJsSlxw80kMCX2Dc8S26ZazrE78FMa99e/FfOfED47tchsPdx5tNYeuftd9N+vh948HiMXy/PGWZexrKGeZMMuqafaojtl1qyYvS39zH2UiPNSbnTTyPMReLDb3G2GU9X3BAE+g7Jq8Izj6S/IPCJUrOhDSoeKz53KMM9pTvJwK41iZQ6i5kw505V9jBzPFgbZl6BWdEfn3HeGr1uCRjaBn87TngDspdWENLh1zWPlmQBAd4YDPdA1mqoJbFbC/z5lMxsH4KU/iqR6bB0WJphzhEbY3i8J11DyzNNBLhZhE0s/qhDHOMCnYcRts7cA+e7HWVNRfBGmR1h506atc7+zCyejAG+bsxBfXY24cfTZFplLlhFHCKMAMNDqd3PJ9BejnOchlHjxCdLmI3HGYTMGSqJ0d4KIQoh5XWYv/vuURk2uonJXZh7d3BYNJ954N6jabIh66+zzs9ycKxzS6sP2wVSC9xnxFh9jQeJZDdJwIwBtEJ1yrINllukEqa5WTBiEB3wluNIP6OsItPu520PAWnK3bQLgU8tBNz+mzh3zhEZSEJZW/YVNmk1Cy0chldXqjBGMkRbp7pma2p9wqxuUaIHxI55g6YIi5wkLuIwtSlblf0FENg8G/M4PkQDPFcGYQzCYPVJbIKkJGve5uwQHchLIJCh4aG0F/8hSV8lU56TUwb5L2KmsI5kT41NGbNAkZcSzWBiokaQGBu5CC/ohLi2+bZlCweL+Vtpm8yfbVY7IDrog4ATKXjCeo99B1DWI4Js4bxq4IUGzMqSSBHpnb5Lq4QZl6GyVJPEmETmsuFbTZYPphIBb0mUuUrflN5pgqFU3hMrPUtjDxH4xG6GO5Yd1bnbzoH/wza9TX0E14rCcwjl6NEG/O1DJv830X5Rt/2mJH5mdF5c/0U/gT4EMNJS+qU/mKRzhsgvWrLPY8dPjyxbKIZGScL4E9TgMxL5Euvb2SvHWiapDINqHxzLog9qMVDrpXW0oh6UvJFi3Gghc2YBXmZ6CCk5nzHmxcMbmW/9i7UfwBRNE7iYRDs8ansl2mRbPMAyE8lbMwovZ/U1iJuzRFG7iLa2YA2Le+eJtibTr/v5MHNtmUmib4jNz3kycxS6GsYgwhI7N4sMnSqFrcyX0n+DNgQEXUYEvzAghjCfpuSB0GxiesmErhHZrDwLJQqxJkG3Y6JOA6pEdbzZJr9LhGuqp8BjubN2iznhzHeeKMyROdL/rcTmsE5biHaecKlIJcy9cO+KdaPz+/G770xffPJX8Wkkwh/E4rn3T6cG5+CoSR8b25uqYxNpZGIP+w7aHs7CUTsaWl320DigmlYdOnI4fe7Rz0WUtItnzoZJcrPBOU5ot1fU9JFO3HdvOnjkUBDXmcDM+4P73iCaDSO/Oa7ouLKZlWufvxysJI9LFMSb/Vx306Ov+jwFdARQJ8VzjLgedRlyxZ38KRzVAchI5bHL2so19t5lBF5t+h7FUf7NUgHz4r5ZKwRoWb7ufo32chJtRxlzM9aN/orb8/tc9INxzrsma1RNGgFehgkDWd3DoeKMR52zkxrX2qk8RG59X9YIl+7cYL7KFKjFMmJqkzXqcl3DznVwDJM6fHGahIlvIhjMxxFkSNh3UZFaevevzeSdfC/PNH5wyfWlebB+qo5INilTq+/fJnxpEkEpGG/66r7dK3MkPkAQcQCzznHGVyHCEu25QtCXJeaGMJFRF9h5T9+oOcPfBm1P5C2Bh/rAqW3nKabsRoi1rUwGtFYwPQjaXAcyYhi7R6RGC3St9ZB3AFM6BZ8K5Qb8zXOa9KlNjLGyLJIfPQgi7BuFx5XOLS9spE0B5sal3S+3GQSCNLnN+rzb3c8SBNggDYyg1FStzCrMkSr6HgiJ69gmGzVruY1vD6p2CQfV/0E8ooKXKWnjdOvmPzyyBwToqfNEjQL5RRQk4OQ9zR3aIIY5nJSlpCoQkB7I0AeSMNjDKohPRuqaDslI/QY4HFDVvv4AIgjLmtSpGWRSJRpEEzGiZnSlkPgiBQcDSpyYKDkkun4TiQWz0dm93bCV7nZ29sgfbyAAAzFIoEhc9K1CkiCRE7kDFnAZ/QFjWbb0h6ZvIrFppdVUOwCz6HUP0cstiNqJwCey0TxReFgW/ec/zlUqaqfOFRx3ZbrUWOm03Uf0ohrw3YsJ4xh9voSkU6JQKaMhYzX9UDq61AaRebhOh2BqhjkOBEKnv35sSPW42ILUAi9qeh8ptEd26u8hWbeEFgZrv9TSZV5F1kWzldhKUH2ylMfRsdwxAfP8l4mCyOM1iJDVPURGRDDgeUjmCaIMk1Ln4gpzfbGfgA/Y6LtWblb8jnXucFHG6DAapKjnwwqzLggW57mEztbEoc0Qvxc4aFWzuuvMhoL4KvL5tJDAyCc0R1OQ5dbp3Ja5cC5JPGrKGRJ056N/1JVXR1FSnv9ZQ9VZl7RNgp/hCiapAZOmNqkBI+06rXDmmFz/KAvOg51zomIbVSQnNnWtwZxqXodCOtprFl9BsMoA0brsR6PYRohg8gSx55/EaOwJCBZwtcREjnuD+JlNyFSQO+omMAQCmrGDe1I/Ap/xPWPpwlk02IR5HhrkcNOLl9IHb7/PobEfhEmjh7vOzMylKQ6c/eCdt9OlCxfwoTnEGUbXYr+8+8SJ9PNnn09vvvF6euC++9JefGzGxkfTnXffmZYIp2wUNoUoaooKRs49U4ZG01nnkOe82T+1ORLkEq1q4CTni+S+UmJMtsCsuMmnY+l+vEaeTNYCP8qJP0BriAnPBhOqHi5toA3Lsk59o+q0w/Y413OiLTxnuf4XydGLvYXPAca8bw4fL/zHhg+AM6qeP+bekLUSxTMf9mnRtnu2h7DuMEqDRBOsYZ7YmEYgYPA12uW6k+/YYBCdGeAXGyizMTpZTrVRzM9g9BbRxrshV4FxrE/Lp1/6tdn2m6XoJzlkxmv0y/HI3WYNUF62wdh8WtisgKv0r1XwZuZV7MLXaKj7lgIwGVGtOK40G/hIcc6Ra4vrGaYZ95kndioLJFmT34pfFix+iSirMDnikzaCtor+uPTd88OqMEcVcEswgGZmEGXkmfnAgJYboRZcJVOkiaDRRudYo1AFwVA534Idpw0K86Jy8FtZJ+UOFGxbd9IPLZqcgdR9a/f7bQKBXQbpNhnoz1o3JXYK5CBx08dmF0yCxDwIR8n6tL5ImLwtNzAB4FC8oaEhpKX1MAFwA1eztAxjE+Z2tTEYGEoCyfdzuNw6ZndKrgaRvo8OgyCRMieQm9ojVfM6hs+hRZonfK1RiNZAHCXClSqJHsIxd5wN3X3Vg2zH1wbSBAhJXxADMWiyoj23CKJCnaHdKjZhkaV1kNe/IhyvKKVBpDylvR08w9OWsO2DciogCrVjmi2AF8hFPhBGw1P2QFZ9BJ9YBeFfpJ+9gVhEX2qXJCKtlXYjzR6i78r8e7W3ErGAMGQyN5LFwhQ1PQCQT8/8KMMcWf9kBf8uJKVqS+ownUrgK0j09YuSmV3BBLJBG0Y4WKfF/QYERxAvRZ82KuELbWqsDKTF+iiERQvmC1YJgktNnKHM/76SRJjIswPlX7gax00NiP3MJWcTRuv5pHUU08bni+9R+MYbo7/9JnMLdUAQ6j2eMs+T8iPrChC8B8HRC2wR5X7yhnXqdzZF9DEYkY9KTP2QUDNBtmSVFL2q1gjG6AJaI/TCNPHmENuEgzOfeUvWbv829ws1QxLRfi/yFyX6KSOi2V0mxXNzzFnDv6nEQZKLaFvDOV8SH1g1IWabwxCxEI4GZSi0SPpUbTBMrMm1IeA+zt6g72M864zYTJKWvaw9681aRhk8W+n4+j1rkggmh8kXZaPNGJqA0IbgdmcyCMr+Awf4VBsHSYhJbw1mad/+fbwINU1o6WeefzY9+6MfhRnvvYSNvu9zD6RZzO/eOXkqPffUMxGIZmKSuJ2YCV/ljJ2rnLXjmTZHjt6RHvjcw5Tbm06fPp3eeO31CFV94I5DMA2cE8ZL2rXSYfKEuebGIVjpdDHDW78cNMwwzvNo+RVEmGIkisHo5N/+IUMlI9DLS2ZX2GkaZgkySzJmmj1qNhlA43rAVO0lgq068Mi5c8lZW+nDVNxVtyZlw5y/M9AYTMuL4ADOghqEqa0TLEBWzKyum4+zQMRZ2S9rhWAMtGcfe2KD9cEeRrOjDevgGUY59n2XovNwHSGSUfkaMPwe4CusK1x3Lth/TYJlHHIwnGIWc6OTvCLcDWHtYcZ5fPJ6zLl3eIZLK5h6N5Y468m9gCSIUFoGI+66Un/L5McXqIWJu3jJchjFijhNLGkbqZmOmD+gRR6ZWF8KLaIPXPPPvvQx5/pYXx5cvoLVhoffDhtMCVxiAIcGbXFdFEk8GQfCg6tlDzUJVyCphg2xXGSzbHHXOlqpsHSgHJ20bJWR92xpNK4olE/70l1P163dr7cRBD4aa91GwNjt6qcEAux7oa2A0TBCV9XQ2GgqVmB2tOU2qpx+NnW5A3blVc79aC1Ncxr8CIwOIcAh6PXzUf7kafSxqbOx9mHypjZlf2skXe2dJzJeP34cOp9mQipOX2HjVQDVZLNVehzmRxB0tkcztTKEyRjleOaK2pK96CDGNQqh/AJJVLjfy8GKar76MAfgZkjNw/adsjSX2xIQIPoAsQGyMuCCCKcjRKMPElQgIRGDyAtEIbEm+TDOBc39xCdXsYt/f2Uhnu3neh3GZJ6+F9GIRKGroUECSXF/hHYNUpZISwI+/APEN8WOQaG2s7UIAgX5VDBPLCH9U3o4BjKb7M/+Jtc566nBmCgBB+MEg2Qxs5iM6Ie0DOGbiShJDe/cmETq842xtNAchfk8j015CwIoE2IDjJF+TRJZPi0S/mUly8pM0i+nRCXcSp6LFGPHPPlFksSf4yWxEXMAKEgoKVEuUkhOix9dn+G7VcvquC2wY9AN86yE2fZaR0EM7jxCXYVu++qY6iS9AKtMPMZtd7f9pB8y4865YiCd554FZGTI85i4Osq/6BjbLwn03C/n3dbkiMiiaM4WVKELyEppnx/9MPphusi+YHhhtc5KyZ2L2E+llWEYTM+IkdFjbfSwYVgEou20PoxOkuMJpIdDp8b1Fv0r2lB8Zm0RmaixWBcSm5r7rbcwWZtmfCm0H81RaUAiL/u6uLc88vhj8ZRhn1uslX1HD6SJifE0ODpKVLty+hLM8ZWLl1NtbDANH5lMC1jB3v/E59IkIaR1lH9kmMienJczNj6W+gYH0uUL5EUjfuD4IcItj6T7Bx9JowcmU32hji/S3lSZHErXOFw0zMNosV6WhSanm8i0b8LWCI8yqCHgog+zmkLnUefuhycJ1wY1BFwoMJPV+RmZCUOUF5qjoiTrddwc0z4YHBlmr3lV4l9zbE3H8uhyj32tHwFMbbma2nPs5TU0g5Ps2WpPuBfl5QKilI/7pgZZAV4fDNvgKHOGSd4EV8nQ2k5b4jiX2efJFdfVtmnWqWlflb3UuSBsZRY9xPvm8GO9sH/qDzbCcRMhnPqItlMsjAT4jb19hTrDmoJrgKSz/zsnM2PmOX5Lamo6ZSqojLlI+92XnLu20z8FJXH0BBPTMcjmy0aOo/30X19itcL6w+rLKlNTqfWkIXychlmLbctm2sf+0AF6D8xUP8LHFaw7PKw97x253qhbfKpfLObf+ka5n/SD2+JoAcecsRd2oqdunJvnbadTnbp2P24/CHwExrr9ALLb408HBAK50lQRrZKxZQ8iZAP1QM9eNsoyzNJwzxB2yx4IByJpcsI4pgEVzuEpY0q0RFAGmRppmDBviFwgX5xcJ2Gi9mHQP4zfxEhfNTZyN/ALhMRWUjaPJmcewoPjjNhgIQgI/93GWdT6q4T1HgURSbCOrXEKOKZ1BaIoIOvGLUEFlQXC4D7apkaDsxuUwmECmB12kRqGWFEkDgJtYjgEsapmqAQRFIEVJNhAopom8I55BmYFoN73kbGDbtIEcBhVcso+/zbOChcgLbQSDGZNjReMpUSNSXiuxBlIENwgVE1SfM4IfvopiSo0gRH9+UMEsqKtOIhHu/E+7eqXCSdb5hwqCECR4XU0EFc5LNKzLFogooR5iFL7FRx7Z1v9aXL4WmiOovXc3m4yFQ2zXiocKMEcggxLmDFmcwmj2mHKB+KXAVAuHL4bBaYuHv6Yn/bTJAGruU9BNMXFX+SNgru1RxYlMVS8x9eP+wa2LzPfjYJnWUpsnVshI4focGRzHR9SMO3anse5UIWpH2P+L6BRLSTByutDskodnjfjmrgV+OgzcLmnwYHHMM0flWiMc7KNhpGpzRhQA+1ZZqEZGdK2OkYSOp8k+bxrL8Nq5xK8r1S6l2iMPZiO9izTb4jZNZjJHiNb0h7XkGZKakGM5MXPWPM9mt+yLxTNi4iBEohesEOaUnVu2gaJtT7WneO2mVhbkG1xeGfnjnBW8t+73JfmryGYQPNXnmQ/04eFB2X68G7Br5A9Yi8hn3lu0QiVCFQGB9HqDg0TrUyzRDRKxyfSiTv3IeBpctg2hosIi/aMDaWjj98XtckC6KtEfLDUf4S8x/ZyRd+PFufMTKOBxsfy4UNpmE7Z7ykEUAthK5Z7UMwR22WyZ37XtMtQyjIw7oleHWN/lqw1PLZt/qhkDsvfhHB+wrJ3Yo6K8nzC+bvJHOU7zi3xgA1UO26zNL2uKXCbAZcwF8b24vtTrcDkc7ZYZ7/0aXvw0S3O9Wx/9zlHzrm+wP7aCsYrs3uaifUxSYS5K00NkZoT90efcx/p4Rl/62Pn307J3Ov4x+qH6iGrmS3X6CwzeTs+QwUyR80l9EOs22COyAhKiDUgvonEh0IpNf8gIS5xgf9e9mixRIV8wmoZBFucE2fkzgFV1eQTP+jdGWdWiZPEDwwOS41xoAzyOf/NxxHQPEeId9rdAM87pwu4x1qGiu1lDSmAiqmhaSLJ/rcbhGDHWqPMwBosaAizvSqWDkvAt07bNXWXIQa5IVx0HdsXyiP/enBN8XP37TaFwC6DdJsO/Ke6227EMApBGvB9Ceakyctw326uOndqr3yMM1cGCMWr5EhNURt7eQ+La7Z80oMReUeK5NlD2u/X0Swt48M0itT0nvX9gVAGMDsrcwinWoorbOlXsLOuQ/jrx6GGyPOKPCRWUw3J1DGYIyV8NUxw9hHQQUI7EFUAPBMzbt+acJSQjPVxTkm5Mkj7QdTm5PDHrCHSNAWEAXMhQtD3SIfnAQ4OrFB3+BSxiYvgva8kdAFfqNeQtF/BDMl0YX2Rc1dkkDzsVtOQjIBluPwmQxe25XGHNsHQRWvFVeSoU+YUpoYiOJ8QtjnxC6m4Uf8chwqRlvjCGUrjIBrCwHIS+iISz8v1xdSAwFzV7wuEaavWMJlYaFZFZSCklqQSsFWiCJK6STLc60h1nqiDDQjmjNzVkCzij1LDrHGohAkkY6FNulJWETNd+BjJERGtq43Jklm1B+E0/zFLulmlsiuh5Sowe9RorR+vpd3l+6yEZq+EE30OgoZrtt2IaJriSGT5n3vY/fSHf5cR9uwX52SGjPmdBdIxznWctSGgujVVNyvRsZ7v+Jf5XBcIbnjEfiwhpJgm/HS/ZmP2hfGv8kL+HUIA/TTWWLfBz99QwodfiLp583MnyMd11ktfA0OyedbiAtoKtEHhdzcEPMeraR1iuXi2YLY2ao0KNn7FvJfqLvJ3d96rClIUdmxPwn0FZkcCWBM+tcRGwqzPEfKethmUoX/EUnlRvmdLqaXVtMiXqWhKW5+V+J2vLGAnFfsGZbvHOF9kcDxoNShhnjSn77Yxt939KRPi7nVGEFtcUzeoqZTaAldPkdNW+T3vN/auCELhei+IUC5H/z3YW02lPl2fJN1Mc9Rdlm2PwCu0d0uimcHQdWAsXAwWAEcOLkhpnKAMw5hFSjcvwkhqDiy8HA8GZktRH+eH0BGDKewp9lef97ptiBe/3Mua1BNaDq5L+zNkwSQ5SCEacY04ll7YliJyG/u2EeAK4db2XJsMJ0wBdbXQ+utT213cur5jCPRC65yHFlgwvtRrEhwRJIk2l8Cl+gC53ylE2aiP33VwtPPBADKaW/dwPxie2FMUrLneqYcyzKgQQTO6ljhIwZ0woI6MBaJqc7BWcj2ekyRTF3lowzJ9MaLiAULVjxDyvgptsMhcm1tugLN5RsbUfnjsAf3rVdjh09TThzDEru6m2xcCuwzS7Tv2n+qeK1EyNKfIRQKiDRHOvggxzkbO5zCmcUqs3fyz1Atkg6q9QRhRowMNDOLAPEAYUKRJ/SBEz0jykNgqZmJqTyaJKrSMo6hMwBpEuZJEI9ip4YEaCGLcg/M8X8QNVtM2fY8m8HUy4VIKUdcPghDZiSLYbCljFVM3zyDS/6lSRRuEBqSFDbe/e4xixWbuieZrMGGGGG8gATNst6ZwgxzsZ/hw2xLOyki/wsxNc0H63BgupSmIHCPGiSAkk6ZhjNzkfWVMlRHSGkSfZnMbEkFyrMFkKGeVMFoGcdCCIIJ9TgKIii2FBCxlevgrD0Ac0TaJ5lUIOAM9aEIyBTO6gL9UmEISsEGmdRWNxPwazCD1jsHwGADCskTeGUlH4Tu+6QM2UMZ4ZxPbYrpHCHYkzzJIMgpqD3X7Llq5Y0E7XpRQNWKZZ4pkLYz9DYJiW37hKtoE8tzRHGyjQdtydv0kiyY1NzATNPRmKNg+WHI3kfrhNSltllDJxJVSesfXixIdubRbh4zzyXOFjJi2ybw64hK7wAChgYS9ZqYSZ7Zzp+RVibhhxiak0RZ8k7zxPOulybqbwydmT98IZXuGieUvp0HXNhB3srfx367DIKjZ+bDidmqTxGYB1+33e1nLZRiQvnnmEQeCbkT5Q5vUSwhvhQuomLEPUphwi6kDmpv1PEN1a1nOC0P1l9k7VtB8S7AZta5VZ1UjCJE52ly7eX07N7vr8Ht36q7H9Wb+IjiM+fLa2hzHIn++kpkl83m9DzPDEmuyRTTBNoyN2hsPcDW5hlxL7gNC2iAYagu6majI2HkzsqXnd8l8+MTHTWrPLD86v8PDsg7O0yI6YHcW+xIM2+bGEnuRfqVyI8iwmOcI4dC2zeP4tRoBCmBWGQ+DFIh/7ONO6WZrwrzWa09lMLY/H6HDWbKW6tpyr3GsquAH50UxrsX4W8ISa6NYCDG3WUeOsX8yO3Ui36k3dZ/rTnY7oqa6VzC3NU1ve4A0N5xzttTw8TiWor1nD2fMi7TFXFiNa+AHhV0K2MCbNmlbUgDSQk1kr9yzI8ohwg777INRI28yoMJGvGKofnfbbGJIj8zUKVto2E/nWkwAKoU0YF7TDjWD5Ns/MpoODY3EPJyHsb+KkNS50IYeiAyUJ5zEVRHG3PJJm5DOv3ffbz8I5B3t9uv3bo8/5RBQUzOHw6pOq26mcY4PjE+QPmhn8pGUOpV6uJ0bL6ZHbozBTEDYo04frEFGwnCoZjd4g0ihH2JeZquBWl7NkwxI3irZcEGyXkMkReAHtFadyG0iWDf7vfg4DWimwQ5exXSk1DcMSjKx40KkKpta4zylZbQyFTQvSrDqS5ybRFikVdtIGUEIockpYbK2RntFzj0QAEag0r/AomSc2og347wk2qofluHJx0F/eARwsjghz0P6pSxsawqt1AJMFGVQMP2HfAXxiXXWiMQFKHlG9CWTlFE32ULbFCWBcEJqyD2DTfSh1SqS+XS9uEqo12lMAkWQFSL6YctHefSHfvRCYEzUWjhAaz6BqSPM30cxR0X5DM/WBPGYx9bRzX+fhMCSaKjiPwLJT/l0YqdkX8g3CdOgg7TSzGU+F+iPzsD+7ZQkaIRlW23Otg4oHVXyr6S1OwXCZwy8bmskOJXA3wxhx5wBFt0mgSXnIESq9xilmz7bXW/3d+sKohMiscFASqh1Q8ZywxEeokifME3udmqfI2PI7SN9g0Eg3wxORd0SfRXW4ADnmYzUWEMQT1OsO02QVjn82YAH5RZrhXOGWkRrXPmYGCyPFO+MRcCtqLjzWWnCiE8jkOCTTJt36bznR/UuejQrtyYH0STB9G3m+MhvrodYS52nPhIWAdGO1JwH9TVx/fb2A+mIS56rtC+aIJYdo2CGP7Ipv1AG+9yAWZtpAgP3ixKB1Km7AIbz0LmjmaI7SBYq5J2oC6IbbRAOaisrMCAevgp0N+591BefdX0492zX9idlLhrsMWpTtzMiUXZng3QuFCk0CsrB8JXJ1wl7j4ZN09XQ4JDRvcu+6+/nfrw9WZoMoy2zVd3tclp5ReI/4Nb1sLndLzLcMoMk9hIPRACCKC8/YBkynWprihris5hokY39h73aoCuraCTZSQJI8QRDprBuBbwZew6aR49/cF/SbNesBmd0FyqDr2Q6Yu5TbtQT/cjDns28o+goyzHJuYqW5Tab2z7LzwUjQ8dc8z3ObUvnX7zoPOcthDyLtCn8toBzwIzaTRHtkq/LjEWhqbJ9wo/tD/wJbuHCIHuJQkVxzRShyJvOBZ6LQ2X5Eqb5NLc38GvGJVmYE9Xsvt3GEPiY6OU2htRu1/9/AwGRiAyJu5ynZ5fQAhn5zchWK5h+aW7WwqRukag/HhjnOROaaa2zYXoGhcRXFYZCTY0USy+fldhE+QlS9/BFN3J9fSoV7sM1qK06t3gptYgopI+OCCUiuvHpZjpEeZNqj9h4lbqP4sPUh/+SG73buQxQIF7Iyt7SEAwQJnRs2O2VWZDRIJoYfaVysuxy3ygPcTIgD2tuEGcm0WXvaVNdJ6yqkj+1N1VMAjUTVKszuVIh2hcPkS+oMb9aSPwDGzgYzfaEnch/DQSlhH8VBGLw48ioJyz5QxshxtmeKNtn9bcIk4viPsxCi9PgZVytu1/mCCJ9HUIhDj0kjPog0kjt0JVAK80TsX3SZBtCcwRzYHctKUP71kvcZI4+fCtEb5f2AKkDUEUyH4x+IPlh+jJFvxdAyyJm52aRJDRoIkSfkac2+5nbCOw6GYtP54pEgg7uMhzBlDgOEAB9EDea/Mns7JS2a7skZtBF7pT1lq8JX8+AkRCsM1YSbUVbLcRfsl7xL0VCW/P1/MX3ATSKuPanUfrGMZLB0OZcO7wLLArpkzHke4TYR4CxyNpbZIx10nZ99qLhQZxMVmvobtEOZe5wSfgLZyAbd4vWOiIEquTFFerMHesqwK4Gk+S5aSSYpFvRJFmu89ww2AomIoIbY+kY+fdhc1ayUeJQ0LQQ5KiF7OtijorWhdCEGaifSYCxuPH38MnMhOlYT5eWamh9xtPIAPtItYk/kVHknBPMUdrrnOzsKOSDUeKeq0xFgzDPcM8NVONZQ0jRQgAlbIsxyXctjod2SAVsNYGOaJsbZbOGGEPDpavp2JE5ojwJZ7VCsZ9ZPm3UT7PUFjfkSIZO7QYaBwl789k62xj+P13r2seLJHNUc4yBgIF8YqoWN3netR0mhXZ0W9fc4zPB7xrIkDJQTTO0JBuFUAp4gjbq51PMoTCZdm+P5jMWrBnnjHhxmX1dbZvt5xIm55hPYzlhffbINb4KnqwYSQ68p+DMwAe2z7PT3N+6k812vO2bJRR31RhWqUeoNzrmnlueszzrdCLkJRh+X7EWEHy0wW8gzNh33BNtv7AWZkWSOTLSXW4TNWuWR3GuF88d1KpEbZj1zCMUHSdo0CyCHM3rTKF94zHPW3J8jdhYRvBgZ/XbCjBtH5h4cvftdoKAq2U37ULgUwUBN+ImG7cRfDSbc4cuQ4yrRdJVcwDzn0H9epBK9mPW5UGBIuehEZkikIbmIAXj5IbI3yAhwMMmmT3YzVPNkskts58IbTMrS+lSax4pXpZGGfWo5HkyEC0+NzhYhalBswByGsSmfgDmSASrTbcbtchV/ya/93uA7Pp8+N5o5sfhGrRA8zSZO170Z5VoWI2+On4HnPtDe0Uklm2o7waHNYqh+2EMBwi0UDJyFgzhEhqtdZDDGhIy0UC5X00H5YlsKJMb0Q7PYzKoRCSBKQTwtVo1mhMd9pIwkXmQyA/TsMgXTwRQSoTzVnMlfETmyhY1JRRVe25SKcIOy3ppV642YzUCKqh9EaGLjHU8zjV1F96pY8ePXJ+3bJ8N0eiEbkUS1waSjXv52vZ321vUVjBHZfouMpd4lQBSOrxZUy5zGDjsxW6++0hXZ8gYDID9uw5RME8pRvASjds+y1xhnmre4xy1bsuVKPOPb0HAeTVLVSEEeEpCwN8m27oGUoceJRH1inr8y/33Wk6WXaSif8XvX+RTePQLH4i9lv3oSs4pSCrmTafHxUB0GlDjueOwaUfR9Kz3LDH/JWe42WlswIPy4wIfwTD4m3nkRJxdXCKAwUqaQVDQQ92cQoRwgfEhjDay4fxcV3tu5avwd746T4sxjtG2fv76Bj1cFKZeU7YmL/2PXDtFsnl0tzcOl2Z8JmCSaqJRbnxI0ox0rr2E5qUVDvNqLH0Z5CE0fAEHC8j9kvSTwHclZ00ipkZozkLCD7G6XVPkntGG0K/wnOV1tXjHVtn37XNox4zbLnpWmQEVFqlvZV1/wiGYGvzd6Nv6UCNN9GsOJjQyPISzc/fsEvsI6r4qG9pIhXOaCE9eoc8Sp0Ua5KysRUzBlqnD52UyCoZLjYTrwkARltmd1Dp5TUhat/W5Zwk719HW3N1P5u8Z9A6s0MfXjXWuUaA9ifN1oszOXkWDnQ6a1mmGLBNfpOhKzF/nEsyDf+wlMaZd/bSiXta0vdRLcHvyiq3uYW+psO5MlleYVucn8vx1f3WX9Z4NCzNChYHkF4Y9CA6dneIV5454RU25zVpmPnUyMndgYPHB6UcoaKh4maQy88ylLfOdoSiWAib0sVir7gEaRub9KUDIfihjyTozjOJOKcad+QNOYKVFO81mG1fYI+L8IfeAALkaQhpLeZq/6rPlfhPMEThvBYa63aS9CAkNYGS/4zwo2rUGUyhM5vAbbtaGc0CJyJFhaX/XgQFZYAhZ+x2Npzg6QofTst10e0Ngl0G6vcf/U9v7kLaziUrUrmIz3esp2myQIzAnByujqbo6lF4735+uXvb8HDZQNuXDe3vTI3dBtO2XyXErFUEjQYRZCIaI55dhQDp7aMDGiEZqSS6szOBoTkQvfptETGp2PBhVgm4NCVYbLNFiAz/UA7OE/UAddf6VxWvQTwYS4DwNpFWoseI5EUsvdvc9JaSw2GSvYsLhxuyWLLm50NdKZwh2MArTp0NrPz4QDUzu9HvSpK8fR/F+tF6eG7EC4yVzpMldG0KyjcZCBLaObxUfYWKxqqRMbAeiyVJQmgLCCVRKHs9A8qUJnAAQOnQvok5pVhjIhtaVRCSa0MAgKrH1bAoRmWYcGXA8yb9C7n7gOWADeEl8itxEXuHsTD0iXdmEzJCYg7yRzE/yWXIVZhUStnGZ5zQ7lCE1HK+tlRiIe0Fx2fobUy4zM43m97wmmSOJ/DiklvL1u1HrpembyZII+IeZGMQDY9ZdcvF9iDorMAEjtFdzuzp9I0ZiBMZYYjxkUp0x2ZE+E30ZIrSZQiSGrV8pac5rzVuTdbW1m2eeFSECAjrckCULgkoo0AavF/DYWson/AWB0k8tK8w7idQM6VxrW4acP6iWIDQkNqxbhvI+COijCBRQMEAcO6+yL4V90X8p5mEuLJ4JqS73lLvX8OfzsEj9AOOgY+auWmAmWhCVKEpDqv1JelTMO00Q7YztlfCzPQZrQb6SVnDM750h6uMs+0FB/XVV5jLpg0mK1dJT65jbdTrTlc+vzhqZS4MEqM1Q06tZYoWDkjUtq0GU6kguISh8zVf4y6i9LsZSwnAl2hKNjrkjLItaiz3RazdPOtDDdME8KFxwn/rw1CmdutVYN/ChnFvnLDlq7S/jAL8C28r+12T+z7U4TJXi1OYXyUAOmjZdWhpLc3Xi7HF/EB+qfbVmOjKs0AR4dzJ79too/oTtiPyp4CEzGBLcimpcJ4YT1x+oeMZH3Us1f5NQ94b3XEfdeTpV3PARK9qMgQ/iQbSEQJxuhwAADcga+59ad39bqmHZZY787v6R85JfxkQ40Sfb4kshUmToqlmmzf1URnZV3LGtpbm/7E30X4GSI+DcMKKj9WatSS7Qe/bBLigIc12t0Y5VmI8w/+OOeBFpHP+ME3NLU+fwB/N6GVEDHTDwj4GNKmpp2WO0HnC/pNc8k/dd65Bhzb6jMonMx4CJbcjJuSoz2+a6xzcU1zu348M2Kzx0zCrAQgGTa889ogy8ZNDCx1bIgKOcIUb2c1+oM5eWifbaRnihlkjhxToqv+VFTLoJAFQOs1d9fYGSL/6WwJnXqkSBJdCEdWsNYlCGCB7ElRpBhiqEsV8Xdoy16rXVNnPuQw6RjY7svn3mIfBRu+NnHgC7Hfz0QcBNboiwpZoiraEJGiYAqKZz/j48MAnhMZx+9lwlvfgmHrZskPpTu90//U7itZ7+y2+vp/uPZCSu1ErGQkJEc4Rwwu6AhD07JIgixpkW4XApX6RlEhF4vUAAEj6GxF5AqnWiH6RHuefnL6X/443/J33l4OPpW8eepI6MYPwEzfAsUacI1yvjZFkm330ZPnWG8laRmBPjKU2yoZtPn6EKfZU50KxAhq5OyPLljkZIc8EywSFknDLmBuHoBNuEwJVBs3wBSCUipegvyAo8FTcMp13Czkj0TQUgO/pIXpG6zKKIWmdhmgWyzv0MDRXfhYmBGkSinqMTIV25ZhJVaaai+UMTArFMONgIk0xZwThICPiK3Bm+lifxoBamid+WBGAQjOQrDsMt4wshiREMK+8idgWHRTmd4uLDOWCfpTG9L5wldmBNA9maSfJDZ3GRNKSPl3iKSIcBtPh5w5vlQFOD7HsTJ21BHDCuIn/ahTyc0YOYFB4boXY3iwBVByHh3C3mwObdrd+cbcvAL6SbVCr5IaEbGie+Cy/pPOFZMHhbS/hkv4SCxJwE7BqaP9vhnHBMgyiV0ea3LxO63HQ373eHlxJzi0bJeHior/CPV85KCTcmshACvpZ6xjwM2Lm3lK6tzXYkwOZnzF2reSneWMBHXBFOjqkhpyW8bUMe6c6DNgA1keZ0G53aXqYPQI8XmqS0B/NahDTbk3UpxAk/MwCkRkH4uZ6aMEnOtSUOTB7wUGaYFZkXrzkf1GPUCE3sXHdlbMCK9rkPZY2CBm9Z0OC682+nZJ0KGHR0l8FowZB76O0YRxpoduX9GxJ7GBMOfy/8y/xEWz+AqWetyrpkjxsi0EoFJskAKgqcShCqvew9tsCXu4iBDRZk+FbHmacQvshT6oQqX4QA9Yym46McxwDh6gP2cRRfNbgKyvR3XoEBL9vH+nIORqRKgd+VXDvOx4+bCiGRc9JGBJwgrI2uFlo//DnX0Xq12F+NRM1Oyvhwn7YZrdR9IjNBMhM8w/5PR4NBUXO8BictfCPCm1XQRIMBaFkQjEBHUFS023WrKW1ow9yX4w+8AdJQ6MXTtGFrKuaGB2dr/svioCsGVNA0TUZJ4YLXZWpgJGGewkzcbATZkSkaMIIbc8oarEZI+lxxcHgBWWHsd2GwPUCF18vRTsaYPd45vnNilgZekfkCp4nLaLd7e4X5XmMsFwlS5Ni4/1uu4yM0VghotEzgItdEDYZoHdzm/WWYIE0GhZF+rz349ZrEWc6N6/jE9sDw6F+s75HMUS9wGq8Opf2cD7aMRG8a31nHxZTPx1KbvJtuZwjsMki38+h/ivt+oDSSDpQmQAAr6QAaI7UlOtL2tPvSnz9bSX/zdCXdf3w9/YOH19ORUTZgDi16/3JKJ89KDIuAQYZsnEaQ84DZdgnEBnLP2AEEB5I0yWeIeKpIww9UJtj0kaKC+FpKFkEAEjU1CF8j1rk5V9ns55GyLrHZzjbn09+c/UnaX9uTfr3nG3GgrYxBmENQ9kKEFaccCRFSIAGQRHzaPtoggpgBoY3D+NRAmLZP6ajMiciiBbKQOdOfqoL5xB5OHR/rxXwNRC6y8y0YG8zxNKsT6Wzd9TMKWEMTU+kjxPkQ55yItPltxCL9H2gSUknuU8cg5nkySRJbhvpVou25GetIkAN2VOnJ8LBoPETl0QjawKfSULUQouFhzGmGIYY8EFHGVJh4aF8QBBLUHTKArxBzMD0wgZanyYtheCtI3DW3kh4oiEIJBV83S4YB30TZEPcQC/a+0Ez5nL+zzXubtmVdjUYu1Na5y8cOKUORflICnlfkh9il8Zcg6tS4eV5T5ky7Hnb+MU4RjpvvH5XMIaHdYryFi+Z4auW6tU72XkmxMJWp6U6Z1Oi+svN3y9jeGudkhTnRhnkOnxjyoNvLdXfNKaW8h4HbBnPUKUnixxSflKU/hetQs/+CEfW+9ULzkI8+QAA5onsY5CGI6TkYpVyKOTtpe0OL6zf5NLtlZGIzz5X87gOdb6zHHgKZ9BCQwaAQN01kz+Z2EMIERVljfXhwZTfwOuRdjH9f/2jMrUXCbhehuM2shlT/JH0f3JNc884VfUb68JI3fHe0l7YAOtanPh7of1iHdfLH+WhcMxqca3On5Jwx4qPMkeNnHUr/Jd71o7PMjflBHYbxN2qfcGCzg1nkN/UPcq+3CSE7zPk9gzD/1e7Q3LTd/QmRjrB0Xrs32adyn0IH2OlVVxMh/9GenVtE0FVhbx3UjCq3OtZvlNFh/mmr69H2KwyQMFeo8EtL9InmMd+AmxOD35mpQCMPzmizr8nQhBkp+4faFpmX0LYwc+H7Y1lrOSDOcO3ZX5sImwvDJOzc+9BKy+iyLl27aiv8Ynkx3FTtOjA6a/gOxmUykgSNL+dJ3iG9upmEhtFVFXZZNY0Fnowp9SnmkRlucU3mxjP/FDT5535YgYHot11u0J1kPfZHBglsafPi5dhUaHcRmjzmafFQ59M+GFDFfSq3flsGflpVtJPvzg9FKiYFKUY7HSBarHuzx0wUY+0evQADNL+0FG0e57zBEmtNGYb9b6ENW5yvp14CuVSRiLqHlKu0lfYrQrCeFaJSroEDhcoIlhsjHJkxMchhyfjvToOzg1mOholRgHX4T92sF9Hk3bfPOAR2GaTP+AB/Frvn9nWsvB+iAwkSeK1WMbQ2mzr260+fWYY56kn3HF5P/+lvrqQ79/WkPdj6V0A8T9zXmy5d60uH9kAMsO9pFqZZWy9cUJsodj2LRH8jctY6SEOztQiCANHTCxFxAATXS2zhFuYwdUxErq3PpiVsm/cPDMO8jIBE5aQgHPrdkte5vxjEr8Sxp4d7gN4AB6TKCKwtLbAZs4HjOKoxuHbUEqC+8mGFkIUc8giOYCvPeLsCg1MBAWqe0yRAwzKfqxAxIrwhyq1ATBpVzgP6WmCNdzgPaRZTu4jGQxn6BOH1QCQwkISIHOQTmAVAiLBNo0MzabAfiSnw1cQhS5zpDe0yWF0/cJEos39qgqINIBydanuAsShWiWO2uwcRA19ToF6xokiLtxLjNtY3FNLg6Dc5CuZIX6p4hgodZ4k/zVbiBHYaGoQdfQ9NHmMT8Mo15Oe6vseFzpt0iBJ2iQOT7xIAOyXrKLRImiFB9oaZ3U55d7oWZVPGonUy/pYhWyi6D1j4EJmcKZpSBUG1U0E7XBMC+TwXYX1j+3O/CIfAHMjazsxqysjbCgmjmyXbls0ZIYYlsDr5BZmEShC7nYdzKQwoX/zuSwJqL9C6BwIHGS7Xcq7OI8EcKUm/zsT+gLO6mnAXo+Qf5ckhFnKN8XHUAx4Q12vMhR4YS452Tvsp8RrP6IFCrb+E5OzaGI1OJyBmiejFwWqpB9O6HojbW0lFdLt1DpKNuNDbHpK5qWFOW0NTYtRNTgejj6wL5wd/o/hLygS1WZdqS53zMTe5X/jhKBywtUrbBxRSQNS6ZnyuzL6ghrLQbm+rnp9K6pfR5nDQKfAreu54LkAYKqSosr9FshKd1Ofo/wwEZ7MDA6+T4FvTEDxTzGmYwhkO7jRCo2W6b6iRlaGRQPecLOe8S390cAYBDgKdFfZQDolexS90AO1TGcFUZp47FVCHZcn8z8lIsoeF3wnl3KrZXDT0Ft9CKw1MIxXTlX2m6T6EQECtimHWFYapNZKRHGDfEdYyA65ANeP5TDB+dfYXy7M4hggck5k7I3lWmc8lxk9moIk2LvweyWef1Y7JfPF1h0QO2lA00QxWFWbTfMlbLXk6z3pshMEmXJOaIYelAAGGiqL1Ixq0LaxHx60o2T1fBlpTaCso6ot+O9cocYn+2ruirNyWrMW08SHA8eLNEnWLc3zeGpwvmrtqpr4OnlSzJoPURABnG2ROZcMNTMSIgKdGItqsxTvr2CkYF4R3+hWTsazvFn1bGUDbSBl1cJJCTq0AavgieWDsILi3ikBRs0XNoGexrhC3dhoVJQcPayW76baFwC6DdNsO/ae745MwJWF/rOSWDbbJgXBKAV96qwzjspJ+48nVdMdBCEUO/Bt14+UgVrfjg3uyyr2J308PyBwbtZRefCEtvfpKWoZJKh0+mipf+UqqHT0WGpceHcRnfpZGrz+HdIozlGoHUn38CQItHExLMAWDy6PpnXeH0hn8nXrASIcPamaxno4eBBkN4JHCBi8BECYO0zBVP/tpap88CWUE0nrwoVT91V9NAwSIMCmBlGGQgVmB8YjfXB/NMsW4J7EVCJbNvoJZQD9IwWARErTWJRI40cMBuRDEp1Zn03WIMSMhSaRUCKywjkONjJXE5yrEoO2iSMppgKSQ0GcwgXRAXUrSwWQDPdh2U/4QSEekoeRZzUe/B1fixC4jVMY3SXpdNCldCb7CbEgTx4wMRV5KVxfw49IkRVOQbIJBhUrOaWMwbiA7x7HXaIEUotmdEYZqwzCW1ovZ4TqMaA+apIIRE3bUYoupXZLgZok7lLE9CTcJBPsqEeTzEgpqCdXEoBsEMVv6racGlOQ8DAAoOB7KBFbX89Sl9FOC2HItPT5pi+3xuwydsOjuj9dtW3ey71ECz0kAZ8kvhxnHH0QSg1bFr2OYwCGa8FjG9mT7JGb1g5Jo0/xMjYQlS+aGFNp6O3U7Z9SeCHkvOW9ldO6DOZpgzLYn7xPgMF3jobdhdC7grSXJSegH6slM0kGI/DtxAJIhVavai9aoh3ksMXcYP58G2qtzaJGWOgT59jpu5bf9cawlvJtr/dHHXszHOCANMTSaObUlmqLi83fLSVhogoZfxDpHBwCGG1LUS5ESg3muSZSqgeb8NAQcNTTQawQucK1uMEiUIiHu+Bn4RF6FbQPCjvXOGnCWqDHyvoTjzZI9cVW4nlaBXZ5dedbo+6ZGXAYr9igmZc98hzkCFjx2Q2KaITCAUMXXchUGZ449wDliibbDueFzWUtnu1ZStdLEZ4ldA43MMqaIKxDt1fIyARtq9AUNQlc9uX0yHi3MKhmXXzBFeRvDubFa8l7A9bwH5v3DoAj6ds6i0WvD3bgeAFjsrzbSuajgQGFRlbnpXriEZqM7WEN3c7P23itozV3LCLQMpqFwJDSxlLe3MsL4V2IOuNrVmm5Pmq4J902hjvsHM4nxyvBy/+I55k+RYnnyQ9BqOtz2sFc7wxXHaYC9zV/uQ+aRaTMwiPPTuorkPRkjtU0KUApzYLPEi2viCrVjzjO29i3PRzlRXq5fM7YQjAVjyh7AHHZvWoXZts3Onyb4fQG4eFxFFYbG6xMekj5UivMGbbDtFP6uKX+HiTxBQvSnct90D3Fuu56Ea22EowOwsJDBdW6KTwyRvkaeSZil0TXmYQd+hv5WqLjTWER/dt9uCwjsMki3xTB/BjsJMjBam1qgpSUlsuzASJ9OXlpJ45hsHEeDZHhPiek5CJ+/Rqu00BDR5dcwViC//jnOO/nBX6XG//1HqXdkKK0OD6f2K6+m1TdeS8P/1X+TBo8cSitn/iitn/sDCMaxOLhybebFVJ9/IfWf+Ddpuvdw+umrpfTUCxA4Q+v4C/SlN98vp/mFnvSdrzXSPQ/mjVun13Uici38+z9JzT/9D6ln/342/kpafv75VJ6fS8Pf+6fYrIOsMJlzU6/T7inM87QhFwVVJYLAOqsS0yDFfiMRhfmRzJc6Ju4h/fJeD8yEASmO4VuAviqYpA9W9Z+CmOqnHG3NRZR8XxO5woyh5gD5eY4NvwORUSvtEFGNEAXwWGVvYDwJdjFVmN4R0hcUnVYqy+nM/NU0j1ZtHaJyBQKoiRnNnYQ931cZp0yKpx32SfQ4RrCK84tXCfisaUWnMr+SIpw55hFGCCzCh4eclkI8Kb2OeVAd2bKwCGYQArcfIkUtmWSnf0rFZZiN8mXdRYpnqM883deL+xLMSlkrSuIZC8kgy+qjL8P2O57qtLd4aIdPcypfnaW9akgKDd72rGraVpi/dZiwddorbCQ+ooVWwytMYJQqO/4QJ7aqO/lL+Ei4+EhIS0H2oemJsjqtZswg94DcKpq7GsSwBoMZhsJN4lYiQ+IryHcnAbBQkqumwFY5f7YweWSRlFtz3jGHPOvobswm95HfkMsxeWiThJBpnvIvAs8L1HCV1thjk5Jhma95ylqgLZDL6Q7KciKu67Aikw1jPgYD8eD6WBok7PgHa4tpBkZbomkrRCzx1pJRFPt6FtP4ai3VptGAYk5mn8Ok7pMUynpBWoB6hTYTQKXTvY3GRG+BhRqEPf0jaChazGcYE34rnc9kMWMJjRv+Yxk8+XnaU6L8Jec9sNW0tFiozgqJ9g9Llq0J8CTY3tDS1ut4d2Yb8Jdch1nTTHYBf8xptOkyRx+S9P0ocV7VKIT9CoIazW0N7azpkrpKiU99nKo9zQit7JRyfymXNAd2jWbmrq+H6KE0f3sPZJMHCW6zjHa9mCsf0pyb3rKPmgsGfgBOEWRH8HX2PgUznuUWfnLA0vY7BxuY/q0Z3AeLgRqBIxZ6OKMJuGkm55wOrSCEdgvtkGvZ5JB198P56cUSOGg/Qqa7YQTPI/g6i4BA5ki/vD5geKA8nvaWh8MsObTcUZIP5+T4Wa47bpH8Nun2iwAAQABJREFUFgE7iAjod/Ga4h02HP43dwqfUwOjJiv8fqKkyEkvnU+2OTMLfhdOPlMkv8v25BnKfcr3Ia+7JzvtDQUeMGHfDAh0yinKsGWOf7SUT58Nnyw+c23iONYBSz0YQDKvIMhrVdgb3UNheBSaOO/7nPv8F2w+WxYJDRIX3fNlvmxF+HdxM/ZCatECIcy5O2vFvcz2GLihKj70MFyEcnFgO+uxF8YsAlV8xNqy9t302YXALoP02R3bz3TP6nXCyoJk2iC/ZrNFmO1BNmwJOXdMNkt3ZL9xrY6m5I2zvWl6QQ1DShevcxYPh70+OXYx9f+7P0y9g8Np8F/967Qyho/AM0+nxh/8QSrddSL1/d4/Tuns/0K5+Mrc99/BXIykdbRJlZP/QypNP5EuVv51+vHza2liZC1991storatp2derKS/JUBEC40V+M+9PJiN9vlzqf4nf5z6jt+V+r/73bT21sm08iLM1vf/Kg382rdS3/iEzQ01/+XGdLrYmkGtI1qCeQEhrYKImziilkGofTCCEkYWLkIzmo/3MwpySVM3rwM6YEPIzOEPdRXJ+6ptgvYM6R3PK42GYohyJF40Q9SJN0OOe6Q9IO6hVjn96OTz1AHRQH3elyhTk/XkvY+ltQkYsaUrSCTRQICkVlf70wTSv6tT16G36ulrdz6W/viNvw27/V978PF0tn0F5A7zIUKlMJGutucVJMuGLtc8wkZJvLR7IJAg5mSOjAQW/eWhhgQy2BkX6OiP/g5GeJLY89lentHnSfPIGAPeNNWx/d3J8iTBNAvxu/NHgmYAglI/jz18N/BCNLT7wZt8l5ibw3dkRgZwa1VbnpBAXSLwRF1nZEl94RA5Nh9agarR50fJf5iN0B5D2UqumCInsHM2yMiEfxCawaIEW23yUyZoAbNN6x0lrLwaR7+bXDH2PY9sXAqY698n8R5MGHNDYUR3HnjqtIdwckOsr3204AB51zAb0iRTQjSIFIq7xpi8z4HNFxm/HKTZFubWFe9emTcftQ1jbjdCWdZlUIgQAvB7mP6f6Bnhfpl88+kKc0CmzzKKPvP1lpJla+7W34ApW4JMYx+JgnKDbqmMLZlYo70wFZqwrms5u+Vm/uE1NRRlFqEmd0OYKrkWCyZ045EdOpNJUsqFEnbsilRcL37f7FMmu4SUXkapBpM0i2Zcgt/l4JrxqF8Px+2blTnKa+hmZUXnYA5kkiqUO44vYQ0C1+ACaqKKZL9GYcidR2qqbKv1mfzubHJtS3Dzc0uyh0MwWIswWGq9Pv4Id4qjvoiwScXuMUUSjgrPcjTTfFWT7RHWhudM9cOc9eDrOFGuEXuDtcIcd28YRDilmaFiFttvVDUFRvpyKRjQr862qnswWMkga3iEffc4WpAJfs8wP9qaDvJ0xehp7HeaIwqrYGsAh2aTgsTkfqJm3WvmK5Irt2xDuM8UorScvCLeka3hFv/c54IaLoU1mgxuh7X5ZaBibOLZXJbv7p4xbpRjHf20o80eY8CfPsY/Dlp36UR11AOc1OCwaKMahT9GoizBcARWorEKqVbQOpYV1rGvmEctD053IQRUE6Vpcj/9Mxqf893w4+4tnuPXF0I+8zICBgZhPxB6wsw5yYQBVlyhLlthu+2WsFzVWkE8wMVg7Cgr/N+ow8Avfe6nlOGeI+x20+0Ngc0d4/aGw27vP2UQWCSsZ2y17GFhwsYvo5YeObieTp7pTR9c7EmP3M9ZQmyIfZiu/POvVZFGcu4MmOV//nPMzniuculsWjl9Og3/m/829X3py3Inqbp3f1r5y79MrWefTj2/cW/qm3sn1e/671Nt3zcDQiv9R1L9nX+bVq++nKbR4kzPLqff/mY7PXgCUxUQ2ZdBvC9i5ufeqiRVCZmht1fOnUmrFy+n0gMPpOVXXk6rU1Op7ytfTX2PPJK1RzwrgpptL6Z3m1NBvPTjJCy+1cdgGSawQSSeFZgPbaUNLy4CCOQFgnHTFw2E+QLEKY8BmPU0im/UBFGyLkEA9hDStRcCxgNeN1LnqwjGUKoikTD9MAP3RDAiVrVNRgB64YNTmC02kowOGCoQ6JHBffgX9KfF1jD3qjCf42ivOLAWxmyeM5tkdE5dPBNBJH7z0a+kA+OT3M9SW83kNKzwUN8ShOMefLo057A3EvBXlmc4B2ce5oaBoz3d0nKJuvDhIbchZ3OYbCFOVmDTxoynDFLtR3ornJQa3phkkGTCJHmyJkrgSfz4aoEw/YzKb3x444p1ags/Bcl+ifFehurQoyCTKJtPW5JM2hLhj+chlNR2bd7lK23oTmq16BljwtylLxVM0Kowptm8UFrAfrchvGWk0R5CpOpvYl+2J/theOll7gfcqdtPpfXa4muoVTwlpGSW1U7pB2Ooec8t8ZpwbBPYZJzIiMeZj3jtUQbPx6RjzkBouBgXKXMKwud9mNspAoc4MhLqEjZqLLqT9QqJK/T1LHkeZIYo5FghtL0S8T4cqYWN5o6HIcirRktcn0sXYPzVbsWC4/1WU4woa6K0BGGm+W3R8Vst4IZ8lOi6UuDQgcMNWToXmFIBh7Ib1kfkLcoIiTf9jHH9hG31WRmaXhgBBQ4o1EkKBRAQQOhXoZL73BijTbyxhnZKMsDrhkBWwEFSMm+Exu1JAlOmYxiO0fPiFER0z0v7ZNAItQcyGN3J2SGzNdTRIm2dLd05P/p74Afnt+3tdMn9IcKRx9yxVZ4xNgBRjlaIud27jOaoyryPYw2Ya0iTeomYORRSJYJMsF8bynqZcjQlVmjVQOMpMzeKJu4OGOBxwoXXeGaANSxsjUJa4kgKODbMyVbj7D19b5gF0bb3Tr6bzr33fnrwC4+mPfvQxTI/3n79ZLoC3nj0C4+kicmJYJCjxwor6EtEt4tOKShzD8tzRNgLs3W0I67xy2fPpYX5+XTs7rvww8Fn16FjiI1mt4Rp+bmzZ9OdJ+6mn9wATmqy4PcyM0FGp4TCkitXLqdr167FYnX8BrG62Hdof1qYW0xvvvI6gRLmuTaUHnn8C6k2WEuvvfBSunzpchqfGE+PPvEFcNdaev2Fl9P87FwELfrCE4+TbzA9/dOnUpMgC+5nd524K5148H4YIup1GlL3e6feTWffPx14sAxTef/DD6bJQweiTUb1FBdG+G41g+4v9CP2IfrQw/wWFq47gc0Wxr319OZrJ2lrLR2583gwXcJSmFqpTJx4azfd3hDYuivd3rDY7f2nCAIiOHc7cZ7qc39qevalh1rpqZfW018+1Zf2TlQIyIDECWT0+RPyP6X07Ml2mp5fT994BEn1EFolSlmHCOtlU8yIigtujDILfkC+lyEl3GDN48bpgaqaCAQSoV79B2pI+uuEhI1IQuSV1JRwcHdXQgtrw4YLcQkCLO8/kMrf/lbqO3pX6t0zgd9CDUKQcNMwFGeXrqbrmMQpffcA2AbPXGwvpCpR3Dw0dg2peQtJW0mxHwgrbNzpfBHcweALnnuhn9Eq5lsNAij0Q8iuIq32kVWeETkGsUA7i6SzrlI3AjmHtiGwEv2/vrIY0X6+8uhjSPCraWYJyf3CbPreF7+ZrnJw7kh1OLRBV89PpanFd7EXH0vHj9wVpnSj/dgxgsipNsZHBDsIMbRvYCy9df79NDU/k4YHaumho3eniRraOfJOz8ynty6e5rHVdHTPgXRw314iDGFShabFMbes7cmxkUEs0JmfakRgKyD+YHrobw0SvlvyXpRh3m6tkgxhSPmBhST9Rca+ShmH6bv3ijqK5/302iLMy2XM9C4xPnrXVDHNE8YynGH6SHnB3FFWHf+GWfzZst/CTj3qLt3v5KE/SlmL8jxkVKlypGiUxG8pTOhmyOuc2wlakjpB2AEva5Yg0SdC86oyFITmhZCDUawEkFHDXF+2XYYva+oMFLKUDi33EzyBFcK4xrTyDcKkDqMwjYnMNO29COM7j/bIySf81GDIkC0y1/Ux2Z4cRfsoNSNBo6+cQg2JoAGkyCZqQTOBtB9m8RKMpocjdyfBERpkJob7QoCnyACh7O8yxOsYh5cONTYZuyLLx/60QOC2ZpCGat6LtlZ6kxK3NOwmeeIyYwZRrb+aUnc1rpLBHzfFePOkRxHU2dxWYbotpihJjcn6GMcPzNEdgc563JKhU6GBcdZpRwA3chQl3Ngi5+AoZmu2eB4NJqIirhT5WQvMgWX2Z88TKsorSjGXegeJ3+41Wty/lc/MCDljKK2otutBCWL3imDyWD/W1UKj2CYU+Tjn5mnS5WOW43qzPbHf0B/d1GQ+qsxtiXnXqO1kd0/3rSGsCBhnRkZTwSYm1FWu9VPWCozWRD+HmFOm5cmYnHnvvfSDP/trTKEJvz4BXuDv5edeSKfffjcdv+toGhkdSXOzs7QNk9ZxPP4Yg8YiGjYYuiY4bBgLiCo+NrY4phbdriNIbII73jv1dpq5PpsOHroj9sG52Znw7RzHcuHcB2fS3/3gb9MoZU7u3Zvmr12PwDtjY2MRMjtmG+28fuVqevvNtyNIUAR9oBbxlH27dnkqnT9zNo3yzOsvvZoGOMdscGgwvfzzF9NeTMpfff7lNDJCtFn6eu6909Q1mU69eSpg+/Cjn0uvPPtiuuteDgfg4HMZQ8dEWMrknH7n/fTsD59KY+OY2FLm1KUr6cqlS+k3f+e30/go52vNzKQ6ZvYj9L/C8z47PTtNvxtpcHQ4GEJAnubm5lILQeMAvkz9aO/eeeutNA5+OXLX8dSASVyYnY92C4dtuwa/d9PtCIFdBul2HPXPQJ81qTPJqISDKJ8VJOu/cryafuvLa+lPn1lL/+dfrKcnHiCK3XhK7yJFunillf7qxXYa49Hf+BXMAyrHU+XOE6n5V99PlXsfTCU22Pozz6b2hQtp6Df+YRrYc09aqd6bBqf/OK1dfgC75PFUuv5jkNyZVDr0e+keCIpDE+30kxcwNRqqcg7Savr5mxV8osBMYF61G/oNNdC8zB3ak8pHj6R1zORK99+XevcdTO2f/1wKMPX/zj8jTHAFBqkFc7QEtkSbU0MHA7KDxKftLZBzM+1HQzCBs30ZglY/cgmKPsruRZOls7dIYAUJ8Cr524YA59ySNYjHEoRQD1I1/iEuYZx8FoFvwSSJ9DVHExH2A8eW9hYkTTrmOMfkzbWLEAGl9Ej5eJg6iBSpMF2szyAtHUzPvftaeurtV9PxPUfSqblz6fr8VPqXv/qd9O6VC+n01Ln09TsfDcRoPdr+P0v+Z959Pd05eSi9d/Vieufa+fSvvvRbaJ+W0h8+932YLLQkmKS8cPZU+t3Hfy3dsWcPmiSoNqmZj5kkuDXNU70Rdu4d4r8oxhIz2ZOJbDVpSpGjrdxrwiSch8gHbWNGJvGxFXVKzM8wShdgjK4GS5Zt4DX9ks/WhMg2qIWzTL/PtbN5U9GGW/8Efgyi5koy6nFGDlJ2CTdYZcZ/HUdwiFF29VkilsnMSJBsEqSbNRWQ9L4MnKZvahIwfIHZZ3y9zkttouemyNSEgIBOrTCv1CZybHKqYw6pz5umLXMUOo3dndH7pmmLJnOeB6XDc06ZuBzCp0MmdI4AKg00Wtn3KrdzhDIPy8wCryDMeHBVfx3yGkLa889M9ixCEW+T8trmPuZYZQnBiBQs/5uhumkY88A9owoBO9Jk3rsWfuFESzlPZn3Qc1kYZRvxS0yOdQOYe8ZOLz4n+YgXzYoc963zcadqzaNiaAFN2dVmHxG7IGrZS3o5jHqghHkyZxp5tlkP63ptDE0d+1qC8O7FH4kJ4ASJvcayo2swguseyFlMoq5K86U8dsVlV9NYaShaq2mfJneOrXNWpl7G2aXdXZxz1r1PH71PyhwV9e/Y0I2bbsEwaAgchKYmWI159j6m2eCw5pDsi3TaNnqgqf5Grr5lBVDss2quZZ7Uqrl6hPUQcITnQ0CVify22jN8j9SeFCZ9+m8NYPK3EGvO53gSUA9D0F84d45zfb4AHqmnRoPAOZSnmeArMBkXL1zkaId62nvoULrzvrvTmy++EoxAnf3+4B0H0688/ngaxp9Wbcg0mp7nn34uLS0spPNnL6QJEOEMzMS5F19Ks9MzodV76LFHYMxOp/feehst08V05cJlGJgPYn0PoQl64utfTkODjl1Kb73+BlCAgUTodvz4sbS4uACeqqVTb7yVDh85kr7xrW+mAzBgf/Tv/q80hdZrfmE+7Tt4MH3rN7+TfvLXP0qnXnsjfeGLX0xf+cbX0qGjR9P3/+zP0wXatQemTAalgv+s5e07uD/WqZOWrSk995OfpRE0Vd/+zrdgHMfSBawvXnzu+YD1mfdPp5dgwpaJOlsFZ37pa0+m2ZnZ9NILLyB0RKCAtunL3/wq5umN9AKwyO1vpfsfeTDuK0hZQJslA7e4QBRbJuHn0OAdAldrmribbm8I7DJIt/f4f2p7XzBISouaRBEKzA0i28shcb/7ZU5oJ3jAU2/2pL/4CdHWsCgowSjUWzBLwyn9k28QiviASPpAGvqXv5+W/vDfpsX/7X9NvUinVq5eSbVvfD3Vfv0fpfLIgdRzz3+d2qf/p9R76n9Mq/jjrDcupbT/11P50HfTMZDn7z5ZSn/ydCv94Q9AiuXBNL2YCVWJPumzUXxx9NWp751MQ//0P0qVv/jr1PiTf0+DIKgI0FD64q8GZZDt5JFq4w/VhOirIQnzQFVNU+pI4Fs1CE8QbAvTokNIzgdQi/RAjPVTdkSxY+uXgGqDKETy+iRpchCaDXQavTBg2oFnMoSNPygdh1/fIwIRIJE3tKuI3ghNyyBk7c3VhI2gDUE3BgGgEVROSrM111IL8uqFd/A1aqQv3/Noujw/m67OXoMIgkBuLqaraIly0sSlJ83WF9Kfvfp0+uY9n0/ffuiL6b2pC+l/f+pP00t3nEz7xybSz0+/kf6LJ/9x+tyBO9PzZ97C3IVDcsNETm0M2JIk2tqJ6I+bO7zZVcN206Qw+clkZc4YEmZQbYEKbaOE5wZ4yEaIi3QGUt+DYIeBFdYZcb8JozoFs3IRp+u5aF2W6/usjJGhamWIZDzCfyu+w4jgV7OlgtyUW353zi8Hl4tUG0a1uz9q6UZgkvQPWES7YvhhzRMlsk0fBjfzbNdMOOqGdNdZWi2G0mo1S6twAVOoNN8oLaMVhIiUIAMedU2ZWBeaAy7zuztJFMuszq4tAUNgHlolidKcTzO9OxjrcbUJBYAYmDL9NcTvAky6Z7bo32EkuzlgX8wJ6xHumgUNLKyloVn6wvxVSdILoSrho5+R5/moJatRdykEAd0jbSkfIzmhTPR3Q3uUr/xS3/V9kchW+NEGrpyYFMS3jHxZk9mb1CaxziNojGCMCDgw1SjDHLk/tdE0cOgrVPwAk3kU36QBTL0CgMyb9SH0yAZxIdhELxHteuvMV2AXaRCzX7RMUPdkD4hv1O9YFKa+zknXVpFkg0YJ0KKGZpbzmNSGxkG1aJcQ71DGZl6fcS4uEoJcU0Bn5cdNxRNbS72xFIdQUyqj8kmNN+qctVTHdGwcZtw+ctkIgvZHX0A1RU0YhCZRDw2K4hrvR0BVYj/XJ9L9soaEQtM1Iea6V8Oywvg5Hh6iYATQEgIgGXXrVHDiPRnBO+++Ky1x3MTC3DyM0tmkhqe+sMS+3sZU7RIMUz1dvzqdTp/+gMBAtfTm6zAnx46kvWhCTr78Rjpw4EA6cd894IVSOonJ2xXM244eO87nVHR+AS3K9avXoj0foJlxvPZM7g3zvcmx8XTqrVNYHQB3mLMX0V7ddf+JVLt7mDXaTlevXEOTdTxdg0G585670+LSIszTYHobBmnfwQPpOO24BGPU5Nl7HrgnPfPjp9P9D91PnuF0HIboKRidI8cPp8GR4XSJ9sxcu47W6ERozw4fOwoo1tIpmLAlAho9+Q+/xrLi+A2EhpfOXUpf/t3vod3ak86cOZPOnb8YffcMwJ/+8MehDTpK1NmXYYpeffW1dPb06RiPO4/dnV5+6QVM+l5JU1euxDjffeJE+tvv/yi0TWp9HbfXXniVtv4sTe6ZxITwSjCP3/sXvwvdwDzfTbc1BHYZpNt6+D/9nY+zC5Qid5Ax+33aN7ye/uMny+mRo6uYcuEYC/9Ugeg6MNaTHjjGwbHjmO1A6KlqH/zOrxMgYTK1XntVe4RU+epX0wBMS4UNXeTZf/R3UqM8mVaIXtcHIbw2+Z1U2v8NJKhHUxmi4bF7wXGUfXUOgoANvUm0o//wEySjAyCekYn02w//Vjo8cgcERzktfOsrqW/P3jQAYipDufTefTz1PfYr+HYoIVxJg5gl3Fu5I00SrUsi/fWZD9A2QJ5j5uE5SpouTeGU2kfDjmHXP4K5mnSFAQ888LaplBmkrdZDAnKW10wviK2f6EtoZSRcRcpBNHSkYxImngg/iiZgHuK1LrEAwSvpac5jfaPpOP4g89QbRNSWKYNUlTKfOPZQ+snyq+ln77yEQ/Nwuu/gUQhZRLCMSUb90UzK4xBdYDyDid5X73sMc4aB9OAdd6ZD43vTi2iLfv/gd9NXuH766oW0SL6JwbF0x+S+jrlYSuOhwZE49lwRmbnNxnR93bzY9U2CSUZB6bWapM1kC+2pDBgkHvNHx9+i3eaT0JkBNu9SyR4ODB6VKGUMZIwuAykZJbUG3W2Q2JEpazEeMstxMrskJd+35rSGj5+c8mp3ZL666NAoSCbJsLkGmjBCnBHGDJdsRCdN6jJhayu6W6yUHK0qz3rVVppsbwtGuEWF+hgJC6XTPUi/l+i3wRcCidAI6/VA3BXgt0zbLN97atmKJMs4j1ZyI1GZd61VxugozL9EdNHGIp9+HD0QmyEQoSGXgf0sfeJCkSXarZarV0YCHmsVMz9N+5womleWOXtHs9hVNCQI9FOfwRns0PZUlLkdsOazugJszP11yveQ6vUhz2T75WuPhINjludQrjwYZGAvYW+wge3+OzbPbi2gFL3eLKUr9VKaRzi0xl4wNNBIA/1oREsN/MtW0OzUInz/xlygiviOMEWtoIxSWmQUF/Bro+BgjmCSbFdoyPlU0+z4BSPHHDNpSpnN5uJnvJnHqJjOE9eiPj/6pG3U3cnq73ywrabNOw3QZpnbvwkh65FRyU/mEmzv9np81j5FhDP22zX283kY616CNAyNYAoK8awYTbNA15lzZxmYa7asFpVoLsCIawSnWWM8ZPNl7RWWMBtYL8x2Vf0wR+4PtuAqO1eLTB7DYM/1QHL81DCLAyYg0tcJInTuzAfpIozAfrQp12Bo4uy7lgFLMAtFyySTomBwiHCsj+Hvc+Lee9LFM+cwo0OfzTpBKZgunLmQjt11PH3pySdDOKYvkMyHxzIYylxfpPpCPY3fO54OHTqY9h84mF59+RXWCmH3R0fTKm2vL7pWhSpriLpNMT6YqukX26Yc90rn3PvvnU6v/PwFTKyPpocefCQ9/9RzsZ+yoqN/RuXUn/D8ufPpuZ89mybwS3rk84+whNfSPszwNM97hcBFP/7RT9KvfOXxNDSEGSFCQA9Bb8GgKXSbmp5OFy6cT++dfBtBRymdo6z/7Pf/83TviXth6pbS6XffS2fPnk3//Pf+k/Twg4+CD1vpnZOn0hQmgN/7F/8sPfTQY+kSWrheBC0xIozp+2+/A8M1mA4RtXYE8zojxOZ7fOym2xoCgdtuawjsdv5TCwEJBRkknVPdvNVqeLZPG4mdOoCH7uB1tIIPSpb61yo9IJWlVK8b/hvJ9CAoCkle9atfS/1ffJww2/htsFG6eVp2pF4cwg9/N7X3fp1tHqQogocQEmfMEwHr+y8hHeRk+W8+AhKAoPjBayA7kOUd+2Eo0Dg9duxXyItZFdL8RQ6RnfsSzqVffDhNUs7Y0J4s5Ub9L8KqwiBx3A9E+CgmNc30Bn2bxUxBDdEA7apilgE9kaaQAPcgWb0bk5keQpg3kLItolFAzghyXgmfjwXMopogcJmrPs1HZI5ABp1ebYy5qK0GfPpBXoM64oPJJe5FeJ6JsZdnDeU7AnzbmnPFnYwkI/oSDTo0ujd9+4En0nUYn1NohM5cPZse2Xs4zKSyp0ugm4CpBJ1J7ZZMoFqr8K1AEyah8rUTjwYBcn72SvrxqZcwMyynR0F+Q2gWDkJ07eMwnWmcoWUACa5H+F0CHtDnQpOwExEUFfImqWSQAf1ZJE+KJNq3L2p9hI8sRCYFihwQ29RzFdmv8B32WceUWg3MkHu0mddvIv0GpmFtiB57n5M5d8rduf1xPzqEs4Sp/kPdSTjokF/p4YBSYBeRymDY6pgFxQGenb5KOPqnhNz8+qHlNubyAh4QVPqEWaaaqR4IqFKbqHZc81mt1GSe1Di6DmXE9FfSFFNYGjTCNhY995mN1Fln/RBORyAXRxmHTXjlryGZZ94EgUYheEjkCHYdYnyjLLPzeGMY3wzC7hf1WV0/5fapJcFvYwWiy2hYaxUIRbiIcotWmtm2SDHr5+Mah9CMw2K9WdxnHa1pTscLyo2JA5OkZpaXj3Z3rbtdn/S78JM4l8IWNIA8N9PravW455gV894Vrons1UZvurxUCTPG9d4WAQfqqdqPGRNmdX0Q9DL4NSK2aZJpEI4bGi4ogLmmdGv2jwiTrowIYU5HV4F9UxNi2qW2xD9HtVhDZdaGRoDbk/lkjExFm2/Mk8uxb5Z50+RNYd6V3M8021O75k1h536mJjRC1duHbUlti/N1Dca6hWlmdZgzmmR66Zt70xwarwX2b+e3Gh/hUqlhioqvkCZ2Bq23fJltlJUIUhrpEnmJ98a6XIYZYo9FlWkU9SlNBlkjcdAvcMyaKc3zgC7t7Ge/U+PzCsENhkZGCG4wwZorpRnO0Dt7+kw6fuIu6mf+0g7eIvDDNAzUJYRNmr4ZFS/7WsLkwTzNwjBdJrDC1amrYVJ28ey5NH19Ot11zz1osdAGwnjY6AY46Pr0dczlTqX7HrovTN1cd7bJudGH+dsdMBAGetD8+/R772ECuBRR7EYx3VvAN0qmZ5xAEg/D9NTAZ/vRKp2BaXr4zvvS++++Q+CJvWmKdvz0734Mk15Nn/8Hj4eQ7Bz9WkJL1g88G/hLaRankMRUAyfejZbp+efBBUNDaXhyNB1uoy3SrA48L968dOFCGh0eTdcxKdRE0Wcunb+U9k3CXE5xDTgu4Yt1/dLVdHXyEv2/ng5hEm/XxPMGidAS4i6YzKtXr4Yg0f5G16MVu2+3KwTcRXbTLgQ+lRAoTDhkktzoZIyCYYKwMUlQ1WoEY+gQL22Yp0UkYpqzaaIn4ikYoR6CBUBLumNuXItCRNH8lznQ0LxK+UQclu0mvob52d+9QeQtAvuUwJBnr/Wkxx9Ew3MQx9XmAtHj8J0BUYfvCIRiGQL/ggwHGqD7iTB3rH8y9bGhZwYGFgyE1QPCaosoMI0RQSP4DQLUwztF70tI7q635tJsM5sjzRMgYhFzJ2SDqaEkk1UdYZYh9AYkeME1Sm191sNPu5Nl1iAmRIRGQkO/hWkWjBbmcRx4H6eMCxjRpH4hQQaBnAeR9g/CWGnO99S7rxKsoZY+f+ShNI1j7A/fJCIRTsMSdYHIeViGSCJ5tDqUDo7tTX/+6s9gqh5P7127kC7NTafvPfL1dGF2Kv3orZfSdx/+UhpDuvmTU6+kc9cuE0r8YQhnJJWUcxBCYy8wx7PKcz3TVYi9cwCoDYWuZilOgN/ooK3Oqfgm8d7CPDHgLWBISkBzUupMRC9gHlqSzv3OzfjwkMRrvAq6rPjszuN3CdtMXPjrZrm898mTfXIuRrhbTKV2JjjV7ECUwiSpORtkfGWWhINjoiZOolYOwUhkEpjdDExueS5b5qiXNaPwYQCCos7zJiXDOqsbvlqDP/3YhGmU5ZpxTkrQfUjygGO89IKJF3ZFcv4Y5rhF2SWYExVCMzB5c7ygD29I4QsS9HfRcqEPQctcRQ1LyYw1bVohhL4a2VWEJtU5CFmEHXIga0QuW0N70AOhCncLt4XfD+ZUHgTLouesNHQD+OmsY34VDATVFPtQV7NvaNcnvSCB77op0U41wKvY7erHtyUSZadwR26JPePcYjldWOCcNZ4bGphPw9U5AtigfWAB0fXYz0qs+aHQMtLProbH2JOnmEsBRerlNFvyFTDNTFuMk+Pb9XynKc4q/hSCFGuruLNZ9uaVnb/ldZmZcDevYq/O1QED2lW0syhBJj+0V4ylXVU7Y58Ujrj36b+3ddow79mPZTHXNbmUMGcuOls1LdUU0GearJnMcjHPmSMeysq0Z04Q7ZH5qcjF8NDioDpjtkD+VUP0Y6XlMQ39wEmhCRZ8gXf62Zutyj0tYE6NVfY8tSV3wgS98uLL6QAMxhDmaEMwBlXM6YbHRyLIwDLCswrMhNYALXxa33r59QhkMIoP7R1HDjPWmazTz+bnP3suPfuTp2CQrlHevmAG1CItzS+EponA72l0gDiUWFRcwHzNQAia8y2350NgZ+v6gAvdxVzuQQIrvBWCLBkuw207nx565OH0/DPPp/fefic9+LmHiUj3s3T3A/emhz7/ufTM3/wk/fCHP0ozBE346ne+GXnexSTvHqK5voQJ39E7OZidtfbqSy+n9955N03BoDz2xS+EeZvCDqfck19/Mv3wBz9KP3/6mYCRh6jfdc9d6R4YJ++fpE0XzpwPn6cvfevraS8+TWqYDCqhr9WXf+3r6did0+ldrk3DMJ5+57108MgdoUHzWInHnvh8evbHz6R3T71NGQvpPiLoid8d3t10e0Mgr6TbGwa7vf8UQ0D7b4nEZrMZLze2MlKlIHDFQCSj/vRBWWVGCmkyz2heEBqVoBjIVHzGE/4UoW0S+NaRrylBzIh5ECLrt5/ogwgh0s4liGYI72883JM+/zDItbyUztevcVoLruwwISaRuT4Ei6j9jQ4nkX64NonEU2mVzBeEK4hKJLsM9d+vuZEYGOykrbQIdoF+LsE8tdB2zYO8B3B+bvH8YIVIfBAHFZCjZivCIUwaOvVavwQNlkVBuAsaZZyDEAeaVdm6EfybJjlNfE5/D7RiMzIf5QaHzg6D/iVXejCHI6Q3WiWOfkp3EB2vD18GGZ6XzpxE27WAn1Q7feehr0KUDaaJoYl0bA+EGdL4oxOH4iDdGozUb33+q+mn77yc/ur1p9MiZwF9+cTD6cSho2lmcQ4CoS/98NRzHBJJdLuDxzhD6SHO2VlOh0HSU1ATsr4epmm4hBrIeYDQ7S36vMD1fTByGt8ZcGARWGmgI/EvISPhJP2jyUz40PBpn4S7+idfzpaAkQwSP3J4cC5uS+bLKZM2eWSLa/9ffmbCzz5KRkKy875z8rrz3WALStglGJ1aErFK6iUAhUUm1zJpar9MOu/3YTYnc1T03QNOo0zuR5AI1x3lWkdEkIsnrRPY86dPkmZixfOd2xsfLB3akevfuMgXhRnhz2f5rCOJTX3BJCztw45kjMWQivbpXK82QzOmfDV/rDExmkSyXKUvVTRJHkeZZH7wvdF0LojXYTQndZiDhsEmgO+QzJHEbe6JeW4KdG79Ism56Pg4ywAt64jxhkFSiyS/tz3N4F90dqGcLi3JaLYxUZ1JQ1UjYjI7aGeAl4ds+xBrZQiNrHuSKWBFCOpetBCa7slo9qA9gtqO+8VcMF8IGdh7itnfybDxYYmeB7SuWvETpGjLRsusGbjHYFAYN63XuaovYKf5G7VodqW/U1GzbXGOyMCs0R6ZpO3tVnvcg+DF848qMNetBqa4nFdkBa4Ew40rHLJPKtOCW+DDOtyfjWJqPkUHi+RZgYFZx6xOwYQHjq7w2eb6GnUY5CEEDTKdPGVbuBVl3/fA/VG0QQt+7f9t78xjqy7aPf6U7pS2lEIpmyxSlgsBeY0XWSMGCC6gyQ0ao94QTQD/MEaMiYkL1wWXKFGJkYsgaoyJiMbXuBI1LheXNy7gyvLKrbzmAlXK0palFNr7/T7n/NpzTksL9EDb8/sOnJ7fMr9nZj4z5zfzzPLMnJm+5qYHjBNcAPPYxRh9KYTyUompdZkY+Rkx9t98tCQXa1X7Dih1q3fnDTnP1yJBsNeJQ88f5pHcC2Vm+MgR7p/yaKmOa5l6DRyC8oEOKxhSmD55MpSjXjZg1iz74/92QbFD5x0MFfTHPXauQaBbuaOS9BfiwOmIrI8KME2uuFexDcL6o9w87iEFpQm/2SzUwUMHD7XMGRg121NhI8eNsqHDhrCnzC6ZPdPTTUMv2Yg/FULWqRWYBtcf1vpGQEFJR4cIsKGs19uAgf1t5pxZtn3HP2FIASNNOdkYZRsMQxWlVggrsBwhqsKarZHjxtggxJnrsLpjlKsafkePH2Nlo8pgLv1XLzM0XMH9sAox0lVSWuJW60rAthtmMFTs2o1pdoOsbEyZ5yfD9kxmIZILJQHUZcFrM5TpV6K7KIGg2LKy5zEVJK7D4UaarECoINCyTeC4+J5KDhfLUkHiJ3AuyyspNDTRG8hzKi9ushvHPHc/wQPRbyphlHsESg0M4HgDPB/KUlXmQfu6ptz2ohcOQaJhgyqeH/xrcpgCge7F2QXjrG9GPipJNNIRdmQBMHZtR0X+1aHt9r+HK1BpQyHpWYAAsBwAPdq1tYgspql046gKpgLQqELfnKOoqKEEoAL3hhXj7G/3SIiszFnBH8DeO3WYy04lsges5BVC2SmCklQIq1Z9oRzlYs+kgzAeUQmz2uU5mMqWhw11M0phzhkth5wC2w0jDNXYpHcoejUPV2NfJ8wTP4rrv1Ri6gKe69E9H/PXB6OixH5NGOU6gjwZ1rsEo0N7sXC4DqZe87zH9cB+hAEDDj2gSA0pKUUjFZUtpvgdQyOt/K89SEQDlKreNhgWlI4fqoRJaJhAB8NBaCBmIg+92chEgf8BNHy2YZ8d7rkyAsNnJ9CYp1GJasDnPzZD8nDvBMoFG+FUKI5CFs1Qs4ee0864aWZs/rCxwz1KuHlu7PUg/1geqJZw81k2hBIXy/vUnGPY14Ot2bPgmHQ2XPLQosvDnitMew4V7TMJC2k5CsWSa5XofJNFpJq/IbLyRiXSGFt62XLgCBl70nmdd2PLmwuK/mFD6hDU1qMo03EOkeU9Tm2ilcCx6M0ehaNYObXozXYLbphCxDUJhWiMcu3Rlvr99i8Ye+D6kGat5GggjBPHBrjxMBVkxvRkfHIw8pKDUbZ0KgRMUKJHlCVX71De2HBrdj8aZjK/WHZpBpvrcXBoNX+h3FbVW35fNNoLvKXu6WK+V8PkenlVlu2F2fIsdM4U5h7AFDCaxseDnqBIzBh1NuiLMwq8fDfGF4YY0vbBmMsh5BHTjt9UPUfLesHkJ6abBY55cxjlhGvbEhEFfvjNaV5UwDh9j2HSBSUoNn8jd+L/0h/TvafuAEbB4suMh4l3g8tkRgTCXT5eUXgn0mQ3RzQ9n6IeKJNl5dBx2lVs+k1SHiYZYn0jNgMHxxqMJlZXdrNe/WC4pgBxR36z82D3sQM4huXIaCcAYxykPxvKpu/thbJci+nOVTThj3c5189wOhzLOJXOE+j4qoMCmoFRiwGYOleI6d1V+E2UZfa3Yqzd5FYLLheCfXQSzzAMKlXchJZpYKcXNXd25xzYv8/+8ekX9rcLJ2BEZCCuoJiwwok61o38DXvdhWNO9+XaKfqgklaLjcT58ylChx1HuCiXI6xUJE/g/diQid8/3l9BOik2kOfvNR/iQZh4H+MGe9zQwQVFEXmP5CMcjHyyHoUAl4x0eBwhp7EMMNyoXL5nyNE9MTqQw1ka3HuKxuE5ZZmWAbl8iCWA7w0SYweOM2FnCkZ9qUtzdJEm2mkgiUZZOCL329bfInkBmRMvmYp1T30i8eF7jIxZLvAs5fIfvNmwvFKPg0dSf0JHoOnNF7qkK8GpQCBQXLh/Anf15gucH44SoBMVL8RIKiP7NmCqA/xx3nLgqEQFU/NYuVBBohz2gAWyA7+x366Y4QItHHFheH4O1jKgQuQ0iwr0jNWgQc+gWW8wEnzp0vE5vpWpWLHirMaeRyVQlHjM3nJuJkhFho12Klh82/v0OFRGx6H95GXlWk80WLipahZknMAc92749ETjPw+VMefZ88OGLZu7NDGegxoFdYXPla/DdKFaTIPLQAMrx+d6w0AEqplCGB/Ih+lj3wgU4cP2nvVGZXQQjYMqxKUUYzYn0OAvRkM1D2mrran0tTyZiHe3Y9VWijVS6bR+BQb/xEjS7uoGG4gGVu+8TPsGvXu1J/KtKLvSdh7ZiSRhjyoofOf1HuBW4TLR41qLUatsKGd9YAnwPOyj5L3PnOoBm7sn0KihJbP+gEkDFex5dLaId3ZugZUiv47A4tW2Y/vgD1NR0FNbiNr6BBpJkaqU+YRGE0alaPIZdSH4mu2Adb/d+HCEwjMFfwNHFYx5wAqbShIVJspiZc+Kn6MuNEPM6U/sXc5FPmVBoYLoc+LY1GAjlFOlWJkHa6s4Ksjz03Iok9wI1s3aIgHsgec/OpSuqDW6RJkMvym1rYVJfxwN5ZoZX08TE7lgVMeNN6AkRtUQb1CyhcL1YlxrxhFUjozSFaAhOzKt0MsODWXsxVhhJA+bBFMZysEwC6fWRfKOudfcMd6eWkzz8YXb9NSSR5Q9T+7J7jcXnbwrCBNZjZ5vxgFl0Nv3uIj/VNIPYtruH1UZUI7Q6ZK13wryDkJJouLIyDblESPEdyMVarJxx9vodKFylE6z3oE+xTZvFd5FMPCCIeNGMSz3KPUtIqI8lkkf98a7iFyD0L2MQtHj78lHeZigVhzLTPAsvfGY70G+P9kexqvJp4jGljuWnaMYbW5AZ0sONphtUs0iAbHhnOgolyrTIXSQcCQ0G6ODVXgfHIMlO7yy/FfPEX7yqoUpf747gnj5+ia8k7MQHjsLaFYaugUUz1yrQ2cQjai4cRZqC4gwFQm+49noIhkqvrW4dhzPex2BlwvLGNNGy4sMiF+ej9Fv4IeyBFn4LXFK3t8mTbQiTMNrcEUmiBmfoUjUAww7cIw85Pjm1Djm9GjGBbqQp5MlhvFFkfL1VMeRGD4S65h/lOtlEJHBITzjXYDRNuaPW++DH5pC5z2aNmegLAseE1zznE+QS4WSIza0aJnBKQLICzp643O1mGlw7BjqdKS9AeFwhM7Thwh2wzuY5YBTT5k+fwj+cCcCEBEZNWqU7yN1GJbvimBRtqgYe3/guhtAQacbAEbSAgEsuYwDVVKXBZFy4SSgEaRw5nuXT/Vh7JvQlourHKKeOZQf27CjBTi+mGOVoWDT1dbku6IDD3zOKwxUChHlLNJTuR+bInKNB3sC+eZtkh956fJ5Tm1jLyt7dOnohyNc/KYVuf11HAfBCxstAvaSNUBJ4jPQwbxCwxPeVGHlwEYtRzICBxGQgPuIA3smWSGzMjgMhZDKI0fauG8U77DCyoMEzDCJxAGVFddM1aGSqcHFfDQQeJ9VnU/nArMMBJAGxcuVUfjluiX0m6ICQ4MaezXVHecoHhbAZqIBAIWlFj30WdhzJQOWs+jY/GFPI/df2vXbv2zj5/9jUyf9u40cMQI3ESMmhZUdHeKLiOFahKX3MuIyw8rIxPQWpI/pPAglKR+p8ak3/mDTHwQP/6j6XAyUU8ji4upD+JALGbbkGA1W/BFKEV/8ywZ57DPIIZQr/o04KrxUnpryvSXp7bvGMsRGXdCUjMQziEH7ZAdPM41MR3sd5bARSRUozhE78xYuB5wLoTwzBbG54ayRzsh+T+4Vf1CeIQvqLSz0cUwg9olIA5S/80i+wbDDX3vtw3c/wDqK0VjjAMMpUcd4kd/ZYBeEcabfzizKjTLws/Mpdt1gnY+942Tg1zF39Ag2wSZf/sa6cdSIv5UWHN8DVPjZCGx0bMRiGnLs1Ejec6KYIsZNYQNp/KW0tp6MwZI5mQbPRGRFfjM+quC/k/j7jXGJHjCcwEoeL1GWS3WhHAmMlKf4XIcnVzKYn0hh1C+fp+Mz/pvEd7wDT3+3olGOBjf6a7x9npWNOEY50vol0x37jmUc+d+NIuD7KNYD/X3d674OaMql0yPvFX8HREND/rCjjmvJuD0DRTPPumMEimtBg7AYO0ad34mO1JgO/uOxPxP9/ST6TTynPL6P+OFzXDnFUuAr83jd/9ET/uN+dIAoUUwL7zTEFv8DpTbx3ejxjIh1WUxbovO4MXzmXyTj3AufpVwfyYoCIbe2kkwZQbj+zWf4IByZu0LkZzyMCo6eezrgl/lb3KNn9Kq+wkhAI0hhzPUUSDPXEHVm1wuTNtrr+mLZeldx3Hv8TN23f/zD/nvlc1bSp9QumjjtTMVg1Oj0mLcnzmccST2YVAKn2nw5UL7HXnh2tS1YsMCunnlFUuMgYSJAAvvq99mLK9fYjBkz7D//4zpBEQER6OIEYrqRunhKFH0REAEREAEREAEREAEREAERaCcBKUjtBKjHRUAEREAEREAEREAEREAEUoeAFKTUyUulRAREQAREQAREQAREQAREoJ0EZKShnQD1uAiIQPsI0JJgTU2Nb94ba369fVL1tAg0EeAeaFVVVUZrl519/WJTrHXUlQjQ+MH+/fvdAio3d5UTARHo2gSkIHXt/FPsRUAEREAEREAEREAEREAEkkhAU+ySCFOiREAEREAEREAEREAEREAEujYBKUhdO/8UexEQAREQAREQAREQAREQgSQSSP8vuCTKkygREAEROCkBbt778ssv27BhwyxxvdGuXbvsvffes61bt1rPnj0tPx9b2bfg9u7da6+++qqNGzfON6ptwYsuhZhAa2WMG0x/9tlntnHjRqO/fv36xZFq636cZ52EmsDnn39u+/btO+0yVF1dbZ988olt2rTJ33GFhdqRLdQFSYnvtAQ0gtRps0YRE4HUI/Dss8/amjVr3ChDbOruvfde38Rz+/btriTdeOON9tVXX8V68WMuhH7kkUfshRde8AZuMw+6EHoCJytjH3zwgc2dO9feeecdV8KXLFliTzzxRCOvtu43etRB6Als3rzZ7rvvPvv111/jWLRVhsrLy+2qq66y119/3X7++We76aab7Ouvv46ToRMREIHOQSCjc0RDsRABEUhlAhUVFd4Y/f7775slc9u2bcbe2PXr11tJSYnfv//++23FihU2adKkOP9sWCQ2SuI86CS0BForY/X19fbSSy/Z4sWLbf78+c6IZe7uu++2q6++2kc0W7s/fPjw0HJVwpsI0BoiR8D5SUtLa7qBo7bKGMsQO3fmzZtnt912mz/PMvfkk0/6iHiivDjhOhEBETjnBDSCdM6RK0ARCB+BRx991Dj689hjjzVLPE3j3nzzzY3KET1MmDDB9uzZ488ED7D3lQ2KW265JbikbxFoJNBaGeNUqIsuushmzZrV6J9ljI5TO9u63/iQDkJNgFOA3333XXv44Ydt0KBBcSzaKkOVlZW2ZcsWH0EKlKErr7zSy586feJQ6kQEOgUBjSB1imxQJEQgtQncdddd1rdvX9u5c2ezhF588cXGT6z7+OOPbfTo0Y29tHV1dcZRpYULF9qAAQNivepYBJxAa2Wsd+/exil1sY5lLD093UaOHGlt3Y99TsfhJTBlyhS7/PLLLSMjwziVM9a1VYbY4UPXv3//xseKi4t936Q///zTxowZ03hdByIgAh1PQCNIHZ8HioEIpDwBKken6tatW2c//PCDT0MJnlm9erWPMHF6ipwItETgdMrYjh07bNWqVXb99de74p4or637if51Hg4CVGioHJ2KSyxDu3fvdsM0icZpaIyGo+hyIiACnYvAqf3SO1ecFRsREIFOSoAL4Gtqahpjx/UdOTk5jedtHaxdu9ZeeeUVW7Zsmffs0z/XLb3//vs+va6t53U/9Qm0t4z9+OOPxtGmSy+91Kd2JhJr636if52nHgF20HA6XOAuvPBCKysrC07b/G6pDGVmZhrXMCU6WlPs3r174mWdi4AIdDABKUgdnAEKXgRSicBHH31knC4SuDlz5pySgsQFzsuXLzc+T8tiwfoQymFPPxsQwfqlgwcPuvh77rnHrZJNmzYtCE7fISBwpmWMaGjee+nSpXbNNdfYokWLmtFq636zB3QhJQlwTdDbb7/dmLaioqJTVpBOVoY4BY/KEE3JxypEVVVVzUyFNwasAxEQgQ4jIAWpw9ArYBFIPQJPPfXUGSXqwQcf9Gl1K1eudItisUKuuOKKuCkoXFT/yy+/2KhRo6xXr16xXnUcAgJnWsa49wzLGS2I0dRyomvrfqJ/nacugeuuu874OV3XWhkaOHCgT8/ju4sGQ+g4SsXOodh1SacbpvyLgAicHQJSkM4OV0kVARE4RQKcPsdRgTvvvNO4iSKntwRu7NixbhY3OOf3d99953sl3XDDDb7AOfaejkWgJQK0IEYrd5dccokNGTIkrozRGhktLLZ2X4p4S1R1LZZAW2WMZWj27Nm+hxsN0HAtE/eE4yh7nz59YkXpWAREoBMQkILUCTJBURCBMBPg3kZ0jz/+eDMMGzZsiJuO0syDLojAKRCgEs6pTR9++KF/Yh/heiQukm/tPkcx5USgNQJtlTGWIe7DRWuc3LCYxhrGjx9vt956a2tidU8ERKCDCKSh56yhg8JWsCIgAiIgAiIgAiIQKgJcd0QT83l5eaFKtxIrAl2JgBSkrpRbiqsIiIAIiIAIiIAIiIAIiMBZJaB9kM4qXgkXAREQAREQAREQAREQARHoSgSkIHWl3FJcRUAEREAEREAEREAEREAEzioBKUhnFa+Ei4AIiIAIiIAIiIAIiIAIdCUCUpC6Um4priIgAiIgAiIgAiIgAiIgAmeVgBSks4pXwkVABERABERABERABERABLoSASlIXSm3FFcREAEREAEnwH2Ldu7caUePHhURERABERABEUgqASlIScUpYSIgAiIgAueCADfmHDJkiH366afnIjiFIQIiIAIiECICUpBClNlKqgiIgAiIgAiIgAiIgAiIQOsEpCC1zkd3RUAEREAEREAEREAEREAEQkQgI0RpVVJFQAREQARSnMA333xj69ats/Lycp+Cd9lll9nMmTPjUv3cc89ZUVGRzZgxw1588UX79ttvrV+/fjZ//nybPHlynF+diIAIiIAIhI+ARpDCl+dKsQiIgAikJIGHHnrIJk6caG+++aalp6fbhg0bbNasWbZ48eK49K5Zs8ZWrFhhU6dOtQceeMD27Nljq1evtunTp9sbb7wR51cnIiACIiAC4SMgBSl8ea4Ui4AIiEDKEfjyyy9t6dKldu2119rWrVvttddes59++smWLFliq1at8lGl2ERv3LjR5s2bZxUVFW7oYdOmTZabm2vLly+P9aZjERABERCBEBKQghTCTFeSRUAERCDVCKxdu9ZHjZ5++mnLzMz05KWlpdmyZcuspKTEnnnmmbgkZ2dnG0ecqBTRlZWV2fjx4910eJxHnYiACIiACISOgBSk0GW5EiwCIiACqUdgy5YtNnjwYFeGYlOXk5Pjig9HlWLdoEGDLCsrK/aSP3vkyJG4azoRAREQAREIHwEpSOHLc6VYBERABFKOQGVlpRUUFLSYrh49elhdXV3cve7du8ed84QjTg0NDc2u64IIiIAIiEC4CEhBCld+K7UiIAIikJIEzj///JNOj/v999/tggsuSMl0K1EiIAIiIALJJyAFKflMJVEEREAEROAcE5gyZYpxFOmtt96KC5nGFzZv3mwTJkyIu64TERABERABETgZASlIJyOj6yIgAiIgAl2GwO233+5rkBYsWGDPP/+8cU3S+vXrbe7cuTZ06FC74447ukxaFFEREAEREIGOJaCNYjuWv0IXAREQARFIAgFao/viiy9s0aJFtnDhQquvr7e8vDybNm2am/keOHBgEkKRCBEQAREQgTAQSMOCVHRiMS0AAAE1SURBVK1IDUNOK40iIAIiEBICtETHdUfDhw9vNPkdkqQrmSIgAiIgAkkgIAUpCRAlQgREQAREQAREQAREQAREIDUIaA1SauSjUiECIiACIiACIiACIiACIpAEAlKQkgBRIkRABERABERABERABERABFKDgBSk1MhHpUIEREAEREAEREAEREAERCAJBKQgJQGiRIiACIiACIiACIiACIiACKQGASlIqZGPSoUIiIAIiIAIiIAIiIAIiEASCEhBSgJEiRABERABERABERABERABEUgNAlKQUiMflQoREAEREAEREAEREAEREIEkEJCClASIEiECIiACIiACIiACIiACIpAaBKQgpUY+KhUiIAIiIAIiIAIiIAIiIAJJICAFKQkQJUIEREAEREAEREAEREAERCA1CPw/bBvCs1aEr5AAAAAASUVORK5CYII=" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-20600-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515409
</td>
<td style="text-align:right;">
5989806
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-29500-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
496209
</td>
<td style="text-align:right;">
5999657
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
100-596500-54900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
583374
</td>
<td style="text-align:right;">
5911978
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
100-596500-03300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
537250
</td>
<td style="text-align:right;">
5991350
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
551588
</td>
<td style="text-align:right;">
5970657
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
100-574400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526285
</td>
<td style="text-align:right;">
5978523
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522679
</td>
<td style="text-align:right;">
5956610
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518502
</td>
<td style="text-align:right;">
5962002
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
524160
</td>
<td style="text-align:right;">
5957999
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
100-560100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521127
</td>
<td style="text-align:right;">
5965112
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
100-567900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
516996
</td>
<td style="text-align:right;">
5972733
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
100-562800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515025
</td>
<td style="text-align:right;">
5966533
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
100-596500-82000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
573972
</td>
<td style="text-align:right;">
5894796
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
100-596500-90900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
590481
</td>
<td style="text-align:right;">
5882133
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-535900-08600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
517279
</td>
<td style="text-align:right;">
5936628
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518845
</td>
<td style="text-align:right;">
5961982
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
100-572700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521864
</td>
<td style="text-align:right;">
5976392
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-587900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526448
</td>
<td style="text-align:right;">
5985791
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
100-580500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522978
</td>
<td style="text-align:right;">
5980978
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
100-536400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
520105
</td>
<td style="text-align:right;">
5935908
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Burnt Cabin Creek
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388946
</td>
<td style="text-align:right;">
5997015
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388276
</td>
<td style="text-align:right;">
5996950
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
398938
</td>
<td style="text-align:right;">
5996429
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
180-296000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
425562
</td>
<td style="text-align:right;">
5996164
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
100-770300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
650785
</td>
<td style="text-align:right;">
5934863
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
100-683800-01900-12800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
587921
</td>
<td style="text-align:right;">
5972451
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
100-698700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
606373
</td>
<td style="text-align:right;">
5965783
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344034
</td>
<td style="text-align:right;">
5862741
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
100-596500-84300-21000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577020
</td>
<td style="text-align:right;">
5886032
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
100-596500-10600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
536470
</td>
<td style="text-align:right;">
5981315
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541465
</td>
<td style="text-align:right;">
5981577
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541358
</td>
<td style="text-align:right;">
5981709
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521645
</td>
<td style="text-align:right;">
5955176
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
100-545900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521513
</td>
<td style="text-align:right;">
5949553
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
556416
</td>
<td style="text-align:right;">
5962053
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Burnt Cabin Creek
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388738
</td>
<td style="text-align:right;">
5997154
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
BB;C;EB;LKC;LNC;LSU;NSC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;CAS;CC;CH;CSU;DV;LDC;LKC;LSU;MW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
BB;CCG;LKC;RB;SP;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
CCG;CSU;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Burnt Cabin Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
LKC;LSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
EB;LKC;RB;RSC;ST
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Burnt Cabin Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Francois Lake
</th>
<th style="text-align:left;">
Lower Chilako
</th>
<th style="text-align:left;">
Lower Salmon
</th>
<th style="text-align:left;">
Morkill
</th>
<th style="text-align:left;">
Nechako
</th>
<th style="text-align:left;">
Tabor
</th>
<th style="text-align:left;">
Upper Fraser
</th>
<th style="text-align:left;">
Willow
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Acipenser transmontanus
</td>
<td style="text-align:left;">
White Sturgeon
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
E/T (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Carassius auratus
</td>
<td style="text-align:left;">
Goldfish
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus platyrhynchus
</td>
<td style="text-align:left;">
Northern Mountain Sucker
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cyprinus carpio
</td>
<td style="text-align:left;">
Carp
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Micropterus salmoides
</td>
<td style="text-align:left;">
Largemouth Bass
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
E/T/SC (Dec 2018)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Anadromous Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Char, General
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
