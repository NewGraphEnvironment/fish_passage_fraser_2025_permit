<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_fraser_2024","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-07-28</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https:/github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/raw/main/mapping/sites_fraser_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Habitat Conservation Trust Foundation, Society for Ecosystem Restoration Northern BC, and the Ministry of Transportation and Infrastructure (MoTI). Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from throughout the study area. Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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ZlHNWTHrWC6rHfGX+t4h5jmzvH5rrVbjvUreH61x3J7+PzfZUPeYHdhNTKtGVFKr+jCmx11vGHl28cO4DuqQAu9s1sZhNDBjERGR8iCt+RSHXW7ws5PuaE4073prIoZDdr7saxE7N954oxM7b3/72yceX3zxxe4O/JxzzrGrrrrK/uIv/sLe+ta3uptwIegimpLJpK1evdqefPJJq62ttX/5l3+xL3/5y57vgx/8oK8PIfRK73rXu5w4etWrXmWve93r7C//8i/tFa94hd11113+XB+D2IPccsst9pOf/OS5EUgqnAZJrJR1X8roWYvwCwwHZTbahirWdgimqmGL4/EuXgIb3l8KFTx0isGMENxFKMlzWAltyJW33v9caULal+th+t5DDz1kgoXgFBFIzzzzjBMxN910k4lQ+td//Ve78847nYj62Mc+Zp/4xCeciP2zP/szu+aaa+w973mP1zbdXP3bv/2bz8eb3/xme+9732u//vWv7a//+q/dbXom3EW0bt682d74xjfm7LHec3lxi+OEQknvQCeS81NqG7FFJXAu0psntm9xiVJ9RbXtaA8Ej6akvqra9ye3bWTd6p5UFLVGf/zEfTZAcN33vvq3bEn9XPvQD76ARkKxq+ndev+dtnrOInvd2S+1Xd2t9tE7byFuEY4bcIazsmmRvfvlN9up1fPsjifvt8byWnvvdb/ha+CdX/iQbd+3B1ffg/a9R++xP375G+2COcvtcw/92H607j47lVhMP3r8Xvvtl7zKrjn9Qvvhs/dCgPWjMt3L/V/Y1WsusjeeeaX9avtT9sTuzS6ZFjMMK17eLCRlqKy38T428qb5/pKxBmTHuYlQEBvI00meKGntyCvqVIXs8FQaFFqrBahtywui7KF0hsgRg/6ykwgpipDSCz47Q/76pIVAnkA6aac+P3BtznL1q/142q0x/XDi4J7IqK183CqLh21VU7Pt78OOqL/Umok3U5nsJJher0sF1Mb0KRAbspNSwFUloY2JdGMqmYSwSaVV6zzDrD4kjZlKJIkILONsEJEk5DlXr4QIVsMSllWMVB+KOVhRtOMAxcaGPsq9upJcPAt9z1VHru6plOygpMsuu58pSQ9zVJRA4hQh4zFY2YKjDr5/+62/ss6dzfayq16GF6hWO69q6ZTqXmgX8rz35APr7T8/8W17x1f+1spqghvd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IAGpD6DrkSIgAiIgAiIgAiIgAiIgAplJQAJSZuaLYiUCIiACItAFAe5btG/fPmtsbOzCly6JgAiIgAiIQM8JSEDqOTPdIQIiIAIi0McEuDHnhAkT7NNPP+3jmOjxIiACIiACfiMgAclvOar0iIAIiIAIiIAIiIAIiIAI9JqABKReo9ONIiACIiACIiACIiACIiACfiOQ47cEKT0iIAIiIALBJbBt2zbbuHGjlZWVuSl4F154oZ1//vlJQJ599lkrKiqyc88911544QX76quvbOTIkbZ48WKbPXt2kl8diIAIiIAIBI+ANEjBy3OlWAREQAR8SeChhx6ymTNn2ptvvmnZ2dm2ZcsWW7BggS1btiwpvevXr7fVq1fb3Llz7YEHHrCKigpbt26dnXPOOfb6668n+dWBCIiACIhA8AhIQApenivFIiACIuA7Al9++aWtWLHCrrzyStu1a5dt2rTJvv/+e1u+fLmtXbvWaZUSE71161ZbtGiRVVZWOkMP27dvt0GDBtmqVasSvem3CIiACIhAAAlIQApgpivJIiACIuA3Ahs2bHBaoyeffNJCoZBLXlZWlq1cudJKSkrsqaeeSkrywIEDjRonCkV0U6ZMsdNOO82ZDk/yqAMREAEREIHAEZCAFLgsV4JFQAREwH8Edu7caePHj3fCUGLqwuGwE3yoVUp0Y8eOtdzc3MRT7t7Dhw8nndOBCIiACIhA8AhIQApenivFIiACIuA7AlVVVVZQUHDMdOXl5VlLS0vStcGDBycd84Aap7a2tg7ndUIEREAERCBYBCQgBSu/lVoREAER8CWBk046qdPpcXv37rXTTz/dl+lWokRABERABNJPQAJS+pkqRBEQAREQgX8ygTlz5hi1SG+99VbSk2l8YceOHTZjxoyk8zoQAREQAREQgc4ISEDqjIzOi4AIiIAI9BsCt912m1uDdMMNN9hzzz1nXJO0efNmW4p+DbkAAAGMSURBVLhwoU2cONFuv/32fpMWRVQEREAERKBvCWij2L7lr6eLgAiIgAikgQCt0X3xxRe2dOlSW7JkiR09etQikYjNmzfPmfkeM2ZMGp6iIERABERABIJAIAsLUrUiNQg5rTSKgAiIQEAI0BId1x1Nnjw5bvI7IElXMkVABERABNJAQAJSGiAqCBEQAREQAREQAREQAREQAX8Q0Bokf+SjUiECIiACIiACIiACIiACIpAGAhKQ0gBRQYiACIiACIiACIiACIiACPiDgAQkf+SjUiECIiACIiACIiACIiACIpAGAhKQ0gBRQYiACIiACIiACIiACIiACPiDgAQkf+SjUiECIiACIiACIiACIiACIpAGAhKQ0gBRQYiACIiACIiACIiACIiACPiDgAQkf+SjUiECIiACIiACIiACIiACIpAGAhKQ0gBRQYiACIiACIiACIiACIiACPiDgAQkf+SjUiECIiACIiACIiACIiACIpAGAhKQ0gBRQYiACIiACIiACIiACIiACPiDwP8DQ70V6MdjfL0AAAAASUVORK5CYII=" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-20600-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515409
</td>
<td style="text-align:right;">
5989806
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-29500-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
496209
</td>
<td style="text-align:right;">
5999657
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
100-596500-54900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
583374
</td>
<td style="text-align:right;">
5911978
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
100-596500-03300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
537250
</td>
<td style="text-align:right;">
5991350
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
551588
</td>
<td style="text-align:right;">
5970657
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
100-574400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526285
</td>
<td style="text-align:right;">
5978523
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522679
</td>
<td style="text-align:right;">
5956610
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518502
</td>
<td style="text-align:right;">
5962002
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
524160
</td>
<td style="text-align:right;">
5957999
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
100-560100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521127
</td>
<td style="text-align:right;">
5965112
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
100-567900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
516996
</td>
<td style="text-align:right;">
5972733
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
100-562800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515025
</td>
<td style="text-align:right;">
5966533
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
100-596500-82000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
573972
</td>
<td style="text-align:right;">
5894796
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
100-596500-90900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
590481
</td>
<td style="text-align:right;">
5882133
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-535900-08600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
517279
</td>
<td style="text-align:right;">
5936628
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518845
</td>
<td style="text-align:right;">
5961982
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
100-572700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521864
</td>
<td style="text-align:right;">
5976392
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-587900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526448
</td>
<td style="text-align:right;">
5985791
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
100-580500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522978
</td>
<td style="text-align:right;">
5980978
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
100-536400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
520105
</td>
<td style="text-align:right;">
5935908
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388945
</td>
<td style="text-align:right;">
5997015
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388276
</td>
<td style="text-align:right;">
5996951
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
398947
</td>
<td style="text-align:right;">
5996427
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
180-296000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
425559
</td>
<td style="text-align:right;">
5996140
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
100-770300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
650784
</td>
<td style="text-align:right;">
5934858
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
100-683800-01900-12800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
587921
</td>
<td style="text-align:right;">
5972449
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
100-698700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
606373
</td>
<td style="text-align:right;">
5965784
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344022
</td>
<td style="text-align:right;">
5862734
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
100-596500-84300-21000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577020
</td>
<td style="text-align:right;">
5886032
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
100-596500-10600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
536470
</td>
<td style="text-align:right;">
5981315
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541465
</td>
<td style="text-align:right;">
5981577
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541358
</td>
<td style="text-align:right;">
5981709
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521645
</td>
<td style="text-align:right;">
5955176
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
100-545900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521513
</td>
<td style="text-align:right;">
5949553
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
556416
</td>
<td style="text-align:right;">
5962053
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388738
</td>
<td style="text-align:right;">
5997154
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
BB;C;EB;LKC;LNC;LSU;NSC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;CAS;CC;CH;CSU;DV;LDC;LKC;LSU;MW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
BB;CCG;LKC;RB;SP;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
CCG;CSU;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
LKC;LSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
EB;LKC;RB;RSC;ST
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Francois Lake
</th>
<th style="text-align:left;">
Lower Chilako
</th>
<th style="text-align:left;">
Lower Salmon
</th>
<th style="text-align:left;">
Morkill
</th>
<th style="text-align:left;">
Nechako
</th>
<th style="text-align:left;">
Tabor
</th>
<th style="text-align:left;">
Upper Fraser
</th>
<th style="text-align:left;">
Willow
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Acipenser transmontanus
</td>
<td style="text-align:left;">
White Sturgeon
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
E/T (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Carassius auratus
</td>
<td style="text-align:left;">
Goldfish
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus platyrhynchus
</td>
<td style="text-align:left;">
Northern Mountain Sucker
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cyprinus carpio
</td>
<td style="text-align:left;">
Carp
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Micropterus salmoides
</td>
<td style="text-align:left;">
Largemouth Bass
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
E/T/SC (Dec 2018)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Anadromous Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Char, General
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
